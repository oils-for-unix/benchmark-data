// _gen/data_lang/pretty.asdl.cc is generated by asdl_main.py

#include "_gen/data_lang/pretty.asdl.h"
#include <assert.h>
#include "prebuilt/asdl/runtime.mycpp.h"  // generated code uses wrappers here

// Generated code uses these types
using hnode_asdl::hnode;
using hnode_asdl::Field;
using hnode_asdl::color_e;


namespace pretty_asdl {

BigStr* doc_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case doc_e::Newline:
    v = "Newline"; break;
  case doc_e::Text:
    v = "Text"; break;
  case doc_e::Indent:
    v = "Indent"; break;
  case doc_e::Cat:
    v = "Cat"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "doc.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

doc__Newline* doc::Newline = &gdoc__Newline.obj;

GcGlobal<doc__Newline> gdoc__Newline = 
  { ObjHeader::Global(doc_e::Newline) };

hnode_t* doc__Newline::PrettyTree(Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);
  hnode::Record* out_node = runtime::NewRecord(doc_str(this->tag()));
  return out_node;
}


hnode_t* doc__Text::PrettyTree(Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);
  hnode::Record* out_node = runtime::NewRecord(doc_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->s, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("s"), x0));

  hnode_t* x1 = Alloc<hnode::Leaf>(str(this->width), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("width"), x1));

  return out_node;
}


hnode_t* doc__Indent::PrettyTree(Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);
  hnode::Record* out_node = runtime::NewRecord(doc_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->ind), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("ind"), x0));

  if (this->children != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<doc_t*> it(this->children); !it.Done(); it.Next()) {
      doc_t* i1 = it.Value();
      hnode_t* h = (i1 == nullptr) ? Alloc<hnode::Leaf>(StrFromC("_"),
                    color_e::OtherConst) : i1->PrettyTree(seen);
      x1->children->append(h);
    }
    L->append(Alloc<Field>(StrFromC("children"), x1));
  }

  return out_node;
}


hnode_t* doc__Cat::PrettyTree(Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);
  hnode::Record* out_node = runtime::NewRecord(doc_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree(seen);
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->right->PrettyTree(seen);
  L->append(Alloc<Field>(StrFromC("right"), x1));

  return out_node;
}


hnode_t* doc_t::PrettyTree(Dict<int, bool>* seen) {
  switch (this->tag()) {
  case doc_e::Newline: {
    doc__Newline* obj = static_cast<doc__Newline*>(this);
    return obj->PrettyTree(seen);
  }
  case doc_e::Text: {
    doc__Text* obj = static_cast<doc__Text*>(this);
    return obj->PrettyTree(seen);
  }
  case doc_e::Indent: {
    doc__Indent* obj = static_cast<doc__Indent*>(this);
    return obj->PrettyTree(seen);
  }
  case doc_e::Cat: {
    doc__Cat* obj = static_cast<doc__Cat*>(this);
    return obj->PrettyTree(seen);
  }
  default:
    assert(0);
  }
}

}  // namespace pretty_asdl
