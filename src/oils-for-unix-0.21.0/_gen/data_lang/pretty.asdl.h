// _gen/data_lang/pretty.asdl.h is generated by asdl_main.py

#ifndef PRETTY_ASDL
#define PRETTY_ASDL

#include <cstdint>

#include "mycpp/runtime.h"
#include "_gen/asdl/hnode.asdl.h"
using hnode_asdl::hnode_t;

namespace pretty_asdl {

// use struct instead of namespace so 'using' works consistently
#define ASDL_NAMES struct

class doc_t;

ASDL_NAMES doc_e {
  enum no_name {
  Newline = 1,
  Text = 2,
  Indent = 3,
  Cat = 4,
  };
};

BigStr* doc_str(int tag, bool dot = true);

class doc_t {
 protected:
  doc_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  hnode_t* PrettyTree(Dict<int, bool>* seen = nullptr);
  DISALLOW_COPY_AND_ASSIGN(doc_t)
};

class doc__Newline : public doc_t {
 public:
  doc__Newline() {}

  hnode_t* PrettyTree(Dict<int, bool>* seen = nullptr);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(doc_e::Newline), 0);
  }


  DISALLOW_COPY_AND_ASSIGN(doc__Newline)
};

class doc__Text : public doc_t {
 public:
  doc__Text(BigStr* s, int width)
      : s(s),
        width(width) {
  }

  static doc__Text* CreateNull(bool alloc_lists = false) { 
    return Alloc<doc__Text>(kEmptyString, -1);
  }

  hnode_t* PrettyTree(Dict<int, bool>* seen = nullptr);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(doc_e::Text), 1);
  }

  BigStr* s;
  int width;

  DISALLOW_COPY_AND_ASSIGN(doc__Text)
};

class doc__Indent : public doc_t {
 public:
  doc__Indent(int ind, List<doc_t*>* children)
      : children(children),
        ind(ind) {
  }

  static doc__Indent* CreateNull(bool alloc_lists = false) { 
    return Alloc<doc__Indent>(-1, alloc_lists ? Alloc<List<doc_t*>>() :
                              nullptr);
  }

  hnode_t* PrettyTree(Dict<int, bool>* seen = nullptr);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(doc_e::Indent), 1);
  }

  List<doc_t*>* children;
  int ind;

  DISALLOW_COPY_AND_ASSIGN(doc__Indent)
};

class doc__Cat : public doc_t {
 public:
  doc__Cat(doc_t* left, doc_t* right)
      : left(left),
        right(right) {
  }

  static doc__Cat* CreateNull(bool alloc_lists = false) { 
    return Alloc<doc__Cat>(nullptr, nullptr);
  }

  hnode_t* PrettyTree(Dict<int, bool>* seen = nullptr);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(doc_e::Cat), 2);
  }

  doc_t* left;
  doc_t* right;

  DISALLOW_COPY_AND_ASSIGN(doc__Cat)
};

extern GcGlobal<doc__Newline> gdoc__Newline;
ASDL_NAMES doc {
  static doc__Newline* Newline;
  typedef doc__Text Text;
  typedef doc__Indent Indent;
  typedef doc__Cat Cat;
};


}  // namespace pretty_asdl

#endif  // PRETTY_ASDL
