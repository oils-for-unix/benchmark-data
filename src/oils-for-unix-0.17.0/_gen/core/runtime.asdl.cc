// _gen/core/runtime.asdl.cc is generated by asdl_main.py

#include "_gen/core/runtime.asdl.h"
#include <assert.h>
#include "prebuilt/asdl/runtime.mycpp.h"  // generated code uses wrappers here
#include "_gen/frontend/syntax.asdl.h"  // "use" in ASDL 

// Generated code uses these types
using hnode_asdl::hnode;
using hnode_asdl::Field;
using hnode_asdl::color_e;

using id_kind_asdl::Id_str;

namespace runtime_asdl {


hnode_t* IntBox::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("IntBox"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->i), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("i"), x0));

  return out_node;
}

hnode_t* AssignArg::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("AssignArg"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->var_name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("var_name"), x0));

  if (this->rval) {  // Optional
    hnode_t* x1 = this->rval->PrettyTree();
    L->append(Alloc<Field>(StrFromC("rval"), x1));
  }

  hnode_t* x2 = Alloc<hnode::Leaf>(this->plus_eq ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("plus_eq"), x2));

  hnode_t* x3 = this->blame_word->PrettyTree();
  L->append(Alloc<Field>(StrFromC("blame_word"), x3));

  return out_node;
}
const char* cmd_value_str(int tag) {
  switch (tag) {
  case cmd_value_e::Argv:
    return "cmd_value.Argv";
  case cmd_value_e::Assign:
    return "cmd_value.Assign";
  default:
    assert(0);
  }
}

hnode_t* cmd_value__Argv::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("cmd_value.Argv"));
  List<Field*>* L = out_node->fields;

  if (this->argv != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Str*> it(this->argv); !it.Done(); it.Next()) {
      Str* i0 = it.Value();
      x0->children->append(runtime::NewLeaf(i0, color_e::StringConst));
    }
    L->append(Alloc<Field>(StrFromC("argv"), x0));
  }

  if (this->arg_locs != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<syntax_asdl::CompoundWord*> it(this->arg_locs); !it.Done();
         it.Next()) {
      syntax_asdl::CompoundWord* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("arg_locs"), x1));
  }

  if (this->typed_args) {  // Optional
    hnode_t* x2 = this->typed_args->PrettyTree();
    L->append(Alloc<Field>(StrFromC("typed_args"), x2));
  }

  return out_node;
}

hnode_t* cmd_value__Assign::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("cmd_value.Assign"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->builtin_id), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("builtin_id"), x0));

  if (this->argv != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Str*> it(this->argv); !it.Done(); it.Next()) {
      Str* i1 = it.Value();
      x1->children->append(runtime::NewLeaf(i1, color_e::StringConst));
    }
    L->append(Alloc<Field>(StrFromC("argv"), x1));
  }

  if (this->arg_locs != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<syntax_asdl::CompoundWord*> it(this->arg_locs); !it.Done();
         it.Next()) {
      syntax_asdl::CompoundWord* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("arg_locs"), x2));
  }

  if (this->pairs != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<AssignArg*> it(this->pairs); !it.Done(); it.Next()) {
      AssignArg* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("pairs"), x3));
  }

  return out_node;
}

hnode_t* cmd_value_t::PrettyTree() {
  switch (this->tag()) {
  case cmd_value_e::Argv: {
    cmd_value__Argv* obj = static_cast<cmd_value__Argv*>(this);
    return obj->PrettyTree();
  }
  case cmd_value_e::Assign: {
    cmd_value__Assign* obj = static_cast<cmd_value__Assign*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* part_value_str(int tag) {
  switch (tag) {
  case part_value_e::String:
    return "part_value.String";
  case part_value_e::Array:
    return "part_value.Array";
  case part_value_e::ExtGlob:
    return "part_value.ExtGlob";
  default:
    assert(0);
  }
}

hnode_t* part_value__String::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("part_value.String"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->s, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("s"), x0));

  hnode_t* x1 = Alloc<hnode::Leaf>(this->quoted ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("quoted"), x1));

  hnode_t* x2 = Alloc<hnode::Leaf>(this->do_split ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("do_split"), x2));

  return out_node;
}

hnode_t* part_value__Array::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("part_value.Array"));
  List<Field*>* L = out_node->fields;

  if (this->strs != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Str*> it(this->strs); !it.Done(); it.Next()) {
      Str* i0 = it.Value();
      x0->children->append(runtime::NewLeaf(i0, color_e::StringConst));
    }
    L->append(Alloc<Field>(StrFromC("strs"), x0));
  }

  return out_node;
}

hnode_t* part_value__ExtGlob::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("part_value.ExtGlob"));
  List<Field*>* L = out_node->fields;

  if (this->part_vals != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<part_value_t*> it(this->part_vals); !it.Done(); it.Next()) {
      part_value_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("part_vals"), x0));
  }

  return out_node;
}

hnode_t* part_value_t::PrettyTree() {
  switch (this->tag()) {
  case part_value_e::String: {
    part_value__String* obj = static_cast<part_value__String*>(this);
    return obj->PrettyTree();
  }
  case part_value_e::Array: {
    part_value__Array* obj = static_cast<part_value__Array*>(this);
    return obj->PrettyTree();
  }
  case part_value_e::ExtGlob: {
    part_value__ExtGlob* obj = static_cast<part_value__ExtGlob*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* value_str(int tag) {
  switch (tag) {
  case value_e::Undef:
    return "value.Undef";
  case value_e::Str:
    return "value.Str";
  case value_e::BashArray:
    return "value.BashArray";
  case value_e::BashAssoc:
    return "value.BashAssoc";
  case value_e::Null:
    return "value.Null";
  case value_e::Bool:
    return "value.Bool";
  case value_e::Int:
    return "value.Int";
  case value_e::Float:
    return "value.Float";
  case value_e::List:
    return "value.List";
  case value_e::Dict:
    return "value.Dict";
  case value_e::Eggex:
    return "value.Eggex";
  case value_e::Expr:
    return "value.Expr";
  case value_e::Template:
    return "value.Template";
  case value_e::Block:
    return "value.Block";
  case value_e::Func:
    return "value.Func";
  case value_e::BoundFunc:
    return "value.BoundFunc";
  case value_e::Proc:
    return "value.Proc";
  case value_e::Slice:
    return "value.Slice";
  default:
    assert(0);
  }
}

value__Undef* value::Undef = &gvalue__Undef.obj;

GcGlobal<value__Undef> gvalue__Undef = 
  {{kNotInPool, value_e::Undef, kZeroMask, HeapTag::Global, kIsGlobal}};

value__Null* value::Null = &gvalue__Null.obj;

GcGlobal<value__Null> gvalue__Null = 
  {{kNotInPool, value_e::Null, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* value__Undef::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Undef"));
  return out_node;
}

hnode_t* value__Str::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Str"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->s, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("s"), x0));

  return out_node;
}

hnode_t* value__BashArray::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.BashArray"));
  List<Field*>* L = out_node->fields;

  if (this->strs != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Str*> it(this->strs); !it.Done(); it.Next()) {
      Str* i0 = it.Value();
      x0->children->append(runtime::NewLeaf(i0, color_e::StringConst));
    }
    L->append(Alloc<Field>(StrFromC("strs"), x0));
  }

  return out_node;
}

hnode_t* value__BashAssoc::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.BashAssoc"));
  List<Field*>* L = out_node->fields;

  if (this->d) {  // Dict
    auto m = Alloc<hnode::Leaf>(StrFromC("Dict"), color_e::OtherConst);
    hnode::Array* x0 = Alloc<hnode::Array>(NewList<hnode_t*>({m}));
    for (DictIter<Str*, Str*> it(this->d); !it.Done(); it.Next()) {
      auto k0 = it.Key();
      auto v0 = it.Value();
      x0->children->append(runtime::NewLeaf(k0, color_e::StringConst));
      x0->children->append(runtime::NewLeaf(v0, color_e::StringConst));
    }
    L->append(Alloc<Field>(StrFromC ("d"), x0));
  }

  return out_node;
}

hnode_t* value__Null::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Null"));
  return out_node;
}

hnode_t* value__Bool::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Bool"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(this->b ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("b"), x0));

  return out_node;
}

hnode_t* value__Int::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Int"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->i), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("i"), x0));

  return out_node;
}

hnode_t* value__Float::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Float"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->f), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("f"), x0));

  return out_node;
}

hnode_t* value__List::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.List"));
  List<Field*>* L = out_node->fields;

  if (this->items != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<value_t*> it(this->items); !it.Done(); it.Next()) {
      value_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("items"), x0));
  }

  return out_node;
}

hnode_t* value__Dict::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Dict"));
  List<Field*>* L = out_node->fields;

  if (this->d) {  // Dict
    auto m = Alloc<hnode::Leaf>(StrFromC("Dict"), color_e::OtherConst);
    hnode::Array* x0 = Alloc<hnode::Array>(NewList<hnode_t*>({m}));
    for (DictIter<Str*, value_t*> it(this->d); !it.Done(); it.Next()) {
      auto k0 = it.Key();
      auto v0 = it.Value();
      x0->children->append(runtime::NewLeaf(k0, color_e::StringConst));
      x0->children->append(v0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC ("d"), x0));
  }

  return out_node;
}

hnode_t* value__Eggex::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Eggex"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->expr->PrettyTree();
  L->append(Alloc<Field>(StrFromC("expr"), x0));

  if (this->as_ere) {  // Optional
    hnode_t* x1 = runtime::NewLeaf(this->as_ere, color_e::StringConst);
    L->append(Alloc<Field>(StrFromC("as_ere"), x1));
  }

  return out_node;
}

hnode_t* value__Expr::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Expr"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->e->PrettyTree();
  L->append(Alloc<Field>(StrFromC("e"), x0));

  return out_node;
}

hnode_t* value__Template::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Template"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->eq->PrettyTree();
  L->append(Alloc<Field>(StrFromC("eq"), x0));

  return out_node;
}

hnode_t* value__Block::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Block"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x0));

  return out_node;
}

hnode_t* value__Func::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Func"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::External>(this->callable);
  L->append(Alloc<Field>(StrFromC("callable"), x0));

  return out_node;
}

hnode_t* value__BoundFunc::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.BoundFunc"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->me->PrettyTree();
  L->append(Alloc<Field>(StrFromC("me"), x0));

  hnode_t* x1 = Alloc<hnode::External>(this->callable);
  L->append(Alloc<Field>(StrFromC("callable"), x1));

  return out_node;
}

hnode_t* value__Proc::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Proc"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::External>(this->p);
  L->append(Alloc<Field>(StrFromC("p"), x0));

  return out_node;
}

hnode_t* value__Slice::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("value.Slice"));
  List<Field*>* L = out_node->fields;

  if (this->lower) {  // Optional
    hnode_t* x0 = this->lower->PrettyTree();
    L->append(Alloc<Field>(StrFromC("lower"), x0));
  }

  if (this->upper) {  // Optional
    hnode_t* x1 = this->upper->PrettyTree();
    L->append(Alloc<Field>(StrFromC("upper"), x1));
  }

  return out_node;
}

hnode_t* value_t::PrettyTree() {
  switch (this->tag()) {
  case value_e::Undef: {
    value__Undef* obj = static_cast<value__Undef*>(this);
    return obj->PrettyTree();
  }
  case value_e::Str: {
    value__Str* obj = static_cast<value__Str*>(this);
    return obj->PrettyTree();
  }
  case value_e::BashArray: {
    value__BashArray* obj = static_cast<value__BashArray*>(this);
    return obj->PrettyTree();
  }
  case value_e::BashAssoc: {
    value__BashAssoc* obj = static_cast<value__BashAssoc*>(this);
    return obj->PrettyTree();
  }
  case value_e::Null: {
    value__Null* obj = static_cast<value__Null*>(this);
    return obj->PrettyTree();
  }
  case value_e::Bool: {
    value__Bool* obj = static_cast<value__Bool*>(this);
    return obj->PrettyTree();
  }
  case value_e::Int: {
    value__Int* obj = static_cast<value__Int*>(this);
    return obj->PrettyTree();
  }
  case value_e::Float: {
    value__Float* obj = static_cast<value__Float*>(this);
    return obj->PrettyTree();
  }
  case value_e::List: {
    value__List* obj = static_cast<value__List*>(this);
    return obj->PrettyTree();
  }
  case value_e::Dict: {
    value__Dict* obj = static_cast<value__Dict*>(this);
    return obj->PrettyTree();
  }
  case value_e::Eggex: {
    value__Eggex* obj = static_cast<value__Eggex*>(this);
    return obj->PrettyTree();
  }
  case value_e::Expr: {
    value__Expr* obj = static_cast<value__Expr*>(this);
    return obj->PrettyTree();
  }
  case value_e::Template: {
    value__Template* obj = static_cast<value__Template*>(this);
    return obj->PrettyTree();
  }
  case value_e::Block: {
    value__Block* obj = static_cast<value__Block*>(this);
    return obj->PrettyTree();
  }
  case value_e::Func: {
    value__Func* obj = static_cast<value__Func*>(this);
    return obj->PrettyTree();
  }
  case value_e::BoundFunc: {
    value__BoundFunc* obj = static_cast<value__BoundFunc*>(this);
    return obj->PrettyTree();
  }
  case value_e::Proc: {
    value__Proc* obj = static_cast<value__Proc*>(this);
    return obj->PrettyTree();
  }
  case value_e::Slice: {
    value__Slice* obj = static_cast<value__Slice*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* a_index_str(int tag) {
  switch (tag) {
  case a_index_e::Str:
    return "a_index.Str";
  case a_index_e::Int:
    return "a_index.Int";
  default:
    assert(0);
  }
}

hnode_t* a_index__Str::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("a_index.Str"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->s, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("s"), x0));

  return out_node;
}

hnode_t* a_index__Int::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("a_index.Int"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->i), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("i"), x0));

  return out_node;
}

hnode_t* a_index_t::PrettyTree() {
  switch (this->tag()) {
  case a_index_e::Str: {
    a_index__Str* obj = static_cast<a_index__Str*>(this);
    return obj->PrettyTree();
  }
  case a_index_e::Int: {
    a_index__Int* obj = static_cast<a_index__Int*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* VTestPlace::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("VTestPlace"));
  List<Field*>* L = out_node->fields;

  if (this->name) {  // Optional
    hnode_t* x0 = runtime::NewLeaf(this->name, color_e::StringConst);
    L->append(Alloc<Field>(StrFromC("name"), x0));
  }

  if (this->index) {  // Optional
    hnode_t* x1 = this->index->PrettyTree();
    L->append(Alloc<Field>(StrFromC("index"), x1));
  }

  return out_node;
}

hnode_t* VarSubState::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("VarSubState"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(this->join_array ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("join_array"), x0));

  hnode_t* x1 = Alloc<hnode::Leaf>(this->is_type_query ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("is_type_query"), x1));

  return out_node;
}

hnode_t* Cell::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("Cell"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(this->exported ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("exported"), x0));

  hnode_t* x1 = Alloc<hnode::Leaf>(this->readonly ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("readonly"), x1));

  hnode_t* x2 = Alloc<hnode::Leaf>(this->nameref ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("nameref"), x2));

  hnode_t* x3 = this->val->PrettyTree();
  L->append(Alloc<Field>(StrFromC("val"), x3));

  return out_node;
}
const char* scope_str(scope_e tag) {
  switch (tag) {
  case scope_e::Parent:
    return "scope.Parent";
  case scope_e::Shopt:
    return "scope.Shopt";
  case scope_e::Dynamic:
    return "scope.Dynamic";
  case scope_e::LocalOrGlobal:
    return "scope.LocalOrGlobal";
  case scope_e::LocalOnly:
    return "scope.LocalOnly";
  case scope_e::GlobalOnly:
    return "scope.GlobalOnly";
  default:
    assert(0);
  }
}
const char* lvalue_str(int tag) {
  switch (tag) {
  case lvalue_e::Named:
    return "lvalue.Named";
  case lvalue_e::Indexed:
    return "lvalue.Indexed";
  case lvalue_e::Keyed:
    return "lvalue.Keyed";
  case lvalue_e::ObjIndex:
    return "lvalue.ObjIndex";
  default:
    assert(0);
  }
}

hnode_t* lvalue__Named::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("lvalue.Named"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x0));

  hnode_t* x1 = this->blame_loc->PrettyTree();
  L->append(Alloc<Field>(StrFromC("blame_loc"), x1));

  return out_node;
}

hnode_t* lvalue__Indexed::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("lvalue.Indexed"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x0));

  hnode_t* x1 = Alloc<hnode::Leaf>(str(this->index), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("index"), x1));

  hnode_t* x2 = this->blame_loc->PrettyTree();
  L->append(Alloc<Field>(StrFromC("blame_loc"), x2));

  return out_node;
}

hnode_t* lvalue__Keyed::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("lvalue.Keyed"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->key, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("key"), x1));

  hnode_t* x2 = this->blame_loc->PrettyTree();
  L->append(Alloc<Field>(StrFromC("blame_loc"), x2));

  return out_node;
}

hnode_t* lvalue__ObjIndex::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("lvalue.ObjIndex"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->obj->PrettyTree();
  L->append(Alloc<Field>(StrFromC("obj"), x0));

  hnode_t* x1 = this->index->PrettyTree();
  L->append(Alloc<Field>(StrFromC("index"), x1));

  return out_node;
}

hnode_t* lvalue_t::PrettyTree() {
  switch (this->tag()) {
  case lvalue_e::Named: {
    lvalue__Named* obj = static_cast<lvalue__Named*>(this);
    return obj->PrettyTree();
  }
  case lvalue_e::Indexed: {
    lvalue__Indexed* obj = static_cast<lvalue__Indexed*>(this);
    return obj->PrettyTree();
  }
  case lvalue_e::Keyed: {
    lvalue__Keyed* obj = static_cast<lvalue__Keyed*>(this);
    return obj->PrettyTree();
  }
  case lvalue_e::ObjIndex: {
    lvalue__ObjIndex* obj = static_cast<lvalue__ObjIndex*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* redirect_arg_str(int tag) {
  switch (tag) {
  case redirect_arg_e::Path:
    return "redirect_arg.Path";
  case redirect_arg_e::CopyFd:
    return "redirect_arg.CopyFd";
  case redirect_arg_e::MoveFd:
    return "redirect_arg.MoveFd";
  case redirect_arg_e::CloseFd:
    return "redirect_arg.CloseFd";
  case redirect_arg_e::HereDoc:
    return "redirect_arg.HereDoc";
  default:
    assert(0);
  }
}

redirect_arg__CloseFd* redirect_arg::CloseFd = &gredirect_arg__CloseFd.obj;

GcGlobal<redirect_arg__CloseFd> gredirect_arg__CloseFd = 
  {{kNotInPool, redirect_arg_e::CloseFd, kZeroMask, HeapTag::Global,
    kIsGlobal}};

hnode_t* redirect_arg__Path::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("redirect_arg.Path"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->filename, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("filename"), x0));

  return out_node;
}

hnode_t* redirect_arg__CopyFd::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("redirect_arg.CopyFd"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->target_fd), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("target_fd"), x0));

  return out_node;
}

hnode_t* redirect_arg__MoveFd::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("redirect_arg.MoveFd"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->target_fd), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("target_fd"), x0));

  return out_node;
}

hnode_t* redirect_arg__CloseFd::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("redirect_arg.CloseFd"));
  return out_node;
}

hnode_t* redirect_arg__HereDoc::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("redirect_arg.HereDoc"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->body, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("body"), x0));

  return out_node;
}

hnode_t* redirect_arg_t::PrettyTree() {
  switch (this->tag()) {
  case redirect_arg_e::Path: {
    redirect_arg__Path* obj = static_cast<redirect_arg__Path*>(this);
    return obj->PrettyTree();
  }
  case redirect_arg_e::CopyFd: {
    redirect_arg__CopyFd* obj = static_cast<redirect_arg__CopyFd*>(this);
    return obj->PrettyTree();
  }
  case redirect_arg_e::MoveFd: {
    redirect_arg__MoveFd* obj = static_cast<redirect_arg__MoveFd*>(this);
    return obj->PrettyTree();
  }
  case redirect_arg_e::CloseFd: {
    redirect_arg__CloseFd* obj = static_cast<redirect_arg__CloseFd*>(this);
    return obj->PrettyTree();
  }
  case redirect_arg_e::HereDoc: {
    redirect_arg__HereDoc* obj = static_cast<redirect_arg__HereDoc*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* RedirValue::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("RedirValue"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->op_id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("op_id"), x0));

  hnode_t* x1 = this->op_loc->PrettyTree();
  L->append(Alloc<Field>(StrFromC("op_loc"), x1));

  hnode_t* x2 = this->loc->PrettyTree();
  L->append(Alloc<Field>(StrFromC("loc"), x2));

  hnode_t* x3 = this->arg->PrettyTree();
  L->append(Alloc<Field>(StrFromC("arg"), x3));

  return out_node;
}

hnode_t* Proc::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("Proc"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x0));

  hnode_t* x1 = this->name_tok->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name_tok"), x1));

  hnode_t* x2 = this->sig->PrettyTree();
  L->append(Alloc<Field>(StrFromC("sig"), x2));

  hnode_t* x3 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x3));

  if (this->defaults != nullptr) {  // List
    hnode::Array* x4 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<value_t*> it(this->defaults); !it.Done(); it.Next()) {
      value_t* i4 = it.Value();
      x4->children->append(i4->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("defaults"), x4));
  }

  hnode_t* x5 = Alloc<hnode::Leaf>(this->dynamic_scope ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("dynamic_scope"), x5));

  return out_node;
}

hnode_t* StatusArray::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("StatusArray"));
  List<Field*>* L = out_node->fields;

  if (this->codes != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<int> it(this->codes); !it.Done(); it.Next()) {
      int i0 = it.Value();
      x0->children->append(Alloc<hnode::Leaf>(str(i0), color_e::OtherConst));
    }
    L->append(Alloc<Field>(StrFromC("codes"), x0));
  }

  if (this->locs != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<syntax_asdl::loc_t*> it(this->locs); !it.Done(); it.Next()) {
      syntax_asdl::loc_t* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("locs"), x1));
  }

  return out_node;
}

hnode_t* CommandStatus::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("CommandStatus"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(this->check_errexit ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("check_errexit"), x0));

  hnode_t* x1 = Alloc<hnode::Leaf>(this->show_code ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("show_code"), x1));

  hnode_t* x2 = Alloc<hnode::Leaf>(this->pipe_negated ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("pipe_negated"), x2));

  if (this->pipe_status != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<int> it(this->pipe_status); !it.Done(); it.Next()) {
      int i3 = it.Value();
      x3->children->append(Alloc<hnode::Leaf>(str(i3), color_e::OtherConst));
    }
    L->append(Alloc<Field>(StrFromC("pipe_status"), x3));
  }

  if (this->pipe_locs != nullptr) {  // List
    hnode::Array* x4 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<syntax_asdl::loc_t*> it(this->pipe_locs); !it.Done();
         it.Next()) {
      syntax_asdl::loc_t* i4 = it.Value();
      x4->children->append(i4->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("pipe_locs"), x4));
  }

  return out_node;
}
const char* wait_status_str(int tag) {
  switch (tag) {
  case wait_status_e::Proc:
    return "wait_status.Proc";
  case wait_status_e::Pipeline:
    return "wait_status.Pipeline";
  case wait_status_e::Cancelled:
    return "wait_status.Cancelled";
  default:
    assert(0);
  }
}

hnode_t* wait_status__Proc::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("wait_status.Proc"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->code), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("code"), x0));

  return out_node;
}

hnode_t* wait_status__Pipeline::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("wait_status.Pipeline"));
  List<Field*>* L = out_node->fields;

  if (this->codes != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<int> it(this->codes); !it.Done(); it.Next()) {
      int i0 = it.Value();
      x0->children->append(Alloc<hnode::Leaf>(str(i0), color_e::OtherConst));
    }
    L->append(Alloc<Field>(StrFromC("codes"), x0));
  }

  return out_node;
}

hnode_t* wait_status__Cancelled::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("wait_status.Cancelled"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->sig_num), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("sig_num"), x0));

  return out_node;
}

hnode_t* wait_status_t::PrettyTree() {
  switch (this->tag()) {
  case wait_status_e::Proc: {
    wait_status__Proc* obj = static_cast<wait_status__Proc*>(this);
    return obj->PrettyTree();
  }
  case wait_status_e::Pipeline: {
    wait_status__Pipeline* obj = static_cast<wait_status__Pipeline*>(this);
    return obj->PrettyTree();
  }
  case wait_status_e::Cancelled: {
    wait_status__Cancelled* obj = static_cast<wait_status__Cancelled*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* flow_str(flow_e tag) {
  switch (tag) {
  case flow_e::Nothing:
    return "flow.Nothing";
  case flow_e::Break:
    return "flow.Break";
  case flow_e::Raise:
    return "flow.Raise";
  default:
    assert(0);
  }
}
const char* span_str(span_e tag) {
  switch (tag) {
  case span_e::Black:
    return "span.Black";
  case span_e::Delim:
    return "span.Delim";
  case span_e::Backslash:
    return "span.Backslash";
  default:
    assert(0);
  }
}
const char* emit_str(int tag) {
  switch (tag) {
  case emit_i::Part:
    return "emit.Part";
  case emit_i::Delim:
    return "emit.Delim";
  case emit_i::Empty:
    return "emit.Empty";
  case emit_i::Escape:
    return "emit.Escape";
  case emit_i::Nothing:
    return "emit.Nothing";
  default:
    assert(0);
  }
}
const char* state_str(int tag) {
  switch (tag) {
  case state_i::Invalid:
    return "state.Invalid";
  case state_i::Start:
    return "state.Start";
  case state_i::DE_White1:
    return "state.DE_White1";
  case state_i::DE_Gray:
    return "state.DE_Gray";
  case state_i::DE_White2:
    return "state.DE_White2";
  case state_i::Black:
    return "state.Black";
  case state_i::Backslash:
    return "state.Backslash";
  case state_i::Done:
    return "state.Done";
  default:
    assert(0);
  }
}
const char* char_kind_str(int tag) {
  switch (tag) {
  case char_kind_i::DE_White:
    return "char_kind.DE_White";
  case char_kind_i::DE_Gray:
    return "char_kind.DE_Gray";
  case char_kind_i::Black:
    return "char_kind.Black";
  case char_kind_i::Backslash:
    return "char_kind.Backslash";
  case char_kind_i::Sentinel:
    return "char_kind.Sentinel";
  default:
    assert(0);
  }
}
const char* job_state_str(job_state_e tag) {
  switch (tag) {
  case job_state_e::Running:
    return "job_state.Running";
  case job_state_e::Done:
    return "job_state.Done";
  case job_state_e::Stopped:
    return "job_state.Stopped";
  default:
    assert(0);
  }
}
const char* flag_type_str(flag_type_e tag) {
  switch (tag) {
  case flag_type_e::Bool:
    return "flag_type.Bool";
  case flag_type_e::Int:
    return "flag_type.Int";
  case flag_type_e::Float:
    return "flag_type.Float";
  case flag_type_e::Str:
    return "flag_type.Str";
  default:
    assert(0);
  }
}
const char* trace_str(int tag) {
  switch (tag) {
  case trace_e::External:
    return "trace.External";
  case trace_e::CommandSub:
    return "trace.CommandSub";
  case trace_e::ForkWait:
    return "trace.ForkWait";
  case trace_e::Fork:
    return "trace.Fork";
  case trace_e::PipelinePart:
    return "trace.PipelinePart";
  case trace_e::ProcessSub:
    return "trace.ProcessSub";
  case trace_e::HereDoc:
    return "trace.HereDoc";
  default:
    assert(0);
  }
}

trace__CommandSub* trace::CommandSub = &gtrace__CommandSub.obj;

GcGlobal<trace__CommandSub> gtrace__CommandSub = 
  {{kNotInPool, trace_e::CommandSub, kZeroMask, HeapTag::Global, kIsGlobal}};

trace__ForkWait* trace::ForkWait = &gtrace__ForkWait.obj;

GcGlobal<trace__ForkWait> gtrace__ForkWait = 
  {{kNotInPool, trace_e::ForkWait, kZeroMask, HeapTag::Global, kIsGlobal}};

trace__Fork* trace::Fork = &gtrace__Fork.obj;

GcGlobal<trace__Fork> gtrace__Fork = 
  {{kNotInPool, trace_e::Fork, kZeroMask, HeapTag::Global, kIsGlobal}};

trace__PipelinePart* trace::PipelinePart = &gtrace__PipelinePart.obj;

GcGlobal<trace__PipelinePart> gtrace__PipelinePart = 
  {{kNotInPool, trace_e::PipelinePart, kZeroMask, HeapTag::Global, kIsGlobal}};

trace__ProcessSub* trace::ProcessSub = &gtrace__ProcessSub.obj;

GcGlobal<trace__ProcessSub> gtrace__ProcessSub = 
  {{kNotInPool, trace_e::ProcessSub, kZeroMask, HeapTag::Global, kIsGlobal}};

trace__HereDoc* trace::HereDoc = &gtrace__HereDoc.obj;

GcGlobal<trace__HereDoc> gtrace__HereDoc = 
  {{kNotInPool, trace_e::HereDoc, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* trace__External::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("trace.External"));
  List<Field*>* L = out_node->fields;

  if (this->argv != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Str*> it(this->argv); !it.Done(); it.Next()) {
      Str* i0 = it.Value();
      x0->children->append(runtime::NewLeaf(i0, color_e::StringConst));
    }
    L->append(Alloc<Field>(StrFromC("argv"), x0));
  }

  return out_node;
}

hnode_t* trace__CommandSub::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("trace.CommandSub"));
  return out_node;
}

hnode_t* trace__ForkWait::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("trace.ForkWait"));
  return out_node;
}

hnode_t* trace__Fork::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("trace.Fork"));
  return out_node;
}

hnode_t* trace__PipelinePart::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("trace.PipelinePart"));
  return out_node;
}

hnode_t* trace__ProcessSub::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("trace.ProcessSub"));
  return out_node;
}

hnode_t* trace__HereDoc::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("trace.HereDoc"));
  return out_node;
}

hnode_t* trace_t::PrettyTree() {
  switch (this->tag()) {
  case trace_e::External: {
    trace__External* obj = static_cast<trace__External*>(this);
    return obj->PrettyTree();
  }
  case trace_e::CommandSub: {
    trace__CommandSub* obj = static_cast<trace__CommandSub*>(this);
    return obj->PrettyTree();
  }
  case trace_e::ForkWait: {
    trace__ForkWait* obj = static_cast<trace__ForkWait*>(this);
    return obj->PrettyTree();
  }
  case trace_e::Fork: {
    trace__Fork* obj = static_cast<trace__Fork*>(this);
    return obj->PrettyTree();
  }
  case trace_e::PipelinePart: {
    trace__PipelinePart* obj = static_cast<trace__PipelinePart*>(this);
    return obj->PrettyTree();
  }
  case trace_e::ProcessSub: {
    trace__ProcessSub* obj = static_cast<trace__ProcessSub*>(this);
    return obj->PrettyTree();
  }
  case trace_e::HereDoc: {
    trace__HereDoc* obj = static_cast<trace__HereDoc*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* word_style_str(word_style_e tag) {
  switch (tag) {
  case word_style_e::Expr:
    return "word_style.Expr";
  case word_style_e::Unquoted:
    return "word_style.Unquoted";
  case word_style_e::DQ:
    return "word_style.DQ";
  case word_style_e::SQ:
    return "word_style.SQ";
  default:
    assert(0);
  }
}

hnode_t* HayNode::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("HayNode"));
  List<Field*>* L = out_node->fields;

  if (this->children) {  // Dict
    auto m = Alloc<hnode::Leaf>(StrFromC("Dict"), color_e::OtherConst);
    hnode::Array* x0 = Alloc<hnode::Array>(NewList<hnode_t*>({m}));
    for (DictIter<Str*, HayNode*> it(this->children); !it.Done(); it.Next()) {
      auto k0 = it.Key();
      auto v0 = it.Value();
      x0->children->append(runtime::NewLeaf(k0, color_e::StringConst));
      x0->children->append(v0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC ("children"), x0));
  }

  return out_node;
}

}  // namespace runtime_asdl
