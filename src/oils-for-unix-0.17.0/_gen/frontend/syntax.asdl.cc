// _gen/frontend/syntax.asdl.cc is generated by asdl_main.py

#include "_gen/frontend/syntax.asdl.h"
#include <assert.h>
#include "prebuilt/asdl/runtime.mycpp.h"  // generated code uses wrappers here

// Generated code uses these types
using hnode_asdl::hnode;
using hnode_asdl::Field;
using hnode_asdl::color_e;

using id_kind_asdl::Id_str;

namespace syntax_asdl {


hnode_t* BoolParamBox::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("BoolParamBox"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(this->b ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("b"), x0));

  return out_node;
}

hnode_t* IntParamBox::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("IntParamBox"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->i), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("i"), x0));

  return out_node;
}
const char* parse_result_str(int tag) {
  switch (tag) {
  case parse_result_e::EmptyLine:
    return "parse_result.EmptyLine";
  case parse_result_e::Eof:
    return "parse_result.Eof";
  case parse_result_e::Node:
    return "parse_result.Node";
  default:
    assert(0);
  }
}

parse_result__EmptyLine* parse_result::EmptyLine =
&gparse_result__EmptyLine.obj;

GcGlobal<parse_result__EmptyLine> gparse_result__EmptyLine = 
  {{kNotInPool, parse_result_e::EmptyLine, kZeroMask, HeapTag::Global,
    kIsGlobal}};

parse_result__Eof* parse_result::Eof = &gparse_result__Eof.obj;

GcGlobal<parse_result__Eof> gparse_result__Eof = 
  {{kNotInPool, parse_result_e::Eof, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* parse_result__EmptyLine::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("parse_result.EmptyLine"));
  return out_node;
}

hnode_t* parse_result__Eof::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("parse_result.Eof"));
  return out_node;
}

hnode_t* parse_result__Node::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("parse_result.Node"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->cmd->PrettyTree();
  L->append(Alloc<Field>(StrFromC("cmd"), x0));

  return out_node;
}

hnode_t* parse_result_t::PrettyTree() {
  switch (this->tag()) {
  case parse_result_e::EmptyLine: {
    parse_result__EmptyLine* obj = static_cast<parse_result__EmptyLine*>(this);
    return obj->PrettyTree();
  }
  case parse_result_e::Eof: {
    parse_result__Eof* obj = static_cast<parse_result__Eof*>(this);
    return obj->PrettyTree();
  }
  case parse_result_e::Node: {
    parse_result__Node* obj = static_cast<parse_result__Node*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* source_str(int tag) {
  switch (tag) {
  case source_e::Interactive:
    return "source.Interactive";
  case source_e::Headless:
    return "source.Headless";
  case source_e::Unused:
    return "source.Unused";
  case source_e::CFlag:
    return "source.CFlag";
  case source_e::Stdin:
    return "source.Stdin";
  case source_e::MainFile:
    return "source.MainFile";
  case source_e::SourcedFile:
    return "source.SourcedFile";
  case source_e::ArgvWord:
    return "source.ArgvWord";
  case source_e::Variable:
    return "source.Variable";
  case source_e::VarRef:
    return "source.VarRef";
  case source_e::Alias:
    return "source.Alias";
  case source_e::Reparsed:
    return "source.Reparsed";
  case source_e::Synthetic:
    return "source.Synthetic";
  default:
    assert(0);
  }
}

source__Interactive* source::Interactive = &gsource__Interactive.obj;

GcGlobal<source__Interactive> gsource__Interactive = 
  {{kNotInPool, source_e::Interactive, kZeroMask, HeapTag::Global, kIsGlobal}};

source__Headless* source::Headless = &gsource__Headless.obj;

GcGlobal<source__Headless> gsource__Headless = 
  {{kNotInPool, source_e::Headless, kZeroMask, HeapTag::Global, kIsGlobal}};

source__CFlag* source::CFlag = &gsource__CFlag.obj;

GcGlobal<source__CFlag> gsource__CFlag = 
  {{kNotInPool, source_e::CFlag, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* source__Interactive::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.Interactive"));
  return out_node;
}

hnode_t* source__Headless::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.Headless"));
  return out_node;
}

hnode_t* source__Unused::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.Unused"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->comment, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("comment"), x0));

  return out_node;
}

hnode_t* source__CFlag::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.CFlag"));
  return out_node;
}

hnode_t* source__Stdin::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.Stdin"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->comment, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("comment"), x0));

  return out_node;
}

hnode_t* source__MainFile::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.MainFile"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->path, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("path"), x0));

  return out_node;
}

hnode_t* source__SourcedFile::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.SourcedFile"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->path, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("path"), x0));

  hnode_t* x1 = this->location->PrettyTree();
  L->append(Alloc<Field>(StrFromC("location"), x1));

  return out_node;
}

hnode_t* source__ArgvWord::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.ArgvWord"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->what, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("what"), x0));

  hnode_t* x1 = this->location->PrettyTree();
  L->append(Alloc<Field>(StrFromC("location"), x1));

  return out_node;
}

hnode_t* source__Variable::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.Variable"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->var_name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("var_name"), x0));

  hnode_t* x1 = this->location->PrettyTree();
  L->append(Alloc<Field>(StrFromC("location"), x1));

  return out_node;
}

hnode_t* source__VarRef::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.VarRef"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->orig_tok->PrettyTree();
  L->append(Alloc<Field>(StrFromC("orig_tok"), x0));

  return out_node;
}

hnode_t* source__Alias::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.Alias"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->argv0, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("argv0"), x0));

  hnode_t* x1 = this->argv0_loc->PrettyTree();
  L->append(Alloc<Field>(StrFromC("argv0_loc"), x1));

  return out_node;
}

hnode_t* source__Reparsed::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.Reparsed"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->what, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("what"), x0));

  hnode_t* x1 = this->left_token->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left_token"), x1));

  hnode_t* x2 = this->right_token->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right_token"), x2));

  return out_node;
}

hnode_t* source__Synthetic::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("source.Synthetic"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->s, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("s"), x0));

  return out_node;
}

hnode_t* source_t::PrettyTree() {
  switch (this->tag()) {
  case source_e::Interactive: {
    source__Interactive* obj = static_cast<source__Interactive*>(this);
    return obj->PrettyTree();
  }
  case source_e::Headless: {
    source__Headless* obj = static_cast<source__Headless*>(this);
    return obj->PrettyTree();
  }
  case source_e::Unused: {
    source__Unused* obj = static_cast<source__Unused*>(this);
    return obj->PrettyTree();
  }
  case source_e::CFlag: {
    source__CFlag* obj = static_cast<source__CFlag*>(this);
    return obj->PrettyTree();
  }
  case source_e::Stdin: {
    source__Stdin* obj = static_cast<source__Stdin*>(this);
    return obj->PrettyTree();
  }
  case source_e::MainFile: {
    source__MainFile* obj = static_cast<source__MainFile*>(this);
    return obj->PrettyTree();
  }
  case source_e::SourcedFile: {
    source__SourcedFile* obj = static_cast<source__SourcedFile*>(this);
    return obj->PrettyTree();
  }
  case source_e::ArgvWord: {
    source__ArgvWord* obj = static_cast<source__ArgvWord*>(this);
    return obj->PrettyTree();
  }
  case source_e::Variable: {
    source__Variable* obj = static_cast<source__Variable*>(this);
    return obj->PrettyTree();
  }
  case source_e::VarRef: {
    source__VarRef* obj = static_cast<source__VarRef*>(this);
    return obj->PrettyTree();
  }
  case source_e::Alias: {
    source__Alias* obj = static_cast<source__Alias*>(this);
    return obj->PrettyTree();
  }
  case source_e::Reparsed: {
    source__Reparsed* obj = static_cast<source__Reparsed*>(this);
    return obj->PrettyTree();
  }
  case source_e::Synthetic: {
    source__Synthetic* obj = static_cast<source__Synthetic*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* SourceLine::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("SourceLine"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->line_num), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("line_num"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->content, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("content"), x1));

  hnode_t* x2 = this->src->PrettyTree();
  L->append(Alloc<Field>(StrFromC("src"), x2));

  return out_node;
}

hnode_t* Token::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("Token"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("id"), x0));

  hnode_t* x1 = Alloc<hnode::Leaf>(str(this->col), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("col"), x1));

  hnode_t* x2 = Alloc<hnode::Leaf>(str(this->length), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("length"), x2));

  hnode_t* x3 = Alloc<hnode::Leaf>(str(this->span_id), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("span_id"), x3));

  if (this->line) {  // Optional
    hnode_t* x4 = this->line->PrettyTree();
    L->append(Alloc<Field>(StrFromC("line"), x4));
  }

  hnode_t* x5 = runtime::NewLeaf(this->tval, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("tval"), x5));

  return out_node;
}

hnode_t* CompoundWord::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("CompoundWord"));
  List<Field*>* L = out_node->fields;

  if (this->parts != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<word_part_t*> it(this->parts); !it.Done(); it.Next()) {
      word_part_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("parts"), x0));
  }

  return out_node;
}
const char* loc_str(int tag) {
  switch (tag) {
  case loc_e::Missing:
    return "loc.Missing";
  case loc_e::Token:
    return "loc.Token";
  case loc_e::ArgWord:
    return "loc.ArgWord";
  case loc_e::WordPart:
    return "loc.WordPart";
  case loc_e::Word:
    return "loc.Word";
  case loc_e::Arith:
    return "loc.Arith";
  case loc_e::Command:
    return "loc.Command";
  default:
    assert(0);
  }
}

loc__Missing* loc::Missing = &gloc__Missing.obj;

GcGlobal<loc__Missing> gloc__Missing = 
  {{kNotInPool, loc_e::Missing, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* loc__Missing::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("loc.Missing"));
  return out_node;
}

hnode_t* loc__WordPart::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("loc.WordPart"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->p->PrettyTree();
  L->append(Alloc<Field>(StrFromC("p"), x0));

  return out_node;
}

hnode_t* loc__Word::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("loc.Word"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->w->PrettyTree();
  L->append(Alloc<Field>(StrFromC("w"), x0));

  return out_node;
}

hnode_t* loc__Arith::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("loc.Arith"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->a->PrettyTree();
  L->append(Alloc<Field>(StrFromC("a"), x0));

  return out_node;
}

hnode_t* loc__Command::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("loc.Command"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->c->PrettyTree();
  L->append(Alloc<Field>(StrFromC("c"), x0));

  return out_node;
}

hnode_t* loc_t::PrettyTree() {
  switch (this->tag()) {
  case loc_e::Missing: {
    loc__Missing* obj = static_cast<loc__Missing*>(this);
    return obj->PrettyTree();
  }
  case loc_e::Token: {
    Token* obj = static_cast<Token*>(this);
    return obj->PrettyTree();
  }
  case loc_e::ArgWord: {
    CompoundWord* obj = static_cast<CompoundWord*>(this);
    return obj->PrettyTree();
  }
  case loc_e::WordPart: {
    loc__WordPart* obj = static_cast<loc__WordPart*>(this);
    return obj->PrettyTree();
  }
  case loc_e::Word: {
    loc__Word* obj = static_cast<loc__Word*>(this);
    return obj->PrettyTree();
  }
  case loc_e::Arith: {
    loc__Arith* obj = static_cast<loc__Arith*>(this);
    return obj->PrettyTree();
  }
  case loc_e::Command: {
    loc__Command* obj = static_cast<loc__Command*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* bracket_op_str(int tag) {
  switch (tag) {
  case bracket_op_e::WholeArray:
    return "bracket_op.WholeArray";
  case bracket_op_e::ArrayIndex:
    return "bracket_op.ArrayIndex";
  default:
    assert(0);
  }
}

hnode_t* bracket_op__WholeArray::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("bracket_op.WholeArray"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->op_id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("op_id"), x0));

  return out_node;
}

hnode_t* bracket_op__ArrayIndex::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("bracket_op.ArrayIndex"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->expr->PrettyTree();
  L->append(Alloc<Field>(StrFromC("expr"), x0));

  return out_node;
}

hnode_t* bracket_op_t::PrettyTree() {
  switch (this->tag()) {
  case bracket_op_e::WholeArray: {
    bracket_op__WholeArray* obj = static_cast<bracket_op__WholeArray*>(this);
    return obj->PrettyTree();
  }
  case bracket_op_e::ArrayIndex: {
    bracket_op__ArrayIndex* obj = static_cast<bracket_op__ArrayIndex*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* suffix_op_str(int tag) {
  switch (tag) {
  case suffix_op_e::Nullary:
    return "suffix_op.Nullary";
  case suffix_op_e::Unary:
    return "suffix_op.Unary";
  case suffix_op_e::Static:
    return "suffix_op.Static";
  case suffix_op_e::PatSub:
    return "suffix_op.PatSub";
  case suffix_op_e::Slice:
    return "suffix_op.Slice";
  default:
    assert(0);
  }
}

hnode_t* suffix_op__Unary::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("suffix_op.Unary"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->op->PrettyTree();
  L->append(Alloc<Field>(StrFromC("op"), x0));

  hnode_t* x1 = this->arg_word->PrettyTree();
  L->append(Alloc<Field>(StrFromC("arg_word"), x1));

  return out_node;
}

hnode_t* suffix_op__Static::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("suffix_op.Static"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->tok->PrettyTree();
  L->append(Alloc<Field>(StrFromC("tok"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->arg, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("arg"), x1));

  return out_node;
}

hnode_t* suffix_op__PatSub::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("suffix_op.PatSub"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->pat->PrettyTree();
  L->append(Alloc<Field>(StrFromC("pat"), x0));

  hnode_t* x1 = this->replace->PrettyTree();
  L->append(Alloc<Field>(StrFromC("replace"), x1));

  hnode_t* x2 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->replace_mode)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("replace_mode"), x2));

  hnode_t* x3 = this->slash_tok->PrettyTree();
  L->append(Alloc<Field>(StrFromC("slash_tok"), x3));

  return out_node;
}

hnode_t* suffix_op__Slice::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("suffix_op.Slice"));
  List<Field*>* L = out_node->fields;

  if (this->begin) {  // Optional
    hnode_t* x0 = this->begin->PrettyTree();
    L->append(Alloc<Field>(StrFromC("begin"), x0));
  }

  if (this->length) {  // Optional
    hnode_t* x1 = this->length->PrettyTree();
    L->append(Alloc<Field>(StrFromC("length"), x1));
  }

  return out_node;
}

hnode_t* suffix_op_t::PrettyTree() {
  switch (this->tag()) {
  case suffix_op_e::Nullary: {
    Token* obj = static_cast<Token*>(this);
    return obj->PrettyTree();
  }
  case suffix_op_e::Unary: {
    suffix_op__Unary* obj = static_cast<suffix_op__Unary*>(this);
    return obj->PrettyTree();
  }
  case suffix_op_e::Static: {
    suffix_op__Static* obj = static_cast<suffix_op__Static*>(this);
    return obj->PrettyTree();
  }
  case suffix_op_e::PatSub: {
    suffix_op__PatSub* obj = static_cast<suffix_op__PatSub*>(this);
    return obj->PrettyTree();
  }
  case suffix_op_e::Slice: {
    suffix_op__Slice* obj = static_cast<suffix_op__Slice*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* BracedVarSub::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("BracedVarSub"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->token->PrettyTree();
  L->append(Alloc<Field>(StrFromC("token"), x1));

  hnode_t* x2 = runtime::NewLeaf(this->var_name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("var_name"), x2));

  if (this->prefix_op) {  // Optional
    hnode_t* x3 = this->prefix_op->PrettyTree();
    L->append(Alloc<Field>(StrFromC("prefix_op"), x3));
  }

  if (this->bracket_op) {  // Optional
    hnode_t* x4 = this->bracket_op->PrettyTree();
    L->append(Alloc<Field>(StrFromC("bracket_op"), x4));
  }

  if (this->suffix_op) {  // Optional
    hnode_t* x5 = this->suffix_op->PrettyTree();
    L->append(Alloc<Field>(StrFromC("suffix_op"), x5));
  }

  hnode_t* x6 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x6));

  return out_node;
}

hnode_t* DoubleQuoted::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("DoubleQuoted"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  if (this->parts != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<word_part_t*> it(this->parts); !it.Done(); it.Next()) {
      word_part_t* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("parts"), x1));
  }

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* SingleQuoted::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("SingleQuoted"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  if (this->tokens != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Token*> it(this->tokens); !it.Done(); it.Next()) {
      Token* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("tokens"), x1));
  }

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* SimpleVarSub::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("SimpleVarSub"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->var_name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("var_name"), x1));

  return out_node;
}

hnode_t* CommandSub::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("CommandSub"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left_token->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left_token"), x0));

  hnode_t* x1 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x1));

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* ShArrayLiteral::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("ShArrayLiteral"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  if (this->words != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<word_t*> it(this->words); !it.Done(); it.Next()) {
      word_t* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("words"), x1));
  }

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* ArgList::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("ArgList"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  if (this->positional != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<expr_t*> it(this->positional); !it.Done(); it.Next()) {
      expr_t* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("positional"), x1));
  }

  if (this->named != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<NamedArg*> it(this->named); !it.Done(); it.Next()) {
      NamedArg* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("named"), x2));
  }

  hnode_t* x3 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x3));

  return out_node;
}

hnode_t* AssocPair::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("AssocPair"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->key->PrettyTree();
  L->append(Alloc<Field>(StrFromC("key"), x0));

  hnode_t* x1 = this->value->PrettyTree();
  L->append(Alloc<Field>(StrFromC("value"), x1));

  return out_node;
}
const char* word_part_str(int tag) {
  switch (tag) {
  case word_part_e::ShArrayLiteral:
    return "word_part.ShArrayLiteral";
  case word_part_e::BashAssocLiteral:
    return "word_part.BashAssocLiteral";
  case word_part_e::Literal:
    return "word_part.Literal";
  case word_part_e::EscapedLiteral:
    return "word_part.EscapedLiteral";
  case word_part_e::SingleQuoted:
    return "word_part.SingleQuoted";
  case word_part_e::DoubleQuoted:
    return "word_part.DoubleQuoted";
  case word_part_e::SimpleVarSub:
    return "word_part.SimpleVarSub";
  case word_part_e::BracedVarSub:
    return "word_part.BracedVarSub";
  case word_part_e::CommandSub:
    return "word_part.CommandSub";
  case word_part_e::TildeSub:
    return "word_part.TildeSub";
  case word_part_e::ArithSub:
    return "word_part.ArithSub";
  case word_part_e::BracedTuple:
    return "word_part.BracedTuple";
  case word_part_e::BracedRange:
    return "word_part.BracedRange";
  case word_part_e::ExtGlob:
    return "word_part.ExtGlob";
  case word_part_e::Splice:
    return "word_part.Splice";
  case word_part_e::ExprSub:
    return "word_part.ExprSub";
  default:
    assert(0);
  }
}

hnode_t* word_part__BashAssocLiteral::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("word_part.BashAssocLiteral"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  if (this->pairs != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<AssocPair*> it(this->pairs); !it.Done(); it.Next()) {
      AssocPair* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("pairs"), x1));
  }

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* word_part__EscapedLiteral::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("word_part.EscapedLiteral"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->token->PrettyTree();
  L->append(Alloc<Field>(StrFromC("token"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->ch, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("ch"), x1));

  return out_node;
}

hnode_t* word_part__TildeSub::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("word_part.TildeSub"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->token->PrettyTree();
  L->append(Alloc<Field>(StrFromC("token"), x0));

  if (this->user_name) {  // Optional
    hnode_t* x1 = runtime::NewLeaf(this->user_name, color_e::StringConst);
    L->append(Alloc<Field>(StrFromC("user_name"), x1));
  }

  return out_node;
}

hnode_t* word_part__ArithSub::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("word_part.ArithSub"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->anode->PrettyTree();
  L->append(Alloc<Field>(StrFromC("anode"), x1));

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* word_part__BracedTuple::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("word_part.BracedTuple"));
  List<Field*>* L = out_node->fields;

  if (this->words != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<CompoundWord*> it(this->words); !it.Done(); it.Next()) {
      CompoundWord* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("words"), x0));
  }

  return out_node;
}

hnode_t* word_part__BracedRange::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("word_part.BracedRange"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->blame_tok->PrettyTree();
  L->append(Alloc<Field>(StrFromC("blame_tok"), x0));

  hnode_t* x1 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->kind)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("kind"), x1));

  hnode_t* x2 = runtime::NewLeaf(this->start, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("start"), x2));

  hnode_t* x3 = runtime::NewLeaf(this->end, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("end"), x3));

  hnode_t* x4 = Alloc<hnode::Leaf>(str(this->step), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("step"), x4));

  return out_node;
}

hnode_t* word_part__ExtGlob::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("word_part.ExtGlob"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->op->PrettyTree();
  L->append(Alloc<Field>(StrFromC("op"), x0));

  if (this->arms != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<CompoundWord*> it(this->arms); !it.Done(); it.Next()) {
      CompoundWord* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("arms"), x1));
  }

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* word_part__Splice::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("word_part.Splice"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->blame_tok->PrettyTree();
  L->append(Alloc<Field>(StrFromC("blame_tok"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->var_name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("var_name"), x1));

  return out_node;
}

hnode_t* word_part__ExprSub::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("word_part.ExprSub"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x1));

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* word_part_t::PrettyTree() {
  switch (this->tag()) {
  case word_part_e::ShArrayLiteral: {
    ShArrayLiteral* obj = static_cast<ShArrayLiteral*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::BashAssocLiteral: {
    word_part__BashAssocLiteral* obj =
static_cast<word_part__BashAssocLiteral*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::Literal: {
    Token* obj = static_cast<Token*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::EscapedLiteral: {
    word_part__EscapedLiteral* obj =
static_cast<word_part__EscapedLiteral*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::SingleQuoted: {
    SingleQuoted* obj = static_cast<SingleQuoted*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::DoubleQuoted: {
    DoubleQuoted* obj = static_cast<DoubleQuoted*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::SimpleVarSub: {
    SimpleVarSub* obj = static_cast<SimpleVarSub*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::BracedVarSub: {
    BracedVarSub* obj = static_cast<BracedVarSub*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::CommandSub: {
    CommandSub* obj = static_cast<CommandSub*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::TildeSub: {
    word_part__TildeSub* obj = static_cast<word_part__TildeSub*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::ArithSub: {
    word_part__ArithSub* obj = static_cast<word_part__ArithSub*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::BracedTuple: {
    word_part__BracedTuple* obj = static_cast<word_part__BracedTuple*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::BracedRange: {
    word_part__BracedRange* obj = static_cast<word_part__BracedRange*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::ExtGlob: {
    word_part__ExtGlob* obj = static_cast<word_part__ExtGlob*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::Splice: {
    word_part__Splice* obj = static_cast<word_part__Splice*>(this);
    return obj->PrettyTree();
  }
  case word_part_e::ExprSub: {
    word_part__ExprSub* obj = static_cast<word_part__ExprSub*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* rhs_word_str(int tag) {
  switch (tag) {
  case rhs_word_e::Empty:
    return "rhs_word.Empty";
  case rhs_word_e::Compound:
    return "rhs_word.Compound";
  default:
    assert(0);
  }
}

rhs_word__Empty* rhs_word::Empty = &grhs_word__Empty.obj;

GcGlobal<rhs_word__Empty> grhs_word__Empty = 
  {{kNotInPool, rhs_word_e::Empty, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* rhs_word__Empty::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("rhs_word.Empty"));
  return out_node;
}

hnode_t* rhs_word_t::PrettyTree() {
  switch (this->tag()) {
  case rhs_word_e::Empty: {
    rhs_word__Empty* obj = static_cast<rhs_word__Empty*>(this);
    return obj->PrettyTree();
  }
  case rhs_word_e::Compound: {
    CompoundWord* obj = static_cast<CompoundWord*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* word_str(int tag) {
  switch (tag) {
  case word_e::Operator:
    return "word.Operator";
  case word_e::Compound:
    return "word.Compound";
  case word_e::BracedTree:
    return "word.BracedTree";
  case word_e::String:
    return "word.String";
  default:
    assert(0);
  }
}

hnode_t* word__BracedTree::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("word.BracedTree"));
  List<Field*>* L = out_node->fields;

  if (this->parts != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<word_part_t*> it(this->parts); !it.Done(); it.Next()) {
      word_part_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("parts"), x0));
  }

  return out_node;
}

hnode_t* word__String::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("word.String"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("id"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->s, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("s"), x1));

  if (this->blame_loc) {  // Optional
    hnode_t* x2 = this->blame_loc->PrettyTree();
    L->append(Alloc<Field>(StrFromC("blame_loc"), x2));
  }

  return out_node;
}

hnode_t* word_t::PrettyTree() {
  switch (this->tag()) {
  case word_e::Operator: {
    Token* obj = static_cast<Token*>(this);
    return obj->PrettyTree();
  }
  case word_e::Compound: {
    CompoundWord* obj = static_cast<CompoundWord*>(this);
    return obj->PrettyTree();
  }
  case word_e::BracedTree: {
    word__BracedTree* obj = static_cast<word__BracedTree*>(this);
    return obj->PrettyTree();
  }
  case word_e::String: {
    word__String* obj = static_cast<word__String*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* sh_lhs_expr_str(int tag) {
  switch (tag) {
  case sh_lhs_expr_e::Name:
    return "sh_lhs_expr.Name";
  case sh_lhs_expr_e::IndexedName:
    return "sh_lhs_expr.IndexedName";
  case sh_lhs_expr_e::UnparsedIndex:
    return "sh_lhs_expr.UnparsedIndex";
  default:
    assert(0);
  }
}

hnode_t* sh_lhs_expr__Name::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("sh_lhs_expr.Name"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x1));

  return out_node;
}

hnode_t* sh_lhs_expr__IndexedName::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("sh_lhs_expr.IndexedName"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x1));

  hnode_t* x2 = this->index->PrettyTree();
  L->append(Alloc<Field>(StrFromC("index"), x2));

  return out_node;
}

hnode_t* sh_lhs_expr__UnparsedIndex::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("sh_lhs_expr.UnparsedIndex"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x1));

  hnode_t* x2 = runtime::NewLeaf(this->index, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("index"), x2));

  return out_node;
}

hnode_t* sh_lhs_expr_t::PrettyTree() {
  switch (this->tag()) {
  case sh_lhs_expr_e::Name: {
    sh_lhs_expr__Name* obj = static_cast<sh_lhs_expr__Name*>(this);
    return obj->PrettyTree();
  }
  case sh_lhs_expr_e::IndexedName: {
    sh_lhs_expr__IndexedName* obj =
static_cast<sh_lhs_expr__IndexedName*>(this);
    return obj->PrettyTree();
  }
  case sh_lhs_expr_e::UnparsedIndex: {
    sh_lhs_expr__UnparsedIndex* obj =
static_cast<sh_lhs_expr__UnparsedIndex*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* arith_expr_str(int tag) {
  switch (tag) {
  case arith_expr_e::VarSub:
    return "arith_expr.VarSub";
  case arith_expr_e::Word:
    return "arith_expr.Word";
  case arith_expr_e::UnaryAssign:
    return "arith_expr.UnaryAssign";
  case arith_expr_e::BinaryAssign:
    return "arith_expr.BinaryAssign";
  case arith_expr_e::Unary:
    return "arith_expr.Unary";
  case arith_expr_e::Binary:
    return "arith_expr.Binary";
  case arith_expr_e::TernaryOp:
    return "arith_expr.TernaryOp";
  default:
    assert(0);
  }
}

hnode_t* arith_expr__UnaryAssign::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("arith_expr.UnaryAssign"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->op_id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("op_id"), x0));

  hnode_t* x1 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x1));

  return out_node;
}

hnode_t* arith_expr__BinaryAssign::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("arith_expr.BinaryAssign"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->op_id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("op_id"), x0));

  hnode_t* x1 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x1));

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* arith_expr__Unary::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("arith_expr.Unary"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->op_id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("op_id"), x0));

  hnode_t* x1 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x1));

  return out_node;
}

hnode_t* arith_expr__Binary::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("arith_expr.Binary"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->op_id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("op_id"), x0));

  hnode_t* x1 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x1));

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* arith_expr__TernaryOp::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("arith_expr.TernaryOp"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->cond->PrettyTree();
  L->append(Alloc<Field>(StrFromC("cond"), x0));

  hnode_t* x1 = this->true_expr->PrettyTree();
  L->append(Alloc<Field>(StrFromC("true_expr"), x1));

  hnode_t* x2 = this->false_expr->PrettyTree();
  L->append(Alloc<Field>(StrFromC("false_expr"), x2));

  return out_node;
}

hnode_t* arith_expr_t::PrettyTree() {
  switch (this->tag()) {
  case arith_expr_e::VarSub: {
    SimpleVarSub* obj = static_cast<SimpleVarSub*>(this);
    return obj->PrettyTree();
  }
  case arith_expr_e::Word: {
    CompoundWord* obj = static_cast<CompoundWord*>(this);
    return obj->PrettyTree();
  }
  case arith_expr_e::UnaryAssign: {
    arith_expr__UnaryAssign* obj = static_cast<arith_expr__UnaryAssign*>(this);
    return obj->PrettyTree();
  }
  case arith_expr_e::BinaryAssign: {
    arith_expr__BinaryAssign* obj =
static_cast<arith_expr__BinaryAssign*>(this);
    return obj->PrettyTree();
  }
  case arith_expr_e::Unary: {
    arith_expr__Unary* obj = static_cast<arith_expr__Unary*>(this);
    return obj->PrettyTree();
  }
  case arith_expr_e::Binary: {
    arith_expr__Binary* obj = static_cast<arith_expr__Binary*>(this);
    return obj->PrettyTree();
  }
  case arith_expr_e::TernaryOp: {
    arith_expr__TernaryOp* obj = static_cast<arith_expr__TernaryOp*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* bool_expr_str(int tag) {
  switch (tag) {
  case bool_expr_e::WordTest:
    return "bool_expr.WordTest";
  case bool_expr_e::Binary:
    return "bool_expr.Binary";
  case bool_expr_e::Unary:
    return "bool_expr.Unary";
  case bool_expr_e::LogicalNot:
    return "bool_expr.LogicalNot";
  case bool_expr_e::LogicalAnd:
    return "bool_expr.LogicalAnd";
  case bool_expr_e::LogicalOr:
    return "bool_expr.LogicalOr";
  default:
    assert(0);
  }
}

hnode_t* bool_expr__WordTest::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("bool_expr.WordTest"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->w->PrettyTree();
  L->append(Alloc<Field>(StrFromC("w"), x0));

  return out_node;
}

hnode_t* bool_expr__Binary::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("bool_expr.Binary"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->op_id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("op_id"), x0));

  hnode_t* x1 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x1));

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* bool_expr__Unary::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("bool_expr.Unary"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->op_id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("op_id"), x0));

  hnode_t* x1 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x1));

  return out_node;
}

hnode_t* bool_expr__LogicalNot::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("bool_expr.LogicalNot"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x0));

  return out_node;
}

hnode_t* bool_expr__LogicalAnd::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("bool_expr.LogicalAnd"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x1));

  return out_node;
}

hnode_t* bool_expr__LogicalOr::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("bool_expr.LogicalOr"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x1));

  return out_node;
}

hnode_t* bool_expr_t::PrettyTree() {
  switch (this->tag()) {
  case bool_expr_e::WordTest: {
    bool_expr__WordTest* obj = static_cast<bool_expr__WordTest*>(this);
    return obj->PrettyTree();
  }
  case bool_expr_e::Binary: {
    bool_expr__Binary* obj = static_cast<bool_expr__Binary*>(this);
    return obj->PrettyTree();
  }
  case bool_expr_e::Unary: {
    bool_expr__Unary* obj = static_cast<bool_expr__Unary*>(this);
    return obj->PrettyTree();
  }
  case bool_expr_e::LogicalNot: {
    bool_expr__LogicalNot* obj = static_cast<bool_expr__LogicalNot*>(this);
    return obj->PrettyTree();
  }
  case bool_expr_e::LogicalAnd: {
    bool_expr__LogicalAnd* obj = static_cast<bool_expr__LogicalAnd*>(this);
    return obj->PrettyTree();
  }
  case bool_expr_e::LogicalOr: {
    bool_expr__LogicalOr* obj = static_cast<bool_expr__LogicalOr*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* redir_loc_str(int tag) {
  switch (tag) {
  case redir_loc_e::Fd:
    return "redir_loc.Fd";
  case redir_loc_e::VarName:
    return "redir_loc.VarName";
  default:
    assert(0);
  }
}

hnode_t* redir_loc__Fd::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("redir_loc.Fd"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->fd), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("fd"), x0));

  return out_node;
}

hnode_t* redir_loc__VarName::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("redir_loc.VarName"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x0));

  return out_node;
}

hnode_t* redir_loc_t::PrettyTree() {
  switch (this->tag()) {
  case redir_loc_e::Fd: {
    redir_loc__Fd* obj = static_cast<redir_loc__Fd*>(this);
    return obj->PrettyTree();
  }
  case redir_loc_e::VarName: {
    redir_loc__VarName* obj = static_cast<redir_loc__VarName*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* redir_param_str(int tag) {
  switch (tag) {
  case redir_param_e::Word:
    return "redir_param.Word";
  case redir_param_e::HereDoc:
    return "redir_param.HereDoc";
  default:
    assert(0);
  }
}

hnode_t* redir_param__HereDoc::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("redir_param.HereDoc"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->here_begin->PrettyTree();
  L->append(Alloc<Field>(StrFromC("here_begin"), x0));

  if (this->here_end_tok) {  // Optional
    hnode_t* x1 = this->here_end_tok->PrettyTree();
    L->append(Alloc<Field>(StrFromC("here_end_tok"), x1));
  }

  if (this->stdin_parts != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<word_part_t*> it(this->stdin_parts); !it.Done(); it.Next()) {
      word_part_t* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("stdin_parts"), x2));
  }

  return out_node;
}

hnode_t* redir_param_t::PrettyTree() {
  switch (this->tag()) {
  case redir_param_e::Word: {
    CompoundWord* obj = static_cast<CompoundWord*>(this);
    return obj->PrettyTree();
  }
  case redir_param_e::HereDoc: {
    redir_param__HereDoc* obj = static_cast<redir_param__HereDoc*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* Redir::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("Redir"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->op->PrettyTree();
  L->append(Alloc<Field>(StrFromC("op"), x0));

  hnode_t* x1 = this->loc->PrettyTree();
  L->append(Alloc<Field>(StrFromC("loc"), x1));

  hnode_t* x2 = this->arg->PrettyTree();
  L->append(Alloc<Field>(StrFromC("arg"), x2));

  return out_node;
}
const char* assign_op_str(assign_op_e tag) {
  switch (tag) {
  case assign_op_e::Equal:
    return "assign_op.Equal";
  case assign_op_e::PlusEqual:
    return "assign_op.PlusEqual";
  default:
    assert(0);
  }
}

hnode_t* AssignPair::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("AssignPair"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->lhs->PrettyTree();
  L->append(Alloc<Field>(StrFromC("lhs"), x1));

  hnode_t* x2 = Alloc<hnode::Leaf>(StrFromC(assign_op_str(this->op)),
                                   color_e::TypeName);
  L->append(Alloc<Field>(StrFromC("op"), x2));

  hnode_t* x3 = this->rhs->PrettyTree();
  L->append(Alloc<Field>(StrFromC("rhs"), x3));

  return out_node;
}

hnode_t* EnvPair::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("EnvPair"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x1));

  hnode_t* x2 = this->val->PrettyTree();
  L->append(Alloc<Field>(StrFromC("val"), x2));

  return out_node;
}
const char* condition_str(int tag) {
  switch (tag) {
  case condition_e::Shell:
    return "condition.Shell";
  case condition_e::YshExpr:
    return "condition.YshExpr";
  default:
    assert(0);
  }
}

hnode_t* condition__Shell::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("condition.Shell"));
  List<Field*>* L = out_node->fields;

  if (this->commands != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<command_t*> it(this->commands); !it.Done(); it.Next()) {
      command_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("commands"), x0));
  }

  return out_node;
}

hnode_t* condition__YshExpr::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("condition.YshExpr"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->e->PrettyTree();
  L->append(Alloc<Field>(StrFromC("e"), x0));

  return out_node;
}

hnode_t* condition_t::PrettyTree() {
  switch (this->tag()) {
  case condition_e::Shell: {
    condition__Shell* obj = static_cast<condition__Shell*>(this);
    return obj->PrettyTree();
  }
  case condition_e::YshExpr: {
    condition__YshExpr* obj = static_cast<condition__YshExpr*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* CaseArm::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("CaseArm"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->pattern->PrettyTree();
  L->append(Alloc<Field>(StrFromC("pattern"), x1));

  hnode_t* x2 = this->middle->PrettyTree();
  L->append(Alloc<Field>(StrFromC("middle"), x2));

  if (this->action != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<command_t*> it(this->action); !it.Done(); it.Next()) {
      command_t* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("action"), x3));
  }

  if (this->right) {  // Optional
    hnode_t* x4 = this->right->PrettyTree();
    L->append(Alloc<Field>(StrFromC("right"), x4));
  }

  return out_node;
}
const char* case_arg_str(int tag) {
  switch (tag) {
  case case_arg_e::Word:
    return "case_arg.Word";
  case case_arg_e::YshExpr:
    return "case_arg.YshExpr";
  default:
    assert(0);
  }
}

hnode_t* case_arg__Word::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("case_arg.Word"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->w->PrettyTree();
  L->append(Alloc<Field>(StrFromC("w"), x0));

  return out_node;
}

hnode_t* case_arg__YshExpr::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("case_arg.YshExpr"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->e->PrettyTree();
  L->append(Alloc<Field>(StrFromC("e"), x0));

  return out_node;
}

hnode_t* case_arg_t::PrettyTree() {
  switch (this->tag()) {
  case case_arg_e::Word: {
    case_arg__Word* obj = static_cast<case_arg__Word*>(this);
    return obj->PrettyTree();
  }
  case case_arg_e::YshExpr: {
    case_arg__YshExpr* obj = static_cast<case_arg__YshExpr*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* pat_str(int tag) {
  switch (tag) {
  case pat_e::Else:
    return "pat.Else";
  case pat_e::Words:
    return "pat.Words";
  case pat_e::YshExprs:
    return "pat.YshExprs";
  case pat_e::Eggex:
    return "pat.Eggex";
  default:
    assert(0);
  }
}

pat__Else* pat::Else = &gpat__Else.obj;

GcGlobal<pat__Else> gpat__Else = 
  {{kNotInPool, pat_e::Else, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* pat__Else::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("pat.Else"));
  return out_node;
}

hnode_t* pat__Words::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("pat.Words"));
  List<Field*>* L = out_node->fields;

  if (this->words != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<word_t*> it(this->words); !it.Done(); it.Next()) {
      word_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("words"), x0));
  }

  return out_node;
}

hnode_t* pat__YshExprs::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("pat.YshExprs"));
  List<Field*>* L = out_node->fields;

  if (this->exprs != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<expr_t*> it(this->exprs); !it.Done(); it.Next()) {
      expr_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("exprs"), x0));
  }

  return out_node;
}

hnode_t* pat__Eggex::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("pat.Eggex"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->eggex->PrettyTree();
  L->append(Alloc<Field>(StrFromC("eggex"), x0));

  return out_node;
}

hnode_t* pat_t::PrettyTree() {
  switch (this->tag()) {
  case pat_e::Else: {
    pat__Else* obj = static_cast<pat__Else*>(this);
    return obj->PrettyTree();
  }
  case pat_e::Words: {
    pat__Words* obj = static_cast<pat__Words*>(this);
    return obj->PrettyTree();
  }
  case pat_e::YshExprs: {
    pat__YshExprs* obj = static_cast<pat__YshExprs*>(this);
    return obj->PrettyTree();
  }
  case pat_e::Eggex: {
    pat__Eggex* obj = static_cast<pat__Eggex*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* IfArm::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("IfArm"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->keyword->PrettyTree();
  L->append(Alloc<Field>(StrFromC("keyword"), x0));

  hnode_t* x1 = this->cond->PrettyTree();
  L->append(Alloc<Field>(StrFromC("cond"), x1));

  if (this->then_kw) {  // Optional
    hnode_t* x2 = this->then_kw->PrettyTree();
    L->append(Alloc<Field>(StrFromC("then_kw"), x2));
  }

  if (this->action != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<command_t*> it(this->action); !it.Done(); it.Next()) {
      command_t* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("action"), x3));
  }

  if (this->spids != nullptr) {  // List
    hnode::Array* x4 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<int> it(this->spids); !it.Done(); it.Next()) {
      int i4 = it.Value();
      x4->children->append(Alloc<hnode::Leaf>(str(i4), color_e::OtherConst));
    }
    L->append(Alloc<Field>(StrFromC("spids"), x4));
  }

  return out_node;
}
const char* for_iter_str(int tag) {
  switch (tag) {
  case for_iter_e::Args:
    return "for_iter.Args";
  case for_iter_e::Words:
    return "for_iter.Words";
  case for_iter_e::YshExpr:
    return "for_iter.YshExpr";
  default:
    assert(0);
  }
}

for_iter__Args* for_iter::Args = &gfor_iter__Args.obj;

GcGlobal<for_iter__Args> gfor_iter__Args = 
  {{kNotInPool, for_iter_e::Args, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* for_iter__Args::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("for_iter.Args"));
  return out_node;
}

hnode_t* for_iter__Words::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("for_iter.Words"));
  List<Field*>* L = out_node->fields;

  if (this->words != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<word_t*> it(this->words); !it.Done(); it.Next()) {
      word_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("words"), x0));
  }

  return out_node;
}

hnode_t* for_iter__YshExpr::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("for_iter.YshExpr"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->e->PrettyTree();
  L->append(Alloc<Field>(StrFromC("e"), x0));

  hnode_t* x1 = this->blame->PrettyTree();
  L->append(Alloc<Field>(StrFromC("blame"), x1));

  return out_node;
}

hnode_t* for_iter_t::PrettyTree() {
  switch (this->tag()) {
  case for_iter_e::Args: {
    for_iter__Args* obj = static_cast<for_iter__Args*>(this);
    return obj->PrettyTree();
  }
  case for_iter_e::Words: {
    for_iter__Words* obj = static_cast<for_iter__Words*>(this);
    return obj->PrettyTree();
  }
  case for_iter_e::YshExpr: {
    for_iter__YshExpr* obj = static_cast<for_iter__YshExpr*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* BraceGroup::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("BraceGroup"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  if (this->doc_token) {  // Optional
    hnode_t* x1 = this->doc_token->PrettyTree();
    L->append(Alloc<Field>(StrFromC("doc_token"), x1));
  }

  if (this->children != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<command_t*> it(this->children); !it.Done(); it.Next()) {
      command_t* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("children"), x2));
  }

  if (this->redirects != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x3));
  }

  hnode_t* x4 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x4));

  return out_node;
}

hnode_t* BlockArg::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("BlockArg"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->brace_group->PrettyTree();
  L->append(Alloc<Field>(StrFromC("brace_group"), x0));

  if (this->lines != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<SourceLine*> it(this->lines); !it.Done(); it.Next()) {
      SourceLine* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("lines"), x1));
  }

  return out_node;
}
const char* command_str(int tag) {
  switch (tag) {
  case command_e::NoOp:
    return "command.NoOp";
  case command_e::Simple:
    return "command.Simple";
  case command_e::ExpandedAlias:
    return "command.ExpandedAlias";
  case command_e::Sentence:
    return "command.Sentence";
  case command_e::ShAssignment:
    return "command.ShAssignment";
  case command_e::Retval:
    return "command.Retval";
  case command_e::ControlFlow:
    return "command.ControlFlow";
  case command_e::Pipeline:
    return "command.Pipeline";
  case command_e::AndOr:
    return "command.AndOr";
  case command_e::DoGroup:
    return "command.DoGroup";
  case command_e::BraceGroup:
    return "command.BraceGroup";
  case command_e::Subshell:
    return "command.Subshell";
  case command_e::DParen:
    return "command.DParen";
  case command_e::DBracket:
    return "command.DBracket";
  case command_e::ForEach:
    return "command.ForEach";
  case command_e::ForExpr:
    return "command.ForExpr";
  case command_e::WhileUntil:
    return "command.WhileUntil";
  case command_e::If:
    return "command.If";
  case command_e::Case:
    return "command.Case";
  case command_e::ShFunction:
    return "command.ShFunction";
  case command_e::TimeBlock:
    return "command.TimeBlock";
  case command_e::CommandList:
    return "command.CommandList";
  case command_e::BareDecl:
    return "command.BareDecl";
  case command_e::VarDecl:
    return "command.VarDecl";
  case command_e::PlaceMutation:
    return "command.PlaceMutation";
  case command_e::Expr:
    return "command.Expr";
  case command_e::Proc:
    return "command.Proc";
  case command_e::Func:
    return "command.Func";
  case command_e::TeaFunc:
    return "command.TeaFunc";
  case command_e::Data:
    return "command.Data";
  case command_e::Enum:
    return "command.Enum";
  case command_e::Class:
    return "command.Class";
  case command_e::Import:
    return "command.Import";
  case command_e::For:
    return "command.For";
  case command_e::While:
    return "command.While";
  case command_e::Break:
    return "command.Break";
  case command_e::Continue:
    return "command.Continue";
  case command_e::Return:
    return "command.Return";
  default:
    assert(0);
  }
}

command__NoOp* command::NoOp = &gcommand__NoOp.obj;

GcGlobal<command__NoOp> gcommand__NoOp = 
  {{kNotInPool, command_e::NoOp, kZeroMask, HeapTag::Global, kIsGlobal}};

command__Break* command::Break = &gcommand__Break.obj;

GcGlobal<command__Break> gcommand__Break = 
  {{kNotInPool, command_e::Break, kZeroMask, HeapTag::Global, kIsGlobal}};

command__Continue* command::Continue = &gcommand__Continue.obj;

GcGlobal<command__Continue> gcommand__Continue = 
  {{kNotInPool, command_e::Continue, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* command__NoOp::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.NoOp"));
  return out_node;
}

hnode_t* command__Simple::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Simple"));
  List<Field*>* L = out_node->fields;

  if (this->blame_tok) {  // Optional
    hnode_t* x0 = this->blame_tok->PrettyTree();
    L->append(Alloc<Field>(StrFromC("blame_tok"), x0));
  }

  if (this->more_env != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<EnvPair*> it(this->more_env); !it.Done(); it.Next()) {
      EnvPair* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("more_env"), x1));
  }

  if (this->words != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<word_t*> it(this->words); !it.Done(); it.Next()) {
      word_t* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("words"), x2));
  }

  if (this->redirects != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x3));
  }

  if (this->typed_args) {  // Optional
    hnode_t* x4 = this->typed_args->PrettyTree();
    L->append(Alloc<Field>(StrFromC("typed_args"), x4));
  }

  if (this->block) {  // Optional
    hnode_t* x5 = this->block->PrettyTree();
    L->append(Alloc<Field>(StrFromC("block"), x5));
  }

  hnode_t* x6 = Alloc<hnode::Leaf>(this->do_fork ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("do_fork"), x6));

  return out_node;
}

hnode_t* command__ExpandedAlias::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("command.ExpandedAlias"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x0));

  if (this->redirects != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x1));
  }

  if (this->more_env != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<EnvPair*> it(this->more_env); !it.Done(); it.Next()) {
      EnvPair* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("more_env"), x2));
  }

  return out_node;
}

hnode_t* command__Sentence::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Sentence"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x0));

  hnode_t* x1 = this->terminator->PrettyTree();
  L->append(Alloc<Field>(StrFromC("terminator"), x1));

  return out_node;
}

hnode_t* command__ShAssignment::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("command.ShAssignment"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  if (this->pairs != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<AssignPair*> it(this->pairs); !it.Done(); it.Next()) {
      AssignPair* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("pairs"), x1));
  }

  if (this->redirects != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x2));
  }

  return out_node;
}

hnode_t* command__Retval::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Retval"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->keyword->PrettyTree();
  L->append(Alloc<Field>(StrFromC("keyword"), x0));

  hnode_t* x1 = this->val->PrettyTree();
  L->append(Alloc<Field>(StrFromC("val"), x1));

  return out_node;
}

hnode_t* command__ControlFlow::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.ControlFlow"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->keyword->PrettyTree();
  L->append(Alloc<Field>(StrFromC("keyword"), x0));

  if (this->arg_word) {  // Optional
    hnode_t* x1 = this->arg_word->PrettyTree();
    L->append(Alloc<Field>(StrFromC("arg_word"), x1));
  }

  return out_node;
}

hnode_t* command__Pipeline::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Pipeline"));
  List<Field*>* L = out_node->fields;

  if (this->negated) {  // Optional
    hnode_t* x0 = this->negated->PrettyTree();
    L->append(Alloc<Field>(StrFromC("negated"), x0));
  }

  if (this->children != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<command_t*> it(this->children); !it.Done(); it.Next()) {
      command_t* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("children"), x1));
  }

  if (this->ops != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Token*> it(this->ops); !it.Done(); it.Next()) {
      Token* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("ops"), x2));
  }

  return out_node;
}

hnode_t* command__AndOr::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.AndOr"));
  List<Field*>* L = out_node->fields;

  if (this->children != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<command_t*> it(this->children); !it.Done(); it.Next()) {
      command_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("children"), x0));
  }

  if (this->ops != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Token*> it(this->ops); !it.Done(); it.Next()) {
      Token* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("ops"), x1));
  }

  return out_node;
}

hnode_t* command__DoGroup::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.DoGroup"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  if (this->children != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<command_t*> it(this->children); !it.Done(); it.Next()) {
      command_t* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("children"), x1));
  }

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* command__Subshell::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Subshell"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x1));

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  if (this->redirects != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x3));
  }

  return out_node;
}

hnode_t* command__DParen::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.DParen"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x1));

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  if (this->redirects != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x3));
  }

  return out_node;
}

hnode_t* command__DBracket::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.DBracket"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->expr->PrettyTree();
  L->append(Alloc<Field>(StrFromC("expr"), x1));

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  if (this->redirects != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x3));
  }

  return out_node;
}

hnode_t* command__ForEach::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.ForEach"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->keyword->PrettyTree();
  L->append(Alloc<Field>(StrFromC("keyword"), x0));

  if (this->iter_names != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Str*> it(this->iter_names); !it.Done(); it.Next()) {
      Str* i1 = it.Value();
      x1->children->append(runtime::NewLeaf(i1, color_e::StringConst));
    }
    L->append(Alloc<Field>(StrFromC("iter_names"), x1));
  }

  hnode_t* x2 = this->iterable->PrettyTree();
  L->append(Alloc<Field>(StrFromC("iterable"), x2));

  if (this->semi_tok) {  // Optional
    hnode_t* x3 = this->semi_tok->PrettyTree();
    L->append(Alloc<Field>(StrFromC("semi_tok"), x3));
  }

  hnode_t* x4 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x4));

  if (this->redirects != nullptr) {  // List
    hnode::Array* x5 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i5 = it.Value();
      x5->children->append(i5->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x5));
  }

  return out_node;
}

hnode_t* command__ForExpr::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.ForExpr"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->keyword->PrettyTree();
  L->append(Alloc<Field>(StrFromC("keyword"), x0));

  if (this->init) {  // Optional
    hnode_t* x1 = this->init->PrettyTree();
    L->append(Alloc<Field>(StrFromC("init"), x1));
  }

  if (this->cond) {  // Optional
    hnode_t* x2 = this->cond->PrettyTree();
    L->append(Alloc<Field>(StrFromC("cond"), x2));
  }

  if (this->update) {  // Optional
    hnode_t* x3 = this->update->PrettyTree();
    L->append(Alloc<Field>(StrFromC("update"), x3));
  }

  if (this->body) {  // Optional
    hnode_t* x4 = this->body->PrettyTree();
    L->append(Alloc<Field>(StrFromC("body"), x4));
  }

  if (this->redirects != nullptr) {  // List
    hnode::Array* x5 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i5 = it.Value();
      x5->children->append(i5->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x5));
  }

  return out_node;
}

hnode_t* command__WhileUntil::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.WhileUntil"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->keyword->PrettyTree();
  L->append(Alloc<Field>(StrFromC("keyword"), x0));

  hnode_t* x1 = this->cond->PrettyTree();
  L->append(Alloc<Field>(StrFromC("cond"), x1));

  hnode_t* x2 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x2));

  if (this->redirects != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x3));
  }

  return out_node;
}

hnode_t* command__If::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.If"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->if_kw->PrettyTree();
  L->append(Alloc<Field>(StrFromC("if_kw"), x0));

  if (this->arms != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<IfArm*> it(this->arms); !it.Done(); it.Next()) {
      IfArm* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("arms"), x1));
  }

  if (this->else_kw) {  // Optional
    hnode_t* x2 = this->else_kw->PrettyTree();
    L->append(Alloc<Field>(StrFromC("else_kw"), x2));
  }

  if (this->else_action != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<command_t*> it(this->else_action); !it.Done(); it.Next()) {
      command_t* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("else_action"), x3));
  }

  if (this->fi_kw) {  // Optional
    hnode_t* x4 = this->fi_kw->PrettyTree();
    L->append(Alloc<Field>(StrFromC("fi_kw"), x4));
  }

  if (this->redirects != nullptr) {  // List
    hnode::Array* x5 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i5 = it.Value();
      x5->children->append(i5->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x5));
  }

  return out_node;
}

hnode_t* command__Case::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Case"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->case_kw->PrettyTree();
  L->append(Alloc<Field>(StrFromC("case_kw"), x0));

  hnode_t* x1 = this->to_match->PrettyTree();
  L->append(Alloc<Field>(StrFromC("to_match"), x1));

  hnode_t* x2 = this->arms_start->PrettyTree();
  L->append(Alloc<Field>(StrFromC("arms_start"), x2));

  if (this->arms != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<CaseArm*> it(this->arms); !it.Done(); it.Next()) {
      CaseArm* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("arms"), x3));
  }

  hnode_t* x4 = this->arms_end->PrettyTree();
  L->append(Alloc<Field>(StrFromC("arms_end"), x4));

  if (this->redirects != nullptr) {  // List
    hnode::Array* x5 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Redir*> it(this->redirects); !it.Done(); it.Next()) {
      Redir* i5 = it.Value();
      x5->children->append(i5->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("redirects"), x5));
  }

  return out_node;
}

hnode_t* command__ShFunction::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.ShFunction"));
  List<Field*>* L = out_node->fields;

  if (this->keyword) {  // Optional
    hnode_t* x0 = this->keyword->PrettyTree();
    L->append(Alloc<Field>(StrFromC("keyword"), x0));
  }

  hnode_t* x1 = this->name_tok->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name_tok"), x1));

  hnode_t* x2 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x2));

  hnode_t* x3 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x3));

  return out_node;
}

hnode_t* command__TimeBlock::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.TimeBlock"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->keyword->PrettyTree();
  L->append(Alloc<Field>(StrFromC("keyword"), x0));

  hnode_t* x1 = this->pipeline->PrettyTree();
  L->append(Alloc<Field>(StrFromC("pipeline"), x1));

  return out_node;
}

hnode_t* command__CommandList::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.CommandList"));
  List<Field*>* L = out_node->fields;

  if (this->children != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<command_t*> it(this->children); !it.Done(); it.Next()) {
      command_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("children"), x0));
  }

  return out_node;
}

hnode_t* command__BareDecl::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.BareDecl"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->lhs->PrettyTree();
  L->append(Alloc<Field>(StrFromC("lhs"), x0));

  hnode_t* x1 = this->rhs->PrettyTree();
  L->append(Alloc<Field>(StrFromC("rhs"), x1));

  return out_node;
}

hnode_t* command__VarDecl::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.VarDecl"));
  List<Field*>* L = out_node->fields;

  if (this->keyword) {  // Optional
    hnode_t* x0 = this->keyword->PrettyTree();
    L->append(Alloc<Field>(StrFromC("keyword"), x0));
  }

  if (this->lhs != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<NameType*> it(this->lhs); !it.Done(); it.Next()) {
      NameType* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("lhs"), x1));
  }

  hnode_t* x2 = this->rhs->PrettyTree();
  L->append(Alloc<Field>(StrFromC("rhs"), x2));

  return out_node;
}

hnode_t* command__PlaceMutation::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("command.PlaceMutation"));
  List<Field*>* L = out_node->fields;

  if (this->keyword) {  // Optional
    hnode_t* x0 = this->keyword->PrettyTree();
    L->append(Alloc<Field>(StrFromC("keyword"), x0));
  }

  if (this->lhs != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<place_expr_t*> it(this->lhs); !it.Done(); it.Next()) {
      place_expr_t* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("lhs"), x1));
  }

  hnode_t* x2 = this->op->PrettyTree();
  L->append(Alloc<Field>(StrFromC("op"), x2));

  hnode_t* x3 = this->rhs->PrettyTree();
  L->append(Alloc<Field>(StrFromC("rhs"), x3));

  return out_node;
}

hnode_t* command__Expr::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Expr"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->keyword->PrettyTree();
  L->append(Alloc<Field>(StrFromC("keyword"), x0));

  hnode_t* x1 = this->e->PrettyTree();
  L->append(Alloc<Field>(StrFromC("e"), x1));

  return out_node;
}

hnode_t* command__Proc::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Proc"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->keyword->PrettyTree();
  L->append(Alloc<Field>(StrFromC("keyword"), x0));

  hnode_t* x1 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x1));

  hnode_t* x2 = this->sig->PrettyTree();
  L->append(Alloc<Field>(StrFromC("sig"), x2));

  hnode_t* x3 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x3));

  return out_node;
}

hnode_t* command__Func::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Func"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->keyword->PrettyTree();
  L->append(Alloc<Field>(StrFromC("keyword"), x0));

  hnode_t* x1 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x1));

  if (this->pos_params != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Param*> it(this->pos_params); !it.Done(); it.Next()) {
      Param* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("pos_params"), x2));
  }

  if (this->pos_splat) {  // Optional
    hnode_t* x3 = this->pos_splat->PrettyTree();
    L->append(Alloc<Field>(StrFromC("pos_splat"), x3));
  }

  if (this->named_params != nullptr) {  // List
    hnode::Array* x4 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Param*> it(this->named_params); !it.Done(); it.Next()) {
      Param* i4 = it.Value();
      x4->children->append(i4->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("named_params"), x4));
  }

  if (this->named_splat) {  // Optional
    hnode_t* x5 = this->named_splat->PrettyTree();
    L->append(Alloc<Field>(StrFromC("named_splat"), x5));
  }

  hnode_t* x6 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x6));

  return out_node;
}

hnode_t* command__TeaFunc::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.TeaFunc"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  if (this->pos_params != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Param*> it(this->pos_params); !it.Done(); it.Next()) {
      Param* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("pos_params"), x1));
  }

  if (this->pos_splat) {  // Optional
    hnode_t* x2 = this->pos_splat->PrettyTree();
    L->append(Alloc<Field>(StrFromC("pos_splat"), x2));
  }

  if (this->named_params != nullptr) {  // List
    hnode::Array* x3 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Param*> it(this->named_params); !it.Done(); it.Next()) {
      Param* i3 = it.Value();
      x3->children->append(i3->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("named_params"), x3));
  }

  if (this->named_splat) {  // Optional
    hnode_t* x4 = this->named_splat->PrettyTree();
    L->append(Alloc<Field>(StrFromC("named_splat"), x4));
  }

  if (this->return_types != nullptr) {  // List
    hnode::Array* x5 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<type_expr_t*> it(this->return_types); !it.Done(); it.Next()) {
      type_expr_t* i5 = it.Value();
      x5->children->append(i5->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("return_types"), x5));
  }

  hnode_t* x6 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x6));

  return out_node;
}

hnode_t* command__Data::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Data"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  if (this->params != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Param*> it(this->params); !it.Done(); it.Next()) {
      Param* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("params"), x1));
  }

  return out_node;
}

hnode_t* command__Enum::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Enum"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  if (this->variants != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Variant*> it(this->variants); !it.Done(); it.Next()) {
      Variant* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("variants"), x1));
  }

  return out_node;
}

hnode_t* command__Class::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Class"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  if (this->extends) {  // Optional
    hnode_t* x1 = this->extends->PrettyTree();
    L->append(Alloc<Field>(StrFromC("extends"), x1));
  }

  if (this->items != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<class_item_t*> it(this->items); !it.Done(); it.Next()) {
      class_item_t* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("items"), x2));
  }

  return out_node;
}

hnode_t* command__Import::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Import"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->path->PrettyTree();
  L->append(Alloc<Field>(StrFromC("path"), x0));

  if (this->alias) {  // Optional
    hnode_t* x1 = this->alias->PrettyTree();
    L->append(Alloc<Field>(StrFromC("alias"), x1));
  }

  if (this->names != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<ImportName*> it(this->names); !it.Done(); it.Next()) {
      ImportName* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("names"), x2));
  }

  return out_node;
}

hnode_t* command__For::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.For"));
  List<Field*>* L = out_node->fields;

  if (this->targets != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<NameType*> it(this->targets); !it.Done(); it.Next()) {
      NameType* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("targets"), x0));
  }

  hnode_t* x1 = this->iterable->PrettyTree();
  L->append(Alloc<Field>(StrFromC("iterable"), x1));

  hnode_t* x2 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x2));

  return out_node;
}

hnode_t* command__While::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.While"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->test->PrettyTree();
  L->append(Alloc<Field>(StrFromC("test"), x0));

  hnode_t* x1 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x1));

  return out_node;
}

hnode_t* command__Break::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Break"));
  return out_node;
}

hnode_t* command__Continue::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Continue"));
  return out_node;
}

hnode_t* command__Return::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("command.Return"));
  List<Field*>* L = out_node->fields;

  if (this->value) {  // Optional
    hnode_t* x0 = this->value->PrettyTree();
    L->append(Alloc<Field>(StrFromC("value"), x0));
  }

  return out_node;
}

hnode_t* command_t::PrettyTree() {
  switch (this->tag()) {
  case command_e::NoOp: {
    command__NoOp* obj = static_cast<command__NoOp*>(this);
    return obj->PrettyTree();
  }
  case command_e::Simple: {
    command__Simple* obj = static_cast<command__Simple*>(this);
    return obj->PrettyTree();
  }
  case command_e::ExpandedAlias: {
    command__ExpandedAlias* obj = static_cast<command__ExpandedAlias*>(this);
    return obj->PrettyTree();
  }
  case command_e::Sentence: {
    command__Sentence* obj = static_cast<command__Sentence*>(this);
    return obj->PrettyTree();
  }
  case command_e::ShAssignment: {
    command__ShAssignment* obj = static_cast<command__ShAssignment*>(this);
    return obj->PrettyTree();
  }
  case command_e::Retval: {
    command__Retval* obj = static_cast<command__Retval*>(this);
    return obj->PrettyTree();
  }
  case command_e::ControlFlow: {
    command__ControlFlow* obj = static_cast<command__ControlFlow*>(this);
    return obj->PrettyTree();
  }
  case command_e::Pipeline: {
    command__Pipeline* obj = static_cast<command__Pipeline*>(this);
    return obj->PrettyTree();
  }
  case command_e::AndOr: {
    command__AndOr* obj = static_cast<command__AndOr*>(this);
    return obj->PrettyTree();
  }
  case command_e::DoGroup: {
    command__DoGroup* obj = static_cast<command__DoGroup*>(this);
    return obj->PrettyTree();
  }
  case command_e::BraceGroup: {
    BraceGroup* obj = static_cast<BraceGroup*>(this);
    return obj->PrettyTree();
  }
  case command_e::Subshell: {
    command__Subshell* obj = static_cast<command__Subshell*>(this);
    return obj->PrettyTree();
  }
  case command_e::DParen: {
    command__DParen* obj = static_cast<command__DParen*>(this);
    return obj->PrettyTree();
  }
  case command_e::DBracket: {
    command__DBracket* obj = static_cast<command__DBracket*>(this);
    return obj->PrettyTree();
  }
  case command_e::ForEach: {
    command__ForEach* obj = static_cast<command__ForEach*>(this);
    return obj->PrettyTree();
  }
  case command_e::ForExpr: {
    command__ForExpr* obj = static_cast<command__ForExpr*>(this);
    return obj->PrettyTree();
  }
  case command_e::WhileUntil: {
    command__WhileUntil* obj = static_cast<command__WhileUntil*>(this);
    return obj->PrettyTree();
  }
  case command_e::If: {
    command__If* obj = static_cast<command__If*>(this);
    return obj->PrettyTree();
  }
  case command_e::Case: {
    command__Case* obj = static_cast<command__Case*>(this);
    return obj->PrettyTree();
  }
  case command_e::ShFunction: {
    command__ShFunction* obj = static_cast<command__ShFunction*>(this);
    return obj->PrettyTree();
  }
  case command_e::TimeBlock: {
    command__TimeBlock* obj = static_cast<command__TimeBlock*>(this);
    return obj->PrettyTree();
  }
  case command_e::CommandList: {
    command__CommandList* obj = static_cast<command__CommandList*>(this);
    return obj->PrettyTree();
  }
  case command_e::BareDecl: {
    command__BareDecl* obj = static_cast<command__BareDecl*>(this);
    return obj->PrettyTree();
  }
  case command_e::VarDecl: {
    command__VarDecl* obj = static_cast<command__VarDecl*>(this);
    return obj->PrettyTree();
  }
  case command_e::PlaceMutation: {
    command__PlaceMutation* obj = static_cast<command__PlaceMutation*>(this);
    return obj->PrettyTree();
  }
  case command_e::Expr: {
    command__Expr* obj = static_cast<command__Expr*>(this);
    return obj->PrettyTree();
  }
  case command_e::Proc: {
    command__Proc* obj = static_cast<command__Proc*>(this);
    return obj->PrettyTree();
  }
  case command_e::Func: {
    command__Func* obj = static_cast<command__Func*>(this);
    return obj->PrettyTree();
  }
  case command_e::TeaFunc: {
    command__TeaFunc* obj = static_cast<command__TeaFunc*>(this);
    return obj->PrettyTree();
  }
  case command_e::Data: {
    command__Data* obj = static_cast<command__Data*>(this);
    return obj->PrettyTree();
  }
  case command_e::Enum: {
    command__Enum* obj = static_cast<command__Enum*>(this);
    return obj->PrettyTree();
  }
  case command_e::Class: {
    command__Class* obj = static_cast<command__Class*>(this);
    return obj->PrettyTree();
  }
  case command_e::Import: {
    command__Import* obj = static_cast<command__Import*>(this);
    return obj->PrettyTree();
  }
  case command_e::For: {
    command__For* obj = static_cast<command__For*>(this);
    return obj->PrettyTree();
  }
  case command_e::While: {
    command__While* obj = static_cast<command__While*>(this);
    return obj->PrettyTree();
  }
  case command_e::Break: {
    command__Break* obj = static_cast<command__Break*>(this);
    return obj->PrettyTree();
  }
  case command_e::Continue: {
    command__Continue* obj = static_cast<command__Continue*>(this);
    return obj->PrettyTree();
  }
  case command_e::Return: {
    command__Return* obj = static_cast<command__Return*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* variant_type_str(int tag) {
  switch (tag) {
  case variant_type_e::Anon:
    return "variant_type.Anon";
  case variant_type_e::Ref:
    return "variant_type.Ref";
  default:
    assert(0);
  }
}

hnode_t* variant_type__Anon::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("variant_type.Anon"));
  List<Field*>* L = out_node->fields;

  if (this->params != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Param*> it(this->params); !it.Done(); it.Next()) {
      Param* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("params"), x0));
  }

  return out_node;
}

hnode_t* variant_type__Ref::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("variant_type.Ref"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->type_name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("type_name"), x0));

  return out_node;
}

hnode_t* variant_type_t::PrettyTree() {
  switch (this->tag()) {
  case variant_type_e::Anon: {
    variant_type__Anon* obj = static_cast<variant_type__Anon*>(this);
    return obj->PrettyTree();
  }
  case variant_type_e::Ref: {
    variant_type__Ref* obj = static_cast<variant_type__Ref*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* Variant::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("Variant"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->tag_name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("tag_name"), x0));

  if (this->typ) {  // Optional
    hnode_t* x1 = this->typ->PrettyTree();
    L->append(Alloc<Field>(StrFromC("typ"), x1));
  }

  return out_node;
}
const char* class_item_str(int tag) {
  switch (tag) {
  case class_item_e::Data:
    return "class_item.Data";
  case class_item_e::Method:
    return "class_item.Method";
  default:
    assert(0);
  }
}

class_item__Method* class_item::Method = &gclass_item__Method.obj;

GcGlobal<class_item__Method> gclass_item__Method = 
  {{kNotInPool, class_item_e::Method, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* class_item__Data::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("class_item.Data"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->keyword->PrettyTree();
  L->append(Alloc<Field>(StrFromC("keyword"), x0));

  if (this->fields != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<NameType*> it(this->fields); !it.Done(); it.Next()) {
      NameType* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("fields"), x1));
  }

  return out_node;
}

hnode_t* class_item__Method::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("class_item.Method"));
  return out_node;
}

hnode_t* class_item_t::PrettyTree() {
  switch (this->tag()) {
  case class_item_e::Data: {
    class_item__Data* obj = static_cast<class_item__Data*>(this);
    return obj->PrettyTree();
  }
  case class_item_e::Method: {
    class_item__Method* obj = static_cast<class_item__Method*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* ImportName::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("ImportName"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  if (this->alias) {  // Optional
    hnode_t* x1 = this->alias->PrettyTree();
    L->append(Alloc<Field>(StrFromC("alias"), x1));
  }

  return out_node;
}

hnode_t* ProcParam::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("ProcParam"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  if (this->type) {  // Optional
    hnode_t* x1 = this->type->PrettyTree();
    L->append(Alloc<Field>(StrFromC("type"), x1));
  }

  if (this->default_val) {  // Optional
    hnode_t* x2 = this->default_val->PrettyTree();
    L->append(Alloc<Field>(StrFromC("default_val"), x2));
  }

  return out_node;
}
const char* proc_sig_str(int tag) {
  switch (tag) {
  case proc_sig_e::Open:
    return "proc_sig.Open";
  case proc_sig_e::Closed:
    return "proc_sig.Closed";
  default:
    assert(0);
  }
}

proc_sig__Open* proc_sig::Open = &gproc_sig__Open.obj;

GcGlobal<proc_sig__Open> gproc_sig__Open = 
  {{kNotInPool, proc_sig_e::Open, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* proc_sig__Open::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("proc_sig.Open"));
  return out_node;
}

hnode_t* proc_sig__Closed::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("proc_sig.Closed"));
  List<Field*>* L = out_node->fields;

  if (this->pos_params != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<ProcParam*> it(this->pos_params); !it.Done(); it.Next()) {
      ProcParam* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("pos_params"), x0));
  }

  if (this->rest) {  // Optional
    hnode_t* x1 = this->rest->PrettyTree();
    L->append(Alloc<Field>(StrFromC("rest"), x1));
  }

  return out_node;
}

hnode_t* proc_sig_t::PrettyTree() {
  switch (this->tag()) {
  case proc_sig_e::Open: {
    proc_sig__Open* obj = static_cast<proc_sig__Open*>(this);
    return obj->PrettyTree();
  }
  case proc_sig_e::Closed: {
    proc_sig__Closed* obj = static_cast<proc_sig__Closed*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* Param::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("Param"));
  List<Field*>* L = out_node->fields;

  if (this->prefix) {  // Optional
    hnode_t* x0 = this->prefix->PrettyTree();
    L->append(Alloc<Field>(StrFromC("prefix"), x0));
  }

  hnode_t* x1 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x1));

  if (this->type) {  // Optional
    hnode_t* x2 = this->type->PrettyTree();
    L->append(Alloc<Field>(StrFromC("type"), x2));
  }

  if (this->default_val) {  // Optional
    hnode_t* x3 = this->default_val->PrettyTree();
    L->append(Alloc<Field>(StrFromC("default_val"), x3));
  }

  return out_node;
}
const char* glob_part_str(int tag) {
  switch (tag) {
  case glob_part_e::Literal:
    return "glob_part.Literal";
  case glob_part_e::Operator:
    return "glob_part.Operator";
  case glob_part_e::CharClass:
    return "glob_part.CharClass";
  default:
    assert(0);
  }
}

hnode_t* glob_part__Literal::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("glob_part.Literal"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("id"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->s, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("s"), x1));

  return out_node;
}

hnode_t* glob_part__Operator::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("glob_part.Operator"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->op_id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("op_id"), x0));

  return out_node;
}

hnode_t* glob_part__CharClass::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("glob_part.CharClass"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(this->negated ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("negated"), x0));

  if (this->strs != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Str*> it(this->strs); !it.Done(); it.Next()) {
      Str* i1 = it.Value();
      x1->children->append(runtime::NewLeaf(i1, color_e::StringConst));
    }
    L->append(Alloc<Field>(StrFromC("strs"), x1));
  }

  return out_node;
}

hnode_t* glob_part_t::PrettyTree() {
  switch (this->tag()) {
  case glob_part_e::Literal: {
    glob_part__Literal* obj = static_cast<glob_part__Literal*>(this);
    return obj->PrettyTree();
  }
  case glob_part_e::Operator: {
    glob_part__Operator* obj = static_cast<glob_part__Operator*>(this);
    return obj->PrettyTree();
  }
  case glob_part_e::CharClass: {
    glob_part__CharClass* obj = static_cast<glob_part__CharClass*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* printf_part_str(int tag) {
  switch (tag) {
  case printf_part_e::Literal:
    return "printf_part.Literal";
  case printf_part_e::Percent:
    return "printf_part.Percent";
  default:
    assert(0);
  }
}

hnode_t* printf_part__Literal::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("printf_part.Literal"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->token->PrettyTree();
  L->append(Alloc<Field>(StrFromC("token"), x0));

  return out_node;
}

hnode_t* printf_part__Percent::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("printf_part.Percent"));
  List<Field*>* L = out_node->fields;

  if (this->flags != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Token*> it(this->flags); !it.Done(); it.Next()) {
      Token* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("flags"), x0));
  }

  if (this->width) {  // Optional
    hnode_t* x1 = this->width->PrettyTree();
    L->append(Alloc<Field>(StrFromC("width"), x1));
  }

  if (this->precision) {  // Optional
    hnode_t* x2 = this->precision->PrettyTree();
    L->append(Alloc<Field>(StrFromC("precision"), x2));
  }

  hnode_t* x3 = this->type->PrettyTree();
  L->append(Alloc<Field>(StrFromC("type"), x3));

  return out_node;
}

hnode_t* printf_part_t::PrettyTree() {
  switch (this->tag()) {
  case printf_part_e::Literal: {
    printf_part__Literal* obj = static_cast<printf_part__Literal*>(this);
    return obj->PrettyTree();
  }
  case printf_part_e::Percent: {
    printf_part__Percent* obj = static_cast<printf_part__Percent*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* expr_context_str(expr_context_e tag) {
  switch (tag) {
  case expr_context_e::Load:
    return "expr_context.Load";
  case expr_context_e::Store:
    return "expr_context.Store";
  case expr_context_e::Del:
    return "expr_context.Del";
  case expr_context_e::AugLoad:
    return "expr_context.AugLoad";
  case expr_context_e::AugStore:
    return "expr_context.AugStore";
  case expr_context_e::Param:
    return "expr_context.Param";
  default:
    assert(0);
  }
}
const char* type_expr_str(int tag) {
  switch (tag) {
  case type_expr_e::Simple:
    return "type_expr.Simple";
  case type_expr_e::Compound:
    return "type_expr.Compound";
  default:
    assert(0);
  }
}

hnode_t* type_expr__Simple::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("type_expr.Simple"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->tok->PrettyTree();
  L->append(Alloc<Field>(StrFromC("tok"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x1));

  return out_node;
}

hnode_t* type_expr__Compound::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("type_expr.Compound"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  if (this->params != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<type_expr_t*> it(this->params); !it.Done(); it.Next()) {
      type_expr_t* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("params"), x1));
  }

  return out_node;
}

hnode_t* type_expr_t::PrettyTree() {
  switch (this->tag()) {
  case type_expr_e::Simple: {
    type_expr__Simple* obj = static_cast<type_expr__Simple*>(this);
    return obj->PrettyTree();
  }
  case type_expr_e::Compound: {
    type_expr__Compound* obj = static_cast<type_expr__Compound*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* NameType::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("NameType"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  if (this->typ) {  // Optional
    hnode_t* x1 = this->typ->PrettyTree();
    L->append(Alloc<Field>(StrFromC("typ"), x1));
  }

  return out_node;
}

hnode_t* Comprehension::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("Comprehension"));
  List<Field*>* L = out_node->fields;

  if (this->lhs != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<NameType*> it(this->lhs); !it.Done(); it.Next()) {
      NameType* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("lhs"), x0));
  }

  hnode_t* x1 = this->iter->PrettyTree();
  L->append(Alloc<Field>(StrFromC("iter"), x1));

  if (this->cond) {  // Optional
    hnode_t* x2 = this->cond->PrettyTree();
    L->append(Alloc<Field>(StrFromC("cond"), x2));
  }

  return out_node;
}

hnode_t* NamedArg::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("NamedArg"));
  List<Field*>* L = out_node->fields;

  if (this->name) {  // Optional
    hnode_t* x0 = this->name->PrettyTree();
    L->append(Alloc<Field>(StrFromC("name"), x0));
  }

  hnode_t* x1 = this->value->PrettyTree();
  L->append(Alloc<Field>(StrFromC("value"), x1));

  return out_node;
}

hnode_t* Subscript::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("Subscript"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->obj->PrettyTree();
  L->append(Alloc<Field>(StrFromC("obj"), x0));

  hnode_t* x1 = this->index->PrettyTree();
  L->append(Alloc<Field>(StrFromC("index"), x1));

  return out_node;
}

hnode_t* Attribute::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("Attribute"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->obj->PrettyTree();
  L->append(Alloc<Field>(StrFromC("obj"), x0));

  hnode_t* x1 = this->op->PrettyTree();
  L->append(Alloc<Field>(StrFromC("op"), x1));

  hnode_t* x2 = this->attr->PrettyTree();
  L->append(Alloc<Field>(StrFromC("attr"), x2));

  hnode_t* x3 = Alloc<hnode::Leaf>(StrFromC(expr_context_str(this->ctx)),
                                   color_e::TypeName);
  L->append(Alloc<Field>(StrFromC("ctx"), x3));

  return out_node;
}
const char* place_expr_str(int tag) {
  switch (tag) {
  case place_expr_e::Var:
    return "place_expr.Var";
  case place_expr_e::Subscript:
    return "place_expr.Subscript";
  case place_expr_e::Attribute:
    return "place_expr.Attribute";
  default:
    assert(0);
  }
}

hnode_t* place_expr__Var::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("place_expr.Var"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  return out_node;
}

hnode_t* place_expr_t::PrettyTree() {
  switch (this->tag()) {
  case place_expr_e::Var: {
    place_expr__Var* obj = static_cast<place_expr__Var*>(this);
    return obj->PrettyTree();
  }
  case place_expr_e::Subscript: {
    Subscript* obj = static_cast<Subscript*>(this);
    return obj->PrettyTree();
  }
  case place_expr_e::Attribute: {
    Attribute* obj = static_cast<Attribute*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* expr_str(int tag) {
  switch (tag) {
  case expr_e::Var:
    return "expr.Var";
  case expr_e::Const:
    return "expr.Const";
  case expr_e::ShArrayLiteral:
    return "expr.ShArrayLiteral";
  case expr_e::RegexLiteral:
    return "expr.RegexLiteral";
  case expr_e::SimpleVarSub:
    return "expr.SimpleVarSub";
  case expr_e::BracedVarSub:
    return "expr.BracedVarSub";
  case expr_e::CommandSub:
    return "expr.CommandSub";
  case expr_e::SingleQuoted:
    return "expr.SingleQuoted";
  case expr_e::DoubleQuoted:
    return "expr.DoubleQuoted";
  case expr_e::BlockArg:
    return "expr.BlockArg";
  case expr_e::Lambda:
    return "expr.Lambda";
  case expr_e::Unary:
    return "expr.Unary";
  case expr_e::Binary:
    return "expr.Binary";
  case expr_e::Compare:
    return "expr.Compare";
  case expr_e::FuncCall:
    return "expr.FuncCall";
  case expr_e::IfExp:
    return "expr.IfExp";
  case expr_e::Tuple:
    return "expr.Tuple";
  case expr_e::List:
    return "expr.List";
  case expr_e::Dict:
    return "expr.Dict";
  case expr_e::Implicit:
    return "expr.Implicit";
  case expr_e::ListComp:
    return "expr.ListComp";
  case expr_e::DictComp:
    return "expr.DictComp";
  case expr_e::GeneratorExp:
    return "expr.GeneratorExp";
  case expr_e::Slice:
    return "expr.Slice";
  case expr_e::Subscript:
    return "expr.Subscript";
  case expr_e::Attribute:
    return "expr.Attribute";
  case expr_e::Spread:
    return "expr.Spread";
  default:
    assert(0);
  }
}

expr__Implicit* expr::Implicit = &gexpr__Implicit.obj;

GcGlobal<expr__Implicit> gexpr__Implicit = 
  {{kNotInPool, expr_e::Implicit, kZeroMask, HeapTag::Global, kIsGlobal}};

hnode_t* expr__Var::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.Var"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  return out_node;
}

hnode_t* expr__Const::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.Const"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->c->PrettyTree();
  L->append(Alloc<Field>(StrFromC("c"), x0));

  return out_node;
}

hnode_t* expr__RegexLiteral::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.RegexLiteral"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->regex->PrettyTree();
  L->append(Alloc<Field>(StrFromC("regex"), x1));

  if (this->flags != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Token*> it(this->flags); !it.Done(); it.Next()) {
      Token* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("flags"), x2));
  }

  if (this->trans_pref) {  // Optional
    hnode_t* x3 = this->trans_pref->PrettyTree();
    L->append(Alloc<Field>(StrFromC("trans_pref"), x3));
  }

  return out_node;
}

hnode_t* expr__Lambda::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.Lambda"));
  List<Field*>* L = out_node->fields;

  if (this->params != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<NameType*> it(this->params); !it.Done(); it.Next()) {
      NameType* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("params"), x0));
  }

  hnode_t* x1 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x1));

  return out_node;
}

hnode_t* expr__Unary::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.Unary"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->op->PrettyTree();
  L->append(Alloc<Field>(StrFromC("op"), x0));

  hnode_t* x1 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x1));

  return out_node;
}

hnode_t* expr__Binary::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.Binary"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->op->PrettyTree();
  L->append(Alloc<Field>(StrFromC("op"), x0));

  hnode_t* x1 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x1));

  hnode_t* x2 = this->right->PrettyTree();
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}

hnode_t* expr__Compare::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.Compare"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree();
  L->append(Alloc<Field>(StrFromC("left"), x0));

  if (this->ops != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Token*> it(this->ops); !it.Done(); it.Next()) {
      Token* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("ops"), x1));
  }

  if (this->comparators != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<expr_t*> it(this->comparators); !it.Done(); it.Next()) {
      expr_t* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("comparators"), x2));
  }

  return out_node;
}

hnode_t* expr__FuncCall::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.FuncCall"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->func->PrettyTree();
  L->append(Alloc<Field>(StrFromC("func"), x0));

  hnode_t* x1 = this->args->PrettyTree();
  L->append(Alloc<Field>(StrFromC("args"), x1));

  return out_node;
}

hnode_t* expr__IfExp::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.IfExp"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->test->PrettyTree();
  L->append(Alloc<Field>(StrFromC("test"), x0));

  hnode_t* x1 = this->body->PrettyTree();
  L->append(Alloc<Field>(StrFromC("body"), x1));

  hnode_t* x2 = this->orelse->PrettyTree();
  L->append(Alloc<Field>(StrFromC("orelse"), x2));

  return out_node;
}

hnode_t* expr__Tuple::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.Tuple"));
  List<Field*>* L = out_node->fields;

  if (this->elts != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<expr_t*> it(this->elts); !it.Done(); it.Next()) {
      expr_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("elts"), x0));
  }

  hnode_t* x1 = Alloc<hnode::Leaf>(StrFromC(expr_context_str(this->ctx)),
                                   color_e::TypeName);
  L->append(Alloc<Field>(StrFromC("ctx"), x1));

  return out_node;
}

hnode_t* expr__List::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.List"));
  List<Field*>* L = out_node->fields;

  if (this->elts != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<expr_t*> it(this->elts); !it.Done(); it.Next()) {
      expr_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("elts"), x0));
  }

  hnode_t* x1 = Alloc<hnode::Leaf>(StrFromC(expr_context_str(this->ctx)),
                                   color_e::TypeName);
  L->append(Alloc<Field>(StrFromC("ctx"), x1));

  return out_node;
}

hnode_t* expr__Dict::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.Dict"));
  List<Field*>* L = out_node->fields;

  if (this->keys != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<expr_t*> it(this->keys); !it.Done(); it.Next()) {
      expr_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("keys"), x0));
  }

  if (this->values != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<expr_t*> it(this->values); !it.Done(); it.Next()) {
      expr_t* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("values"), x1));
  }

  return out_node;
}

hnode_t* expr__Implicit::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.Implicit"));
  return out_node;
}

hnode_t* expr__ListComp::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.ListComp"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->elt->PrettyTree();
  L->append(Alloc<Field>(StrFromC("elt"), x0));

  if (this->generators != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Comprehension*> it(this->generators); !it.Done(); it.Next()) {
      Comprehension* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("generators"), x1));
  }

  return out_node;
}

hnode_t* expr__DictComp::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.DictComp"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->key->PrettyTree();
  L->append(Alloc<Field>(StrFromC("key"), x0));

  hnode_t* x1 = this->value->PrettyTree();
  L->append(Alloc<Field>(StrFromC("value"), x1));

  if (this->generators != nullptr) {  // List
    hnode::Array* x2 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Comprehension*> it(this->generators); !it.Done(); it.Next()) {
      Comprehension* i2 = it.Value();
      x2->children->append(i2->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("generators"), x2));
  }

  return out_node;
}

hnode_t* expr__GeneratorExp::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.GeneratorExp"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->elt->PrettyTree();
  L->append(Alloc<Field>(StrFromC("elt"), x0));

  if (this->generators != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<Comprehension*> it(this->generators); !it.Done(); it.Next()) {
      Comprehension* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("generators"), x1));
  }

  return out_node;
}

hnode_t* expr__Slice::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.Slice"));
  List<Field*>* L = out_node->fields;

  if (this->lower) {  // Optional
    hnode_t* x0 = this->lower->PrettyTree();
    L->append(Alloc<Field>(StrFromC("lower"), x0));
  }

  if (this->upper) {  // Optional
    hnode_t* x1 = this->upper->PrettyTree();
    L->append(Alloc<Field>(StrFromC("upper"), x1));
  }

  return out_node;
}

hnode_t* expr__Spread::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("expr.Spread"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x0));

  hnode_t* x1 = Alloc<hnode::Leaf>(StrFromC(expr_context_str(this->ctx)),
                                   color_e::TypeName);
  L->append(Alloc<Field>(StrFromC("ctx"), x1));

  return out_node;
}

hnode_t* expr_t::PrettyTree() {
  switch (this->tag()) {
  case expr_e::Var: {
    expr__Var* obj = static_cast<expr__Var*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Const: {
    expr__Const* obj = static_cast<expr__Const*>(this);
    return obj->PrettyTree();
  }
  case expr_e::ShArrayLiteral: {
    ShArrayLiteral* obj = static_cast<ShArrayLiteral*>(this);
    return obj->PrettyTree();
  }
  case expr_e::RegexLiteral: {
    expr__RegexLiteral* obj = static_cast<expr__RegexLiteral*>(this);
    return obj->PrettyTree();
  }
  case expr_e::SimpleVarSub: {
    SimpleVarSub* obj = static_cast<SimpleVarSub*>(this);
    return obj->PrettyTree();
  }
  case expr_e::BracedVarSub: {
    BracedVarSub* obj = static_cast<BracedVarSub*>(this);
    return obj->PrettyTree();
  }
  case expr_e::CommandSub: {
    CommandSub* obj = static_cast<CommandSub*>(this);
    return obj->PrettyTree();
  }
  case expr_e::SingleQuoted: {
    SingleQuoted* obj = static_cast<SingleQuoted*>(this);
    return obj->PrettyTree();
  }
  case expr_e::DoubleQuoted: {
    DoubleQuoted* obj = static_cast<DoubleQuoted*>(this);
    return obj->PrettyTree();
  }
  case expr_e::BlockArg: {
    BlockArg* obj = static_cast<BlockArg*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Lambda: {
    expr__Lambda* obj = static_cast<expr__Lambda*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Unary: {
    expr__Unary* obj = static_cast<expr__Unary*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Binary: {
    expr__Binary* obj = static_cast<expr__Binary*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Compare: {
    expr__Compare* obj = static_cast<expr__Compare*>(this);
    return obj->PrettyTree();
  }
  case expr_e::FuncCall: {
    expr__FuncCall* obj = static_cast<expr__FuncCall*>(this);
    return obj->PrettyTree();
  }
  case expr_e::IfExp: {
    expr__IfExp* obj = static_cast<expr__IfExp*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Tuple: {
    expr__Tuple* obj = static_cast<expr__Tuple*>(this);
    return obj->PrettyTree();
  }
  case expr_e::List: {
    expr__List* obj = static_cast<expr__List*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Dict: {
    expr__Dict* obj = static_cast<expr__Dict*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Implicit: {
    expr__Implicit* obj = static_cast<expr__Implicit*>(this);
    return obj->PrettyTree();
  }
  case expr_e::ListComp: {
    expr__ListComp* obj = static_cast<expr__ListComp*>(this);
    return obj->PrettyTree();
  }
  case expr_e::DictComp: {
    expr__DictComp* obj = static_cast<expr__DictComp*>(this);
    return obj->PrettyTree();
  }
  case expr_e::GeneratorExp: {
    expr__GeneratorExp* obj = static_cast<expr__GeneratorExp*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Slice: {
    expr__Slice* obj = static_cast<expr__Slice*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Subscript: {
    Subscript* obj = static_cast<Subscript*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Attribute: {
    Attribute* obj = static_cast<Attribute*>(this);
    return obj->PrettyTree();
  }
  case expr_e::Spread: {
    expr__Spread* obj = static_cast<expr__Spread*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* PosixClass::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("PosixClass"));
  List<Field*>* L = out_node->fields;

  if (this->negated) {  // Optional
    hnode_t* x0 = this->negated->PrettyTree();
    L->append(Alloc<Field>(StrFromC("negated"), x0));
  }

  hnode_t* x1 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x1));

  return out_node;
}

hnode_t* PerlClass::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("PerlClass"));
  List<Field*>* L = out_node->fields;

  if (this->negated) {  // Optional
    hnode_t* x0 = this->negated->PrettyTree();
    L->append(Alloc<Field>(StrFromC("negated"), x0));
  }

  hnode_t* x1 = runtime::NewLeaf(this->name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("name"), x1));

  return out_node;
}
const char* class_literal_term_str(int tag) {
  switch (tag) {
  case class_literal_term_e::PosixClass:
    return "class_literal_term.PosixClass";
  case class_literal_term_e::PerlClass:
    return "class_literal_term.PerlClass";
  case class_literal_term_e::Range:
    return "class_literal_term.Range";
  case class_literal_term_e::CharLiteral:
    return "class_literal_term.CharLiteral";
  case class_literal_term_e::SingleQuoted:
    return "class_literal_term.SingleQuoted";
  case class_literal_term_e::Splice:
    return "class_literal_term.Splice";
  default:
    assert(0);
  }
}

hnode_t* class_literal_term__Range::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("class_literal_term.Range"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->start->PrettyTree();
  L->append(Alloc<Field>(StrFromC("start"), x0));

  hnode_t* x1 = this->end->PrettyTree();
  L->append(Alloc<Field>(StrFromC("end"), x1));

  return out_node;
}

hnode_t* class_literal_term__CharLiteral::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("class_literal_term.CharLiteral"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->tok->PrettyTree();
  L->append(Alloc<Field>(StrFromC("tok"), x0));

  return out_node;
}

hnode_t* class_literal_term__Splice::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("class_literal_term.Splice"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->var_name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("var_name"), x1));

  return out_node;
}

hnode_t* class_literal_term_t::PrettyTree() {
  switch (this->tag()) {
  case class_literal_term_e::PosixClass: {
    PosixClass* obj = static_cast<PosixClass*>(this);
    return obj->PrettyTree();
  }
  case class_literal_term_e::PerlClass: {
    PerlClass* obj = static_cast<PerlClass*>(this);
    return obj->PrettyTree();
  }
  case class_literal_term_e::Range: {
    class_literal_term__Range* obj =
static_cast<class_literal_term__Range*>(this);
    return obj->PrettyTree();
  }
  case class_literal_term_e::CharLiteral: {
    class_literal_term__CharLiteral* obj =
static_cast<class_literal_term__CharLiteral*>(this);
    return obj->PrettyTree();
  }
  case class_literal_term_e::SingleQuoted: {
    SingleQuoted* obj = static_cast<SingleQuoted*>(this);
    return obj->PrettyTree();
  }
  case class_literal_term_e::Splice: {
    class_literal_term__Splice* obj =
static_cast<class_literal_term__Splice*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

hnode_t* CharCode::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("CharCode"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(str(this->i), color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("i"), x0));

  hnode_t* x1 = Alloc<hnode::Leaf>(this->u_braced ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("u_braced"), x1));

  hnode_t* x2 = this->blame_tok->PrettyTree();
  L->append(Alloc<Field>(StrFromC("blame_tok"), x2));

  return out_node;
}
const char* char_class_term_str(int tag) {
  switch (tag) {
  case char_class_term_e::PosixClass:
    return "char_class_term.PosixClass";
  case char_class_term_e::PerlClass:
    return "char_class_term.PerlClass";
  case char_class_term_e::Range:
    return "char_class_term.Range";
  case char_class_term_e::CharCode:
    return "char_class_term.CharCode";
  default:
    assert(0);
  }
}

hnode_t* char_class_term__Range::PrettyTree() {
  hnode::Record* out_node =
runtime::NewRecord(StrFromC("char_class_term.Range"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->start->PrettyTree();
  L->append(Alloc<Field>(StrFromC("start"), x0));

  hnode_t* x1 = this->end->PrettyTree();
  L->append(Alloc<Field>(StrFromC("end"), x1));

  return out_node;
}

hnode_t* char_class_term_t::PrettyTree() {
  switch (this->tag()) {
  case char_class_term_e::PosixClass: {
    PosixClass* obj = static_cast<PosixClass*>(this);
    return obj->PrettyTree();
  }
  case char_class_term_e::PerlClass: {
    PerlClass* obj = static_cast<PerlClass*>(this);
    return obj->PrettyTree();
  }
  case char_class_term_e::Range: {
    char_class_term__Range* obj = static_cast<char_class_term__Range*>(this);
    return obj->PrettyTree();
  }
  case char_class_term_e::CharCode: {
    CharCode* obj = static_cast<CharCode*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* re_repeat_str(int tag) {
  switch (tag) {
  case re_repeat_e::Op:
    return "re_repeat.Op";
  case re_repeat_e::Num:
    return "re_repeat.Num";
  case re_repeat_e::Range:
    return "re_repeat.Range";
  default:
    assert(0);
  }
}

hnode_t* re_repeat__Op::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re_repeat.Op"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->op->PrettyTree();
  L->append(Alloc<Field>(StrFromC("op"), x0));

  return out_node;
}

hnode_t* re_repeat__Num::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re_repeat.Num"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->times->PrettyTree();
  L->append(Alloc<Field>(StrFromC("times"), x0));

  return out_node;
}

hnode_t* re_repeat__Range::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re_repeat.Range"));
  List<Field*>* L = out_node->fields;

  if (this->lower) {  // Optional
    hnode_t* x0 = this->lower->PrettyTree();
    L->append(Alloc<Field>(StrFromC("lower"), x0));
  }

  if (this->upper) {  // Optional
    hnode_t* x1 = this->upper->PrettyTree();
    L->append(Alloc<Field>(StrFromC("upper"), x1));
  }

  return out_node;
}

hnode_t* re_repeat_t::PrettyTree() {
  switch (this->tag()) {
  case re_repeat_e::Op: {
    re_repeat__Op* obj = static_cast<re_repeat__Op*>(this);
    return obj->PrettyTree();
  }
  case re_repeat_e::Num: {
    re_repeat__Num* obj = static_cast<re_repeat__Num*>(this);
    return obj->PrettyTree();
  }
  case re_repeat_e::Range: {
    re_repeat__Range* obj = static_cast<re_repeat__Range*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}
const char* re_str(int tag) {
  switch (tag) {
  case re_e::Token:
    return "re.Token";
  case re_e::PosixClass:
    return "re.PosixClass";
  case re_e::PerlClass:
    return "re.PerlClass";
  case re_e::CharClassLiteral:
    return "re.CharClassLiteral";
  case re_e::CharClass:
    return "re.CharClass";
  case re_e::Splice:
    return "re.Splice";
  case re_e::SingleQuoted:
    return "re.SingleQuoted";
  case re_e::Repeat:
    return "re.Repeat";
  case re_e::Seq:
    return "re.Seq";
  case re_e::Alt:
    return "re.Alt";
  case re_e::Group:
    return "re.Group";
  case re_e::Capture:
    return "re.Capture";
  case re_e::Backtracking:
    return "re.Backtracking";
  case re_e::Primitive:
    return "re.Primitive";
  case re_e::LiteralChars:
    return "re.LiteralChars";
  default:
    assert(0);
  }
}

hnode_t* re__CharClassLiteral::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re.CharClassLiteral"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(this->negated ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("negated"), x0));

  if (this->terms != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<class_literal_term_t*> it(this->terms); !it.Done();
         it.Next()) {
      class_literal_term_t* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("terms"), x1));
  }

  return out_node;
}

hnode_t* re__CharClass::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re.CharClass"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(this->negated ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("negated"), x0));

  if (this->terms != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<char_class_term_t*> it(this->terms); !it.Done(); it.Next()) {
      char_class_term_t* i1 = it.Value();
      x1->children->append(i1->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("terms"), x1));
  }

  return out_node;
}

hnode_t* re__Splice::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re.Splice"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x0));

  hnode_t* x1 = runtime::NewLeaf(this->var_name, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("var_name"), x1));

  return out_node;
}

hnode_t* re__Repeat::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re.Repeat"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x0));

  hnode_t* x1 = this->op->PrettyTree();
  L->append(Alloc<Field>(StrFromC("op"), x1));

  return out_node;
}

hnode_t* re__Seq::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re.Seq"));
  List<Field*>* L = out_node->fields;

  if (this->children != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<re_t*> it(this->children); !it.Done(); it.Next()) {
      re_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("children"), x0));
  }

  return out_node;
}

hnode_t* re__Alt::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re.Alt"));
  List<Field*>* L = out_node->fields;

  if (this->children != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<re_t*> it(this->children); !it.Done(); it.Next()) {
      re_t* i0 = it.Value();
      x0->children->append(i0->PrettyTree());
    }
    L->append(Alloc<Field>(StrFromC("children"), x0));
  }

  return out_node;
}

hnode_t* re__Group::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re.Group"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x0));

  return out_node;
}

hnode_t* re__Capture::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re.Capture"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x0));

  if (this->var_name) {  // Optional
    hnode_t* x1 = this->var_name->PrettyTree();
    L->append(Alloc<Field>(StrFromC("var_name"), x1));
  }

  return out_node;
}

hnode_t* re__Backtracking::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re.Backtracking"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(this->negated ? runtime::TRUE_STR :
                                   runtime::FALSE_STR, color_e::OtherConst);
  L->append(Alloc<Field>(StrFromC("negated"), x0));

  hnode_t* x1 = this->name->PrettyTree();
  L->append(Alloc<Field>(StrFromC("name"), x1));

  hnode_t* x2 = this->child->PrettyTree();
  L->append(Alloc<Field>(StrFromC("child"), x2));

  return out_node;
}

hnode_t* re__Primitive::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re.Primitive"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(StrFromC(Id_str(this->id)),
                                   color_e::UserType);
  L->append(Alloc<Field>(StrFromC("id"), x0));

  return out_node;
}

hnode_t* re__LiteralChars::PrettyTree() {
  hnode::Record* out_node = runtime::NewRecord(StrFromC("re.LiteralChars"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = runtime::NewLeaf(this->s, color_e::StringConst);
  L->append(Alloc<Field>(StrFromC("s"), x0));

  hnode_t* x1 = this->blame_tok->PrettyTree();
  L->append(Alloc<Field>(StrFromC("blame_tok"), x1));

  return out_node;
}

hnode_t* re_t::PrettyTree() {
  switch (this->tag()) {
  case re_e::Token: {
    Token* obj = static_cast<Token*>(this);
    return obj->PrettyTree();
  }
  case re_e::PosixClass: {
    PosixClass* obj = static_cast<PosixClass*>(this);
    return obj->PrettyTree();
  }
  case re_e::PerlClass: {
    PerlClass* obj = static_cast<PerlClass*>(this);
    return obj->PrettyTree();
  }
  case re_e::CharClassLiteral: {
    re__CharClassLiteral* obj = static_cast<re__CharClassLiteral*>(this);
    return obj->PrettyTree();
  }
  case re_e::CharClass: {
    re__CharClass* obj = static_cast<re__CharClass*>(this);
    return obj->PrettyTree();
  }
  case re_e::Splice: {
    re__Splice* obj = static_cast<re__Splice*>(this);
    return obj->PrettyTree();
  }
  case re_e::SingleQuoted: {
    SingleQuoted* obj = static_cast<SingleQuoted*>(this);
    return obj->PrettyTree();
  }
  case re_e::Repeat: {
    re__Repeat* obj = static_cast<re__Repeat*>(this);
    return obj->PrettyTree();
  }
  case re_e::Seq: {
    re__Seq* obj = static_cast<re__Seq*>(this);
    return obj->PrettyTree();
  }
  case re_e::Alt: {
    re__Alt* obj = static_cast<re__Alt*>(this);
    return obj->PrettyTree();
  }
  case re_e::Group: {
    re__Group* obj = static_cast<re__Group*>(this);
    return obj->PrettyTree();
  }
  case re_e::Capture: {
    re__Capture* obj = static_cast<re__Capture*>(this);
    return obj->PrettyTree();
  }
  case re_e::Backtracking: {
    re__Backtracking* obj = static_cast<re__Backtracking*>(this);
    return obj->PrettyTree();
  }
  case re_e::Primitive: {
    re__Primitive* obj = static_cast<re__Primitive*>(this);
    return obj->PrettyTree();
  }
  case re_e::LiteralChars: {
    re__LiteralChars* obj = static_cast<re__LiteralChars*>(this);
    return obj->PrettyTree();
  }
  default:
    assert(0);
  }
}

}  // namespace syntax_asdl
