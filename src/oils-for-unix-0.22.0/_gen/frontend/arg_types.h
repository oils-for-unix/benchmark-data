// arg_types.h is generated by frontend/flag_gen.py

#ifndef ARG_TYPES_H
#define ARG_TYPES_H

#include "cpp/frontend_flag_spec.h"  // for FlagSpec_c
#include "mycpp/gc_mylib.h"

using value_asdl::value;
using value_asdl::value_e;

namespace arg_types {

class cd {
 public:
  cd(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : L(static_cast<value::Bool*>(attrs->at(StrFromC("L")))->b),
        P(static_cast<value::Bool*>(attrs->at(StrFromC("P")))->b) {
  }

  bool L;
  bool P;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(cd));
  }
};

class command {
 public:
  command(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : V(static_cast<value::Bool*>(attrs->at(StrFromC("V")))->b),
        p(static_cast<value::Bool*>(attrs->at(StrFromC("p")))->b),
        v(static_cast<value::Bool*>(attrs->at(StrFromC("v")))->b) {
  }

  bool V;
  bool p;
  bool v;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(command));
  }
};

class compadjust {
 public:
  compadjust(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : n(attrs->at(StrFromC("n"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("n")))->s),
        s(static_cast<value::Bool*>(attrs->at(StrFromC("s")))->b) {
  }

  BigStr* n;
  bool s;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::FixedSize, field_mask(), sizeof(compadjust));
  }

  static constexpr uint32_t field_mask() {
    return
      maskbit(offsetof(compadjust, n));
  }

};

class compexport {
 public:
  compexport(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : begin(attrs->at(StrFromC("begin"))->tag() == value_e::Undef
          ? -1
          : static_cast<value::Int*>(attrs->at(StrFromC("begin")))->i),
        c(attrs->at(StrFromC("c"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("c")))->s),
        end(attrs->at(StrFromC("end"))->tag() == value_e::Undef
          ? -1
          : static_cast<value::Int*>(attrs->at(StrFromC("end")))->i),
        format(attrs->at(StrFromC("format"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("format")))->s) {
  }

  int begin;
  BigStr* c;
  int end;
  BigStr* format;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::FixedSize, field_mask(), sizeof(compexport));
  }

  static constexpr uint32_t field_mask() {
    return
      maskbit(offsetof(compexport, c))
    | maskbit(offsetof(compexport, format));
  }

};

class compgen {
 public:
  compgen(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : C(attrs->at(StrFromC("C"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("C")))->s),
        F(attrs->at(StrFromC("F"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("F")))->s),
        P(attrs->at(StrFromC("P"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("P")))->s),
        S(attrs->at(StrFromC("S"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("S")))->s),
        W(attrs->at(StrFromC("W"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("W")))->s),
        X(attrs->at(StrFromC("X"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("X")))->s) {
  }

  BigStr* C;
  BigStr* F;
  BigStr* P;
  BigStr* S;
  BigStr* W;
  BigStr* X;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::FixedSize, field_mask(), sizeof(compgen));
  }

  static constexpr uint32_t field_mask() {
    return
      maskbit(offsetof(compgen, C))
    | maskbit(offsetof(compgen, F))
    | maskbit(offsetof(compgen, P))
    | maskbit(offsetof(compgen, S))
    | maskbit(offsetof(compgen, W))
    | maskbit(offsetof(compgen, X));
  }

};

class complete {
 public:
  complete(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : C(attrs->at(StrFromC("C"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("C")))->s),
        D(static_cast<value::Bool*>(attrs->at(StrFromC("D")))->b),
        E(static_cast<value::Bool*>(attrs->at(StrFromC("E")))->b),
        F(attrs->at(StrFromC("F"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("F")))->s),
        P(attrs->at(StrFromC("P"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("P")))->s),
        S(attrs->at(StrFromC("S"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("S")))->s),
        W(attrs->at(StrFromC("W"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("W")))->s),
        X(attrs->at(StrFromC("X"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("X")))->s) {
  }

  BigStr* C;
  bool D;
  bool E;
  BigStr* F;
  BigStr* P;
  BigStr* S;
  BigStr* W;
  BigStr* X;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::FixedSize, field_mask(), sizeof(complete));
  }

  static constexpr uint32_t field_mask() {
    return
      maskbit(offsetof(complete, C))
    | maskbit(offsetof(complete, F))
    | maskbit(offsetof(complete, P))
    | maskbit(offsetof(complete, S))
    | maskbit(offsetof(complete, W))
    | maskbit(offsetof(complete, X));
  }

};

class dirs {
 public:
  dirs(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : c(static_cast<value::Bool*>(attrs->at(StrFromC("c")))->b),
        l(static_cast<value::Bool*>(attrs->at(StrFromC("l")))->b),
        p(static_cast<value::Bool*>(attrs->at(StrFromC("p")))->b),
        v(static_cast<value::Bool*>(attrs->at(StrFromC("v")))->b) {
  }

  bool c;
  bool l;
  bool p;
  bool v;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(dirs));
  }
};

class echo {
 public:
  echo(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : e(static_cast<value::Bool*>(attrs->at(StrFromC("e")))->b),
        n(static_cast<value::Bool*>(attrs->at(StrFromC("n")))->b) {
  }

  bool e;
  bool n;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(echo));
  }
};

class export_ {
 public:
  export_(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : f(static_cast<value::Bool*>(attrs->at(StrFromC("f")))->b),
        n(static_cast<value::Bool*>(attrs->at(StrFromC("n")))->b),
        p(static_cast<value::Bool*>(attrs->at(StrFromC("p")))->b) {
  }

  bool f;
  bool n;
  bool p;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(export_));
  }
};

class hash {
 public:
  hash(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : r(static_cast<value::Bool*>(attrs->at(StrFromC("r")))->b) {
  }

  bool r;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(hash));
  }
};

class history {
 public:
  history(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : a(static_cast<value::Bool*>(attrs->at(StrFromC("a")))->b),
        c(static_cast<value::Bool*>(attrs->at(StrFromC("c")))->b),
        d(attrs->at(StrFromC("d"))->tag() == value_e::Undef
          ? -1
          : static_cast<value::Int*>(attrs->at(StrFromC("d")))->i),
        r(static_cast<value::Bool*>(attrs->at(StrFromC("r")))->b) {
  }

  bool a;
  bool c;
  int d;
  bool r;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(history));
  }
};

class jobs {
 public:
  jobs(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : debug(static_cast<value::Bool*>(attrs->at(StrFromC("debug")))->b),
        l(static_cast<value::Bool*>(attrs->at(StrFromC("l")))->b),
        p(static_cast<value::Bool*>(attrs->at(StrFromC("p")))->b) {
  }

  bool debug;
  bool l;
  bool p;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(jobs));
  }
};

class json_write {
 public:
  json_write(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : indent(attrs->at(StrFromC("indent"))->tag() == value_e::Undef
          ? -1
          : static_cast<value::Int*>(attrs->at(StrFromC("indent")))->i),
        pretty(static_cast<value::Bool*>(attrs->at(StrFromC("pretty")))->b),
        surrogate_ok(static_cast<value::Bool*>(attrs->at(StrFromC("surrogate_ok")))->b) {
  }

  int indent;
  bool pretty;
  bool surrogate_ok;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(json_write));
  }
};

class main {
 public:
  main(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : ast_format(attrs->at(StrFromC("ast_format"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("ast_format")))->s),
        c(attrs->at(StrFromC("c"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("c")))->s),
        completion_demo(static_cast<value::Bool*>(attrs->at(StrFromC("completion_demo")))->b),
        completion_display(attrs->at(StrFromC("completion_display"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("completion_display")))->s),
        debug_file(attrs->at(StrFromC("debug_file"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("debug_file")))->s),
        do_lossless(static_cast<value::Bool*>(attrs->at(StrFromC("do_lossless")))->b),
        headless(static_cast<value::Bool*>(attrs->at(StrFromC("headless")))->b),
        help(static_cast<value::Bool*>(attrs->at(StrFromC("help")))->b),
        i(static_cast<value::Bool*>(attrs->at(StrFromC("i")))->b),
        l(static_cast<value::Bool*>(attrs->at(StrFromC("l")))->b),
        location_start_line(attrs->at(StrFromC("location_start_line"))->tag() == value_e::Undef
          ? -1
          : static_cast<value::Int*>(attrs->at(StrFromC("location_start_line")))->i),
        location_str(attrs->at(StrFromC("location_str"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("location_str")))->s),
        login(static_cast<value::Bool*>(attrs->at(StrFromC("login")))->b),
        norc(static_cast<value::Bool*>(attrs->at(StrFromC("norc")))->b),
        print_status(static_cast<value::Bool*>(attrs->at(StrFromC("print_status")))->b),
        rcdir(attrs->at(StrFromC("rcdir"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("rcdir")))->s),
        rcfile(attrs->at(StrFromC("rcfile"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("rcfile")))->s),
        tool(attrs->at(StrFromC("tool"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("tool")))->s),
        version(static_cast<value::Bool*>(attrs->at(StrFromC("version")))->b),
        xtrace_to_debug_file(static_cast<value::Bool*>(attrs->at(StrFromC("xtrace_to_debug_file")))->b) {
  }

  BigStr* ast_format;
  BigStr* c;
  bool completion_demo;
  BigStr* completion_display;
  BigStr* debug_file;
  bool do_lossless;
  bool headless;
  bool help;
  bool i;
  bool l;
  int location_start_line;
  BigStr* location_str;
  bool login;
  bool norc;
  bool print_status;
  BigStr* rcdir;
  BigStr* rcfile;
  BigStr* tool;
  bool version;
  bool xtrace_to_debug_file;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::FixedSize, field_mask(), sizeof(main));
  }

  static constexpr uint32_t field_mask() {
    return
      maskbit(offsetof(main, ast_format))
    | maskbit(offsetof(main, c))
    | maskbit(offsetof(main, completion_display))
    | maskbit(offsetof(main, debug_file))
    | maskbit(offsetof(main, location_str))
    | maskbit(offsetof(main, rcdir))
    | maskbit(offsetof(main, rcfile))
    | maskbit(offsetof(main, tool));
  }

};

class mapfile {
 public:
  mapfile(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : t(static_cast<value::Bool*>(attrs->at(StrFromC("t")))->b) {
  }

  bool t;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(mapfile));
  }
};

class new_var {
 public:
  new_var(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : A(static_cast<value::Bool*>(attrs->at(StrFromC("A")))->b),
        F(static_cast<value::Bool*>(attrs->at(StrFromC("F")))->b),
        a(static_cast<value::Bool*>(attrs->at(StrFromC("a")))->b),
        f(static_cast<value::Bool*>(attrs->at(StrFromC("f")))->b),
        g(static_cast<value::Bool*>(attrs->at(StrFromC("g")))->b),
        i(static_cast<value::Bool*>(attrs->at(StrFromC("i")))->b),
        n(attrs->at(StrFromC("n"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("n")))->s),
        p(static_cast<value::Bool*>(attrs->at(StrFromC("p")))->b),
        r(attrs->at(StrFromC("r"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("r")))->s),
        x(attrs->at(StrFromC("x"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("x")))->s) {
  }

  bool A;
  bool F;
  bool a;
  bool f;
  bool g;
  bool i;
  BigStr* n;
  bool p;
  BigStr* r;
  BigStr* x;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::FixedSize, field_mask(), sizeof(new_var));
  }

  static constexpr uint32_t field_mask() {
    return
      maskbit(offsetof(new_var, n))
    | maskbit(offsetof(new_var, r))
    | maskbit(offsetof(new_var, x));
  }

};

class printf {
 public:
  printf(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : v(attrs->at(StrFromC("v"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("v")))->s) {
  }

  BigStr* v;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::FixedSize, field_mask(), sizeof(printf));
  }

  static constexpr uint32_t field_mask() {
    return
      maskbit(offsetof(printf, v));
  }

};

class pwd {
 public:
  pwd(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : L(static_cast<value::Bool*>(attrs->at(StrFromC("L")))->b),
        P(static_cast<value::Bool*>(attrs->at(StrFromC("P")))->b) {
  }

  bool L;
  bool P;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(pwd));
  }
};

class read {
 public:
  read(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : N(attrs->at(StrFromC("N"))->tag() == value_e::Undef
          ? -1
          : static_cast<value::Int*>(attrs->at(StrFromC("N")))->i),
        Z(static_cast<value::Bool*>(attrs->at(StrFromC("Z")))->b),
        a(attrs->at(StrFromC("a"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("a")))->s),
        all(static_cast<value::Bool*>(attrs->at(StrFromC("all")))->b),
        d(attrs->at(StrFromC("d"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("d")))->s),
        j8(static_cast<value::Bool*>(attrs->at(StrFromC("j8")))->b),
        json(static_cast<value::Bool*>(attrs->at(StrFromC("json")))->b),
        line(static_cast<value::Bool*>(attrs->at(StrFromC("line")))->b),
        n(attrs->at(StrFromC("n"))->tag() == value_e::Undef
          ? -1
          : static_cast<value::Int*>(attrs->at(StrFromC("n")))->i),
        num_bytes(attrs->at(StrFromC("num_bytes"))->tag() == value_e::Undef
          ? -1
          : static_cast<value::Int*>(attrs->at(StrFromC("num_bytes")))->i),
        p(attrs->at(StrFromC("p"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("p")))->s),
        r(static_cast<value::Bool*>(attrs->at(StrFromC("r")))->b),
        s(static_cast<value::Bool*>(attrs->at(StrFromC("s")))->b),
        t(attrs->at(StrFromC("t"))->tag() == value_e::Undef
          ? -1
          : static_cast<value::Float*>(attrs->at(StrFromC("t")))->f),
        u(attrs->at(StrFromC("u"))->tag() == value_e::Undef
          ? -1
          : static_cast<value::Int*>(attrs->at(StrFromC("u")))->i),
        with_eol(static_cast<value::Bool*>(attrs->at(StrFromC("with_eol")))->b) {
  }

  int N;
  bool Z;
  BigStr* a;
  bool all;
  BigStr* d;
  bool j8;
  bool json;
  bool line;
  int n;
  int num_bytes;
  BigStr* p;
  bool r;
  bool s;
  float t;
  int u;
  bool with_eol;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::FixedSize, field_mask(), sizeof(read));
  }

  static constexpr uint32_t field_mask() {
    return
      maskbit(offsetof(read, a))
    | maskbit(offsetof(read, d))
    | maskbit(offsetof(read, p));
  }

};

class readonly {
 public:
  readonly(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : A(static_cast<value::Bool*>(attrs->at(StrFromC("A")))->b),
        a(static_cast<value::Bool*>(attrs->at(StrFromC("a")))->b),
        p(static_cast<value::Bool*>(attrs->at(StrFromC("p")))->b) {
  }

  bool A;
  bool a;
  bool p;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(readonly));
  }
};

class runproc {
 public:
  runproc(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : h(static_cast<value::Bool*>(attrs->at(StrFromC("h")))->b) {
  }

  bool h;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(runproc));
  }
};

class shopt {
 public:
  shopt(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : o(static_cast<value::Bool*>(attrs->at(StrFromC("o")))->b),
        p(static_cast<value::Bool*>(attrs->at(StrFromC("p")))->b),
        q(static_cast<value::Bool*>(attrs->at(StrFromC("q")))->b),
        s(static_cast<value::Bool*>(attrs->at(StrFromC("s")))->b),
        u(static_cast<value::Bool*>(attrs->at(StrFromC("u")))->b) {
  }

  bool o;
  bool p;
  bool q;
  bool s;
  bool u;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(shopt));
  }
};

class source {
 public:
  source(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : builtin(static_cast<value::Bool*>(attrs->at(StrFromC("builtin")))->b) {
  }

  bool builtin;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(source));
  }
};

class trap {
 public:
  trap(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : l(static_cast<value::Bool*>(attrs->at(StrFromC("l")))->b),
        p(static_cast<value::Bool*>(attrs->at(StrFromC("p")))->b) {
  }

  bool l;
  bool p;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(trap));
  }
};

class try_ {
 public:
  try_(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : assign(attrs->at(StrFromC("assign"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("assign")))->s) {
  }

  BigStr* assign;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::FixedSize, field_mask(), sizeof(try_));
  }

  static constexpr uint32_t field_mask() {
    return
      maskbit(offsetof(try_, assign));
  }

};

class type {
 public:
  type(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : P(static_cast<value::Bool*>(attrs->at(StrFromC("P")))->b),
        a(static_cast<value::Bool*>(attrs->at(StrFromC("a")))->b),
        f(static_cast<value::Bool*>(attrs->at(StrFromC("f")))->b),
        p(static_cast<value::Bool*>(attrs->at(StrFromC("p")))->b),
        t(static_cast<value::Bool*>(attrs->at(StrFromC("t")))->b) {
  }

  bool P;
  bool a;
  bool f;
  bool p;
  bool t;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(type));
  }
};

class ulimit {
 public:
  ulimit(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : H(static_cast<value::Bool*>(attrs->at(StrFromC("H")))->b),
        S(static_cast<value::Bool*>(attrs->at(StrFromC("S")))->b),
        a(static_cast<value::Bool*>(attrs->at(StrFromC("a")))->b),
        all(static_cast<value::Bool*>(attrs->at(StrFromC("all")))->b),
        c(static_cast<value::Bool*>(attrs->at(StrFromC("c")))->b),
        d(static_cast<value::Bool*>(attrs->at(StrFromC("d")))->b),
        f(static_cast<value::Bool*>(attrs->at(StrFromC("f")))->b),
        n(static_cast<value::Bool*>(attrs->at(StrFromC("n")))->b),
        s(static_cast<value::Bool*>(attrs->at(StrFromC("s")))->b),
        t(static_cast<value::Bool*>(attrs->at(StrFromC("t")))->b),
        v(static_cast<value::Bool*>(attrs->at(StrFromC("v")))->b) {
  }

  bool H;
  bool S;
  bool a;
  bool all;
  bool c;
  bool d;
  bool f;
  bool n;
  bool s;
  bool t;
  bool v;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(ulimit));
  }
};

class unset {
 public:
  unset(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : f(static_cast<value::Bool*>(attrs->at(StrFromC("f")))->b),
        v(static_cast<value::Bool*>(attrs->at(StrFromC("v")))->b) {
  }

  bool f;
  bool v;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(unset));
  }
};

class wait {
 public:
  wait(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : n(static_cast<value::Bool*>(attrs->at(StrFromC("n")))->b) {
  }

  bool n;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::Opaque, kZeroMask, sizeof(wait));
  }
};

class write {
 public:
  write(Dict<BigStr*, value_asdl::value_t*>* attrs)
      : end(attrs->at(StrFromC("end"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("end")))->s),
        j8(static_cast<value::Bool*>(attrs->at(StrFromC("j8")))->b),
        json(static_cast<value::Bool*>(attrs->at(StrFromC("json")))->b),
        n(static_cast<value::Bool*>(attrs->at(StrFromC("n")))->b),
        sep(attrs->at(StrFromC("sep"))->tag() == value_e::Undef
          ? nullptr
          : static_cast<value::Str*>(attrs->at(StrFromC("sep")))->s) {
  }

  BigStr* end;
  bool j8;
  bool json;
  bool n;
  BigStr* sep;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::Class(HeapTag::FixedSize, field_mask(), sizeof(write));
  }

  static constexpr uint32_t field_mask() {
    return
      maskbit(offsetof(write, end))
    | maskbit(offsetof(write, sep));
  }

};

extern FlagSpec_c kFlagSpecs[];
extern FlagSpecAndMore_c kFlagSpecsAndMore[];

}  // namespace arg_types

#endif  // ARG_TYPES_H

