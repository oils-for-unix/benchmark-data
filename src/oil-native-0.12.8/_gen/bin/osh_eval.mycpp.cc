// osh_eval.cc: translated from Python by mycpp

// #include "_gen/bin/osh_eval.mycpp.h"

#include "cpp/leaky_preamble.h"  // hard-coded stuff
// BEGIN mycpp output

#include "mycpp/runtime.h"

GLOBAL_STR(str0, "(");
GLOBAL_STR(str1, ")");
GLOBAL_STR(str2, "_");
GLOBAL_STR(str3, "T");
GLOBAL_STR(str4, "F");
GLOBAL_STR(str5, "");
GLOBAL_STR(str6, "");
GLOBAL_STR(str7, "\n<html>\n  <head>\n     <title>oil AST</title>\n     <style>\n      .n { color: brown }\n      .s { font-weight: bold }\n      .o { color: darkgreen }\n     </style>\n  </head>\n  <body>\n    <pre>\n");
GLOBAL_STR(str8, "\n    </pre>\n  </body>\n</html>\n    ");
GLOBAL_STR(str9, "n");
GLOBAL_STR(str10, "s");
GLOBAL_STR(str11, "o");
GLOBAL_STR(str12, "o");
GLOBAL_STR(str13, "o");
GLOBAL_STR(str14, "<span class=\"%s\">");
GLOBAL_STR(str15, "</span>");
GLOBAL_STR(str16, " ");
GLOBAL_STR(str17, "\n");
GLOBAL_STR(str18, " ");
GLOBAL_STR(str19, "]");
GLOBAL_STR(str20, " ");
GLOBAL_STR(str21, " ");
GLOBAL_STR(str22, "\n");
GLOBAL_STR(str23, "\n");
GLOBAL_STR(str24, " ");
GLOBAL_STR(str25, "%s%s: [");
GLOBAL_STR(str26, "\n");
GLOBAL_STR(str27, "\n");
GLOBAL_STR(str28, "%s]");
GLOBAL_STR(str29, "%s%s: ");
GLOBAL_STR(str30, "\n");
GLOBAL_STR(str31, "\n");
GLOBAL_STR(str32, " ");
GLOBAL_STR(str33, " ");
GLOBAL_STR(str34, " ");
GLOBAL_STR(str35, " %s:");
GLOBAL_STR(str36, "[");
GLOBAL_STR(str37, " ");
GLOBAL_STR(str38, "]");
GLOBAL_STR(str39, "osh");
GLOBAL_STR(str40, "oil: %s");
GLOBAL_STR(str41, "osh fatal error: %s");
GLOBAL_STR(str42, "");
GLOBAL_STR(str43, "osh I/O error: %s");
GLOBAL_STR(str44, " ");
GLOBAL_STR(str45, "");
GLOBAL_STR(str46, "\u001b[0;0m");
GLOBAL_STR(str47, "\u001b[1m");
GLOBAL_STR(str48, "\u001b[4m");
GLOBAL_STR(str49, "\u001b[7m");
GLOBAL_STR(str50, "\u001b[31m");
GLOBAL_STR(str51, "\u001b[32m");
GLOBAL_STR(str52, "\u001b[33m");
GLOBAL_STR(str53, "\u001b[34m");
GLOBAL_STR(str54, "proc");
GLOBAL_STR(str55, "source");
GLOBAL_STR(str56, "?");
GLOBAL_STR(str57, "(");
GLOBAL_STR(str58, ")");
GLOBAL_STR(str59, " ");
GLOBAL_STR(str60, "(");
GLOBAL_STR(str61, "[%s]=%s");
GLOBAL_STR(str62, ")");
GLOBAL_STR(str63, " ");
GLOBAL_STR(str64, " ");
GLOBAL_STR(str65, "\n");
GLOBAL_STR(str66, "");
GLOBAL_STR(str67, "");
GLOBAL_STR(str68, "");
GLOBAL_STR(str69, "");
GLOBAL_STR(str70, "SHX_indent");
GLOBAL_STR(str71, "SHX_punct");
GLOBAL_STR(str72, "SHX_pid_str");
GLOBAL_STR(str73, "PS4");
GLOBAL_STR(str74, "");
GLOBAL_STR(str75, "<ERROR: Can't parse PS4: %s>");
GLOBAL_STR(str76, "");
GLOBAL_STR(str77, "  ");
GLOBAL_STR(str78, "+");
GLOBAL_STR(str79, "|");
GLOBAL_STR(str80, "command %d:");
GLOBAL_STR(str81, "forkwait %d\n");
GLOBAL_STR(str82, "command sub %d\n");
GLOBAL_STR(str83, "proc sub %d\n");
GLOBAL_STR(str84, "here doc %d\n");
GLOBAL_STR(str85, "fork %d\n");
GLOBAL_STR(str86, "part %d\n");
GLOBAL_STR(str87, ";");
GLOBAL_STR(str88, "process %d: status %d\n");
GLOBAL_STR(str89, " %d");
GLOBAL_STR(str90, ">");
GLOBAL_STR(str91, "proc");
GLOBAL_STR(str92, "source");
GLOBAL_STR(str93, "wait");
GLOBAL_STR(str94, "\n");
GLOBAL_STR(str95, "<");
GLOBAL_STR(str96, " ");
GLOBAL_STR(str97, "\n");
GLOBAL_STR(str98, "!");
GLOBAL_STR(str99, "\n");
GLOBAL_STR(str100, ".");
GLOBAL_STR(str101, "exec");
GLOBAL_STR(str102, ".");
GLOBAL_STR(str103, "builtin");
GLOBAL_STR(str104, " ");
GLOBAL_STR(str105, "\n");
GLOBAL_STR(str106, " ");
GLOBAL_STR(str107, " ");
GLOBAL_STR(str108, "=");
GLOBAL_STR(str109, "\n");
GLOBAL_STR(str110, "?");
GLOBAL_STR(str111, "%s[%d]");
GLOBAL_STR(str112, "%s[%s]");
GLOBAL_STR(str113, "+=");
GLOBAL_STR(str114, "=");
GLOBAL_STR(str115, "\n");
GLOBAL_STR(str116, "+");
GLOBAL_STR(str117, " ");
GLOBAL_STR(str118, "\n");
GLOBAL_STR(str119, "\n");
GLOBAL_STR(str120, " ...");
GLOBAL_STR(str121, "\n");
GLOBAL_STR(str122, "<_ControlFlow %s>");
GLOBAL_STR(str123, "Invalid control flow %r in pipeline / subshell / background");
GLOBAL_STR(str124, "%r ");
GLOBAL_STR(str125, "Command evaluated to an empty argv array");
GLOBAL_STR(str126, "Can't run assignment builtin recursively");
GLOBAL_STR(str127, "errexit was disabled for this construct");
GLOBAL_STR(str128, "");
GLOBAL_STR(str129, "Can't run a proc while errexit is disabled. Use 'try' or wrap it in a process with $0 myproc");
GLOBAL_STR(str130, "proc");
GLOBAL_STR(str131, "Unknown command %r while running hay");
GLOBAL_STR(str132, "Unexpected typed args passed to external command %r");
GLOBAL_STR(str133, "%r not found");
GLOBAL_STR(str134, "for -Wreturn-type in C++");
GLOBAL_STR(str135, "pipeline");
GLOBAL_STR(str136, "Command subs not allowed here because status wouldn't be checked (strict_errexit).");
GLOBAL_STR(str137, "__cat");
GLOBAL_STR(str138, "osh I/O error: %s");
GLOBAL_STR(str139, "Command Sub exited with status %d");
GLOBAL_STR(str140, "");
GLOBAL_STR(str141, "\n");
GLOBAL_STR(str142, "Process subs not allowed here because status wouldn't be checked (strict_errexit).");
GLOBAL_STR(str143, "/dev/fd/%d");
GLOBAL_STR(str144, "/dev/fd/%d");
GLOBAL_STR(str145, "<_FdFrame %s>");
GLOBAL_STR(str146, "r");
GLOBAL_STR(str147, "%d: %s");
GLOBAL_STR(str148, "%d: %s");
GLOBAL_STR(str149, "%d: %s");
GLOBAL_STR(str150, "Can't open %r: %s");
GLOBAL_STR(str151, "Error closing descriptor %d: %s");
GLOBAL_STR(str152, "dup2(%d, %d) error: %s");
GLOBAL_STR(str153, "<StdinFromPipe %d %d>");
GLOBAL_STR(str154, "<StdoutToPipe %d %d>");
GLOBAL_STR(str155, "Hijacked: %s");
GLOBAL_STR(str156, "/bin/sh");
GLOBAL_STR(str157, "/bin/sh");
GLOBAL_STR(str158, "Can't execute %r: %s");
GLOBAL_STR(str159, "[process] %s");
GLOBAL_STR(str160, " ");
GLOBAL_STR(str161, "[subprog] %s");
GLOBAL_STR(str162, "");
GLOBAL_STR(str163, "osh I/O error: %s");
GLOBAL_STR(str164, "[here doc writer]");
GLOBAL_STR(str165, "<Process %s %s>");
GLOBAL_STR(str166, "  ");
GLOBAL_STR(str167, "%%%d");
GLOBAL_STR(str168, "%d\n");
GLOBAL_STR(str169, "%s %d %7s ");
GLOBAL_STR(str170, "\n");
GLOBAL_STR(str171, "Fatal error in posix.fork()");
GLOBAL_STR(str172, "%d\n");
GLOBAL_STR(str173, "%%%d");
GLOBAL_STR(str174, "  ");
GLOBAL_STR(str175, "%s %d %7s ");
GLOBAL_STR(str176, "\n");
GLOBAL_STR(str177, "Pipeline in state %s");
GLOBAL_STR(str178, "\n");
GLOBAL_STR(str179, "[process debug info]\n");
GLOBAL_STR(str180, "\n");
GLOBAL_STR(str181, "[pipeline debug info]\n");
GLOBAL_STR(str182, "osh: PID %d stopped, but osh didn't start it");
GLOBAL_STR(str183, "");
GLOBAL_STR(str184, "");
GLOBAL_STR(str185, "[PID %d] Stopped");
GLOBAL_STR(str186, "");
GLOBAL_STR(str187, "main");
GLOBAL_STR(str188, "osh usage error: %s");
GLOBAL_STR(str189, "%s-usage");
GLOBAL_STR(str190, "Oil");
GLOBAL_STR(str191, "main");
GLOBAL_STR(str192, "oil");
GLOBAL_STR(str193, "oil:all");
GLOBAL_STR(str194, "--one-pass-parse requires noexec (-n)");
GLOBAL_STR(str195, "completion");
GLOBAL_STR(str196, "history");
GLOBAL_STR(str197, "");
GLOBAL_STR(str198, "OSH_DEBUG_DIR");
GLOBAL_STR(str199, "%d-osh.log");
GLOBAL_STR(str200, "Writing logs to %r");
GLOBAL_STR(str201, "OSH_HIJACK_SHEBANG");
GLOBAL_STR(str202, "");
GLOBAL_STR(str203, "OSH_CRASH_DUMP_DIR");
GLOBAL_STR(str204, "");
GLOBAL_STR(str205, "");
GLOBAL_STR(str206, "osh: Couldn't open %r: %s");
GLOBAL_STR(str207, "/proc/%d/status");
GLOBAL_STR(str208, "--parser-mem-dump can only be used with -n");
GLOBAL_STR(str209, "/proc/%d/status");
GLOBAL_STR(str210, " \t\n\"'><=;|&(:");
GLOBAL_STR(str211, "/");
GLOBAL_STR(str212, "PATH");
GLOBAL_STR(str213, ":");
GLOBAL_STR(str214, "Recursive 'hay eval' not allowed");
GLOBAL_STR(str215, "source");
GLOBAL_STR(str216, "children");
GLOBAL_STR(str217, "got invalid option %r");
GLOBAL_STR(str218, "got invalid option %r");
GLOBAL_STR(str219, "invalid option %r (try shopt)");
GLOBAL_STR(str220, "SHELLOPTS");
GLOBAL_STR(str221, ":");
GLOBAL_STR(str222, "Syntax options must be set at the top level (outside any function)");
GLOBAL_STR(str223, "Warning: set -o verbose not implemented");
GLOBAL_STR(str224, "SHELLOPTS");
GLOBAL_STR(str225, "%s:%s");
GLOBAL_STR(str226, "SHELLOPTS");
GLOBAL_STR(str227, ":");
GLOBAL_STR(str228, ":");
GLOBAL_STR(str229, "SHELLOPTS");
GLOBAL_STR(str230, "set %so %s");
GLOBAL_STR(str231, "-");
GLOBAL_STR(str232, "+");
GLOBAL_STR(str233, "got invalid option %r");
GLOBAL_STR(str234, "shopt -%s %s");
GLOBAL_STR(str235, "s");
GLOBAL_STR(str236, "u");
GLOBAL_STR(str237, "<_ArgFrame %s %d at %x>");
GLOBAL_STR(str238, "Can't determine working directory: %s");
GLOBAL_STR(str239, "IFS");
GLOBAL_STR(str240, "UID");
GLOBAL_STR(str241, "EUID");
GLOBAL_STR(str242, "PPID");
GLOBAL_STR(str243, "HOSTNAME");
GLOBAL_STR(str244, "OSTYPE");
GLOBAL_STR(str245, "OPTIND");
GLOBAL_STR(str246, "1");
GLOBAL_STR(str247, "PS4");
GLOBAL_STR(str248, "${SHX_indent}${SHX_punct}${SHX_pid_str} ");
GLOBAL_STR(str249, "COMP_WORDBREAKS");
GLOBAL_STR(str250, "SHELLOPTS");
GLOBAL_STR(str251, "SHELLOPTS");
GLOBAL_STR(str252, "");
GLOBAL_STR(str253, "SHELLOPTS");
GLOBAL_STR(str254, "PWD");
GLOBAL_STR(str255, "PWD");
GLOBAL_STR(str256, "PWD");
GLOBAL_STR(str257, "PATH");
GLOBAL_STR(str258, "PATH");
GLOBAL_STR(str259, "/bin:/usr/bin");
GLOBAL_STR(str260, "OIL_VERSION");
GLOBAL_STR(str261, "PWD");
GLOBAL_STR(str262, "PS1");
GLOBAL_STR(str263, "PS1");
GLOBAL_STR(str264, "\\s-\\v\\$ ");
GLOBAL_STR(str265, "");
GLOBAL_STR(str266, "<Mem");
GLOBAL_STR(str267, "  -- %d --");
GLOBAL_STR(str268, "  %s %s");
GLOBAL_STR(str269, ">");
GLOBAL_STR(str270, "\n");
GLOBAL_STR(str271, "\n");
GLOBAL_STR(str272, "Warning: span_id undefined in SetCurrentSpanId");
GLOBAL_STR(str273, "setref requires a nameref (:out param)");
GLOBAL_STR(str274, "nameref %r is undefined");
GLOBAL_STR(str275, "nameref %r contains invalid variable name %r");
GLOBAL_STR(str276, "Circular nameref %s");
GLOBAL_STR(str277, " -> ");
GLOBAL_STR(str278, "__");
GLOBAL_STR(str279, "Can't assign to readonly value %r");
GLOBAL_STR(str280, "Only strings can be exported");
GLOBAL_STR(str281, "nameref must be a string");
GLOBAL_STR(str282, "Can't assign to readonly array");
GLOBAL_STR(str283, "Can't assign to items in a string");
GLOBAL_STR(str284, "Value of type %s can't be indexed");
GLOBAL_STR(str285, "Can't assign to readonly associative array");
GLOBAL_STR(str286, "ARGV");
GLOBAL_STR(str287, "_status");
GLOBAL_STR(str288, "_this_dir");
GLOBAL_STR(str289, "PIPESTATUS");
GLOBAL_STR(str290, "_pipeline_status");
GLOBAL_STR(str291, "_process_sub_status");
GLOBAL_STR(str292, "BASH_REMATCH");
GLOBAL_STR(str293, "FUNCNAME");
GLOBAL_STR(str294, "source");
GLOBAL_STR(str295, "BASH_SOURCE");
GLOBAL_STR(str296, "BASH_LINENO");
GLOBAL_STR(str297, "0");
GLOBAL_STR(str298, "LINENO");
GLOBAL_STR(str299, "BASHPID");
GLOBAL_STR(str300, "Can't unset readonly variable %r");
GLOBAL_STR(str301, "%r isn't an array");
GLOBAL_STR(str302, "$%s isn't defined");
GLOBAL_STR(str303, "$%s should be a string");
GLOBAL_STR(str304, "$%s should be a string, got %s");
GLOBAL_STR(str305, "$%s doesn't look like an integer, got %r");
GLOBAL_STR(str306, "EOF");
GLOBAL_STR(str307, "/");
GLOBAL_STR(str308, "~");
GLOBAL_STR(str309, "  ");
GLOBAL_STR(str310, "\n  ");
GLOBAL_STR(str311, "\t");
GLOBAL_STR(str312, "\t");
GLOBAL_STR(str313, " ");
GLOBAL_STR(str314, "^");
GLOBAL_STR(str315, "~");
GLOBAL_STR(str316, "\n");
GLOBAL_STR(str317, "[ interactive ]");
GLOBAL_STR(str318, "[ headless ]");
GLOBAL_STR(str319, "[ -c flag ]");
GLOBAL_STR(str320, "[ stdin%s ]");
GLOBAL_STR(str321, "[ %s word at ? ]");
GLOBAL_STR(str322, "[ %s word at line %d of %s ]");
GLOBAL_STR(str323, "?");
GLOBAL_STR(str324, "?");
GLOBAL_STR(str325, "line %d of %s");
GLOBAL_STR(str326, "[ var %s at %s ]");
GLOBAL_STR(str327, "[ expansion of alias %r ]");
GLOBAL_STR(str328, "[ %s in %s ]");
GLOBAL_STR(str329, "-- %s");
GLOBAL_STR(str330, "[??? no location ???] %s%s\n");
GLOBAL_STR(str331, "%s:%d: %s%s\n");
GLOBAL_STR(str332, "");
GLOBAL_STR(str333, "");
GLOBAL_STR(str334, "");
GLOBAL_STR(str335, "errexit PID %d: ");
GLOBAL_STR(str336, "none");
GLOBAL_STR(str337, "AST not printed.");
GLOBAL_STR(str338, "text");
GLOBAL_STR(str339, "abbrev-text");
GLOBAL_STR(str340, "html");
GLOBAL_STR(str341, "abbrev-html");
GLOBAL_STR(str342, "abbrev-");
GLOBAL_STR(str343, "\n");
GLOBAL_STR(str344, "\n");
GLOBAL_STR(str345, "-");
GLOBAL_STR(str346, "_");
GLOBAL_STR(str347, "<_Attributes %s>");
GLOBAL_STR(str348, "<args.Reader %r %d>");
GLOBAL_STR(str349, "expected argument to %r");
GLOBAL_STR(str350, "-");
GLOBAL_STR(str351, "expected integer after %s, got %r");
GLOBAL_STR(str352, "-");
GLOBAL_STR(str353, "got invalid integer for %s: %s");
GLOBAL_STR(str354, "-");
GLOBAL_STR(str355, "expected number after %r, got %r");
GLOBAL_STR(str356, "-");
GLOBAL_STR(str357, "got invalid float for %s: %s");
GLOBAL_STR(str358, "-");
GLOBAL_STR(str359, "got invalid argument %r to %r, expected one of: %s");
GLOBAL_STR(str360, "-");
GLOBAL_STR(str361, "|");
GLOBAL_STR(str362, "0");
GLOBAL_STR(str363, "F");
GLOBAL_STR(str364, "false");
GLOBAL_STR(str365, "False");
GLOBAL_STR(str366, "1");
GLOBAL_STR(str367, "T");
GLOBAL_STR(str368, "true");
GLOBAL_STR(str369, "Talse");
GLOBAL_STR(str370, "got invalid argument to boolean flag: %r");
GLOBAL_STR(str371, "-");
GLOBAL_STR(str372, "-");
GLOBAL_STR(str373, "Invalid option %r");
GLOBAL_STR(str374, "Expected argument for action");
GLOBAL_STR(str375, "Invalid action name %r");
GLOBAL_STR(str376, "--");
GLOBAL_STR(str377, "--");
GLOBAL_STR(str378, "=");
GLOBAL_STR(str379, "got invalid flag %r");
GLOBAL_STR(str380, "-");
GLOBAL_STR(str381, "0");
GLOBAL_STR(str382, "Z");
GLOBAL_STR(str383, "-");
GLOBAL_STR(str384, "doesn't accept flag %s");
GLOBAL_STR(str385, "-");
GLOBAL_STR(str386, "+");
GLOBAL_STR(str387, "+");
GLOBAL_STR(str388, "doesn't accept option %s");
GLOBAL_STR(str389, "+");
GLOBAL_STR(str390, "-");
GLOBAL_STR(str391, "--");
GLOBAL_STR(str392, "--");
GLOBAL_STR(str393, "got invalid flag %r");
GLOBAL_STR(str394, "-");
GLOBAL_STR(str395, "+");
GLOBAL_STR(str396, "got invalid flag %r");
GLOBAL_STR(str397, "-");
GLOBAL_STR(str398, "<LineLexer at pos %d of line %r (id = %d)>");
GLOBAL_STR(str399, "");
GLOBAL_STR(str400, "");
GLOBAL_STR(str401, "");
GLOBAL_STR(str402, "");
GLOBAL_STR(str403, "<Trail %s %s %s %s>");
GLOBAL_STR(str404, "");
GLOBAL_STR(str405, "Here docs aren't allowed in expressions");
GLOBAL_STR(str406, "\n");
GLOBAL_STR(str407, "got unexpected typed args");
GLOBAL_STR(str408, "Expected an expression");
GLOBAL_STR(str409, "Expected an expression");
GLOBAL_STR(str410, "Too many typed args (expected one expression)");
GLOBAL_STR(str411, "Expected block argument");
GLOBAL_STR(str412, "Too many typed args (expected one block)");
GLOBAL_STR(str413, "Use === to be exact, or ~== to convert types");
GLOBAL_STR(str414, "");
GLOBAL_STR(str415, " (%s)");
GLOBAL_STR(str416, "Unexpected token in expression mode%s");
GLOBAL_STR(str417, "Syntax error in expression (near %s)");
GLOBAL_STR(str418, "alnum");
GLOBAL_STR(str419, "cntrl");
GLOBAL_STR(str420, "lower");
GLOBAL_STR(str421, "space");
GLOBAL_STR(str422, "alpha");
GLOBAL_STR(str423, "digit");
GLOBAL_STR(str424, "print");
GLOBAL_STR(str425, "upper");
GLOBAL_STR(str426, "blank");
GLOBAL_STR(str427, "graph");
GLOBAL_STR(str428, "punct");
GLOBAL_STR(str429, "xdigit");
GLOBAL_STR(str430, "Range start/end shouldn't have more than one character");
GLOBAL_STR(str431, "Write singleton tuples with tup(), not a trailing comma");
GLOBAL_STR(str432, "testlist_comp");
GLOBAL_STR(str433, "obj.field isn't valid, but obj.method() is");
GLOBAL_STR(str434, "In expressions, remove $ and use `%s`, or sometimes \"$%s\"");
GLOBAL_STR(str435, "PNode type %d (%s) wasn't handled");
GLOBAL_STR(str436, "Can't assign to this expression");
GLOBAL_STR(str437, "PNode type %d (%s) wasn't handled");
GLOBAL_STR(str438, "Expr");
GLOBAL_STR(str439, "Block");
GLOBAL_STR(str440, "proc param types should be Expr or Block");
GLOBAL_STR(str441, "dot");
GLOBAL_STR(str442, "Can't negate this symbol");
GLOBAL_STR(str443, "%r isn't a character class");
GLOBAL_STR(str444, "Can't negate this symbol");
GLOBAL_STR(str445, "%r isn't a character class");
GLOBAL_STR(str446, "%start");
GLOBAL_STR(str447, "%end");
GLOBAL_STR(str448, "dot");
GLOBAL_STR(str449, "Unexpected token %r in regex");
GLOBAL_STR(str450, "Backtracking with !! isn't implemented (requires Python/PCRE)");
GLOBAL_STR(str451, "Couldn't open %r: %s");
GLOBAL_STR(str452, "ERE can't express char code %d");
GLOBAL_STR(str453, "Can't use char %d as start of range in ERE syntax");
GLOBAL_STR(str454, "-");
GLOBAL_STR(str455, "Can't use char %d as end of range in ERE syntax");
GLOBAL_STR(str456, "Perl classes can't be negated in ERE");
GLOBAL_STR(str457, "%s");
GLOBAL_STR(str458, "POSIX classes can't be negated in ERE");
GLOBAL_STR(str459, "[:%s:]");
GLOBAL_STR(str460, ".");
GLOBAL_STR(str461, "^");
GLOBAL_STR(str462, "$");
GLOBAL_STR(str463, "|");
GLOBAL_STR(str464, "POSIX EREs don't have groups without capture, so this node needs () around it.");
GLOBAL_STR(str465, "+");
GLOBAL_STR(str466, "*");
GLOBAL_STR(str467, "?");
GLOBAL_STR(str468, "{%s}");
GLOBAL_STR(str469, "");
GLOBAL_STR(str470, "");
GLOBAL_STR(str471, "{%s,%s}");
GLOBAL_STR(str472, "(");
GLOBAL_STR(str473, ")");
GLOBAL_STR(str474, "[^%s]");
GLOBAL_STR(str475, "[%s]");
GLOBAL_STR(str476, "[^[:%s:]]");
GLOBAL_STR(str477, "[[:%s:]]");
GLOBAL_STR(str478, "[");
GLOBAL_STR(str479, "^");
GLOBAL_STR(str480, "]");
GLOBAL_STR(str481, "\\\\");
GLOBAL_STR(str482, "^");
GLOBAL_STR(str483, "-");
GLOBAL_STR(str484, "]");
GLOBAL_STR(str485, "The [ operator doesn't apply to this expression");
GLOBAL_STR(str486, "Expected ]]");
GLOBAL_STR(str487, "Unexpected trailing word %s");
GLOBAL_STR(str488, "Invalid argument to unary operator");
GLOBAL_STR(str489, "Expected ), got %s");
GLOBAL_STR(str490, "Unexpected token in boolean expression (%s)");
GLOBAL_STR(str491, "");
GLOBAL_STR(str492, "Expected %d, got %d");
GLOBAL_STR(str493, "Step can't be 0");
GLOBAL_STR(str494, "Invalid step %d for ascending integer range");
GLOBAL_STR(str495, "Invalid step %d for descending integer range");
GLOBAL_STR(str496, "Invalid step %d for ascending character range");
GLOBAL_STR(str497, "Invalid step %d for descending character range");
GLOBAL_STR(str498, "Mismatched cases in character range");
GLOBAL_STR(str499, "");
GLOBAL_STR(str500, "0");
GLOBAL_STR(str501, "0");
GLOBAL_STR(str502, "g");
GLOBAL_STR(str503, "a");
GLOBAL_STR(str504, "A");
GLOBAL_STR(str505, "n");
GLOBAL_STR(str506, "r");
GLOBAL_STR(str507, "x");
GLOBAL_STR(str508, "%s=%s");
GLOBAL_STR(str509, "-");
GLOBAL_STR(str510, "+");
GLOBAL_STR(str511, "-");
GLOBAL_STR(str512, "+");
GLOBAL_STR(str513, "-");
GLOBAL_STR(str514, "+");
GLOBAL_STR(str515, "n");
GLOBAL_STR(str516, "r");
GLOBAL_STR(str517, "x");
GLOBAL_STR(str518, "a");
GLOBAL_STR(str519, "A");
GLOBAL_STR(str520, "-");
GLOBAL_STR(str521, "declare -");
GLOBAL_STR(str522, "");
GLOBAL_STR(str523, " ");
GLOBAL_STR(str524, "=");
GLOBAL_STR(str525, "=()");
GLOBAL_STR(str526, ";");
GLOBAL_STR(str527, " ");
GLOBAL_STR(str528, "[");
GLOBAL_STR(str529, "]=");
GLOBAL_STR(str530, " ");
GLOBAL_STR(str531, "=(");
GLOBAL_STR(str532, "");
GLOBAL_STR(str533, ")");
GLOBAL_STR(str534, " ");
GLOBAL_STR(str535, "[");
GLOBAL_STR(str536, "]=");
GLOBAL_STR(str537, "=(");
GLOBAL_STR(str538, "");
GLOBAL_STR(str539, ")");
GLOBAL_STR(str540, "");
GLOBAL_STR(str541, "export_");
GLOBAL_STR(str542, "doesn't accept -f because it's dangerous.  (The code can usually be restructured with 'source')");
GLOBAL_STR(str543, "doesn't accept RHS with -n");
GLOBAL_STR(str544, "Got -a but RHS isn't an array");
GLOBAL_STR(str545, "Got -A but RHS isn't an associative array");
GLOBAL_STR(str546, "readonly");
GLOBAL_STR(str547, "new_var");
GLOBAL_STR(str548, "with -f expects function names");
GLOBAL_STR(str549, "declare -f %s");
GLOBAL_STR(str550, "-");
GLOBAL_STR(str551, "-");
GLOBAL_STR(str552, "-");
GLOBAL_STR(str553, "+");
GLOBAL_STR(str554, "+");
GLOBAL_STR(str555, "+");
GLOBAL_STR(str556, "unset");
GLOBAL_STR(str557, "Invalid shift argument %r");
GLOBAL_STR(str558, "got too many arguments");
GLOBAL_STR(str559, "eval");
GLOBAL_STR(str560, "requires code string");
GLOBAL_STR(str561, "requires exactly 1 argument");
GLOBAL_STR(str562, " ");
GLOBAL_STR(str563, "eval");
GLOBAL_STR(str564, "eval");
GLOBAL_STR(str565, "source");
GLOBAL_STR(str566, "missing required argument");
GLOBAL_STR(str567, "source %r failed: %s");
GLOBAL_STR(str568, "source");
GLOBAL_STR(str569, "command");
GLOBAL_STR(str570, "Can't run assignment builtin recursively");
GLOBAL_STR(str571, "%r isn't a shell builtin");
GLOBAL_STR(str572, "runproc");
GLOBAL_STR(str573, "requires arguments");
GLOBAL_STR(str574, "runproc: no proc named %r");
GLOBAL_STR(str575, "try_");
GLOBAL_STR(str576, "expects a block or command argv");
GLOBAL_STR(str577, "boolstatus");
GLOBAL_STR(str578, "expected a command to run");
GLOBAL_STR(str579, "boolstatus expected status 0 or 1, got %d");
GLOBAL_STR(str580, "function");
GLOBAL_STR(str581, "alias");
GLOBAL_STR(str582, "builtin");
GLOBAL_STR(str583, "builtin");
GLOBAL_STR(str584, "builtin");
GLOBAL_STR(str585, "keyword");
GLOBAL_STR(str586, "keyword");
GLOBAL_STR(str587, "file");
GLOBAL_STR(str588, "type");
GLOBAL_STR(str589, "type: %r not found");
GLOBAL_STR(str590, "file");
GLOBAL_STR(str591, "file");
GLOBAL_STR(str592, "%s is a %s");
GLOBAL_STR(str593, "function");
GLOBAL_STR(str594, "");
GLOBAL_STR(str595, "");
GLOBAL_STR(str596, "\r\n");
GLOBAL_STR(str597, "\n");
GLOBAL_STR(str598, "'");
GLOBAL_STR(str599, "");
GLOBAL_STR(str600, "");
GLOBAL_STR(str601, "read error: %s");
GLOBAL_STR(str602, "read");
GLOBAL_STR(str603, "_line");
GLOBAL_STR(str604, ":");
GLOBAL_STR(str605, "got extra argument");
GLOBAL_STR(str606, "--qsn can only be used with --line");
GLOBAL_STR(str607, "_all");
GLOBAL_STR(str608, ":");
GLOBAL_STR(str609, "got extra argument");
GLOBAL_STR(str610, "--qsn not implemented yet");
GLOBAL_STR(str611, "read -t isn't implemented (except t=0)");
GLOBAL_STR(str612, "REPLY");
GLOBAL_STR(str613, "REPLY");
GLOBAL_STR(str614, "");
GLOBAL_STR(str615, ":");
GLOBAL_STR(str616, "mapfile");
GLOBAL_STR(str617, "MAPFILE");
GLOBAL_STR(str618, ":");
GLOBAL_STR(str619, "mapfile: read() error: %s");
GLOBAL_STR(str620, "\n");
GLOBAL_STR(str621, "cd");
GLOBAL_STR(str622, "cd");
GLOBAL_STR(str623, "HOME");
GLOBAL_STR(str624, "HOME");
GLOBAL_STR(str625, "-");
GLOBAL_STR(str626, "OLDPWD");
GLOBAL_STR(str627, "PWD");
GLOBAL_STR(str628, "cd %r: %s");
GLOBAL_STR(str629, "PWD");
GLOBAL_STR(str630, "OLDPWD");
GLOBAL_STR(str631, "%2d  %s");
GLOBAL_STR(str632, " ");
GLOBAL_STR(str633, "pushd");
GLOBAL_STR(str634, "pushd: no other directory");
GLOBAL_STR(str635, "got too many arguments");
GLOBAL_STR(str636, "pushd: %r: %s");
GLOBAL_STR(str637, "HOME");
GLOBAL_STR(str638, "PWD");
GLOBAL_STR(str639, "%s: directory stack is empty");
GLOBAL_STR(str640, "%s: %r: %s");
GLOBAL_STR(str641, "PWD");
GLOBAL_STR(str642, "pushd");
GLOBAL_STR(str643, "got extra argument");
GLOBAL_STR(str644, "popd");
GLOBAL_STR(str645, "HOME");
GLOBAL_STR(str646, "dirs");
GLOBAL_STR(str647, "HOME");
GLOBAL_STR(str648, "pwd");
GLOBAL_STR(str649, "_devbuild/help/groups.txt");
GLOBAL_STR(str650, "help");
GLOBAL_STR(str651, "help");
GLOBAL_STR(str652, "_devbuild/help/%s");
GLOBAL_STR(str653, "no help topics match %r");
GLOBAL_STR(str654, "osh I/O error: %s");
GLOBAL_STR(str655, "# +");
GLOBAL_STR(str656, "osh printf doesn't support the %r flag");
GLOBAL_STR(str657, "eEfFgG");
GLOBAL_STR(str658, "osh printf doesn't support floating point");
GLOBAL_STR(str659, "c");
GLOBAL_STR(str660, "osh printf doesn't support single characters (bytes)");
GLOBAL_STR(str661, "Invalid printf format character");
GLOBAL_STR(str662, "Expected a printf format character");
GLOBAL_STR(str663, "%");
GLOBAL_STR(str664, "");
GLOBAL_STR(str665, "printf got invalid width %r");
GLOBAL_STR(str666, "0");
GLOBAL_STR(str667, "");
GLOBAL_STR(str668, "printf got invalid precision %r");
GLOBAL_STR(str669, "");
GLOBAL_STR(str670, "s");
GLOBAL_STR(str671, "q");
GLOBAL_STR(str672, "b");
GLOBAL_STR(str673, "");
GLOBAL_STR(str674, "diouxX");
GLOBAL_STR(str675, "'\"");
GLOBAL_STR(str676, "printf expected an integer, got %r");
GLOBAL_STR(str677, "TZ");
GLOBAL_STR(str678, "TZ");
GLOBAL_STR(str679, "ouxX");
GLOBAL_STR(str680, "Can't format negative number %d with %%%s");
GLOBAL_STR(str681, "o");
GLOBAL_STR(str682, "x");
GLOBAL_STR(str683, "X");
GLOBAL_STR(str684, "0");
GLOBAL_STR(str685, "-");
GLOBAL_STR(str686, "-");
GLOBAL_STR(str687, "");
GLOBAL_STR(str688, "0");
GLOBAL_STR(str689, "-");
GLOBAL_STR(str690, " ");
GLOBAL_STR(str691, " ");
GLOBAL_STR(str692, "printf");
GLOBAL_STR(str693, "requires a format string");
GLOBAL_STR(str694, "printf");
GLOBAL_STR(str695, "");
GLOBAL_STR(str696, "exec");
GLOBAL_STR(str697, "exec: %r not found");
GLOBAL_STR(str698, "unreachable");
GLOBAL_STR(str699, "wait");
GLOBAL_STR(str700, "wait");
GLOBAL_STR(str701, "%");
GLOBAL_STR(str702, "doesn't support bash-style jobspecs (got %r)");
GLOBAL_STR(str703, "expected PID or jobspec, got %r");
GLOBAL_STR(str704, "%d isn't a child of this shell");
GLOBAL_STR(str705, "0%03o");
GLOBAL_STR(str706, "osh warning: umask with symbolic input isn't implemented");
GLOBAL_STR(str707, "umask: unexpected arguments");
GLOBAL_STR(str708, "alias");
GLOBAL_STR(str709, "alias %s=%r");
GLOBAL_STR(str710, "=");
GLOBAL_STR(str711, "No alias named %r");
GLOBAL_STR(str712, "alias %s=%r");
GLOBAL_STR(str713, "unalias");
GLOBAL_STR(str714, "requires an argument");
GLOBAL_STR(str715, "No alias named %r");
GLOBAL_STR(str716, "%s=%s");
GLOBAL_STR(str717, "set");
GLOBAL_STR(str718, "shopt");
GLOBAL_STR(str719, "got invalid option %r");
GLOBAL_STR(str720, "hash");
GLOBAL_STR(str721, "got extra arguments after -r");
GLOBAL_STR(str722, "hash: %r not found");
GLOBAL_STR(str723, ":");
GLOBAL_STR(str724, "OPTIND");
GLOBAL_STR(str725, "OPTIND");
GLOBAL_STR(str726, "OPTARG");
GLOBAL_STR(str727, "OPTARG");
GLOBAL_STR(str728, "");
GLOBAL_STR(str729, "?");
GLOBAL_STR(str730, "-");
GLOBAL_STR(str731, "-");
GLOBAL_STR(str732, "?");
GLOBAL_STR(str733, "?");
GLOBAL_STR(str734, "getopts: option %r requires an argument.");
GLOBAL_STR(str735, "(getopts argv: %s)");
GLOBAL_STR(str736, " ");
GLOBAL_STR(str737, "?");
GLOBAL_STR(str738, "");
GLOBAL_STR(str739, "requires an argspec");
GLOBAL_STR(str740, "requires the name of a variable to set");
GLOBAL_STR(str741, "got invalid variable name %r");
GLOBAL_STR(str742, "echo");
GLOBAL_STR(str743, "");
GLOBAL_STR(str744, "takes at most one arg when simple_echo is on (hint: add quotes)");
GLOBAL_STR(str745, " ");
GLOBAL_STR(str746, "\n");
GLOBAL_STR(str747, "module");
GLOBAL_STR(str748, "requires a name");
GLOBAL_STR(str749, "(interactive) Reloading module %r");
GLOBAL_STR(str750, "expected 'bin' or 'dialect'");
GLOBAL_STR(str751, "dialect");
GLOBAL_STR(str752, "expected dialect name");
GLOBAL_STR(str753, "_DIALECT");
GLOBAL_STR(str754, "Expected dialect %r, got %r");
GLOBAL_STR(str755, "Expected dialect %r");
GLOBAL_STR(str756, "bin");
GLOBAL_STR(str757, "bin %s");
GLOBAL_STR(str758, "expected 'bin' or 'dialect'");
GLOBAL_STR(str759, "shvar");
GLOBAL_STR(str760, "expected a block");
GLOBAL_STR(str761, "Expected name=value");
GLOBAL_STR(str762, "=");
GLOBAL_STR(str763, "Expected name=value");
GLOBAL_STR(str764, "PATH");
GLOBAL_STR(str765, "push-registers");
GLOBAL_STR(str766, "expected a block");
GLOBAL_STR(str767, "fopen");
GLOBAL_STR(str768, "expected a block");
GLOBAL_STR(str769, "1");
GLOBAL_STR(str770, "2");
GLOBAL_STR(str771, "3");
GLOBAL_STR(str772, "6");
GLOBAL_STR(str773, "9");
GLOBAL_STR(str774, "13");
GLOBAL_STR(str775, "14");
GLOBAL_STR(str776, "15");
GLOBAL_STR(str777, "SIG");
GLOBAL_STR(str778, "EXIT");
GLOBAL_STR(str779, "ERR");
GLOBAL_STR(str780, "RETURN");
GLOBAL_STR(str781, "DEBUG");
GLOBAL_STR(str782, "trap");
GLOBAL_STR(str783, "trap");
GLOBAL_STR(str784, "%s TrapState");
GLOBAL_STR(str785, "%d TrapState");
GLOBAL_STR(str786, "   %s");
GLOBAL_STR(str787, "requires a code string");
GLOBAL_STR(str788, "requires a signal or hook name");
GLOBAL_STR(str789, "0");
GLOBAL_STR(str790, "EXIT");
GLOBAL_STR(str791, "Invalid signal or hook %r");
GLOBAL_STR(str792, "-");
GLOBAL_STR(str793, "Signal or trap");
GLOBAL_STR(str794, "ERR");
GLOBAL_STR(str795, "RETURN");
GLOBAL_STR(str796, "DEBUG");
GLOBAL_STR(str797, "osh warning: The %r hook isn't implemented");
GLOBAL_STR(str798, "Signal %r can't be handled");
GLOBAL_STR(str799, "Signal or trap");
GLOBAL_STR(str800, "Can't append array to string");
GLOBAL_STR(str801, "Can't append string to array");
GLOBAL_STR(str802, "Assignment builtin %r not configured");
GLOBAL_STR(str803, "%r ");
GLOBAL_STR(str804, "Command");
GLOBAL_STR(str805, "Assignment");
GLOBAL_STR(str806, "Subshell");
GLOBAL_STR(str807, "Pipeline");
GLOBAL_STR(str808, "%s failed with status %d");
GLOBAL_STR(str809, "Redirect filename can't be empty");
GLOBAL_STR(str810, "Redirect descriptor can't be empty");
GLOBAL_STR(str811, "-");
GLOBAL_STR(str812, "-");
GLOBAL_STR(str813, "Invalid descriptor %r.  Expected D, -, or D- where D is an integer");
GLOBAL_STR(str814, "\n");
GLOBAL_STR(str815, "Unknown redirect op");
GLOBAL_STR(str816, "Unknown redirect type");
GLOBAL_STR(str817, "for -Wreturn-type in C++");
GLOBAL_STR(str818, "strict_errexit only allows simple commands in conditionals (got %s). ");
GLOBAL_STR(str819, "strict_errexit only allows a single command.  Hint: use 'try'.");
GLOBAL_STR(str820, "strict_errexit only allows simple commands in conditionals (got %s). ");
GLOBAL_STR(str821, "ShAssignment builtins don't accept blocks");
GLOBAL_STR(str822, "|& isn't supported");
GLOBAL_STR(str823, "%r expected a number, got %r");
GLOBAL_STR(str824, "Invalid control flow at top level");
GLOBAL_STR(str825, "warning: ");
GLOBAL_STR(str826, "List iteration expects at most 2 loop variables");
GLOBAL_STR(str827, "Function %s was already defined (redefine_proc)");
GLOBAL_STR(str828, "Proc %s was already defined (redefine_proc)");
GLOBAL_STR(str829, "trap");
GLOBAL_STR(str830, "failglob: ");
GLOBAL_STR(str831, "Loop and control flow can't be in different processes");
GLOBAL_STR(str832, "fatal: ");
GLOBAL_STR(str833, "EXIT");
GLOBAL_STR(str834, "trap EXIT");
GLOBAL_STR(str835, "__");
GLOBAL_STR(str836, ":");
GLOBAL_STR(str837, "Invalid argument %r.  Expected a name starting with :");
GLOBAL_STR(str838, "No value provided for param %r");
GLOBAL_STR(str839, "proc %r expected %d arguments, but got %d");
GLOBAL_STR(str840, "Unexpected %r (in function call)");
GLOBAL_STR(str841, "Unexpected control flow in block");
GLOBAL_STR(str842, "Attempted to exit from completion hook.");
GLOBAL_STR(str843, "Couldn't find terminator for here doc that starts here");
GLOBAL_STR(str844, "\t");
GLOBAL_STR(str845, "Invalid here doc delimiter");
GLOBAL_STR(str846, "+");
GLOBAL_STR(str847, "+");
GLOBAL_STR(str848, "+");
GLOBAL_STR(str849, "%d != %d");
GLOBAL_STR(str850, "array place");
GLOBAL_STR(str851, "Environment binding shouldn't look like an array assignment");
GLOBAL_STR(str852, "+");
GLOBAL_STR(str853, "Expected = in environment binding, got +=");
GLOBAL_STR(str854, "Environment bindings can't contain array literals");
GLOBAL_STR(str855, "procs and shell functions can't be nested");
GLOBAL_STR(str856, "%r was already declared");
GLOBAL_STR(str857, "%r hasn't been declared");
GLOBAL_STR(str858, "Can't modify constant %r");
GLOBAL_STR(str859, "Expected word type %s, got %s");
GLOBAL_STR(str860, "{");
GLOBAL_STR(str861, "}");
GLOBAL_STR(str862, "Invalid token after redirect operator");
GLOBAL_STR(str863, "Space required before (");
GLOBAL_STR(str864, "Unexpected left paren (might need a space before it)");
GLOBAL_STR(str865, "Empty arg list not allowed");
GLOBAL_STR(str866, " ");
GLOBAL_STR(str867, " ");
GLOBAL_STR(str868, "line IDs %d != %d");
GLOBAL_STR(str869, " ");
GLOBAL_STR(str870, "");
GLOBAL_STR(str871, "Unexpected typed args");
GLOBAL_STR(str872, "=word isn't allowed.  Hint: either quote it or add a space after =\nto pretty print an expression");
GLOBAL_STR(str873, "Use const or var/setvar to assign in Oil (parse_sh_assign)");
GLOBAL_STR(str874, "Unexpected typed args");
GLOBAL_STR(str875, "Unexpected typed args");
GLOBAL_STR(str876, "Control flow shouldn't have redirects");
GLOBAL_STR(str877, "Control flow shouldn't have environment bindings");
GLOBAL_STR(str878, "Unexpected argument to %r");
GLOBAL_STR(str879, "Invalid word in for loop");
GLOBAL_STR(str880, "Invalid word after for expression");
GLOBAL_STR(str881, "Expected loop variable (a constant word)");
GLOBAL_STR(str882, ",");
GLOBAL_STR(str883, "Loop variables look like x, y (fix spaces)");
GLOBAL_STR(str884, "Invalid loop variable name %r");
GLOBAL_STR(str885, "Unexpected word after 3 loop variables");
GLOBAL_STR(str886, "Expected { after iterable expression");
GLOBAL_STR(str887, "Surround this word with either parens or quotes (parse_bare_word)");
GLOBAL_STR(str888, "Expected at most 2 loop variables");
GLOBAL_STR(str889, "Unexpected word after for loop variable");
GLOBAL_STR(str890, "Bash for loops aren't allowed (parse_dparen)");
GLOBAL_STR(str891, "Expected left paren (parse_sloppy_case)");
GLOBAL_STR(str892, "Constant pattern should be quoted (parse_bare_word)");
GLOBAL_STR(str893, "Expected ;; or esac");
GLOBAL_STR(str894, "This is a constant string.  You may want a variable like $x (parse_bare_word)");
GLOBAL_STR(str895, "You may want a space between parens (parse_dparen)");
GLOBAL_STR(str896, "Unexpected word while parsing compound command");
GLOBAL_STR(str897, "Invalid function name");
GLOBAL_STR(str898, "Expected ) in function definition");
GLOBAL_STR(str899, "Invalid KSH-style function name");
GLOBAL_STR(str900, "Unexpected word when parsing command");
GLOBAL_STR(str901, "Enable Oil to use procs (parse_proc)");
GLOBAL_STR(str902, "Unexpected right brace");
GLOBAL_STR(str903, "Unexpected = (Hint: use const/var/setvar, or quote it)");
GLOBAL_STR(str904, "Unexpected EOF while parsing command");
GLOBAL_STR(str905, "Invalid word while parsing command");
GLOBAL_STR(str906, "Invalid word while parsing command line");
GLOBAL_STR(str907, "Invalid word while parsing command list");
GLOBAL_STR(str908, "Unterminated here doc began here");
GLOBAL_STR(str909, "\\");
GLOBAL_STR(str910, "*");
GLOBAL_STR(str911, "?");
GLOBAL_STR(str912, "[");
GLOBAL_STR(str913, "]");
GLOBAL_STR(str914, "\\*?[]-:!()|");
GLOBAL_STR(str915, "\\?*+{}^$.()|[]");
GLOBAL_STR(str916, "\\");
GLOBAL_STR(str917, "Unexpected escaped character %r");
GLOBAL_STR(str918, "");
GLOBAL_STR(str919, "");
GLOBAL_STR(str920, "Malformed character class; treating as literal");
GLOBAL_STR(str921, "Got unescaped right bracket");
GLOBAL_STR(str922, "Got unescaped trailing backslash");
GLOBAL_STR(str923, ".|^$()+*?[]{}\\");
GLOBAL_STR(str924, "\\");
GLOBAL_STR(str925, "\\");
GLOBAL_STR(str926, "\\[");
GLOBAL_STR(str927, "\\]");
GLOBAL_STR(str928, "\\\\");
GLOBAL_STR(str929, "^");
GLOBAL_STR(str930, ".");
GLOBAL_STR(str931, ".*");
GLOBAL_STR(str932, "[");
GLOBAL_STR(str933, "^");
GLOBAL_STR(str934, "\\-");
GLOBAL_STR(str935, "\\]");
GLOBAL_STR(str936, "]");
GLOBAL_STR(str937, "-");
GLOBAL_STR(str938, "]");
GLOBAL_STR(str939, "");
GLOBAL_STR(str940, "Error expanding glob %r: %s");
GLOBAL_STR(str941, "-");
GLOBAL_STR(str942, "<Error: unbalanced \\[ and \\]> ");
GLOBAL_STR(str943, "$");
GLOBAL_STR(str944, "#");
GLOBAL_STR(str945, "$");
GLOBAL_STR(str946, "hostname");
GLOBAL_STR(str947, "user");
GLOBAL_STR(str948, "\u0001");
GLOBAL_STR(str949, "\u0002");
GLOBAL_STR(str950, "$");
GLOBAL_STR(str951, "$");
GLOBAL_STR(str952, "u");
GLOBAL_STR(str953, "user");
GLOBAL_STR(str954, "h");
GLOBAL_STR(str955, "hostname");
GLOBAL_STR(str956, ".");
GLOBAL_STR(str957, "H");
GLOBAL_STR(str958, "hostname");
GLOBAL_STR(str959, "s");
GLOBAL_STR(str960, "v");
GLOBAL_STR(str961, "A");
GLOBAL_STR(str962, "%H:%M");
GLOBAL_STR(str963, "D");
GLOBAL_STR(str964, "%X");
GLOBAL_STR(str965, "w");
GLOBAL_STR(str966, "PWD");
GLOBAL_STR(str967, "HOME");
GLOBAL_STR(str968, "<Error: %s>");
GLOBAL_STR(str969, "W");
GLOBAL_STR(str970, "PWD");
GLOBAL_STR(str971, "<Error: PWD is not a string> ");
GLOBAL_STR(str972, "<Error: \\%s not implemented in $PS1> ");
GLOBAL_STR(str973, "$");
GLOBAL_STR(str974, "\\$");
GLOBAL_STR(str975, "Invalid token %r");
GLOBAL_STR(str976, "");
GLOBAL_STR(str977, "");
GLOBAL_STR(str978, "<ERROR: Can't parse PS1: %s>");
GLOBAL_STR(str979, "osh");
GLOBAL_STR(str980, "PS1");
GLOBAL_STR(str981, "$ ");
GLOBAL_STR(str982, "PROMPT_COMMAND");
GLOBAL_STR(str983, "Undefined variable %r");
GLOBAL_STR(str984, "Can't use [] on value of type %s");
GLOBAL_STR(str985, "");
GLOBAL_STR(str986, "Can't use [] on value of type %s");
GLOBAL_STR(str987, "");
GLOBAL_STR(str988, "dynamic place");
GLOBAL_STR(str989, "got invalid place expression");
GLOBAL_STR(str990, "expected a var name.  shopt -s eval_unsafe_arith allows a[i]");
GLOBAL_STR(str991, "Invalid var ref");
GLOBAL_STR(str992, "0x");
GLOBAL_STR(str993, "Invalid hex constant %r");
GLOBAL_STR(str994, "0");
GLOBAL_STR(str995, "Invalid octal constant %r");
GLOBAL_STR(str996, "#");
GLOBAL_STR(str997, "#");
GLOBAL_STR(str998, "Invalid base for numeric constant %r");
GLOBAL_STR(str999, "a");
GLOBAL_STR(str1000, "A");
GLOBAL_STR(str1001, "@");
GLOBAL_STR(str1002, "_");
GLOBAL_STR(str1003, "Invalid digits for numeric constant %r");
GLOBAL_STR(str1004, "Digits %r out of range for base %d");
GLOBAL_STR(str1005, "Parse error in recursive arithmetic");
GLOBAL_STR(str1006, "Invalid integer constant %r");
GLOBAL_STR(str1007, "Invalid integer constant %r");
GLOBAL_STR(str1008, "Invalid integer constant %r");
GLOBAL_STR(str1009, "Undefined value in arithmetic context");
GLOBAL_STR(str1010, "Expected a value convertible to integer, got %s");
GLOBAL_STR(str1011, "0");
GLOBAL_STR(str1012, "Undefined variable %r");
GLOBAL_STR(str1013, "Divide by zero");
GLOBAL_STR(str1014, "Divide by zero");
GLOBAL_STR(str1015, "Expected array or assoc in index expression, got %s");
GLOBAL_STR(str1016, "Divide by zero");
GLOBAL_STR(str1017, "Divide by zero");
GLOBAL_STR(str1018, "Exponent can't be less than zero");
GLOBAL_STR(str1019, "for -Wreturn-type in C++");
GLOBAL_STR(str1020, "Associative array keys must be strings: $x 'x' \"$x\" etc.");
GLOBAL_STR(str1021, "Invalid place to modify");
GLOBAL_STR(str1022, "%s isn't implemented");
GLOBAL_STR(str1023, "Invalid regex %r: %s");
GLOBAL_STR(str1024, " \t\n");
GLOBAL_STR(str1025, "IFS");
GLOBAL_STR(str1026, "IFS shouldn't be an array");
GLOBAL_STR(str1027, " \t\n");
GLOBAL_STR(str1028, "IFS");
GLOBAL_STR(str1029, " ");
GLOBAL_STR(str1030, "");
GLOBAL_STR(str1031, "IFS shouldn't be an array");
GLOBAL_STR(str1032, "for -Wreturn-type in C++");
GLOBAL_STR(str1033, "\\");
GLOBAL_STR(str1034, "\\");
GLOBAL_STR(str1035, "Invalid transition from %r with %r");
GLOBAL_STR(str1036, "\u00ef\u00bf\u00bd");
GLOBAL_STR(str1037, "");
GLOBAL_STR(str1038, "Incomplete UTF-8 character");
GLOBAL_STR(str1039, "Invalid UTF-8 continuation byte");
GLOBAL_STR(str1040, "Invalid start of UTF-8 character");
GLOBAL_STR(str1041, "");
GLOBAL_STR(str1042, "%s can't have an argument");
GLOBAL_STR(str1043, "");
GLOBAL_STR(str1044, "%s can't have an argument");
GLOBAL_STR(str1045, "");
GLOBAL_STR(str1046, "%s can't have an argument");
GLOBAL_STR(str1047, "");
GLOBAL_STR(str1048, "%s can't have an argument");
GLOBAL_STR(str1049, "");
GLOBAL_STR(str1050, "<_GlobReplacer regex %r r %r>");
GLOBAL_STR(str1051, "(%s)");
GLOBAL_STR(str1052, "Error matching regex %r: %s");
GLOBAL_STR(str1053, "^");
GLOBAL_STR(str1054, "$");
GLOBAL_STR(str1055, "\r");
GLOBAL_STR(str1056, "<INVALID CR>");
GLOBAL_STR(str1057, "\n");
GLOBAL_STR(str1058, "<INVALID NEWLINE>");
GLOBAL_STR(str1059, " `~!$&*()[]{}\\|;'\"<>?");
GLOBAL_STR(str1060, "Left-hand side of this assignment is invalid");
GLOBAL_STR(str1061, "Token can't be used in prefix position");
GLOBAL_STR(str1062, "Token can't be used in infix position");
GLOBAL_STR(str1063, "Parser expected %s, got %s");
GLOBAL_STR(str1064, "Unexpected end of input");
GLOBAL_STR(str1065, "");
GLOBAL_STR(str1066, "");
GLOBAL_STR(str1067, "");
GLOBAL_STR(str1068, "");
GLOBAL_STR(str1069, "");
GLOBAL_STR(str1070, "");
GLOBAL_STR(str1071, "");
GLOBAL_STR(str1072, "");
GLOBAL_STR(str1073, "");
GLOBAL_STR(str1074, "for -Wreturn-type in C++");
GLOBAL_STR(str1075, "Compound shouldn't be empty");
GLOBAL_STR(str1076, "for -Wreturn-type in C++");
GLOBAL_STR(str1077, "/");
GLOBAL_STR(str1078, "/");
GLOBAL_STR(str1079, "");
GLOBAL_STR(str1080, "EOF");
GLOBAL_STR(str1081, "");
GLOBAL_STR(str1082, "");
GLOBAL_STR(str1083, " \t");
GLOBAL_STR(str1084, "\n");
GLOBAL_STR(str1085, "\n");
GLOBAL_STR(str1086, "\n");
GLOBAL_STR(str1087, "\n");
GLOBAL_STR(str1088, "BASH_SOURCE");
GLOBAL_STR(str1089, "FUNCNAME");
GLOBAL_STR(str1090, "BASH_LINENO");
GLOBAL_STR(str1091, "0");
GLOBAL_STR(str1092, "0");
GLOBAL_STR(str1093, "^([a-zA-Z_][a-zA-Z0-9_]*)((=|\\+=)(.*))?$");
GLOBAL_STR(str1094, "Assignment builtin expected NAME=value, got %r");
GLOBAL_STR(str1095, "+");
GLOBAL_STR(str1096, "\\");
GLOBAL_STR(str1097, "\\\\");
GLOBAL_STR(str1098, "");
GLOBAL_STR(str1099, "for -Wreturn-type in C++");
GLOBAL_STR(str1100, "");
GLOBAL_STR(str1101, "The length index of a array slice can't be negative: %d");
GLOBAL_STR(str1102, "Can't slice associative arrays");
GLOBAL_STR(str1103, "i");
GLOBAL_STR(str1104, "e");
GLOBAL_STR(str1105, "f");
GLOBAL_STR(str1106, "n");
GLOBAL_STR(str1107, "u");
GLOBAL_STR(str1108, "x");
GLOBAL_STR(str1109, "C");
GLOBAL_STR(str1110, "");
GLOBAL_STR(str1111, "~");
GLOBAL_STR(str1112, "HOME");
GLOBAL_STR(str1113, "Error expanding tilde (e.g. invalid user)");
GLOBAL_STR(str1114, "Can't assign to special variable");
GLOBAL_STR(str1115, "unset variable %r");
GLOBAL_STR(str1116, "warning: ");
GLOBAL_STR(str1117, "-1");
GLOBAL_STR(str1118, "a[i] not allowed without shopt -s eval_unsafe_arith");
GLOBAL_STR(str1119, "Indirect expansion of array");
GLOBAL_STR(str1120, "Indirect expansion of assoc array");
GLOBAL_STR(str1121, "extended globs not supported in ${x//GLOB/}");
GLOBAL_STR(str1122, "");
GLOBAL_STR(str1123, "warning: ");
GLOBAL_STR(str1124, "");
GLOBAL_STR(str1125, "\u0001");
GLOBAL_STR(str1126, "");
GLOBAL_STR(str1127, "\u0002");
GLOBAL_STR(str1128, "");
GLOBAL_STR(str1129, "Can't use @P on %s");
GLOBAL_STR(str1130, " ");
GLOBAL_STR(str1131, "Can't use @Q on %s");
GLOBAL_STR(str1132, "a");
GLOBAL_STR(str1133, "A");
GLOBAL_STR(str1134, "r");
GLOBAL_STR(str1135, "x");
GLOBAL_STR(str1136, "n");
GLOBAL_STR(str1137, "");
GLOBAL_STR(str1138, "Var op %r not implemented");
GLOBAL_STR(str1139, "Can't index string with @");
GLOBAL_STR(str1140, "Can't index string with *");
GLOBAL_STR(str1141, "Can't index string %r with integer");
GLOBAL_STR(str1142, "");
GLOBAL_STR(str1143, "");
GLOBAL_STR(str1144, "$");
GLOBAL_STR(str1145, "Undefined variable %r");
GLOBAL_STR(str1146, "Undefined array %r");
GLOBAL_STR(str1147, "Array %r can't be referred to as a scalar (without @ or *)");
GLOBAL_STR(str1148, "Test operation not allowed with ${!array[@]}");
GLOBAL_STR(str1149, "Not implemented");
GLOBAL_STR(str1150, "Illegal array word part (strict_array)");
GLOBAL_STR(str1151, " ");
GLOBAL_STR(str1152, "");
GLOBAL_STR(str1153, "Array %r can't be referred to as a scalar (without @ or *)");
GLOBAL_STR(str1154, "@(");
GLOBAL_STR(str1155, "|");
GLOBAL_STR(str1156, ")");
GLOBAL_STR(str1157, "Extended globs and arrays can't appear in the same word");
GLOBAL_STR(str1158, "*");
GLOBAL_STR(str1159, "Unexpected array literal");
GLOBAL_STR(str1160, "Unexpected associative array literal");
GLOBAL_STR(str1161, "Can't splice %r");
GLOBAL_STR(str1162, "");
GLOBAL_STR(str1163, "");
GLOBAL_STR(str1164, "Extended glob %r matched no files");
GLOBAL_STR(str1165, "Extended glob not allowed in this word");
GLOBAL_STR(str1166, "");
GLOBAL_STR(str1167, "This word should yield a string, but it contains an array");
GLOBAL_STR(str1168, " ");
GLOBAL_STR(str1169, "extended glob not allowed in this word");
GLOBAL_STR(str1170, "");
GLOBAL_STR(str1171, "");
GLOBAL_STR(str1172, "");
GLOBAL_STR(str1173, "");
GLOBAL_STR(str1174, "<Runtime error: %s>");
GLOBAL_STR(str1175, "<I/O error: %s>");
GLOBAL_STR(str1176, "<Ctrl-C>");
GLOBAL_STR(str1177, "");
GLOBAL_STR(str1178, "");
GLOBAL_STR(str1179, "");
GLOBAL_STR(str1180, "");
GLOBAL_STR(str1181, "Pattern %r matched no files");
GLOBAL_STR(str1182, "");
GLOBAL_STR(str1183, "LHS array not allowed in assignment builtin");
GLOBAL_STR(str1184, "+");
GLOBAL_STR(str1185, "-");
GLOBAL_STR(str1186, "+");
GLOBAL_STR(str1187, "f");
GLOBAL_STR(str1188, "F");
GLOBAL_STR(str1189, "Pattern %r matched no files");
GLOBAL_STR(str1190, "");
GLOBAL_STR(str1191, "__NO_COMMAND_SUB__");
GLOBAL_STR(str1192, "__NO_PROCESS_SUB__");
GLOBAL_STR(str1193, "Expected : or } in slice");
GLOBAL_STR(str1194, "Pattern in ${x/pat/replace} must not be empty");
GLOBAL_STR(str1195, "Expected } after replacement string, got %s");
GLOBAL_STR(str1196, "Expected } or / to close pattern");
GLOBAL_STR(str1197, "Expected ] to close subscript");
GLOBAL_STR(str1198, "Expected } to close ${");
GLOBAL_STR(str1199, "Expected } to close ${");
GLOBAL_STR(str1200, "Expected a constant argument");
GLOBAL_STR(str1201, "Expected } to close ${");
GLOBAL_STR(str1202, "Expected } to close ${");
GLOBAL_STR(str1203, "Unexpected token in ${} (%s)");
GLOBAL_STR(str1204, "VOp2");
GLOBAL_STR(str1205, "Unexpected token in ${} (%s)");
GLOBAL_STR(str1206, "VOp3");
GLOBAL_STR(str1207, "Expected } to close ${");
GLOBAL_STR(str1208, "Expected } after length expression");
GLOBAL_STR(str1209, "TODO: ${.myproc builtin sub}");
GLOBAL_STR(str1210, "Unexpected token in ${}");
GLOBAL_STR(str1211, "\\");
GLOBAL_STR(str1212, "Strings with backslashes should look like r'\\n' or $'\\n'");
GLOBAL_STR(str1213, "Use \\xhh or \\u{...} instead of octal escapes in Oil strings");
GLOBAL_STR(str1214, "Invalid hex escape in Oil string (must be \\xHH)");
GLOBAL_STR(str1215, "Invalid char escape in C-style string literal");
GLOBAL_STR(str1216, "Unexpected EOF in single-quoted string that began here");
GLOBAL_STR(str1217, "\"");
GLOBAL_STR(str1218, "'");
GLOBAL_STR(str1219, "Unexpected EOF reading extended glob that began here");
GLOBAL_STR(str1220, "Invalid char escape in double quoted string");
GLOBAL_STR(str1221, "Literal $ should be quoted like \\$");
GLOBAL_STR(str1222, "Invalid backtick: use $(cmd) or \\` in Oil strings");
GLOBAL_STR(str1223, "Unexpected EOF reading double-quoted string that began here");
GLOBAL_STR(str1224, "Use $(cmd) instead of backticks (parse_backticks)");
GLOBAL_STR(str1225, "Unexpected EOF while looking for closing backtick");
GLOBAL_STR(str1226, "");
GLOBAL_STR(str1227, "backticks");
GLOBAL_STR(str1228, "Invalid proc name %s");
GLOBAL_STR(str1229, "Unexpected token after arithmetic expression (%s != %s)");
GLOBAL_STR(str1230, "Expected second ) to end arith sub");
GLOBAL_STR(str1231, "Expected second ) to end arith statement");
GLOBAL_STR(str1232, "Expected ; here");
GLOBAL_STR(str1233, "Expected ; here");
GLOBAL_STR(str1234, "Expected ) to end for loop expression");
GLOBAL_STR(str1235, "Expected ( after =");
GLOBAL_STR(str1236, "Unexpected token in array literal");
GLOBAL_STR(str1237, "Expected associative array pair");
GLOBAL_STR(str1238, "Invalid char escape (parse_backslash)");
GLOBAL_STR(str1239, "Unexpected token after array literal");
GLOBAL_STR(str1240, "Unexpected token after array splice");
GLOBAL_STR(str1241, "TODO: @{.myproc builtin sub}");
GLOBAL_STR(str1242, "Literal @ starting a word must be quoted (parse_at_all)");
GLOBAL_STR(str1243, "/");
GLOBAL_STR(str1244, "next_byte %r");
GLOBAL_STR(str1245, "Literal $ should be quoted like \\$");
GLOBAL_STR(str1246, "Unexpected token after @()");
GLOBAL_STR(str1247, "Word has unbalanced { }.  Maybe add a space or quote it like \\{");
GLOBAL_STR(str1248, "Unexpected parts after triple quoted string");
GLOBAL_STR(str1249, "Unexpected token while parsing arithmetic: %r");
GLOBAL_STR(str1250, "Invalid blank line in multiline mode");
GLOBAL_STR(str1251, "r");
GLOBAL_STR(str1252, "Unhandled: %s (%s)");
GLOBAL_STR(str1253, "Invalid var ref");
GLOBAL_STR(str1254, "Expected end of var ref");
GLOBAL_STR(str1255, "Invalid lex state %s");
GLOBAL_STR(str1256, "typ");
GLOBAL_STR(str1257, "tok");
GLOBAL_STR(str1258, "children");
GLOBAL_STR(str1259, "-");
GLOBAL_STR(str1260, "with %d children");
GLOBAL_STR(str1261, "");
GLOBAL_STR(str1262, "(PNode %s %s %s)");
GLOBAL_STR(str1263, "&");
GLOBAL_STR(str1264, "&amp;");
GLOBAL_STR(str1265, "<");
GLOBAL_STR(str1266, "&lt;");
GLOBAL_STR(str1267, ">");
GLOBAL_STR(str1268, "&gt;");
GLOBAL_STR(str1269, ".");
GLOBAL_STR(str1270, "/");
GLOBAL_STR(str1271, "/");
GLOBAL_STR(str1272, "/");
GLOBAL_STR(str1273, "%s/%s");
GLOBAL_STR(str1274, "/");
GLOBAL_STR(str1275, "");
GLOBAL_STR(str1276, "/");
GLOBAL_STR(str1277, "/");
GLOBAL_STR(str1278, "/");
GLOBAL_STR(str1279, ".");
GLOBAL_STR(str1280, "");
GLOBAL_STR(str1281, "/");
GLOBAL_STR(str1282, "//");
GLOBAL_STR(str1283, "///");
GLOBAL_STR(str1284, "/");
GLOBAL_STR(str1285, ".");
GLOBAL_STR(str1286, "..");
GLOBAL_STR(str1287, "..");
GLOBAL_STR(str1288, "/");
GLOBAL_STR(str1289, "\\'\r\n\t\u0000");
GLOBAL_STR(str1290, "$'");
GLOBAL_STR(str1291, "'");
GLOBAL_STR(str1292, "'");
GLOBAL_STR(str1293, "");
GLOBAL_STR(str1294, "'");
GLOBAL_STR(str1295, "'");
GLOBAL_STR(str1296, "");
GLOBAL_STR(str1297, "'");
GLOBAL_STR(str1298, "'");
GLOBAL_STR(str1299, "");
GLOBAL_STR(str1300, "\\");
GLOBAL_STR(str1301, "\\\\");
GLOBAL_STR(str1302, "'");
GLOBAL_STR(str1303, "\\'");
GLOBAL_STR(str1304, "\n");
GLOBAL_STR(str1305, "\\n");
GLOBAL_STR(str1306, "\r");
GLOBAL_STR(str1307, "\\r");
GLOBAL_STR(str1308, "\t");
GLOBAL_STR(str1309, "\\t");
GLOBAL_STR(str1310, "\u0000");
GLOBAL_STR(str1311, "\\x00");
GLOBAL_STR(str1312, "\\0");
GLOBAL_STR(str1313, "");
GLOBAL_STR(str1314, "");
GLOBAL_STR(str1315, "");
GLOBAL_STR(str1316, "\\");
GLOBAL_STR(str1317, "\\\\");
GLOBAL_STR(str1318, "'");
GLOBAL_STR(str1319, "\\'");
GLOBAL_STR(str1320, "\n");
GLOBAL_STR(str1321, "\\n");
GLOBAL_STR(str1322, "\r");
GLOBAL_STR(str1323, "\\r");
GLOBAL_STR(str1324, "\t");
GLOBAL_STR(str1325, "\\t");
GLOBAL_STR(str1326, "\u0000");
GLOBAL_STR(str1327, "\\x00");
GLOBAL_STR(str1328, "\\0");
GLOBAL_STR(str1329, " \n\r\t");
GLOBAL_STR(str1330, "Unexpected token in QSN string");
GLOBAL_STR(str1331, "Expected closing single quote in QSN string");
GLOBAL_STR(str1332, "Unexpected data after closing quote");
GLOBAL_STR(str1333, "Unexpected token after QSN string");
GLOBAL_STR(str1334, "");
GLOBAL_STR(str1335, "!");
GLOBAL_STR(str1336, "--");
GLOBAL_STR(str1337, "--dir");
GLOBAL_STR(str1338, "--exists");
GLOBAL_STR(str1339, "--file");
GLOBAL_STR(str1340, "--symlink");
GLOBAL_STR(str1341, "Expected unary operator, got %r (2 args)");
GLOBAL_STR(str1342, "-a");
GLOBAL_STR(str1343, "-o");
GLOBAL_STR(str1344, "!");
GLOBAL_STR(str1345, "(");
GLOBAL_STR(str1346, ")");
GLOBAL_STR(str1347, "Expected binary operator, got %r (3 args)");
GLOBAL_STR(str1348, "should be invoked as 'test' (simple_test_builtin)");
GLOBAL_STR(str1349, "]");
GLOBAL_STR(str1350, "missing closing ]");
GLOBAL_STR(str1351, "should only have 3 arguments or fewer (simple_test_builtin)");
GLOBAL_STR(str1352, "!");
GLOBAL_STR(str1353, "(");
GLOBAL_STR(str1354, ")");
GLOBAL_STR(str1355, "(test) ");
GLOBAL_STR(str1356, "(test) ");

namespace runtime {  // forward declare


}  // forward declare namespace runtime

namespace vm {  // forward declare

  class _Executor;
  class _AssignBuiltin;
  class _Builtin;
  class ctx_Redirect;
  class ctx_ProcessSub;

}  // forward declare namespace vm

namespace format {  // forward declare

  class ColorOutput;
  class TextOutput;
  class HtmlOutput;
  class AnsiOutput;
  class _PrettyPrinter;

}  // forward declare namespace format

namespace osh_eval {  // forward declare


}  // forward declare namespace osh_eval

namespace alloc {  // forward declare

  class ctx_Location;
  class Arena;

}  // forward declare namespace alloc

namespace ansi {  // forward declare


}  // forward declare namespace ansi

namespace dev {  // forward declare

  class CrashDumper;
  class ctx_Tracer;
  class Tracer;

}  // forward declare namespace dev

namespace error {  // forward declare

  class _ControlFlow;

}  // forward declare namespace error

namespace executor {  // forward declare

  class _ProcessSubFrame;
  class ShellExecutor;

}  // forward declare namespace executor

namespace main_loop {  // forward declare

  class ctx_Descriptors;

}  // forward declare namespace main_loop

namespace process {  // forward declare

  class _RedirFrame;
  class _FdFrame;
  class FdState;
  class ChildStateChange;
  class StdinFromPipe;
  class StdoutToPipe;
  class ExternalProgram;
  class Thunk;
  class ExternalThunk;
  class SubProgramThunk;
  class _HereDocWriterThunk;
  class Job;
  class Process;
  class ctx_Pipe;
  class Pipeline;
  class JobState;
  class Waiter;

}  // forward declare namespace process

namespace shell_native {  // forward declare


}  // forward declare namespace shell_native

namespace state {  // forward declare

  class SearchPath;
  class ctx_Source;
  class ctx_Option;
  class ctx_AssignBuiltin;
  class ctx_OilExpr;
  class ctx_ErrExit;
  class ctx_HayNode;
  class ctx_HayEval;
  class Hay;
  class OptHook;
  class MutableOpts;
  class _ArgFrame;
  class DirStack;
  class DebugFrame;
  class ctx_Call;
  class ctx_Temp;
  class ctx_Shvar;
  class ctx_Registers;
  class ctx_ThisDir;
  class Mem;

}  // forward declare namespace state

namespace ui {  // forward declare

  class ctx_Location;
  class ErrorFormatter;

}  // forward declare namespace ui

namespace util {  // forward declare

  class UserExit;
  class _DebugFile;
  class NullDebugFile;
  class DebugFile;

}  // forward declare namespace util

namespace args {  // forward declare

  class _Attributes;
  class Reader;
  class _Action;
  class _ArgAction;
  class SetToInt;
  class SetToFloat;
  class SetToString;
  class SetAttachedBool;
  class SetToTrue;
  class SetOption;
  class SetNamedOption;
  class SetAction;
  class SetNamedAction;

}  // forward declare namespace args

namespace lexer {  // forward declare

  class LineLexer;
  class Lexer;

}  // forward declare namespace lexer

namespace location {  // forward declare


}  // forward declare namespace location

namespace parse_lib {  // forward declare

  class _BaseTrail;
  class ctx_Alias;
  class Trail;
  class ParseContext;

}  // forward declare namespace parse_lib

namespace reader {  // forward declare

  class _Reader;
  class DisallowedLineReader;
  class FileLineReader;
  class VirtualLineReader;

}  // forward declare namespace reader

namespace typed_args {  // forward declare


}  // forward declare namespace typed_args

namespace expr_parse {  // forward declare

  class ExprParser;

}  // forward declare namespace expr_parse

namespace expr_to_ast {  // forward declare

  class Transformer;

}  // forward declare namespace expr_to_ast

namespace funcs {  // forward declare

  class ParseHay;
  class EvalHay;
  class BlockAsStr;
  class HayFunc;

}  // forward declare namespace funcs

namespace regex_translate {  // forward declare


}  // forward declare namespace regex_translate

namespace arith_parse {  // forward declare


}  // forward declare namespace arith_parse

namespace bool_parse {  // forward declare

  class BoolParser;

}  // forward declare namespace bool_parse

namespace braces {  // forward declare

  class _NotARange;
  class _RangeParser;
  class _StackFrame;

}  // forward declare namespace braces

namespace builtin_assign {  // forward declare

  class Export;
  class Readonly;
  class NewVar;
  class Unset;
  class Shift;

}  // forward declare namespace builtin_assign

namespace builtin_meta {  // forward declare

  class Eval;
  class Source;
  class Command;
  class Builtin;
  class RunProc;
  class Try;
  class BoolStatus;
  class Type;

}  // forward declare namespace builtin_meta

namespace builtin_misc {  // forward declare

  class Times;
  class Read;
  class MapFile;
  class ctx_CdBlock;
  class Cd;
  class Pushd;
  class Popd;
  class Dirs;
  class Pwd;
  class Help;
  class Cat;

}  // forward declare namespace builtin_misc

namespace builtin_printf {  // forward declare

  class _FormatStringParser;
  class Printf;

}  // forward declare namespace builtin_printf

namespace builtin_process2 {  // forward declare

  class Exec;
  class Wait;
  class Umask;

}  // forward declare namespace builtin_process2

namespace builtin_pure {  // forward declare

  class Boolean;
  class Alias;
  class UnAlias;
  class Set;
  class Shopt;
  class Hash;
  class GetOptsState;
  class GetOpts;
  class Echo;
  class Module;
  class Use;
  class Shvar;
  class PushRegisters;
  class Fopen;

}  // forward declare namespace builtin_pure

namespace builtin_trap {  // forward declare

  class TrapState;
  class Trap;

}  // forward declare namespace builtin_trap

namespace cmd_eval {  // forward declare

  class Deps;
  class ctx_LoopLevel;
  class CommandEvaluator;

}  // forward declare namespace cmd_eval

namespace cmd_parse {  // forward declare

  class VarChecker;
  class ctx_VarChecker;
  class CommandParser;

}  // forward declare namespace cmd_parse

namespace glob_ {  // forward declare

  class _GlobParser;
  class Globber;

}  // forward declare namespace glob_

namespace prompt {  // forward declare

  class _PromptEvaluatorCache;
  class Evaluator;
  class UserPlugin;

}  // forward declare namespace prompt

namespace sh_expr_eval {  // forward declare

  class UnsafeArith;
  class ArithEvaluator;
  class BoolEvaluator;

}  // forward declare namespace sh_expr_eval

namespace split {  // forward declare

  class SplitContext;
  class _BaseSplitter;
  class IfsSplitter;

}  // forward declare namespace split

namespace string_ops {  // forward declare

  class GlobReplacer;

}  // forward declare namespace string_ops

namespace tdop {  // forward declare

  class TdopParser;

}  // forward declare namespace tdop

namespace word_ {  // forward declare

  class ctx_EmitDocToken;
  class ctx_Multiline;

}  // forward declare namespace word_

namespace word_compile {  // forward declare


}  // forward declare namespace word_compile

namespace word_eval {  // forward declare

  class StringWordEvaluator;
  class TildeEvaluator;
  class AbstractWordEvaluator;
  class NormalWordEvaluator;
  class CompletionWordEvaluator;

}  // forward declare namespace word_eval

namespace word_parse {  // forward declare

  class WordEmitter;
  class WordParser;

}  // forward declare namespace word_parse

namespace grammar {  // forward declare

  class Grammar;

}  // forward declare namespace grammar

namespace pnode {  // forward declare

  class PNode;

}  // forward declare namespace pnode

namespace cgi {  // forward declare


}  // forward declare namespace cgi

namespace os_path {  // forward declare


}  // forward declare namespace os_path

namespace qsn {  // forward declare


}  // forward declare namespace qsn

namespace qsn_native {  // forward declare


}  // forward declare namespace qsn_native

namespace builtin_bracket {  // forward declare

  class _StringWordEmitter;
  class _WordEvaluator;
  class Test;

}  // forward declare namespace builtin_bracket

namespace runtime {  // declare

extern int NO_SPID;
hnode_asdl::hnode__Record* NewRecord(Str* node_type);
hnode_asdl::hnode__Leaf* NewLeaf(Str* s, hnode_asdl::color_t e_color);
extern Str* TRUE_STR;
extern Str* FALSE_STR;


}  // declare namespace runtime

namespace vm {  // declare

void InitUnsafeArith(state::Mem* mem, word_eval::NormalWordEvaluator* word_ev, sh_expr_eval::UnsafeArith* unsafe_arith);
void InitCircularDeps(sh_expr_eval::ArithEvaluator* arith_ev, sh_expr_eval::BoolEvaluator* bool_ev, expr_eval::OilEvaluator* expr_ev, word_eval::NormalWordEvaluator* word_ev, cmd_eval::CommandEvaluator* cmd_ev, vm::_Executor* shell_ex, prompt::Evaluator* prompt_ev, dev::Tracer* tracer);
class _Executor : public Obj {
 public:
  _Executor();
  virtual void CheckCircularDeps();
  virtual int RunBuiltin(int builtin_id, runtime_asdl::cmd_value__Argv* cmd_val);
  int RunSimpleCommand(runtime_asdl::cmd_value__Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork);
  virtual int RunSimpleCommand(runtime_asdl::cmd_value__Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork, bool call_procs);
  virtual int RunBackgroundJob(syntax_asdl::command_t* node);
  virtual void RunPipeline(syntax_asdl::command__Pipeline* node, runtime_asdl::CommandStatus* status_out);
  virtual int RunSubshell(syntax_asdl::command_t* node);
  virtual Str* RunCommandSub(syntax_asdl::command_sub* cs_part);
  virtual Str* RunProcessSub(syntax_asdl::command_sub* cs_part);
  virtual void Time();
  virtual bool PushRedirects(List<runtime_asdl::redirect*>* redirects);
  virtual void PopRedirects();
  virtual void PushProcessSub();
  virtual void PopProcessSub(runtime_asdl::StatusArray* compound_st);

  cmd_eval::CommandEvaluator* cmd_ev;

  DISALLOW_COPY_AND_ASSIGN(_Executor)
};

constexpr uint16_t maskof__Executor() {
  return
    maskbit_v(offsetof(_Executor, cmd_ev));
}

class _AssignBuiltin : public Obj {
 public:
  _AssignBuiltin();
  virtual int Run(runtime_asdl::cmd_value__Assign* cmd_val);

  DISALLOW_COPY_AND_ASSIGN(_AssignBuiltin)
};

class _Builtin : public Obj {
 public:
  _Builtin();
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  DISALLOW_COPY_AND_ASSIGN(_Builtin)
};

class ctx_Redirect : public Obj {
 public:
  ctx_Redirect(vm::_Executor* shell_ex);
  ~ctx_Redirect();

  vm::_Executor* shell_ex;

  DISALLOW_COPY_AND_ASSIGN(ctx_Redirect)
};

constexpr uint16_t maskof_ctx_Redirect() {
  return
    maskbit(offsetof(ctx_Redirect, shell_ex));
}

class ctx_ProcessSub : public Obj {
 public:
  ctx_ProcessSub(vm::_Executor* shell_ex, runtime_asdl::StatusArray* process_sub_status);
  ~ctx_ProcessSub();

  runtime_asdl::StatusArray* process_sub_status;
  vm::_Executor* shell_ex;

  DISALLOW_COPY_AND_ASSIGN(ctx_ProcessSub)
};

constexpr uint16_t maskof_ctx_ProcessSub() {
  return
    maskbit(offsetof(ctx_ProcessSub, process_sub_status))
  | maskbit(offsetof(ctx_ProcessSub, shell_ex));
}



}  // declare namespace vm

namespace format {  // declare

format::ColorOutput* DetectConsoleOutput(mylib::Writer* f);
class ColorOutput : public Obj {
 public:
  ColorOutput(mylib::Writer* f);
  virtual format::ColorOutput* NewTempBuffer();
  virtual void FileHeader();
  virtual void FileFooter();
  virtual void PushColor(hnode_asdl::color_t e_color);
  virtual void PopColor();
  virtual void write(Str* s);
  void WriteRaw(Tuple2<Str*, int>* raw);
  int NumChars();
  Tuple2<Str*, int> GetRaw();

  mylib::Writer* f;
  int num_chars;

  DISALLOW_COPY_AND_ASSIGN(ColorOutput)
};

constexpr uint16_t maskof_ColorOutput() {
  return
    maskbit_v(offsetof(ColorOutput, f));
}

class TextOutput : public ColorOutput {
 public:
  TextOutput(mylib::Writer* f);
  virtual format::TextOutput* NewTempBuffer();
  virtual void PushColor(hnode_asdl::color_t e_color);
  virtual void PopColor();

  DISALLOW_COPY_AND_ASSIGN(TextOutput)
};

class HtmlOutput : public ColorOutput {
 public:
  HtmlOutput(mylib::Writer* f);
  virtual format::HtmlOutput* NewTempBuffer();
  virtual void FileHeader();
  virtual void FileFooter();
  virtual void PushColor(hnode_asdl::color_t e_color);
  virtual void PopColor();
  virtual void write(Str* s);

  DISALLOW_COPY_AND_ASSIGN(HtmlOutput)
};

class AnsiOutput : public ColorOutput {
 public:
  AnsiOutput(mylib::Writer* f);
  virtual format::AnsiOutput* NewTempBuffer();
  virtual void PushColor(hnode_asdl::color_t e_color);
  virtual void PopColor();

  DISALLOW_COPY_AND_ASSIGN(AnsiOutput)
};

extern int INDENT;
class _PrettyPrinter : public Obj {
 public:
  _PrettyPrinter(int max_col);
  bool _PrintWrappedArray(List<hnode_asdl::hnode_t*>* array, int prefix_len, format::ColorOutput* f, int indent);
  bool _PrintWholeArray(List<hnode_asdl::hnode_t*>* array, int prefix_len, format::ColorOutput* f, int indent);
  void _PrintRecord(hnode_asdl::hnode__Record* node, format::ColorOutput* f, int indent);
  void PrintNode(hnode_asdl::hnode_t* node, format::ColorOutput* f, int indent);

  int max_col;

  DISALLOW_COPY_AND_ASSIGN(_PrettyPrinter)
};

bool _TrySingleLineObj(hnode_asdl::hnode__Record* node, format::ColorOutput* f, int max_chars);
bool _TrySingleLine(hnode_asdl::hnode_t* node, format::ColorOutput* f, int max_chars);
void PrintTree(hnode_asdl::hnode_t* node, format::ColorOutput* f);

inline Str* fmt0(Str* a0) {
  gBuf.reset();
  gBuf.write_const("<span class=\"", 13);
  gBuf.format_s(a0);
  gBuf.write_const("\">", 2);
  return gBuf.getvalue();
}

inline Str* fmt1(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.format_s(a1);
  gBuf.write_const(": [", 3);
  return gBuf.getvalue();
}

inline Str* fmt2(Str* a0) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const("]", 1);
  return gBuf.getvalue();
}

inline Str* fmt3(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.format_s(a1);
  gBuf.write_const(": ", 2);
  return gBuf.getvalue();
}

inline Str* fmt4(Str* a0) {
  gBuf.reset();
  gBuf.write_const(" ", 1);
  gBuf.format_s(a0);
  gBuf.write_const(":", 1);
  return gBuf.getvalue();
}


}  // declare namespace format

namespace osh_eval {  // declare

int main(List<Str*>* argv);

inline Str* fmt5(Str* a0) {
  gBuf.reset();
  gBuf.write_const("oil: ", 5);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt6(Str* a0) {
  gBuf.reset();
  gBuf.write_const("osh fatal error: ", 17);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt7(Str* a0) {
  gBuf.reset();
  gBuf.write_const("osh I/O error: ", 15);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}


}  // declare namespace osh_eval

namespace alloc {  // declare

class ctx_Location : public Obj {
 public:
  ctx_Location(alloc::Arena* arena, syntax_asdl::source_t* src);
  ~ctx_Location();

  alloc::Arena* arena;

  DISALLOW_COPY_AND_ASSIGN(ctx_Location)
};

constexpr uint16_t maskof_ctx_Location() {
  return
    maskbit(offsetof(ctx_Location, arena));
}

class Arena : public Obj {
 public:
  Arena();
  void PushSource(syntax_asdl::source_t* src);
  void PopSource();
  int AddLine(Str* line, int line_num);
  Str* GetLine(int line_id);
  int GetLineNumber(int line_id);
  Str* GetLineNumStr(int line_id);
  Str* GetCodeString(int lbrace_spid, int rbrace_spid);
  syntax_asdl::source_t* GetLineSource(int line_id);
  int AddLineSpan(int line_id, int col, int length);
  syntax_asdl::line_span* GetLineSpan(int span_id);
  int LastSpanId();

  Dict<int, Str*>* line_num_strs;
  List<int>* line_nums;
  List<syntax_asdl::source_t*>* line_srcs;
  List<Str*>* line_vals;
  List<syntax_asdl::source_t*>* source_instances;
  List<syntax_asdl::line_span*>* spans;

  DISALLOW_COPY_AND_ASSIGN(Arena)
};

constexpr uint16_t maskof_Arena() {
  return
    maskbit(offsetof(Arena, line_num_strs))
  | maskbit(offsetof(Arena, line_nums))
  | maskbit(offsetof(Arena, line_srcs))
  | maskbit(offsetof(Arena, line_vals))
  | maskbit(offsetof(Arena, source_instances))
  | maskbit(offsetof(Arena, spans));
}



}  // declare namespace alloc

namespace ansi {  // declare

extern Str* RESET;
extern Str* BOLD;
extern Str* UNDERLINE;
extern Str* REVERSE;
extern Str* RED;
extern Str* GREEN;
extern Str* YELLOW;
extern Str* BLUE;


}  // declare namespace ansi

namespace dev {  // declare

class CrashDumper : public Obj {
 public:
  CrashDumper(Str* crash_dump_dir);
  void MaybeCollect(void* cmd_ev, error::_ErrorWithLocation* err);
  void MaybeDump(int status);

  void* argv_stack;
  bool collected;
  Str* crash_dump_dir;
  void* debug_stack;
  bool do_collect;
  Dict<Str*, void*>* error;
  void* var_stack;

  DISALLOW_COPY_AND_ASSIGN(CrashDumper)
};

constexpr uint16_t maskof_CrashDumper() {
  return
    maskbit(offsetof(CrashDumper, argv_stack))
  | maskbit(offsetof(CrashDumper, crash_dump_dir))
  | maskbit(offsetof(CrashDumper, debug_stack))
  | maskbit(offsetof(CrashDumper, error))
  | maskbit(offsetof(CrashDumper, var_stack));
}

class ctx_Tracer : public Obj {
 public:
  ctx_Tracer(dev::Tracer* tracer, Str* label, List<Str*>* argv);
  ~ctx_Tracer();

  Str* arg;
  Str* label;
  dev::Tracer* tracer;

  DISALLOW_COPY_AND_ASSIGN(ctx_Tracer)
};

constexpr uint16_t maskof_ctx_Tracer() {
  return
    maskbit(offsetof(ctx_Tracer, arg))
  | maskbit(offsetof(ctx_Tracer, label))
  | maskbit(offsetof(ctx_Tracer, tracer));
}

void _PrintShValue(runtime_asdl::value_t* val, mylib::BufWriter* buf);
void _PrintArgv(List<Str*>* argv, mylib::BufWriter* buf);
class Tracer : public Obj {
 public:
  Tracer(parse_lib::ParseContext* parse_ctx, optview::Exec* exec_opts, state::MutableOpts* mutable_opts, state::Mem* mem, util::_DebugFile* f);
  void CheckCircularDeps();
  Str* _EvalPS4(Str* punct);
  void _Inc();
  void _Dec();
  mylib::BufWriter* _ShTraceBegin();
  mylib::BufWriter* _RichTraceBegin(Str* punct);
  void OnProcessStart(int pid, runtime_asdl::trace_t* why);
  void OnProcessEnd(int pid, int status);
  void SetProcess(int pid);
  void PushMessage(Str* label, List<Str*>* argv);
  void PopMessage(Str* label, Str* arg);
  void PrintMessage(Str* message);
  void OnExec(List<Str*>* argv);
  void OnBuiltin(int builtin_id, List<Str*>* argv);
  void OnSimpleCommand(List<Str*>* argv);
  void OnAssignBuiltin(runtime_asdl::cmd_value__Assign* cmd_val);
  void OnShAssignment(runtime_asdl::lvalue_t* lval, syntax_asdl::assign_op_t op, runtime_asdl::value_t* val, int flags, runtime_asdl::scope_t which_scopes);
  void OnControlFlow(Str* keyword, int arg);
  void PrintSourceCode(int left_spid, int right_spid, alloc::Arena* arena);

  optview::Exec* exec_opts;
  util::_DebugFile* f;
  int ind;
  List<Str*>* indents;
  runtime_asdl::lvalue__Named* lval_indent;
  runtime_asdl::lvalue__Named* lval_pid_str;
  runtime_asdl::lvalue__Named* lval_punct;
  state::Mem* mem;
  state::MutableOpts* mutable_opts;
  Dict<Str*, syntax_asdl::compound_word*>* parse_cache;
  parse_lib::ParseContext* parse_ctx;
  runtime_asdl::value__Str* val_indent;
  runtime_asdl::value__Str* val_pid_str;
  runtime_asdl::value__Str* val_punct;
  word_eval::NormalWordEvaluator* word_ev;

  DISALLOW_COPY_AND_ASSIGN(Tracer)
};

constexpr uint16_t maskof_Tracer() {
  return
    maskbit(offsetof(Tracer, exec_opts))
  | maskbit(offsetof(Tracer, f))
  | maskbit(offsetof(Tracer, indents))
  | maskbit(offsetof(Tracer, lval_indent))
  | maskbit(offsetof(Tracer, lval_pid_str))
  | maskbit(offsetof(Tracer, lval_punct))
  | maskbit(offsetof(Tracer, mem))
  | maskbit(offsetof(Tracer, mutable_opts))
  | maskbit(offsetof(Tracer, parse_cache))
  | maskbit(offsetof(Tracer, parse_ctx))
  | maskbit(offsetof(Tracer, val_indent))
  | maskbit(offsetof(Tracer, val_pid_str))
  | maskbit(offsetof(Tracer, val_punct))
  | maskbit(offsetof(Tracer, word_ev));
}


inline Str* fmt8(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("[", 1);
  gBuf.format_s(a0);
  gBuf.write_const("]=", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt9(Str* a0) {
  gBuf.reset();
  gBuf.write_const("<ERROR: Can't parse PS4: ", 25);
  gBuf.format_s(a0);
  gBuf.write_const(">", 1);
  return gBuf.getvalue();
}

inline Str* fmt10(int a0) {
  gBuf.reset();
  gBuf.write_const("command ", 8);
  gBuf.format_d(a0);
  gBuf.write_const(":", 1);
  return gBuf.getvalue();
}

inline Str* fmt11(int a0) {
  gBuf.reset();
  gBuf.write_const("forkwait ", 9);
  gBuf.format_d(a0);
  gBuf.write_const("\n", 1);
  return gBuf.getvalue();
}

inline Str* fmt12(int a0) {
  gBuf.reset();
  gBuf.write_const("command sub ", 12);
  gBuf.format_d(a0);
  gBuf.write_const("\n", 1);
  return gBuf.getvalue();
}

inline Str* fmt13(int a0) {
  gBuf.reset();
  gBuf.write_const("proc sub ", 9);
  gBuf.format_d(a0);
  gBuf.write_const("\n", 1);
  return gBuf.getvalue();
}

inline Str* fmt14(int a0) {
  gBuf.reset();
  gBuf.write_const("here doc ", 9);
  gBuf.format_d(a0);
  gBuf.write_const("\n", 1);
  return gBuf.getvalue();
}

inline Str* fmt15(int a0) {
  gBuf.reset();
  gBuf.write_const("fork ", 5);
  gBuf.format_d(a0);
  gBuf.write_const("\n", 1);
  return gBuf.getvalue();
}

inline Str* fmt16(int a0) {
  gBuf.reset();
  gBuf.write_const("part ", 5);
  gBuf.format_d(a0);
  gBuf.write_const("\n", 1);
  return gBuf.getvalue();
}

inline Str* fmt17(int a0, int a1) {
  gBuf.reset();
  gBuf.write_const("process ", 8);
  gBuf.format_d(a0);
  gBuf.write_const(": status ", 9);
  gBuf.format_d(a1);
  gBuf.write_const("\n", 1);
  return gBuf.getvalue();
}

inline Str* fmt18(int a0) {
  gBuf.reset();
  gBuf.write_const(" ", 1);
  gBuf.format_d(a0);
  return gBuf.getvalue();
}

inline Str* fmt19(Str* a0, int a1) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const("[", 1);
  gBuf.format_d(a1);
  gBuf.write_const("]", 1);
  return gBuf.getvalue();
}

inline Str* fmt20(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const("[", 1);
  gBuf.format_s(a1);
  gBuf.write_const("]", 1);
  return gBuf.getvalue();
}


}  // declare namespace dev

namespace error {  // declare

extern int NO_SPID;
class _ControlFlow : public Obj {
 public:
  _ControlFlow(syntax_asdl::Token* token, int arg);
  bool IsReturn();
  bool IsBreak();
  bool IsContinue();
  int StatusCode();

  int arg;
  syntax_asdl::Token* token;

  DISALLOW_COPY_AND_ASSIGN(_ControlFlow)
};

constexpr uint16_t maskof__ControlFlow() {
  return
    maskbit(offsetof(_ControlFlow, token));
}



}  // declare namespace error

namespace executor {  // declare

class _ProcessSubFrame : public Obj {
 public:
  _ProcessSubFrame();

  List<int>* span_ids;
  List<int>* to_close;
  List<process::Process*>* to_wait;

  DISALLOW_COPY_AND_ASSIGN(_ProcessSubFrame)
};

constexpr uint16_t maskof__ProcessSubFrame() {
  return
    maskbit(offsetof(_ProcessSubFrame, span_ids))
  | maskbit(offsetof(_ProcessSubFrame, to_close))
  | maskbit(offsetof(_ProcessSubFrame, to_wait));
}

class ShellExecutor : public vm::_Executor {
 public:
  ShellExecutor(state::Mem* mem, optview::Exec* exec_opts, state::MutableOpts* mutable_opts, Dict<Str*, runtime_asdl::Proc*>* procs, state::Hay* hay_state, Dict<int, vm::_Builtin*>* builtins, state::SearchPath* search_path, process::ExternalProgram* ext_prog, process::Waiter* waiter, dev::Tracer* tracer, process::JobState* job_state, process::FdState* fd_state, ui::ErrorFormatter* errfmt);
  virtual void CheckCircularDeps();
  process::Process* _MakeProcess(syntax_asdl::command_t* node);
  process::Process* _MakeProcess(syntax_asdl::command_t* node, bool inherit_errexit);
  virtual int RunBuiltin(int builtin_id, runtime_asdl::cmd_value__Argv* cmd_val);
  int RunSimpleCommand(runtime_asdl::cmd_value__Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork);
  virtual int RunSimpleCommand(runtime_asdl::cmd_value__Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork, bool call_procs);
  virtual int RunBackgroundJob(syntax_asdl::command_t* node);
  virtual void RunPipeline(syntax_asdl::command__Pipeline* node, runtime_asdl::CommandStatus* status_out);
  virtual int RunSubshell(syntax_asdl::command_t* node);
  virtual Str* RunCommandSub(syntax_asdl::command_sub* cs_part);
  virtual Str* RunProcessSub(syntax_asdl::command_sub* cs_part);
  void MaybeWaitOnProcessSubs(executor::_ProcessSubFrame* frame, runtime_asdl::StatusArray* compound_st);
  virtual void Time();
  virtual bool PushRedirects(List<runtime_asdl::redirect*>* redirects);
  virtual void PopRedirects();
  virtual void PushProcessSub();
  virtual void PopProcessSub(runtime_asdl::StatusArray* compound_st);

  Dict<int, vm::_Builtin*>* builtins;
  ui::ErrorFormatter* errfmt;
  optview::Exec* exec_opts;
  process::ExternalProgram* ext_prog;
  process::FdState* fd_state;
  state::Hay* hay_state;
  process::JobState* job_state;
  state::Mem* mem;
  state::MutableOpts* mutable_opts;
  List<executor::_ProcessSubFrame*>* process_sub_stack;
  Dict<Str*, runtime_asdl::Proc*>* procs;
  state::SearchPath* search_path;
  dev::Tracer* tracer;
  process::Waiter* waiter;

  DISALLOW_COPY_AND_ASSIGN(ShellExecutor)
};

constexpr uint16_t maskof_ShellExecutor() {
  return
    maskbit_v(offsetof(ShellExecutor, builtins))
  | maskbit_v(offsetof(ShellExecutor, errfmt))
  | maskbit_v(offsetof(ShellExecutor, exec_opts))
  | maskbit_v(offsetof(ShellExecutor, ext_prog))
  | maskbit_v(offsetof(ShellExecutor, fd_state))
  | maskbit_v(offsetof(ShellExecutor, hay_state))
  | maskbit_v(offsetof(ShellExecutor, job_state))
  | maskbit_v(offsetof(ShellExecutor, mem))
  | maskbit_v(offsetof(ShellExecutor, mutable_opts))
  | maskbit_v(offsetof(ShellExecutor, process_sub_stack))
  | maskbit_v(offsetof(ShellExecutor, procs))
  | maskbit_v(offsetof(ShellExecutor, search_path))
  | maskbit_v(offsetof(ShellExecutor, tracer))
  | maskbit_v(offsetof(ShellExecutor, waiter));
}


inline Str* fmt21(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid control flow ", 21);
  gBuf.format_r(a0);
  gBuf.write_const(" in pipeline / subshell / background", 36);
  return gBuf.getvalue();
}

inline Str* fmt22(Str* a0) {
  gBuf.reset();
  gBuf.format_r(a0);
  gBuf.write_const(" ", 1);
  return gBuf.getvalue();
}

inline Str* fmt23() {
  gBuf.reset();
  gBuf.write_const("Command evaluated to an empty argv array", 40);
  return gBuf.getvalue();
}

inline Str* fmt24() {
  gBuf.reset();
  gBuf.write_const("Can't run a proc while errexit is disabled. Use 'try' or wrap it in a process with $0 myproc", 92);
  return gBuf.getvalue();
}

inline Str* fmt25(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Unknown command ", 16);
  gBuf.format_r(a0);
  gBuf.write_const(" while running hay", 18);
  return gBuf.getvalue();
}

inline Str* fmt26(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Unexpected typed args passed to external command ", 49);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt27(Str* a0) {
  gBuf.reset();
  gBuf.format_r(a0);
  gBuf.write_const(" not found", 10);
  return gBuf.getvalue();
}

inline Str* fmt28() {
  gBuf.reset();
  gBuf.write_const("Command subs not allowed here because status wouldn't be checked (strict_errexit).", 82);
  return gBuf.getvalue();
}

inline Str* fmt29(Str* a0) {
  gBuf.reset();
  gBuf.write_const("osh I/O error: ", 15);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt30(int a0) {
  gBuf.reset();
  gBuf.write_const("Command Sub exited with status ", 31);
  gBuf.format_d(a0);
  return gBuf.getvalue();
}

inline Str* fmt31() {
  gBuf.reset();
  gBuf.write_const("Process subs not allowed here because status wouldn't be checked (strict_errexit).", 82);
  return gBuf.getvalue();
}

inline Str* fmt32(int a0) {
  gBuf.reset();
  gBuf.write_const("/dev/fd/", 8);
  gBuf.format_d(a0);
  return gBuf.getvalue();
}

inline Str* fmt33(int a0) {
  gBuf.reset();
  gBuf.write_const("/dev/fd/", 8);
  gBuf.format_d(a0);
  return gBuf.getvalue();
}


}  // declare namespace executor

namespace main_loop {  // declare

class ctx_Descriptors : public Obj {
 public:
  ctx_Descriptors(List<int>* fds);
  ~ctx_Descriptors();

  List<int>* fds;
  int saved0;
  int saved1;
  int saved2;

  DISALLOW_COPY_AND_ASSIGN(ctx_Descriptors)
};

constexpr uint16_t maskof_ctx_Descriptors() {
  return
    maskbit(offsetof(ctx_Descriptors, fds));
}

int Batch(cmd_eval::CommandEvaluator* cmd_ev, cmd_parse::CommandParser* c_parser, ui::ErrorFormatter* errfmt);
int Batch(cmd_eval::CommandEvaluator* cmd_ev, cmd_parse::CommandParser* c_parser, ui::ErrorFormatter* errfmt, int cmd_flags);
syntax_asdl::command_t* ParseWholeFile(cmd_parse::CommandParser* c_parser);


}  // declare namespace main_loop

namespace process {  // declare

extern int NO_FD;
extern int _SHELL_MIN_FD;
extern int STYLE_DEFAULT;
extern int STYLE_LONG;
extern int STYLE_PID_ONLY;
int SaveFd(int fd);
class _RedirFrame : public Obj {
 public:
  _RedirFrame(int saved_fd, int orig_fd, bool forget);

  bool forget;
  int orig_fd;
  int saved_fd;

  DISALLOW_COPY_AND_ASSIGN(_RedirFrame)
};

class _FdFrame : public Obj {
 public:
  _FdFrame();
  void Forget();

  List<process::Process*>* need_wait;
  List<process::_RedirFrame*>* saved;

  DISALLOW_COPY_AND_ASSIGN(_FdFrame)
};

constexpr uint16_t maskof__FdFrame() {
  return
    maskbit(offsetof(_FdFrame, need_wait))
  | maskbit(offsetof(_FdFrame, saved));
}

class FdState : public Obj {
 public:
  FdState(ui::ErrorFormatter* errfmt, process::JobState* job_state, state::Mem* mem, dev::Tracer* tracer, process::Waiter* waiter);
  mylib::LineReader* Open(Str* path);
  mylib::LineReader* _Open(Str* path, Str* c_mode, int fd_mode);
  void _WriteFdToMem(Str* fd_name, int fd);
  int _ReadFdFromMem(Str* fd_name);
  bool _PushSave(int fd);
  int _PushDup(int fd1, syntax_asdl::redir_loc_t* loc);
  bool _PushCloseFd(syntax_asdl::redir_loc_t* loc);
  void _PushClose(int fd);
  void _PushWait(process::Process* proc);
  void _ApplyRedirect(runtime_asdl::redirect* r);
  bool Push(List<runtime_asdl::redirect*>* redirects);
  bool PushStdinFromPipe(int r);
  void Pop();
  void MakePermanent();

  process::_FdFrame* cur_frame;
  ui::ErrorFormatter* errfmt;
  process::JobState* job_state;
  state::Mem* mem;
  List<process::_FdFrame*>* stack;
  dev::Tracer* tracer;
  process::Waiter* waiter;

  DISALLOW_COPY_AND_ASSIGN(FdState)
};

constexpr uint16_t maskof_FdState() {
  return
    maskbit(offsetof(FdState, cur_frame))
  | maskbit(offsetof(FdState, errfmt))
  | maskbit(offsetof(FdState, job_state))
  | maskbit(offsetof(FdState, mem))
  | maskbit(offsetof(FdState, stack))
  | maskbit(offsetof(FdState, tracer))
  | maskbit(offsetof(FdState, waiter));
}

class ChildStateChange : public Obj {
 public:
  ChildStateChange();
  virtual void Apply();

  DISALLOW_COPY_AND_ASSIGN(ChildStateChange)
};

class StdinFromPipe : public ChildStateChange {
 public:
  StdinFromPipe(int pipe_read_fd, int w);
  virtual void Apply();

  int r;
  int w;

  DISALLOW_COPY_AND_ASSIGN(StdinFromPipe)
};

class StdoutToPipe : public ChildStateChange {
 public:
  StdoutToPipe(int r, int pipe_write_fd);
  virtual void Apply();

  int r;
  int w;

  DISALLOW_COPY_AND_ASSIGN(StdoutToPipe)
};

class ExternalProgram : public Obj {
 public:
  ExternalProgram(Str* hijack_shebang, process::FdState* fd_state, ui::ErrorFormatter* errfmt, util::_DebugFile* debug_f);
  void Exec(Str* argv0_path, runtime_asdl::cmd_value__Argv* cmd_val, Dict<Str*, Str*>* environ);
  void _Exec(Str* argv0_path, List<Str*>* argv, int argv0_spid, Dict<Str*, Str*>* environ, bool should_retry);

  util::_DebugFile* debug_f;
  ui::ErrorFormatter* errfmt;
  process::FdState* fd_state;
  Str* hijack_shebang;

  DISALLOW_COPY_AND_ASSIGN(ExternalProgram)
};

constexpr uint16_t maskof_ExternalProgram() {
  return
    maskbit(offsetof(ExternalProgram, debug_f))
  | maskbit(offsetof(ExternalProgram, errfmt))
  | maskbit(offsetof(ExternalProgram, fd_state))
  | maskbit(offsetof(ExternalProgram, hijack_shebang));
}

class Thunk : public Obj {
 public:
  Thunk();
  virtual void Run();
  virtual Str* UserString();

  DISALLOW_COPY_AND_ASSIGN(Thunk)
};

class ExternalThunk : public Thunk {
 public:
  ExternalThunk(process::ExternalProgram* ext_prog, Str* argv0_path, runtime_asdl::cmd_value__Argv* cmd_val, Dict<Str*, Str*>* environ);
  virtual Str* UserString();
  virtual void Run();

  Str* argv0_path;
  runtime_asdl::cmd_value__Argv* cmd_val;
  Dict<Str*, Str*>* environ;
  process::ExternalProgram* ext_prog;

  DISALLOW_COPY_AND_ASSIGN(ExternalThunk)
};

constexpr uint16_t maskof_ExternalThunk() {
  return
    maskbit_v(offsetof(ExternalThunk, argv0_path))
  | maskbit_v(offsetof(ExternalThunk, cmd_val))
  | maskbit_v(offsetof(ExternalThunk, environ))
  | maskbit_v(offsetof(ExternalThunk, ext_prog));
}

class SubProgramThunk : public Thunk {
 public:
  SubProgramThunk(cmd_eval::CommandEvaluator* cmd_ev, syntax_asdl::command_t* node, bool inherit_errexit);
  virtual Str* UserString();
  virtual void Run();

  cmd_eval::CommandEvaluator* cmd_ev;
  bool inherit_errexit;
  syntax_asdl::command_t* node;

  DISALLOW_COPY_AND_ASSIGN(SubProgramThunk)
};

constexpr uint16_t maskof_SubProgramThunk() {
  return
    maskbit_v(offsetof(SubProgramThunk, cmd_ev))
  | maskbit_v(offsetof(SubProgramThunk, node));
}

class _HereDocWriterThunk : public Thunk {
 public:
  _HereDocWriterThunk(int w, Str* body_str);
  virtual Str* UserString();
  virtual void Run();

  Str* body_str;
  int w;

  DISALLOW_COPY_AND_ASSIGN(_HereDocWriterThunk)
};

constexpr uint16_t maskof__HereDocWriterThunk() {
  return
    maskbit_v(offsetof(_HereDocWriterThunk, body_str));
}

class Job : public Obj {
 public:
  Job();
  virtual void DisplayJob(int job_id, mylib::Writer* f, int style);
  runtime_asdl::job_state_t State();
  virtual runtime_asdl::wait_status_t* JobWait(process::Waiter* waiter);

  runtime_asdl::job_state_t state;

  DISALLOW_COPY_AND_ASSIGN(Job)
};

class Process : public Job {
 public:
  Process(process::Thunk* thunk, process::JobState* job_state, dev::Tracer* tracer);
  void Init_ParentPipeline(process::Pipeline* pi);
  virtual void DisplayJob(int job_id, mylib::Writer* f, int style);
  void AddStateChange(process::ChildStateChange* s);
  void AddPipeToClose(int r, int w);
  void MaybeClosePipe();
  int Start(runtime_asdl::trace_t* why);
  int Wait(process::Waiter* waiter);
  virtual runtime_asdl::wait_status_t* JobWait(process::Waiter* waiter);
  void WhenStopped();
  void WhenDone(int pid, int status);
  int RunWait(process::Waiter* waiter, runtime_asdl::trace_t* why);

  int close_r;
  int close_w;
  process::JobState* job_state;
  process::Pipeline* parent_pipeline;
  int pid;
  List<process::ChildStateChange*>* state_changes;
  int status;
  process::Thunk* thunk;
  dev::Tracer* tracer;

  DISALLOW_COPY_AND_ASSIGN(Process)
};

constexpr uint16_t maskof_Process() {
  return
    maskbit_v(offsetof(Process, job_state))
  | maskbit_v(offsetof(Process, parent_pipeline))
  | maskbit_v(offsetof(Process, state_changes))
  | maskbit_v(offsetof(Process, thunk))
  | maskbit_v(offsetof(Process, tracer));
}

class ctx_Pipe : public Obj {
 public:
  ctx_Pipe(process::FdState* fd_state, int fd);
  ~ctx_Pipe();

  process::FdState* fd_state;

  DISALLOW_COPY_AND_ASSIGN(ctx_Pipe)
};

constexpr uint16_t maskof_ctx_Pipe() {
  return
    maskbit(offsetof(ctx_Pipe, fd_state));
}

class Pipeline : public Job {
 public:
  Pipeline(bool sigpipe_status_ok);
  virtual void DisplayJob(int job_id, mylib::Writer* f, int style);
  void DebugPrint();
  void Add(process::Process* p);
  void AddLast(Tuple2<cmd_eval::CommandEvaluator*, syntax_asdl::command_t*>* thunk);
  void Start(process::Waiter* waiter);
  int LastPid();
  List<int>* Wait(process::Waiter* waiter);
  virtual runtime_asdl::wait_status_t* JobWait(process::Waiter* waiter);
  List<int>* Run(process::Waiter* waiter, process::FdState* fd_state);
  bool AllDone();
  void WhenDone(int pid, int status);

  Tuple2<int, int>* last_pipe;
  Tuple2<cmd_eval::CommandEvaluator*, syntax_asdl::command_t*>* last_thunk;
  List<int>* pids;
  List<int>* pipe_status;
  List<process::Process*>* procs;
  bool sigpipe_status_ok;
  int status;

  DISALLOW_COPY_AND_ASSIGN(Pipeline)
};

constexpr uint16_t maskof_Pipeline() {
  return
    maskbit_v(offsetof(Pipeline, last_pipe))
  | maskbit_v(offsetof(Pipeline, last_thunk))
  | maskbit_v(offsetof(Pipeline, pids))
  | maskbit_v(offsetof(Pipeline, pipe_status))
  | maskbit_v(offsetof(Pipeline, procs));
}

Str* _JobStateStr(runtime_asdl::job_state_t i);
class JobState : public Obj {
 public:
  JobState();
  void WhenStopped(int pid);
  int GetLastStopped();
  int WhenContinued(int pid, process::Waiter* waiter);
  void WhenDone(int pid);
  int AddJob(process::Job* job);
  void AddChildProcess(int pid, process::Process* proc);
  void AddPipeline(process::Pipeline* pi);
  process::Process* JobFromPid(int pid);
  void DisplayJobs(int style);
  void DebugPrint();
  void ListRecent();
  int NumRunning();

  Dict<int, process::Process*>* child_procs;
  List<process::Pipeline*>* debug_pipelines;
  int job_id;
  Dict<int, process::Job*>* jobs;
  int last_stopped_pid;

  DISALLOW_COPY_AND_ASSIGN(JobState)
};

constexpr uint16_t maskof_JobState() {
  return
    maskbit(offsetof(JobState, child_procs))
  | maskbit(offsetof(JobState, debug_pipelines))
  | maskbit(offsetof(JobState, jobs));
}

extern int W1_OK;
extern int W1_ECHILD;
class Waiter : public Obj {
 public:
  Waiter(process::JobState* job_state, optview::Exec* exec_opts, builtin_trap::TrapState* trap_state, dev::Tracer* tracer);
  int WaitForOne();

  optview::Exec* exec_opts;
  process::JobState* job_state;
  int last_status;
  dev::Tracer* tracer;
  builtin_trap::TrapState* trap_state;

  DISALLOW_COPY_AND_ASSIGN(Waiter)
};

constexpr uint16_t maskof_Waiter() {
  return
    maskbit(offsetof(Waiter, exec_opts))
  | maskbit(offsetof(Waiter, job_state))
  | maskbit(offsetof(Waiter, tracer))
  | maskbit(offsetof(Waiter, trap_state));
}


inline Str* fmt34(int a0, Str* a1) {
  gBuf.reset();
  gBuf.format_d(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt35(int a0, Str* a1) {
  gBuf.reset();
  gBuf.format_d(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt36(int a0, Str* a1) {
  gBuf.reset();
  gBuf.format_d(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt37(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Can't open ", 11);
  gBuf.format_r(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt38(int a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Error closing descriptor ", 25);
  gBuf.format_d(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt39(int a0, int a1, Str* a2) {
  gBuf.reset();
  gBuf.write_const("dup2(", 5);
  gBuf.format_d(a0);
  gBuf.write_const(", ", 2);
  gBuf.format_d(a1);
  gBuf.write_const(") error: ", 9);
  gBuf.format_s(a2);
  return gBuf.getvalue();
}

inline Str* fmt40(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Hijacked: ", 10);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt41(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Can't execute ", 14);
  gBuf.format_r(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt42(Str* a0) {
  gBuf.reset();
  gBuf.write_const("[process] ", 10);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt43(Str* a0) {
  gBuf.reset();
  gBuf.write_const("[subprog] ", 10);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt44(Str* a0) {
  gBuf.reset();
  gBuf.write_const("osh I/O error: ", 15);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt45(int a0) {
  gBuf.reset();
  gBuf.write_const("%", 1);
  gBuf.format_d(a0);
  return gBuf.getvalue();
}

inline Str* fmt46(int a0) {
  gBuf.reset();
  gBuf.format_d(a0);
  gBuf.write_const("\n", 1);
  return gBuf.getvalue();
}

inline Str* fmt47(Str* a0, int a1, Str* a2) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(" ", 1);
  gBuf.format_d(a1);
  gBuf.write_const(" ", 1);
  gBuf.format_s(a2);
  gBuf.write_const(" ", 1);
  return gBuf.getvalue();
}

inline Str* fmt48(int a0) {
  gBuf.reset();
  gBuf.format_d(a0);
  gBuf.write_const("\n", 1);
  return gBuf.getvalue();
}

inline Str* fmt49(int a0) {
  gBuf.reset();
  gBuf.write_const("%", 1);
  gBuf.format_d(a0);
  return gBuf.getvalue();
}

inline Str* fmt50(Str* a0, int a1, Str* a2) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(" ", 1);
  gBuf.format_d(a1);
  gBuf.write_const(" ", 1);
  gBuf.format_s(a2);
  gBuf.write_const(" ", 1);
  return gBuf.getvalue();
}

inline Str* fmt51(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Pipeline in state ", 18);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt52(int a0) {
  gBuf.reset();
  gBuf.write_const("osh: PID ", 9);
  gBuf.format_d(a0);
  gBuf.write_const(" stopped, but osh didn't start it", 33);
  return gBuf.getvalue();
}

inline Str* fmt53(int a0) {
  gBuf.reset();
  gBuf.write_const("[PID ", 5);
  gBuf.format_d(a0);
  gBuf.write_const("] Stopped", 9);
  return gBuf.getvalue();
}


}  // declare namespace process

namespace shell_native {  // declare

runtime_asdl::cmd_value__Argv* MakeBuiltinArgv(List<Str*>* argv1);
void AddPure(Dict<int, vm::_Builtin*>* b, state::Mem* mem, Dict<Str*, runtime_asdl::Proc*>* procs, Dict<Str*, bool>* modules, state::MutableOpts* mutable_opts, Dict<Str*, Str*>* aliases, state::SearchPath* search_path, ui::ErrorFormatter* errfmt);
void AddIO(Dict<int, vm::_Builtin*>* b, state::Mem* mem, state::DirStack* dir_stack, optview::Exec* exec_opts, split::SplitContext* splitter, parse_lib::ParseContext* parse_ctx, ui::ErrorFormatter* errfmt);
void AddProcess(Dict<int, vm::_Builtin*>* b, state::Mem* mem, vm::_Executor* shell_ex, process::ExternalProgram* ext_prog, process::FdState* fd_state, process::JobState* job_state, process::Waiter* waiter, dev::Tracer* tracer, state::SearchPath* search_path, ui::ErrorFormatter* errfmt);
void AddMeta(Dict<int, vm::_Builtin*>* builtins, vm::_Executor* shell_ex, state::MutableOpts* mutable_opts, state::Mem* mem, Dict<Str*, runtime_asdl::Proc*>* procs, Dict<Str*, Str*>* aliases, state::SearchPath* search_path, ui::ErrorFormatter* errfmt);
void AddBlock(Dict<int, vm::_Builtin*>* builtins, state::Mem* mem, state::MutableOpts* mutable_opts, state::DirStack* dir_stack, cmd_eval::CommandEvaluator* cmd_ev, vm::_Executor* shell_ex, state::Hay* hay_state, ui::ErrorFormatter* errfmt);
Dict<int, vm::_AssignBuiltin*>* InitAssignmentBuiltins(state::Mem* mem, Dict<Str*, runtime_asdl::Proc*>* procs, ui::ErrorFormatter* errfmt);
int Main(Str* lang, args::Reader* arg_r, Dict<Str*, Str*>* environ, bool login_shell, pyutil::_ResourceLoader* loader, void* line_input);

inline Str* fmt54(Str* a0) {
  gBuf.reset();
  gBuf.write_const("osh usage error: ", 17);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt55(Str* a0) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const("-usage", 6);
  return gBuf.getvalue();
}

inline Str* fmt56(int a0) {
  gBuf.reset();
  gBuf.format_d(a0);
  gBuf.write_const("-osh.log", 8);
  return gBuf.getvalue();
}

inline Str* fmt57(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Writing logs to ", 16);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt58(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("osh: Couldn't open ", 19);
  gBuf.format_r(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt59(int a0) {
  gBuf.reset();
  gBuf.write_const("/proc/", 6);
  gBuf.format_d(a0);
  gBuf.write_const("/status", 7);
  return gBuf.getvalue();
}

inline Str* fmt60(int a0) {
  gBuf.reset();
  gBuf.write_const("/proc/", 6);
  gBuf.format_d(a0);
  gBuf.write_const("/status", 7);
  return gBuf.getvalue();
}


}  // declare namespace shell_native

namespace state {  // declare

extern Str* _READLINE_DELIMS;
extern int LINE_ZERO;
extern int SetReadOnly;
extern int ClearReadOnly;
extern int SetExport;
extern int ClearExport;
extern int SetNameref;
extern int ClearNameref;
class SearchPath : public Obj {
 public:
  SearchPath(state::Mem* mem);
  Str* Lookup(Str* name);
  Str* Lookup(Str* name, bool exec_required);
  Str* CachedLookup(Str* name);
  void MaybeRemoveEntry(Str* name);
  void ClearCache();
  List<Str*>* CachedCommands();

  Dict<Str*, Str*>* cache;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(SearchPath)
};

constexpr uint16_t maskof_SearchPath() {
  return
    maskbit(offsetof(SearchPath, cache))
  | maskbit(offsetof(SearchPath, mem));
}

class ctx_Source : public Obj {
 public:
  ctx_Source(state::Mem* mem, Str* source_name, List<Str*>* argv);
  ~ctx_Source();

  List<Str*>* argv;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(ctx_Source)
};

constexpr uint16_t maskof_ctx_Source() {
  return
    maskbit(offsetof(ctx_Source, argv))
  | maskbit(offsetof(ctx_Source, mem));
}

class ctx_Option : public Obj {
 public:
  ctx_Option(state::MutableOpts* mutable_opts, List<int>* opt_nums, bool b);
  ~ctx_Option();

  state::MutableOpts* mutable_opts;
  List<int>* opt_nums;

  DISALLOW_COPY_AND_ASSIGN(ctx_Option)
};

constexpr uint16_t maskof_ctx_Option() {
  return
    maskbit(offsetof(ctx_Option, mutable_opts))
  | maskbit(offsetof(ctx_Option, opt_nums));
}

class ctx_AssignBuiltin : public Obj {
 public:
  ctx_AssignBuiltin(state::MutableOpts* mutable_opts);
  ~ctx_AssignBuiltin();

  state::MutableOpts* mutable_opts;
  bool strict;

  DISALLOW_COPY_AND_ASSIGN(ctx_AssignBuiltin)
};

constexpr uint16_t maskof_ctx_AssignBuiltin() {
  return
    maskbit(offsetof(ctx_AssignBuiltin, mutable_opts));
}

class ctx_OilExpr : public Obj {
 public:
  ctx_OilExpr(state::MutableOpts* mutable_opts);
  ~ctx_OilExpr();

  state::MutableOpts* mutable_opts;

  DISALLOW_COPY_AND_ASSIGN(ctx_OilExpr)
};

constexpr uint16_t maskof_ctx_OilExpr() {
  return
    maskbit(offsetof(ctx_OilExpr, mutable_opts));
}

class ctx_ErrExit : public Obj {
 public:
  ctx_ErrExit(state::MutableOpts* mutable_opts, bool b, int span_id);
  ~ctx_ErrExit();

  state::MutableOpts* mutable_opts;
  bool strict;

  DISALLOW_COPY_AND_ASSIGN(ctx_ErrExit)
};

constexpr uint16_t maskof_ctx_ErrExit() {
  return
    maskbit(offsetof(ctx_ErrExit, mutable_opts));
}

class ctx_HayNode : public Obj {
 public:
  ctx_HayNode(state::Hay* hay_state, Str* hay_name);
  ~ctx_HayNode();

  state::Hay* hay_state;

  DISALLOW_COPY_AND_ASSIGN(ctx_HayNode)
};

constexpr uint16_t maskof_ctx_HayNode() {
  return
    maskbit(offsetof(ctx_HayNode, hay_state));
}

class ctx_HayEval : public Obj {
 public:
  ctx_HayEval(state::Hay* hay_state, state::MutableOpts* mutable_opts, state::Mem* mem);
  ~ctx_HayEval();

  state::Hay* hay_state;
  state::Mem* mem;
  state::MutableOpts* mutable_opts;

  DISALLOW_COPY_AND_ASSIGN(ctx_HayEval)
};

constexpr uint16_t maskof_ctx_HayEval() {
  return
    maskbit(offsetof(ctx_HayEval, hay_state))
  | maskbit(offsetof(ctx_HayEval, mem))
  | maskbit(offsetof(ctx_HayEval, mutable_opts));
}

class Hay : public Obj {
 public:
  Hay();
  Dict<Str*, void*>* _MakeOutputNode();
  void PushEval();
  void PopEval();
  bool Resolve(Str* first_word);
  void DefinePath(List<Str*>* path);
  void Reset();
  void Push(Str* hay_name);
  void Pop();

  runtime_asdl::hay_node* cur_defs;
  List<runtime_asdl::hay_node*>* def_stack;
  Dict<Str*, void*>* output;
  List<Dict<Str*, void*>*>* result_stack;
  runtime_asdl::hay_node* root_defs;

  DISALLOW_COPY_AND_ASSIGN(Hay)
};

constexpr uint16_t maskof_Hay() {
  return
    maskbit(offsetof(Hay, cur_defs))
  | maskbit(offsetof(Hay, def_stack))
  | maskbit(offsetof(Hay, output))
  | maskbit(offsetof(Hay, result_stack))
  | maskbit(offsetof(Hay, root_defs));
}

class OptHook : public Obj {
 public:
  OptHook();
  bool OnChange(List<bool>* opt0_array, Str* opt_name, bool b);

  DISALLOW_COPY_AND_ASSIGN(OptHook)
};

List<bool>* InitOpts();
Tuple3<optview::Parse*, optview::Exec*, state::MutableOpts*> MakeOpts(state::Mem* mem, state::OptHook* opt_hook);
void _SetGroup(List<bool>* opt0_array, List<int>* opt_nums, bool b);
optview::Parse* MakeOilOpts();
int _AnyOptionNum(Str* opt_name);
int _SetOptionNum(Str* opt_name);
class MutableOpts : public Obj {
 public:
  MutableOpts(state::Mem* mem, List<bool>* opt0_array, List<List<bool>*>* opt_stacks, state::OptHook* opt_hook);
  void Init();
  void _InitOptionsFromEnv(Str* shellopts);
  void Push(int opt_num, bool b);
  bool Pop(int opt_num);
  void PushDynamicScope(bool b);
  void PopDynamicScope();
  bool Get(int opt_num);
  void _Set(int opt_num, bool b);
  void set_interactive();
  void set_redefine_proc();
  void set_redefine_module();
  void set_emacs();
  void set_xtrace(bool b);
  void _SetArrayByNum(int opt_num, bool b);
  void SetDeferredErrExit(bool b);
  void DisableErrExit();
  int ErrExitDisabledSpanId();
  void _SetOldOption(Str* opt_name, bool b);
  void SetOldOption(Str* opt_name, bool b);
  void SetAnyOption(Str* opt_name, bool b);
  void ShowOptions(List<Str*>* opt_names);
  void ShowShoptOptions(List<Str*>* opt_names);

  List<int>* errexit_disabled_spid;
  state::Mem* mem;
  List<bool>* opt0_array;
  state::OptHook* opt_hook;
  List<List<bool>*>* opt_stacks;

  DISALLOW_COPY_AND_ASSIGN(MutableOpts)
};

constexpr uint16_t maskof_MutableOpts() {
  return
    maskbit(offsetof(MutableOpts, errexit_disabled_spid))
  | maskbit(offsetof(MutableOpts, mem))
  | maskbit(offsetof(MutableOpts, opt0_array))
  | maskbit(offsetof(MutableOpts, opt_hook))
  | maskbit(offsetof(MutableOpts, opt_stacks));
}

class _ArgFrame : public Obj {
 public:
  _ArgFrame(List<Str*>* argv);
  runtime_asdl::value_t* GetArgNum(int arg_num);
  List<Str*>* GetArgv();
  int GetNumArgs();
  void SetArgv(List<Str*>* argv);

  List<Str*>* argv;
  int num_shifted;

  DISALLOW_COPY_AND_ASSIGN(_ArgFrame)
};

constexpr uint16_t maskof__ArgFrame() {
  return
    maskbit(offsetof(_ArgFrame, argv));
}

class DirStack : public Obj {
 public:
  DirStack();
  void Reset();
  void Push(Str* entry);
  Str* Pop();
  List<Str*>* Iter();

  List<Str*>* stack;

  DISALLOW_COPY_AND_ASSIGN(DirStack)
};

constexpr uint16_t maskof_DirStack() {
  return
    maskbit(offsetof(DirStack, stack));
}

Str* _GetWorkingDir();
class DebugFrame : public Obj {
 public:
  DebugFrame(Str* bash_source, Str* func_name, Str* source_name, int call_spid, int argv_i, int var_i);

  int argv_i;
  Str* bash_source;
  int call_spid;
  Str* func_name;
  Str* source_name;
  int var_i;

  DISALLOW_COPY_AND_ASSIGN(DebugFrame)
};

constexpr uint16_t maskof_DebugFrame() {
  return
    maskbit(offsetof(DebugFrame, bash_source))
  | maskbit(offsetof(DebugFrame, func_name))
  | maskbit(offsetof(DebugFrame, source_name));
}

void _InitDefaults(state::Mem* mem);
void _InitVarsFromEnv(state::Mem* mem, Dict<Str*, Str*>* environ);
void InitMem(state::Mem* mem, Dict<Str*, Str*>* environ, Str* version_str);
void InitInteractive(state::Mem* mem);
class ctx_Call : public Obj {
 public:
  ctx_Call(state::Mem* mem, state::MutableOpts* mutable_opts, runtime_asdl::Proc* proc, List<Str*>* argv);
  ~ctx_Call();

  state::Mem* mem;
  state::MutableOpts* mutable_opts;

  DISALLOW_COPY_AND_ASSIGN(ctx_Call)
};

constexpr uint16_t maskof_ctx_Call() {
  return
    maskbit(offsetof(ctx_Call, mem))
  | maskbit(offsetof(ctx_Call, mutable_opts));
}

class ctx_Temp : public Obj {
 public:
  ctx_Temp(state::Mem* mem);
  ~ctx_Temp();

  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(ctx_Temp)
};

constexpr uint16_t maskof_ctx_Temp() {
  return
    maskbit(offsetof(ctx_Temp, mem));
}

class ctx_Shvar : public Obj {
 public:
  ctx_Shvar(state::Mem* mem, List<Tuple2<Str*, Str*>*>* pairs);
  ~ctx_Shvar();
  void _Push(List<Tuple2<Str*, Str*>*>* pairs);
  void _Pop();

  state::Mem* mem;
  List<Tuple2<runtime_asdl::lvalue_t*, runtime_asdl::value_t*>*>* restore;

  DISALLOW_COPY_AND_ASSIGN(ctx_Shvar)
};

constexpr uint16_t maskof_ctx_Shvar() {
  return
    maskbit(offsetof(ctx_Shvar, mem))
  | maskbit(offsetof(ctx_Shvar, restore));
}

class ctx_Registers : public Obj {
 public:
  ctx_Registers(state::Mem* mem);
  ~ctx_Registers();

  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(ctx_Registers)
};

constexpr uint16_t maskof_ctx_Registers() {
  return
    maskbit(offsetof(ctx_Registers, mem));
}

class ctx_ThisDir : public Obj {
 public:
  ctx_ThisDir(state::Mem* mem, Str* filename);
  ~ctx_ThisDir();

  bool do_pop;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(ctx_ThisDir)
};

constexpr uint16_t maskof_ctx_ThisDir() {
  return
    maskbit(offsetof(ctx_ThisDir, mem));
}

class Mem : public Obj {
 public:
  Mem(Str* dollar0, List<Str*>* argv, alloc::Arena* arena, List<state::DebugFrame*>* debug_stack);
  void SetPwd(Str* pwd);
  bool InGlobalNamespace();
  Tuple3<void*, void*, void*> Dump();
  void SetCurrentSpanId(int span_id);
  int CurrentSpanId();
  int LastStatus();
  int TryStatus();
  List<int>* PipeStatus();
  void SetLastStatus(int x);
  void SetTryStatus(int x);
  void SetPipeStatus(List<int>* x);
  void SetProcessSubStatus(List<int>* x);
  void PushCall(Str* func_name, int def_spid, List<Str*>* argv);
  void PopCall();
  void PushSource(Str* source_name, List<Str*>* argv);
  void PopSource(List<Str*>* argv);
  void PushTemp();
  void PopTemp();
  Dict<Str*, runtime_asdl::cell*>* TopNamespace();
  void _PushDebugStack(Str* bash_source, Str* func_name, Str* source_name);
  void _PopDebugStack();
  int Shift(int n);
  runtime_asdl::value__Str* GetArg0();
  runtime_asdl::value_t* GetArgNum(int arg_num);
  List<Str*>* GetArgv();
  void SetArgv(List<Str*>* argv);
  runtime_asdl::value_t* GetSpecialVar(int op_id);
  Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*> _ResolveNameOnly(Str* name, runtime_asdl::scope_t which_scopes);
  Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*> _ResolveNameOrRef(Str* name, runtime_asdl::scope_t which_scopes, bool is_setref);
  Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*> _ResolveNameOrRef(Str* name, runtime_asdl::scope_t which_scopes, bool is_setref, List<Str*>* ref_trail);
  bool IsAssocArray(Str* name);
  void SetValue(runtime_asdl::lvalue_t* lval, runtime_asdl::value_t* val, runtime_asdl::scope_t which_scopes);
  void SetValue(runtime_asdl::lvalue_t* lval, runtime_asdl::value_t* val, runtime_asdl::scope_t which_scopes, int flags);
  void _BindNewArrayWithEntry(Dict<Str*, runtime_asdl::cell*>* name_map, runtime_asdl::lvalue__Indexed* lval, runtime_asdl::value__Str* val, int flags);
  void InternalSetGlobal(Str* name, runtime_asdl::value_t* new_val);
  runtime_asdl::value_t* GetValue(Str* name);
  runtime_asdl::value_t* GetValue(Str* name, runtime_asdl::scope_t which_scopes);
  runtime_asdl::cell* GetCell(Str* name);
  runtime_asdl::cell* GetCell(Str* name, runtime_asdl::scope_t which_scopes);
  bool Unset(runtime_asdl::lvalue_t* lval, runtime_asdl::scope_t which_scopes);
  runtime_asdl::scope_t ScopesForReading();
  runtime_asdl::scope_t ScopesForWriting();
  bool ClearFlag(Str* name, int flag);
  Dict<Str*, Str*>* GetExported();
  List<Str*>* VarNames();
  List<Str*>* VarNamesStartingWith(Str* prefix);
  Dict<Str*, Str*>* GetAllVars();
  Dict<Str*, runtime_asdl::cell*>* GetAllCells(runtime_asdl::scope_t which_scopes);
  bool IsGlobalScope();
  void ClearMatches();
  void SetMatches(List<Str*>* matches);
  Str* GetMatch(int i);

  alloc::Arena* arena;
  List<state::_ArgFrame*>* argv_stack;
  int current_spid;
  List<state::DebugFrame*>* debug_stack;
  Str* dollar0;
  optview::Exec* exec_opts;
  int last_bg_pid;
  List<int>* last_status;
  runtime_asdl::value__Str* line_num;
  List<List<int>*>* pipe_status;
  List<List<int>*>* process_sub_status;
  Str* pwd;
  List<List<Str*>*>* regex_matches;
  int root_pid;
  List<Str*>* this_dir;
  List<int>* try_status;
  sh_expr_eval::UnsafeArith* unsafe_arith;
  List<Dict<Str*, runtime_asdl::cell*>*>* var_stack;

  DISALLOW_COPY_AND_ASSIGN(Mem)
};

constexpr uint16_t maskof_Mem() {
  return
    maskbit(offsetof(Mem, arena))
  | maskbit(offsetof(Mem, argv_stack))
  | maskbit(offsetof(Mem, debug_stack))
  | maskbit(offsetof(Mem, dollar0))
  | maskbit(offsetof(Mem, exec_opts))
  | maskbit(offsetof(Mem, last_status))
  | maskbit(offsetof(Mem, line_num))
  | maskbit(offsetof(Mem, pipe_status))
  | maskbit(offsetof(Mem, process_sub_status))
  | maskbit(offsetof(Mem, pwd))
  | maskbit(offsetof(Mem, regex_matches))
  | maskbit(offsetof(Mem, this_dir))
  | maskbit(offsetof(Mem, try_status))
  | maskbit(offsetof(Mem, unsafe_arith))
  | maskbit(offsetof(Mem, var_stack));
}

void OshLanguageSetValue(state::Mem* mem, runtime_asdl::lvalue_t* lval, runtime_asdl::value_t* val);
void OshLanguageSetValue(state::Mem* mem, runtime_asdl::lvalue_t* lval, runtime_asdl::value_t* val, int flags);
void BuiltinSetValue(state::Mem* mem, runtime_asdl::lvalue_t* lval, runtime_asdl::value_t* val);
void BuiltinSetString(state::Mem* mem, Str* name, Str* s);
void BuiltinSetArray(state::Mem* mem, Str* name, List<Str*>* a);
void SetGlobalString(state::Mem* mem, Str* name, Str* s);
void SetGlobalArray(state::Mem* mem, Str* name, List<Str*>* a);
void ExportGlobalString(state::Mem* mem, Str* name, Str* s);
Str* GetString(state::Mem* mem, Str* name);
Str* MaybeString(state::Mem* mem, Str* name);
int GetInteger(state::Mem* mem, Str* name);

inline Str* fmt61(Str* a0) {
  gBuf.reset();
  gBuf.write_const("got invalid option ", 19);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt62(Str* a0) {
  gBuf.reset();
  gBuf.write_const("got invalid option ", 19);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt63(Str* a0) {
  gBuf.reset();
  gBuf.write_const("invalid option ", 15);
  gBuf.format_r(a0);
  gBuf.write_const(" (try shopt)", 12);
  return gBuf.getvalue();
}

inline Str* fmt64(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(":", 1);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt65(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("set ", 4);
  gBuf.format_s(a0);
  gBuf.write_const("o ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt66(Str* a0) {
  gBuf.reset();
  gBuf.write_const("got invalid option ", 19);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt67(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("shopt -", 7);
  gBuf.format_s(a0);
  gBuf.write_const(" ", 1);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt68(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Can't determine working directory: ", 35);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt69(Str* a0) {
  gBuf.reset();
  gBuf.write_const("nameref ", 8);
  gBuf.format_r(a0);
  gBuf.write_const(" is undefined", 13);
  return gBuf.getvalue();
}

inline Str* fmt70(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("nameref ", 8);
  gBuf.format_r(a0);
  gBuf.write_const(" contains invalid variable name ", 32);
  gBuf.format_r(a1);
  return gBuf.getvalue();
}

inline Str* fmt71(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Circular nameref ", 17);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt72(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Can't assign to readonly value ", 31);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt73() {
  gBuf.reset();
  gBuf.write_const("Can't assign to readonly array", 30);
  return gBuf.getvalue();
}

inline Str* fmt74() {
  gBuf.reset();
  gBuf.write_const("Can't assign to items in a string", 33);
  return gBuf.getvalue();
}

inline Str* fmt75(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Value of type ", 14);
  gBuf.format_s(a0);
  gBuf.write_const(" can't be indexed", 17);
  return gBuf.getvalue();
}

inline Str* fmt76() {
  gBuf.reset();
  gBuf.write_const("Can't assign to readonly associative array", 42);
  return gBuf.getvalue();
}

inline Str* fmt77(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Can't unset readonly variable ", 30);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt78(Str* a0) {
  gBuf.reset();
  gBuf.format_r(a0);
  gBuf.write_const(" isn't an array", 15);
  return gBuf.getvalue();
}

inline Str* fmt79(Str* a0) {
  gBuf.reset();
  gBuf.write_const("$", 1);
  gBuf.format_s(a0);
  gBuf.write_const(" isn't defined", 14);
  return gBuf.getvalue();
}

inline Str* fmt80(Str* a0) {
  gBuf.reset();
  gBuf.write_const("$", 1);
  gBuf.format_s(a0);
  gBuf.write_const(" should be a string", 19);
  return gBuf.getvalue();
}

inline Str* fmt81(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("$", 1);
  gBuf.format_s(a0);
  gBuf.write_const(" should be a string, got ", 25);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt82(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("$", 1);
  gBuf.format_s(a0);
  gBuf.write_const(" doesn't look like an integer, got ", 35);
  gBuf.format_r(a1);
  return gBuf.getvalue();
}


}  // declare namespace state

namespace ui {  // declare

Str* ValType(runtime_asdl::value_t* val);
Str* CommandType(syntax_asdl::command_t* cmd);
Str* PrettyId(int id_);
Str* PrettyToken(syntax_asdl::Token* tok, alloc::Arena* arena);
Str* PrettyDir(Str* dir_name, Str* home_dir);
void _PrintCodeExcerpt(Str* line, int col, int length, mylib::Writer* f);
Str* GetLineSourceString(alloc::Arena* arena, int line_id);
Str* GetLineSourceString(alloc::Arena* arena, int line_id, bool quote_filename);
void _PrintWithSpanId(Str* prefix, Str* msg, int span_id, alloc::Arena* arena, bool show_code);
class ctx_Location : public Obj {
 public:
  ctx_Location(ui::ErrorFormatter* errfmt, int spid);
  ~ctx_Location();

  ui::ErrorFormatter* errfmt;

  DISALLOW_COPY_AND_ASSIGN(ctx_Location)
};

constexpr uint16_t maskof_ctx_Location() {
  return
    maskbit(offsetof(ctx_Location, errfmt));
}

class ErrorFormatter : public Obj {
 public:
  ErrorFormatter(alloc::Arena* arena);
  void OneLineErrExit();
  int CurrentLocation();
  void PrefixPrint(Str* msg, Str* prefix, int span_id);
  void Print_(Str* msg);
  void Print_(Str* msg, int span_id);
  void PrintMessage(Str* msg);
  void PrintMessage(Str* msg, int span_id);
  void StderrLine(Str* msg);
  void PrettyPrintError(error::_ErrorWithLocation* err);
  void PrettyPrintError(error::_ErrorWithLocation* err, Str* prefix);
  void PrintErrExit(error::_ErrorWithLocation* err, int pid);

  alloc::Arena* arena;
  int last_spid;
  bool one_line_errexit;
  List<int>* spid_stack;

  DISALLOW_COPY_AND_ASSIGN(ErrorFormatter)
};

constexpr uint16_t maskof_ErrorFormatter() {
  return
    maskbit(offsetof(ErrorFormatter, arena))
  | maskbit(offsetof(ErrorFormatter, spid_stack));
}

void PrintAst(syntax_asdl::command_t* node, arg_types::main* flag);

inline Str* fmt83(Str* a0) {
  gBuf.reset();
  gBuf.write_const("[ stdin", 7);
  gBuf.format_s(a0);
  gBuf.write_const(" ]", 2);
  return gBuf.getvalue();
}

inline Str* fmt84(Str* a0) {
  gBuf.reset();
  gBuf.write_const("[ ", 2);
  gBuf.format_s(a0);
  gBuf.write_const(" word at ? ]", 12);
  return gBuf.getvalue();
}

inline Str* fmt85(Str* a0, int a1, Str* a2) {
  gBuf.reset();
  gBuf.write_const("[ ", 2);
  gBuf.format_s(a0);
  gBuf.write_const(" word at line ", 14);
  gBuf.format_d(a1);
  gBuf.write_const(" of ", 4);
  gBuf.format_s(a2);
  gBuf.write_const(" ]", 2);
  return gBuf.getvalue();
}

inline Str* fmt86(int a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("line ", 5);
  gBuf.format_d(a0);
  gBuf.write_const(" of ", 4);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt87(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("[ var ", 6);
  gBuf.format_s(a0);
  gBuf.write_const(" at ", 4);
  gBuf.format_s(a1);
  gBuf.write_const(" ]", 2);
  return gBuf.getvalue();
}

inline Str* fmt88(Str* a0) {
  gBuf.reset();
  gBuf.write_const("[ expansion of alias ", 21);
  gBuf.format_r(a0);
  gBuf.write_const(" ]", 2);
  return gBuf.getvalue();
}

inline Str* fmt89(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("[ ", 2);
  gBuf.format_s(a0);
  gBuf.write_const(" in ", 4);
  gBuf.format_s(a1);
  gBuf.write_const(" ]", 2);
  return gBuf.getvalue();
}

inline Str* fmt90(Str* a0) {
  gBuf.reset();
  gBuf.write_const("-- ", 3);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt91(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("[??? no location ???] ", 22);
  gBuf.format_s(a0);
  gBuf.format_s(a1);
  gBuf.write_const("\n", 1);
  return gBuf.getvalue();
}

inline Str* fmt92(Str* a0, int a1, Str* a2, Str* a3) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(":", 1);
  gBuf.format_d(a1);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a2);
  gBuf.format_s(a3);
  gBuf.write_const("\n", 1);
  return gBuf.getvalue();
}

inline Str* fmt93(int a0) {
  gBuf.reset();
  gBuf.write_const("errexit PID ", 12);
  gBuf.format_d(a0);
  gBuf.write_const(": ", 2);
  return gBuf.getvalue();
}


}  // declare namespace ui

namespace util {  // declare

class UserExit : public Obj {
 public:
  UserExit(int status);

  int status;

  DISALLOW_COPY_AND_ASSIGN(UserExit)
};

class _DebugFile : public Obj {
 public:
  _DebugFile();
  virtual void log(Str* msg, void* args);
  virtual void write(Str* s);
  virtual bool isatty();

  DISALLOW_COPY_AND_ASSIGN(_DebugFile)
};

class NullDebugFile : public _DebugFile {
 public:
  NullDebugFile();

  DISALLOW_COPY_AND_ASSIGN(NullDebugFile)
};

class DebugFile : public _DebugFile {
 public:
  DebugFile(mylib::Writer* f);
  virtual void log(Str* msg, void* args);
  virtual void write(Str* s);
  virtual bool isatty();

  mylib::Writer* f;

  DISALLOW_COPY_AND_ASSIGN(DebugFile)
};

constexpr uint16_t maskof_DebugFile() {
  return
    maskbit_v(offsetof(DebugFile, f));
}



}  // declare namespace util

namespace args {  // declare

extern int String;
extern int Int;
extern int Float;
extern int Bool;
class _Attributes : public Obj {
 public:
  _Attributes(Dict<Str*, runtime_asdl::value_t*>* defaults);
  void SetTrue(Str* name);
  void Set(Str* name, runtime_asdl::value_t* val);

  List<Str*>* actions;
  Dict<Str*, runtime_asdl::value_t*>* attrs;
  List<Tuple2<Str*, bool>*>* opt_changes;
  bool saw_double_dash;
  List<Tuple2<Str*, bool>*>* shopt_changes;
  bool show_options;

  DISALLOW_COPY_AND_ASSIGN(_Attributes)
};

constexpr uint16_t maskof__Attributes() {
  return
    maskbit(offsetof(_Attributes, actions))
  | maskbit(offsetof(_Attributes, attrs))
  | maskbit(offsetof(_Attributes, opt_changes))
  | maskbit(offsetof(_Attributes, shopt_changes));
}

class Reader : public Obj {
 public:
  Reader(List<Str*>* argv, List<int>* spids);
  void Next();
  Str* Peek();
  Tuple2<Str*, int> Peek2();
  Str* ReadRequired(Str* error_msg);
  Tuple2<Str*, int> ReadRequired2(Str* error_msg);
  List<Str*>* Rest();
  Tuple2<List<Str*>*, List<int>*> Rest2();
  bool AtEnd();
  int _FirstSpanId();
  int SpanId();

  List<Str*>* argv;
  int i;
  int n;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(Reader)
};

constexpr uint16_t maskof_Reader() {
  return
    maskbit(offsetof(Reader, argv))
  | maskbit(offsetof(Reader, spids));
}

class _Action : public Obj {
 public:
  _Action();
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  DISALLOW_COPY_AND_ASSIGN(_Action)
};

class _ArgAction : public _Action {
 public:
  _ArgAction(Str* name, bool quit_parsing_flags, List<Str*>* valid);
  virtual runtime_asdl::value_t* _Value(Str* arg, int span_id);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  Str* name;
  bool quit_parsing_flags;
  List<Str*>* valid;

  DISALLOW_COPY_AND_ASSIGN(_ArgAction)
};

constexpr uint16_t maskof__ArgAction() {
  return
    maskbit_v(offsetof(_ArgAction, name))
  | maskbit_v(offsetof(_ArgAction, valid));
}

class SetToInt : public _ArgAction {
 public:
  SetToInt(Str* name);
  virtual runtime_asdl::value_t* _Value(Str* arg, int span_id);

  DISALLOW_COPY_AND_ASSIGN(SetToInt)
};

class SetToFloat : public _ArgAction {
 public:
  SetToFloat(Str* name);
  virtual runtime_asdl::value_t* _Value(Str* arg, int span_id);

  DISALLOW_COPY_AND_ASSIGN(SetToFloat)
};

class SetToString : public _ArgAction {
 public:
  SetToString(Str* name, bool quit_parsing_flags, List<Str*>* valid);
  virtual runtime_asdl::value_t* _Value(Str* arg, int span_id);

  DISALLOW_COPY_AND_ASSIGN(SetToString)
};

class SetAttachedBool : public _Action {
 public:
  SetAttachedBool(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  Str* name;

  DISALLOW_COPY_AND_ASSIGN(SetAttachedBool)
};

constexpr uint16_t maskof_SetAttachedBool() {
  return
    maskbit_v(offsetof(SetAttachedBool, name));
}

class SetToTrue : public _Action {
 public:
  SetToTrue(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  Str* name;

  DISALLOW_COPY_AND_ASSIGN(SetToTrue)
};

constexpr uint16_t maskof_SetToTrue() {
  return
    maskbit_v(offsetof(SetToTrue, name));
}

class SetOption : public _Action {
 public:
  SetOption(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  Str* name;

  DISALLOW_COPY_AND_ASSIGN(SetOption)
};

constexpr uint16_t maskof_SetOption() {
  return
    maskbit_v(offsetof(SetOption, name));
}

class SetNamedOption : public _Action {
 public:
  SetNamedOption(bool shopt);
  void ArgName(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  List<Str*>* names;
  bool shopt;

  DISALLOW_COPY_AND_ASSIGN(SetNamedOption)
};

constexpr uint16_t maskof_SetNamedOption() {
  return
    maskbit_v(offsetof(SetNamedOption, names));
}

class SetAction : public _Action {
 public:
  SetAction(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  Str* name;

  DISALLOW_COPY_AND_ASSIGN(SetAction)
};

constexpr uint16_t maskof_SetAction() {
  return
    maskbit_v(offsetof(SetAction, name));
}

class SetNamedAction : public _Action {
 public:
  SetNamedAction();
  void ArgName(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  List<Str*>* names;

  DISALLOW_COPY_AND_ASSIGN(SetNamedAction)
};

constexpr uint16_t maskof_SetNamedAction() {
  return
    maskbit_v(offsetof(SetNamedAction, names));
}

args::_Attributes* Parse(flag_spec::_FlagSpec* spec, args::Reader* arg_r);
args::_Attributes* ParseLikeEcho(flag_spec::_FlagSpec* spec, args::Reader* arg_r);
args::_Attributes* ParseMore(flag_spec::_FlagSpecAndMore* spec, args::Reader* arg_r);

inline Str* fmt94(Str* a0) {
  gBuf.reset();
  gBuf.write_const("got invalid argument to boolean flag: ", 38);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt95(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid option ", 15);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt96(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid action name ", 20);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}


}  // declare namespace args

namespace lexer {  // declare

extern syntax_asdl::Token* _EOL_TOK;
class LineLexer : public Obj {
 public:
  LineLexer(Str* line, alloc::Arena* arena);
  void Reset(Str* line, int line_id, int line_pos);
  bool MaybeUnreadOne();
  int GetSpanIdForEof();
  int LookAheadOne(types_asdl::lex_mode_t lex_mode);
  int LookPastSpace(types_asdl::lex_mode_t lex_mode);
  bool LookAheadFuncParens(int unread);
  Str* ByteLookAhead();
  int ByteLookBack();
  syntax_asdl::Token* Read(types_asdl::lex_mode_t lex_mode);

  alloc::Arena* arena;
  bool arena_skip;
  int last_span_id;
  Str* line;
  int line_id;
  int line_pos;

  DISALLOW_COPY_AND_ASSIGN(LineLexer)
};

constexpr uint16_t maskof_LineLexer() {
  return
    maskbit(offsetof(LineLexer, arena))
  | maskbit(offsetof(LineLexer, line));
}

class Lexer : public Obj {
 public:
  Lexer(lexer::LineLexer* line_lexer, reader::_Reader* line_reader);
  void ResetInputObjects();
  bool MaybeUnreadOne();
  int LookAheadOne(types_asdl::lex_mode_t lex_mode);
  int LookPastSpace(types_asdl::lex_mode_t lex_mode);
  bool LookAheadFuncParens(int unread);
  Str* ByteLookAhead();
  int ByteLookBack();
  void EmitCompDummy();
  void PushHint(int old_id, int new_id);
  syntax_asdl::Token* _Read(types_asdl::lex_mode_t lex_mode);
  syntax_asdl::Token* Read(types_asdl::lex_mode_t lex_mode);

  bool emit_comp_dummy;
  int line_id;
  lexer::LineLexer* line_lexer;
  reader::_Reader* line_reader;
  List<Tuple2<int, int>*>* translation_stack;

  DISALLOW_COPY_AND_ASSIGN(Lexer)
};

constexpr uint16_t maskof_Lexer() {
  return
    maskbit(offsetof(Lexer, line_lexer))
  | maskbit(offsetof(Lexer, line_reader))
  | maskbit(offsetof(Lexer, translation_stack));
}



}  // declare namespace lexer

namespace location {  // declare

int SpanForCommand(syntax_asdl::command_t* node);
int SpanForArithExpr(syntax_asdl::arith_expr_t* node);


}  // declare namespace location

namespace parse_lib {  // declare

class _BaseTrail : public Obj {
 public:
  _BaseTrail();
  virtual void Clear();
  virtual void SetLatestWords(List<syntax_asdl::compound_word*>* words, List<syntax_asdl::redir*>* redirects);
  virtual void AppendToken(syntax_asdl::Token* token);
  void BeginAliasExpansion();
  void EndAliasExpansion();

  bool _expanding_alias;
  List<syntax_asdl::compound_word*>* alias_words;
  List<syntax_asdl::redir*>* redirects;
  List<syntax_asdl::Token*>* tokens;
  List<syntax_asdl::compound_word*>* words;

  DISALLOW_COPY_AND_ASSIGN(_BaseTrail)
};

constexpr uint16_t maskof__BaseTrail() {
  return
    maskbit_v(offsetof(_BaseTrail, alias_words))
  | maskbit_v(offsetof(_BaseTrail, redirects))
  | maskbit_v(offsetof(_BaseTrail, tokens))
  | maskbit_v(offsetof(_BaseTrail, words));
}

class ctx_Alias : public Obj {
 public:
  ctx_Alias(parse_lib::_BaseTrail* trail);
  ~ctx_Alias();

  parse_lib::_BaseTrail* trail;

  DISALLOW_COPY_AND_ASSIGN(ctx_Alias)
};

constexpr uint16_t maskof_ctx_Alias() {
  return
    maskbit(offsetof(ctx_Alias, trail));
}

class Trail : public _BaseTrail {
 public:
  Trail();
  virtual void Clear();
  virtual void SetLatestWords(List<syntax_asdl::compound_word*>* words, List<syntax_asdl::redir*>* redirects);
  virtual void AppendToken(syntax_asdl::Token* token);

  DISALLOW_COPY_AND_ASSIGN(Trail)
};

class ParseContext : public Obj {
 public:
  ParseContext(alloc::Arena* arena, optview::Parse* parse_opts, Dict<Str*, Str*>* aliases, grammar::Grammar* oil_grammar);
  void Init_Trail(parse_lib::_BaseTrail* trail);
  void Init_OnePassParse(bool b);
  lexer::Lexer* MakeLexer(reader::_Reader* line_reader);
  cmd_parse::CommandParser* MakeOshParser(reader::_Reader* line_reader);
  cmd_parse::CommandParser* MakeOshParser(reader::_Reader* line_reader, bool emit_comp_dummy);
  cmd_parse::CommandParser* MakeConfigParser(reader::_Reader* line_reader);
  word_parse::WordParser* MakeWordParserForHereDoc(reader::_Reader* line_reader);
  word_parse::WordParser* MakeWordParser(lexer::Lexer* lx, reader::_Reader* line_reader);
  tdop::TdopParser* MakeArithParser(Str* code_str);
  cmd_parse::CommandParser* MakeParserForCommandSub(reader::_Reader* line_reader, lexer::Lexer* lexer, int eof_id);
  word_parse::WordParser* MakeWordParserForPlugin(Str* code_str);
  Tuple2<pnode::PNode*, syntax_asdl::Token*> _ParseOil(lexer::Lexer* lexer, int start_symbol);
  Tuple2<pnode::PNode*, syntax_asdl::Token*> _ParseTea(lexer::Lexer* lexer, int start_symbol);
  Tuple2<syntax_asdl::command__VarDecl*, syntax_asdl::Token*> ParseVarDecl(syntax_asdl::Token* kw_token, lexer::Lexer* lexer);
  Tuple2<syntax_asdl::command__PlaceMutation*, syntax_asdl::Token*> ParsePlaceMutation(syntax_asdl::Token* kw_token, lexer::Lexer* lexer);
  syntax_asdl::Token* ParseOilArgList(lexer::Lexer* lexer, syntax_asdl::ArgList* out);
  Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> ParseOilExpr(lexer::Lexer* lexer, int start_symbol);
  Tuple3<List<syntax_asdl::name_type*>*, syntax_asdl::expr_t*, syntax_asdl::Token*> ParseOilForExpr(lexer::Lexer* lexer, int start_symbol);
  syntax_asdl::Token* ParseProc(lexer::Lexer* lexer, syntax_asdl::command__Proc* out);
  syntax_asdl::Token* ParseFunc(lexer::Lexer* lexer, syntax_asdl::command__Func* out);
  syntax_asdl::Token* ParseDataType(lexer::Lexer* lexer, syntax_asdl::command__Data* out);
  syntax_asdl::Token* ParseEnum(lexer::Lexer* lexer, syntax_asdl::command__Enum* out);
  syntax_asdl::Token* ParseClass(lexer::Lexer* lexer, syntax_asdl::command__Class* out);
  syntax_asdl::Token* ParseImport(lexer::Lexer* lexer, syntax_asdl::command__Import* out);

  Dict<Str*, Str*>* aliases;
  alloc::Arena* arena;
  grammar::Grammar* oil_grammar;
  bool one_pass_parse;
  optview::Parse* parse_opts;
  expr_to_ast::Transformer* tr;
  parse_lib::_BaseTrail* trail;

  DISALLOW_COPY_AND_ASSIGN(ParseContext)
};

constexpr uint16_t maskof_ParseContext() {
  return
    maskbit(offsetof(ParseContext, aliases))
  | maskbit(offsetof(ParseContext, arena))
  | maskbit(offsetof(ParseContext, oil_grammar))
  | maskbit(offsetof(ParseContext, parse_opts))
  | maskbit(offsetof(ParseContext, tr))
  | maskbit(offsetof(ParseContext, trail));
}



}  // declare namespace parse_lib

namespace reader {  // declare

class _Reader : public Obj {
 public:
  _Reader(alloc::Arena* arena);
  void SetLineOffset(int n);
  virtual Str* _GetLine();
  virtual Tuple3<int, Str*, int> GetLine();
  void Reset();
  virtual bool LastLineHint();

  alloc::Arena* arena;
  int line_num;

  DISALLOW_COPY_AND_ASSIGN(_Reader)
};

constexpr uint16_t maskof__Reader() {
  return
    maskbit_v(offsetof(_Reader, arena));
}

class DisallowedLineReader : public _Reader {
 public:
  DisallowedLineReader(alloc::Arena* arena, syntax_asdl::Token* blame_token);
  virtual Str* _GetLine();

  syntax_asdl::Token* blame_token;

  DISALLOW_COPY_AND_ASSIGN(DisallowedLineReader)
};

constexpr uint16_t maskof_DisallowedLineReader() {
  return
    maskbit_v(offsetof(DisallowedLineReader, blame_token));
}

class FileLineReader : public _Reader {
 public:
  FileLineReader(mylib::LineReader* f, alloc::Arena* arena);
  virtual Str* _GetLine();
  virtual bool LastLineHint();

  mylib::LineReader* f;
  bool last_line_hint;

  DISALLOW_COPY_AND_ASSIGN(FileLineReader)
};

constexpr uint16_t maskof_FileLineReader() {
  return
    maskbit_v(offsetof(FileLineReader, f));
}

reader::FileLineReader* StringLineReader(Str* s, alloc::Arena* arena);
class VirtualLineReader : public _Reader {
 public:
  VirtualLineReader(List<Tuple3<int, Str*, int>*>* lines, alloc::Arena* arena);
  virtual Tuple3<int, Str*, int> GetLine();

  List<Tuple3<int, Str*, int>*>* lines;
  int num_lines;
  int pos;

  DISALLOW_COPY_AND_ASSIGN(VirtualLineReader)
};

constexpr uint16_t maskof_VirtualLineReader() {
  return
    maskbit_v(offsetof(VirtualLineReader, lines));
}


inline Str* fmt97() {
  gBuf.reset();
  gBuf.write_const("Here docs aren't allowed in expressions", 39);
  return gBuf.getvalue();
}


}  // declare namespace reader

namespace typed_args {  // declare

void DoesNotAccept(syntax_asdl::ArgList* arg_list);
syntax_asdl::expr_t* RequiredExpr(syntax_asdl::ArgList* arg_list);
syntax_asdl::command_t* GetOneBlock(syntax_asdl::ArgList* arg_list);

inline Str* fmt98() {
  gBuf.reset();
  gBuf.write_const("got unexpected typed args", 25);
  return gBuf.getvalue();
}

inline Str* fmt99() {
  gBuf.reset();
  gBuf.write_const("Expected an expression", 22);
  return gBuf.getvalue();
}

inline Str* fmt100() {
  gBuf.reset();
  gBuf.write_const("Too many typed args (expected one expression)", 45);
  return gBuf.getvalue();
}

inline Str* fmt101() {
  gBuf.reset();
  gBuf.write_const("Expected block argument", 23);
  return gBuf.getvalue();
}

inline Str* fmt102() {
  gBuf.reset();
  gBuf.write_const("Too many typed args (expected one block)", 40);
  return gBuf.getvalue();
}


}  // declare namespace typed_args

namespace expr_parse {  // declare

int _Classify(grammar::Grammar* gr, syntax_asdl::Token* tok, bool tea_keywords);
extern Dict<int, int>* _OTHER_BALANCE;
syntax_asdl::Token* _PushOilTokens(parse_lib::ParseContext* parse_ctx, grammar::Grammar* gr, parse::Parser* p, lexer::Lexer* lex, bool tea_keywords);
class ExprParser : public Obj {
 public:
  ExprParser(parse_lib::ParseContext* parse_ctx, grammar::Grammar* gr, bool tea_keywords);
  Tuple2<pnode::PNode*, syntax_asdl::Token*> Parse(lexer::Lexer* lexer, int start_symbol);

  grammar::Grammar* gr;
  parse_lib::ParseContext* parse_ctx;
  parse::Parser* push_parser;
  bool tea_keywords;

  DISALLOW_COPY_AND_ASSIGN(ExprParser)
};

constexpr uint16_t maskof_ExprParser() {
  return
    maskbit(offsetof(ExprParser, gr))
  | maskbit(offsetof(ExprParser, parse_ctx))
  | maskbit(offsetof(ExprParser, push_parser));
}


inline Str* fmt103() {
  gBuf.reset();
  gBuf.write_const("Use === to be exact, or ~== to convert types", 44);
  return gBuf.getvalue();
}

inline Str* fmt104(Str* a0) {
  gBuf.reset();
  gBuf.write_const(" (", 2);
  gBuf.format_s(a0);
  gBuf.write_const(")", 1);
  return gBuf.getvalue();
}

inline Str* fmt105(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Unexpected token in expression mode", 35);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt106(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Syntax error in expression (near ", 33);
  gBuf.format_s(a0);
  gBuf.write_const(")", 1);
  return gBuf.getvalue();
}


}  // declare namespace expr_parse

namespace expr_to_ast {  // declare

extern Dict<Str*, Str*>* PERL_CLASSES;
extern List<Str*>* POSIX_CLASSES;
extern Str* RANGE_POINT_TOO_LONG;
extern int NT_OFFSET;
bool ISNONTERMINAL(int x);
class Transformer : public Obj {
 public:
  Transformer(grammar::Grammar* gr);
  syntax_asdl::expr_t* _AssocBinary(List<pnode::PNode*>* children);
  syntax_asdl::expr_t* _Trailer(syntax_asdl::expr_t* base, pnode::PNode* p_trailer);
  Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*> _DictPair(pnode::PNode* p_node);
  syntax_asdl::expr__Dict* _Dict(pnode::PNode* p_node);
  syntax_asdl::expr_t* _Tuple(List<pnode::PNode*>* children);
  syntax_asdl::expr_t* _TestlistComp(pnode::PNode* p_node, int id0);
  syntax_asdl::expr_t* _Atom(List<pnode::PNode*>* children);
  List<syntax_asdl::name_type*>* _NameTypeList(pnode::PNode* p_node);
  syntax_asdl::comprehension* _CompFor(pnode::PNode* p_node);
  syntax_asdl::expr_t* _CompareChain(List<pnode::PNode*>* children);
  syntax_asdl::expr_t* _Subscript(List<pnode::PNode*>* children);
  syntax_asdl::expr_t* Expr(pnode::PNode* pnode);
  syntax_asdl::expr_t* _ArrayItem(pnode::PNode* p_node);
  List<syntax_asdl::place_expr_t*>* _PlaceList(pnode::PNode* p_node);
  syntax_asdl::command__VarDecl* MakeVarDecl(pnode::PNode* p_node);
  syntax_asdl::command__PlaceMutation* MakePlaceMutation(pnode::PNode* p_node);
  Tuple2<List<syntax_asdl::name_type*>*, syntax_asdl::expr_t*> OilForExpr(pnode::PNode* pnode);
  void _Argument(pnode::PNode* p_node, bool do_named, syntax_asdl::ArgList* arglist);
  void _Arglist(List<pnode::PNode*>* children, syntax_asdl::ArgList* arglist);
  void ToArgList(pnode::PNode* pnode, syntax_asdl::ArgList* arglist);
  syntax_asdl::type_expr_t* _TypeExpr(pnode::PNode* pnode);
  List<syntax_asdl::type_expr_t*>* _TypeExprList(pnode::PNode* pnode);
  Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::expr_t*> _ProcParam(pnode::PNode* pnode);
  syntax_asdl::proc_sig_t* _ProcParams(pnode::PNode* p_node);
  syntax_asdl::param* _FuncParam(pnode::PNode* pnode);
  Tuple2<List<syntax_asdl::param*>*, syntax_asdl::Token*> _FuncParams(pnode::PNode* p_node);
  syntax_asdl::proc_sig_t* Proc(pnode::PNode* pnode);
  syntax_asdl::command_t* func_item(pnode::PNode* node);
  List<syntax_asdl::command_t*>* func_items(pnode::PNode* pnode);
  syntax_asdl::command__CommandList* _Suite(pnode::PNode* pnode);
  void TeaFunc(pnode::PNode* pnode, syntax_asdl::command__Func* out);
  void NamedFunc(pnode::PNode* pnode, syntax_asdl::command__Func* out);
  List<syntax_asdl::param*>* _DataParams(pnode::PNode* p_node);
  void Data(pnode::PNode* pnode, syntax_asdl::command__Data* out);
  syntax_asdl::variant_type_t* _VariantType(pnode::PNode* pnode);
  syntax_asdl::variant* _Variant(pnode::PNode* pnode);
  void Enum(pnode::PNode* pnode, syntax_asdl::command__Enum* out);
  void Class(pnode::PNode* pnode, syntax_asdl::command__Class* out);
  void Import(pnode::PNode* pnode, syntax_asdl::command__Import* out);
  syntax_asdl::Token* _RangeChar(pnode::PNode* p_node);
  syntax_asdl::class_literal_term_t* _NonRangeChars(pnode::PNode* p_node);
  syntax_asdl::class_literal_term_t* _ClassLiteralTerm(pnode::PNode* p_node);
  List<syntax_asdl::class_literal_term_t*>* _ClassLiteral(pnode::PNode* p_node);
  syntax_asdl::re_t* _NameInRegex(syntax_asdl::Token* negated_tok, syntax_asdl::Token* tok);
  syntax_asdl::class_literal_term_t* _NameInClass(syntax_asdl::Token* negated_tok, syntax_asdl::Token* tok);
  syntax_asdl::re_t* _ReAtom(pnode::PNode* p_atom);
  syntax_asdl::re_repeat_t* _RepeatOp(pnode::PNode* p_repeat);
  syntax_asdl::re_t* _Regex(pnode::PNode* p_node);

  Dict<int, Str*>* number2symbol;

  DISALLOW_COPY_AND_ASSIGN(Transformer)
};

constexpr uint16_t maskof_Transformer() {
  return
    maskbit(offsetof(Transformer, number2symbol));
}


inline Str* fmt107() {
  gBuf.reset();
  gBuf.write_const("Write singleton tuples with tup(), not a trailing comma", 55);
  return gBuf.getvalue();
}

inline Str* fmt108() {
  gBuf.reset();
  gBuf.write_const("obj.field isn't valid, but obj.method() is", 42);
  return gBuf.getvalue();
}

inline Str* fmt109(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("In expressions, remove $ and use `", 34);
  gBuf.format_s(a0);
  gBuf.write_const("`, or sometimes \"$", 18);
  gBuf.format_s(a1);
  gBuf.write_const("\"", 1);
  return gBuf.getvalue();
}

inline Str* fmt110() {
  gBuf.reset();
  gBuf.write_const("Can't assign to this expression", 31);
  return gBuf.getvalue();
}

inline Str* fmt111() {
  gBuf.reset();
  gBuf.write_const("proc param types should be Expr or Block", 40);
  return gBuf.getvalue();
}

inline Str* fmt112() {
  gBuf.reset();
  gBuf.write_const("Can't negate this symbol", 24);
  return gBuf.getvalue();
}

inline Str* fmt113(Str* a0) {
  gBuf.reset();
  gBuf.format_r(a0);
  gBuf.write_const(" isn't a character class", 24);
  return gBuf.getvalue();
}

inline Str* fmt114() {
  gBuf.reset();
  gBuf.write_const("Can't negate this symbol", 24);
  return gBuf.getvalue();
}

inline Str* fmt115(Str* a0) {
  gBuf.reset();
  gBuf.format_r(a0);
  gBuf.write_const(" isn't a character class", 24);
  return gBuf.getvalue();
}

inline Str* fmt116(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Unexpected token ", 17);
  gBuf.format_r(a0);
  gBuf.write_const(" in regex", 9);
  return gBuf.getvalue();
}

inline Str* fmt117() {
  gBuf.reset();
  gBuf.write_const("Backtracking with !! isn't implemented (requires Python/PCRE)", 61);
  return gBuf.getvalue();
}


}  // declare namespace expr_to_ast

namespace funcs {  // declare

class ParseHay : public Obj {
 public:
  ParseHay(process::FdState* fd_state, parse_lib::ParseContext* parse_ctx, ui::ErrorFormatter* errfmt);
  runtime_asdl::value_t* Call(Str* path);

  ui::ErrorFormatter* errfmt;
  process::FdState* fd_state;
  parse_lib::ParseContext* parse_ctx;

  DISALLOW_COPY_AND_ASSIGN(ParseHay)
};

constexpr uint16_t maskof_ParseHay() {
  return
    maskbit(offsetof(ParseHay, errfmt))
  | maskbit(offsetof(ParseHay, fd_state))
  | maskbit(offsetof(ParseHay, parse_ctx));
}

class EvalHay : public Obj {
 public:
  EvalHay(state::Hay* hay_state, state::MutableOpts* mutable_opts, state::Mem* mem, cmd_eval::CommandEvaluator* cmd_ev);

  cmd_eval::CommandEvaluator* cmd_ev;
  state::Hay* hay_state;
  state::Mem* mem;
  state::MutableOpts* mutable_opts;

  DISALLOW_COPY_AND_ASSIGN(EvalHay)
};

constexpr uint16_t maskof_EvalHay() {
  return
    maskbit(offsetof(EvalHay, cmd_ev))
  | maskbit(offsetof(EvalHay, hay_state))
  | maskbit(offsetof(EvalHay, mem))
  | maskbit(offsetof(EvalHay, mutable_opts));
}

class BlockAsStr : public Obj {
 public:
  BlockAsStr(alloc::Arena* arena);
  runtime_asdl::value_t* Call(runtime_asdl::value_t* block);

  alloc::Arena* arena;

  DISALLOW_COPY_AND_ASSIGN(BlockAsStr)
};

constexpr uint16_t maskof_BlockAsStr() {
  return
    maskbit(offsetof(BlockAsStr, arena));
}

class HayFunc : public Obj {
 public:
  HayFunc(state::Hay* hay_state);

  state::Hay* hay_state;

  DISALLOW_COPY_AND_ASSIGN(HayFunc)
};

constexpr uint16_t maskof_HayFunc() {
  return
    maskbit(offsetof(HayFunc, hay_state));
}


inline Str* fmt118(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Couldn't open ", 14);
  gBuf.format_r(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}


}  // declare namespace funcs

namespace regex_translate {  // declare

extern Dict<Str*, Str*>* PERL_CLASS;
extern int CH_RBRACKET;
extern int CH_BACKSLASH;
extern int CH_CARET;
extern int CH_HYPHEN;
extern int FLAG_RBRACKET;
extern int FLAG_BACKSLASH;
extern int FLAG_CARET;
extern int FLAG_HYPHEN;
void _CharCodeToEre(syntax_asdl::CharCode* term, List<Str*>* parts, List<int>* special_char_flags);
void _CharClassTermToEre(syntax_asdl::char_class_term_t* term, List<Str*>* parts, List<int>* special_char_flags);
void AsPosixEre(syntax_asdl::re_t* node, List<Str*>* parts);

inline Str* fmt119(int a0) {
  gBuf.reset();
  gBuf.write_const("ERE can't express char code ", 28);
  gBuf.format_d(a0);
  return gBuf.getvalue();
}

inline Str* fmt120(int a0) {
  gBuf.reset();
  gBuf.write_const("Can't use char ", 15);
  gBuf.format_d(a0);
  gBuf.write_const(" as start of range in ERE syntax", 32);
  return gBuf.getvalue();
}

inline Str* fmt121(int a0) {
  gBuf.reset();
  gBuf.write_const("Can't use char ", 15);
  gBuf.format_d(a0);
  gBuf.write_const(" as end of range in ERE syntax", 30);
  return gBuf.getvalue();
}

inline Str* fmt122() {
  gBuf.reset();
  gBuf.write_const("Perl classes can't be negated in ERE", 36);
  return gBuf.getvalue();
}

inline Str* fmt123(Str* a0) {
  gBuf.reset();
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt124() {
  gBuf.reset();
  gBuf.write_const("POSIX classes can't be negated in ERE", 37);
  return gBuf.getvalue();
}

inline Str* fmt125(Str* a0) {
  gBuf.reset();
  gBuf.write_const("[:", 2);
  gBuf.format_s(a0);
  gBuf.write_const(":]", 2);
  return gBuf.getvalue();
}

inline Str* fmt126() {
  gBuf.reset();
  gBuf.write_const("POSIX EREs don't have groups without capture, so this node needs () around it.", 78);
  return gBuf.getvalue();
}

inline Str* fmt127(Str* a0) {
  gBuf.reset();
  gBuf.write_const("{", 1);
  gBuf.format_s(a0);
  gBuf.write_const("}", 1);
  return gBuf.getvalue();
}

inline Str* fmt128(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("{", 1);
  gBuf.format_s(a0);
  gBuf.write_const(",", 1);
  gBuf.format_s(a1);
  gBuf.write_const("}", 1);
  return gBuf.getvalue();
}

inline Str* fmt129(Str* a0) {
  gBuf.reset();
  gBuf.write_const("[^", 2);
  gBuf.format_s(a0);
  gBuf.write_const("]", 1);
  return gBuf.getvalue();
}

inline Str* fmt130(Str* a0) {
  gBuf.reset();
  gBuf.write_const("[", 1);
  gBuf.format_s(a0);
  gBuf.write_const("]", 1);
  return gBuf.getvalue();
}

inline Str* fmt131(Str* a0) {
  gBuf.reset();
  gBuf.write_const("[^[:", 4);
  gBuf.format_s(a0);
  gBuf.write_const(":]]", 3);
  return gBuf.getvalue();
}

inline Str* fmt132(Str* a0) {
  gBuf.reset();
  gBuf.write_const("[[:", 3);
  gBuf.format_s(a0);
  gBuf.write_const(":]]", 3);
  return gBuf.getvalue();
}


}  // declare namespace regex_translate

namespace arith_parse {  // declare

syntax_asdl::arith_expr_t* NullIncDec(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp);
syntax_asdl::arith_expr_t* NullUnaryPlus(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp);
syntax_asdl::arith_expr_t* NullUnaryMinus(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp);
syntax_asdl::arith_expr_t* LeftIncDec(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp);
syntax_asdl::arith_expr_t* LeftIndex(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int unused_bp);
syntax_asdl::arith_expr_t* LeftTernary(tdop::TdopParser* p, syntax_asdl::word_t* t, syntax_asdl::arith_expr_t* left, int bp);

inline Str* fmt133() {
  gBuf.reset();
  gBuf.write_const("The [ operator doesn't apply to this expression", 47);
  return gBuf.getvalue();
}


}  // declare namespace arith_parse

namespace bool_parse {  // declare

class BoolParser : public Obj {
 public:
  BoolParser(word_parse::WordEmitter* w_parser);
  void _NextOne(types_asdl::lex_mode_t lex_mode);
  void _Next();
  void _Next(types_asdl::lex_mode_t lex_mode);
  syntax_asdl::word_t* _LookAhead();
  syntax_asdl::bool_expr_t* Parse();
  bool _TestAtEnd();
  syntax_asdl::bool_expr_t* ParseForBuiltin();
  syntax_asdl::bool_expr_t* ParseExpr();
  syntax_asdl::bool_expr_t* ParseTerm();
  syntax_asdl::bool_expr_t* ParseNegatedFactor();
  syntax_asdl::bool_expr_t* ParseFactor();

  int bool_id;
  id_kind_asdl::Kind_t bool_kind;
  syntax_asdl::word_t* cur_word;
  word_parse::WordEmitter* w_parser;
  List<syntax_asdl::word_t*>* words;

  DISALLOW_COPY_AND_ASSIGN(BoolParser)
};

constexpr uint16_t maskof_BoolParser() {
  return
    maskbit(offsetof(BoolParser, cur_word))
  | maskbit(offsetof(BoolParser, w_parser))
  | maskbit(offsetof(BoolParser, words));
}


inline Str* fmt134() {
  gBuf.reset();
  gBuf.write_const("Expected ]]", 11);
  return gBuf.getvalue();
}

inline Str* fmt135(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Unexpected trailing word ", 25);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt136() {
  gBuf.reset();
  gBuf.write_const("Invalid argument to unary operator", 34);
  return gBuf.getvalue();
}

inline Str* fmt137(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Expected ), got ", 16);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt138(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Unexpected token in boolean expression (", 40);
  gBuf.format_s(a0);
  gBuf.write_const(")", 1);
  return gBuf.getvalue();
}


}  // declare namespace bool_parse

namespace braces {  // declare

extern int NO_STEP;
class _NotARange : public Obj {
 public:
  _NotARange(Str* s);

  DISALLOW_COPY_AND_ASSIGN(_NotARange)
};

class _RangeParser : public Obj {
 public:
  _RangeParser(match::SimpleLexer* lexer, int span_id);
  void _Next();
  Str* _Eat(int token_type);
  int _ParseStep();
  syntax_asdl::word_part__BracedRange* _ParseRange(int range_kind);
  syntax_asdl::word_part__BracedRange* Parse();

  match::SimpleLexer* lexer;
  int span_id;
  int token_type;
  Str* token_val;

  DISALLOW_COPY_AND_ASSIGN(_RangeParser)
};

constexpr uint16_t maskof__RangeParser() {
  return
    maskbit(offsetof(_RangeParser, lexer))
  | maskbit(offsetof(_RangeParser, token_val));
}

syntax_asdl::word_part_t* _RangePartDetect(syntax_asdl::Token* tok);
class _StackFrame : public Obj {
 public:
  _StackFrame(List<syntax_asdl::word_part_t*>* cur_parts);

  syntax_asdl::word_part__BracedTuple* alt_part;
  List<syntax_asdl::word_part_t*>* cur_parts;
  bool saw_comma;

  DISALLOW_COPY_AND_ASSIGN(_StackFrame)
};

constexpr uint16_t maskof__StackFrame() {
  return
    maskbit(offsetof(_StackFrame, alt_part))
  | maskbit(offsetof(_StackFrame, cur_parts));
}

syntax_asdl::word__BracedTree* _BraceDetect(syntax_asdl::compound_word* w);
List<syntax_asdl::word_t*>* BraceDetectAll(List<syntax_asdl::compound_word*>* words);
int _LeadingZeros(Str* s);
Str* _IntToString(int i, int width);
List<Str*>* _RangeStrings(syntax_asdl::word_part__BracedRange* part);
List<List<syntax_asdl::word_part_t*>*>* _ExpandPart(List<syntax_asdl::word_part_t*>* parts, int first_alt_index, List<List<syntax_asdl::word_part_t*>*>* suffixes);
List<List<syntax_asdl::word_part_t*>*>* _BraceExpand(List<syntax_asdl::word_part_t*>* parts);
List<syntax_asdl::compound_word*>* BraceExpandWords(List<syntax_asdl::word_t*>* words);

inline Str* fmt139(int a0, int a1) {
  gBuf.reset();
  gBuf.write_const("Expected ", 9);
  gBuf.format_d(a0);
  gBuf.write_const(", got ", 6);
  gBuf.format_d(a1);
  return gBuf.getvalue();
}

inline Str* fmt140() {
  gBuf.reset();
  gBuf.write_const("Step can't be 0", 15);
  return gBuf.getvalue();
}

inline Str* fmt141(int a0) {
  gBuf.reset();
  gBuf.write_const("Invalid step ", 13);
  gBuf.format_d(a0);
  gBuf.write_const(" for ascending integer range", 28);
  return gBuf.getvalue();
}

inline Str* fmt142(int a0) {
  gBuf.reset();
  gBuf.write_const("Invalid step ", 13);
  gBuf.format_d(a0);
  gBuf.write_const(" for descending integer range", 29);
  return gBuf.getvalue();
}

inline Str* fmt143(int a0) {
  gBuf.reset();
  gBuf.write_const("Invalid step ", 13);
  gBuf.format_d(a0);
  gBuf.write_const(" for ascending character range", 30);
  return gBuf.getvalue();
}

inline Str* fmt144(int a0) {
  gBuf.reset();
  gBuf.write_const("Invalid step ", 13);
  gBuf.format_d(a0);
  gBuf.write_const(" for descending character range", 31);
  return gBuf.getvalue();
}

inline Str* fmt145() {
  gBuf.reset();
  gBuf.write_const("Mismatched cases in character range", 35);
  return gBuf.getvalue();
}


}  // declare namespace braces

namespace builtin_assign {  // declare

extern int _OTHER;
extern int _READONLY;
extern int _EXPORT;
int _PrintVariables(state::Mem* mem, runtime_asdl::cmd_value__Assign* cmd_val, args::_Attributes* attrs, bool print_flags);
int _PrintVariables(state::Mem* mem, runtime_asdl::cmd_value__Assign* cmd_val, args::_Attributes* attrs, bool print_flags, int builtin);
void _ExportReadonly(state::Mem* mem, runtime_asdl::assign_arg* pair, int flags);
class Export : public vm::_AssignBuiltin {
 public:
  Export(state::Mem* mem, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Assign* cmd_val);

  ui::ErrorFormatter* errfmt;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(Export)
};

constexpr uint16_t maskof_Export() {
  return
    maskbit_v(offsetof(Export, errfmt))
  | maskbit_v(offsetof(Export, mem));
}

runtime_asdl::value_t* _ReconcileTypes(runtime_asdl::value_t* rval, bool flag_a, bool flag_A, int span_id);
class Readonly : public vm::_AssignBuiltin {
 public:
  Readonly(state::Mem* mem, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Assign* cmd_val);

  ui::ErrorFormatter* errfmt;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(Readonly)
};

constexpr uint16_t maskof_Readonly() {
  return
    maskbit_v(offsetof(Readonly, errfmt))
  | maskbit_v(offsetof(Readonly, mem));
}

class NewVar : public vm::_AssignBuiltin {
 public:
  NewVar(state::Mem* mem, Dict<Str*, runtime_asdl::Proc*>* procs, ui::ErrorFormatter* errfmt);
  int _PrintFuncs(List<Str*>* names);
  virtual int Run(runtime_asdl::cmd_value__Assign* cmd_val);

  ui::ErrorFormatter* errfmt;
  state::Mem* mem;
  Dict<Str*, runtime_asdl::Proc*>* procs;

  DISALLOW_COPY_AND_ASSIGN(NewVar)
};

constexpr uint16_t maskof_NewVar() {
  return
    maskbit_v(offsetof(NewVar, errfmt))
  | maskbit_v(offsetof(NewVar, mem))
  | maskbit_v(offsetof(NewVar, procs));
}

class Unset : public vm::_Builtin {
 public:
  Unset(state::Mem* mem, Dict<Str*, runtime_asdl::Proc*>* procs, sh_expr_eval::UnsafeArith* unsafe_arith, ui::ErrorFormatter* errfmt);
  bool _UnsetVar(Str* arg, int spid, bool proc_fallback);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  state::Mem* mem;
  Dict<Str*, runtime_asdl::Proc*>* procs;
  sh_expr_eval::UnsafeArith* unsafe_arith;

  DISALLOW_COPY_AND_ASSIGN(Unset)
};

constexpr uint16_t maskof_Unset() {
  return
    maskbit_v(offsetof(Unset, errfmt))
  | maskbit_v(offsetof(Unset, mem))
  | maskbit_v(offsetof(Unset, procs))
  | maskbit_v(offsetof(Unset, unsafe_arith));
}

class Shift : public vm::_Builtin {
 public:
  Shift(state::Mem* mem);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(Shift)
};

constexpr uint16_t maskof_Shift() {
  return
    maskbit_v(offsetof(Shift, mem));
}


inline Str* fmt146(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const("=", 1);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt147() {
  gBuf.reset();
  gBuf.write_const("doesn't accept RHS with -n", 26);
  return gBuf.getvalue();
}

inline Str* fmt148() {
  gBuf.reset();
  gBuf.write_const("Got -a but RHS isn't an array", 29);
  return gBuf.getvalue();
}

inline Str* fmt149() {
  gBuf.reset();
  gBuf.write_const("Got -A but RHS isn't an associative array", 41);
  return gBuf.getvalue();
}

inline Str* fmt150(Str* a0) {
  gBuf.reset();
  gBuf.write_const("declare -f ", 11);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt151(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid shift argument ", 23);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}


}  // declare namespace builtin_assign

namespace builtin_meta {  // declare

class Eval : public vm::_Builtin {
 public:
  Eval(parse_lib::ParseContext* parse_ctx, optview::Exec* exec_opts, cmd_eval::CommandEvaluator* cmd_ev, dev::Tracer* tracer, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  alloc::Arena* arena;
  cmd_eval::CommandEvaluator* cmd_ev;
  ui::ErrorFormatter* errfmt;
  optview::Exec* exec_opts;
  parse_lib::ParseContext* parse_ctx;
  dev::Tracer* tracer;

  DISALLOW_COPY_AND_ASSIGN(Eval)
};

constexpr uint16_t maskof_Eval() {
  return
    maskbit_v(offsetof(Eval, arena))
  | maskbit_v(offsetof(Eval, cmd_ev))
  | maskbit_v(offsetof(Eval, errfmt))
  | maskbit_v(offsetof(Eval, exec_opts))
  | maskbit_v(offsetof(Eval, parse_ctx))
  | maskbit_v(offsetof(Eval, tracer));
}

class Source : public vm::_Builtin {
 public:
  Source(parse_lib::ParseContext* parse_ctx, state::SearchPath* search_path, cmd_eval::CommandEvaluator* cmd_ev, process::FdState* fd_state, dev::Tracer* tracer, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  alloc::Arena* arena;
  cmd_eval::CommandEvaluator* cmd_ev;
  ui::ErrorFormatter* errfmt;
  process::FdState* fd_state;
  state::Mem* mem;
  parse_lib::ParseContext* parse_ctx;
  state::SearchPath* search_path;
  dev::Tracer* tracer;

  DISALLOW_COPY_AND_ASSIGN(Source)
};

constexpr uint16_t maskof_Source() {
  return
    maskbit_v(offsetof(Source, arena))
  | maskbit_v(offsetof(Source, cmd_ev))
  | maskbit_v(offsetof(Source, errfmt))
  | maskbit_v(offsetof(Source, fd_state))
  | maskbit_v(offsetof(Source, mem))
  | maskbit_v(offsetof(Source, parse_ctx))
  | maskbit_v(offsetof(Source, search_path))
  | maskbit_v(offsetof(Source, tracer));
}

class Command : public vm::_Builtin {
 public:
  Command(vm::_Executor* shell_ex, Dict<Str*, runtime_asdl::Proc*>* funcs, Dict<Str*, Str*>* aliases, state::SearchPath* search_path);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  Dict<Str*, Str*>* aliases;
  Dict<Str*, runtime_asdl::Proc*>* funcs;
  state::SearchPath* search_path;
  vm::_Executor* shell_ex;

  DISALLOW_COPY_AND_ASSIGN(Command)
};

constexpr uint16_t maskof_Command() {
  return
    maskbit_v(offsetof(Command, aliases))
  | maskbit_v(offsetof(Command, funcs))
  | maskbit_v(offsetof(Command, search_path))
  | maskbit_v(offsetof(Command, shell_ex));
}

class Builtin : public vm::_Builtin {
 public:
  Builtin(vm::_Executor* shell_ex, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  vm::_Executor* shell_ex;

  DISALLOW_COPY_AND_ASSIGN(Builtin)
};

constexpr uint16_t maskof_Builtin() {
  return
    maskbit_v(offsetof(Builtin, errfmt))
  | maskbit_v(offsetof(Builtin, shell_ex));
}

class RunProc : public vm::_Builtin {
 public:
  RunProc(vm::_Executor* shell_ex, Dict<Str*, runtime_asdl::Proc*>* procs, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  Dict<Str*, runtime_asdl::Proc*>* procs;
  vm::_Executor* shell_ex;

  DISALLOW_COPY_AND_ASSIGN(RunProc)
};

constexpr uint16_t maskof_RunProc() {
  return
    maskbit_v(offsetof(RunProc, errfmt))
  | maskbit_v(offsetof(RunProc, procs))
  | maskbit_v(offsetof(RunProc, shell_ex));
}

class Try : public vm::_Builtin {
 public:
  Try(state::MutableOpts* mutable_opts, state::Mem* mem, cmd_eval::CommandEvaluator* cmd_ev, vm::_Executor* shell_ex, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  cmd_eval::CommandEvaluator* cmd_ev;
  ui::ErrorFormatter* errfmt;
  state::Mem* mem;
  state::MutableOpts* mutable_opts;
  vm::_Executor* shell_ex;

  DISALLOW_COPY_AND_ASSIGN(Try)
};

constexpr uint16_t maskof_Try() {
  return
    maskbit_v(offsetof(Try, cmd_ev))
  | maskbit_v(offsetof(Try, errfmt))
  | maskbit_v(offsetof(Try, mem))
  | maskbit_v(offsetof(Try, mutable_opts))
  | maskbit_v(offsetof(Try, shell_ex));
}

class BoolStatus : public vm::_Builtin {
 public:
  BoolStatus(vm::_Executor* shell_ex, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  vm::_Executor* shell_ex;

  DISALLOW_COPY_AND_ASSIGN(BoolStatus)
};

constexpr uint16_t maskof_BoolStatus() {
  return
    maskbit_v(offsetof(BoolStatus, errfmt))
  | maskbit_v(offsetof(BoolStatus, shell_ex));
}

List<Tuple2<Str*, Str*>*>* _ResolveNames(List<Str*>* names, Dict<Str*, runtime_asdl::Proc*>* funcs, Dict<Str*, Str*>* aliases, state::SearchPath* search_path);
class Type : public vm::_Builtin {
 public:
  Type(Dict<Str*, runtime_asdl::Proc*>* funcs, Dict<Str*, Str*>* aliases, state::SearchPath* search_path, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  Dict<Str*, Str*>* aliases;
  ui::ErrorFormatter* errfmt;
  Dict<Str*, runtime_asdl::Proc*>* funcs;
  state::SearchPath* search_path;

  DISALLOW_COPY_AND_ASSIGN(Type)
};

constexpr uint16_t maskof_Type() {
  return
    maskbit_v(offsetof(Type, aliases))
  | maskbit_v(offsetof(Type, errfmt))
  | maskbit_v(offsetof(Type, funcs))
  | maskbit_v(offsetof(Type, search_path));
}


inline Str* fmt152(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("source ", 7);
  gBuf.format_r(a0);
  gBuf.write_const(" failed: ", 9);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt153(Str* a0) {
  gBuf.reset();
  gBuf.format_r(a0);
  gBuf.write_const(" isn't a shell builtin", 22);
  return gBuf.getvalue();
}

inline Str* fmt154(Str* a0) {
  gBuf.reset();
  gBuf.write_const("runproc: no proc named ", 23);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt155(int a0) {
  gBuf.reset();
  gBuf.write_const("boolstatus expected status 0 or 1, got ", 39);
  gBuf.format_d(a0);
  return gBuf.getvalue();
}

inline Str* fmt156(Str* a0) {
  gBuf.reset();
  gBuf.write_const("type: ", 6);
  gBuf.format_r(a0);
  gBuf.write_const(" not found", 10);
  return gBuf.getvalue();
}

inline Str* fmt157(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(" is a ", 6);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}


}  // declare namespace builtin_meta

namespace builtin_misc {  // declare

class Times : public vm::_Builtin {
 public:
  Times();
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  DISALLOW_COPY_AND_ASSIGN(Times)
};

Tuple2<bool, bool> _AppendParts(Str* s, List<Tuple2<runtime_asdl::span_t, int>*>* spans, int max_results, bool join_next, List<mylib::BufWriter*>* parts);
Str* _ReadN(int stdin_fd, int num_bytes, cmd_eval::CommandEvaluator* cmd_ev);
Tuple2<Str*, bool> _ReadUntilDelim(int delim_byte, cmd_eval::CommandEvaluator* cmd_ev);
Str* _ReadLineSlowly(cmd_eval::CommandEvaluator* cmd_ev);
Str* _ReadAll();
class Read : public vm::_Builtin {
 public:
  Read(split::SplitContext* splitter, state::Mem* mem, parse_lib::ParseContext* parse_ctx, cmd_eval::CommandEvaluator* cmd_ev, ui::ErrorFormatter* errfmt);
  int _Line(arg_types::read* arg, Str* var_name);
  int _All(Str* var_name);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);
  int _Run(runtime_asdl::cmd_value__Argv* cmd_val);
  int _Read(arg_types::read* arg, List<Str*>* names);

  cmd_eval::CommandEvaluator* cmd_ev;
  ui::ErrorFormatter* errfmt;
  state::Mem* mem;
  parse_lib::ParseContext* parse_ctx;
  split::SplitContext* splitter;
  mylib::LineReader* stdin;

  DISALLOW_COPY_AND_ASSIGN(Read)
};

constexpr uint16_t maskof_Read() {
  return
    maskbit_v(offsetof(Read, cmd_ev))
  | maskbit_v(offsetof(Read, errfmt))
  | maskbit_v(offsetof(Read, mem))
  | maskbit_v(offsetof(Read, parse_ctx))
  | maskbit_v(offsetof(Read, splitter))
  | maskbit_v(offsetof(Read, stdin));
}

class MapFile : public vm::_Builtin {
 public:
  MapFile(state::Mem* mem, ui::ErrorFormatter* errfmt, cmd_eval::CommandEvaluator* cmd_ev);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  cmd_eval::CommandEvaluator* cmd_ev;
  ui::ErrorFormatter* errfmt;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(MapFile)
};

constexpr uint16_t maskof_MapFile() {
  return
    maskbit_v(offsetof(MapFile, cmd_ev))
  | maskbit_v(offsetof(MapFile, errfmt))
  | maskbit_v(offsetof(MapFile, mem));
}

class ctx_CdBlock : public Obj {
 public:
  ctx_CdBlock(state::DirStack* dir_stack, Str* dest_dir, state::Mem* mem, ui::ErrorFormatter* errfmt, List<bool>* out_errs);
  ~ctx_CdBlock();

  state::DirStack* dir_stack;
  ui::ErrorFormatter* errfmt;
  state::Mem* mem;
  List<bool>* out_errs;

  DISALLOW_COPY_AND_ASSIGN(ctx_CdBlock)
};

constexpr uint16_t maskof_ctx_CdBlock() {
  return
    maskbit(offsetof(ctx_CdBlock, dir_stack))
  | maskbit(offsetof(ctx_CdBlock, errfmt))
  | maskbit(offsetof(ctx_CdBlock, mem))
  | maskbit(offsetof(ctx_CdBlock, out_errs));
}

class Cd : public vm::_Builtin {
 public:
  Cd(state::Mem* mem, state::DirStack* dir_stack, cmd_eval::CommandEvaluator* cmd_ev, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  cmd_eval::CommandEvaluator* cmd_ev;
  state::DirStack* dir_stack;
  ui::ErrorFormatter* errfmt;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(Cd)
};

constexpr uint16_t maskof_Cd() {
  return
    maskbit_v(offsetof(Cd, cmd_ev))
  | maskbit_v(offsetof(Cd, dir_stack))
  | maskbit_v(offsetof(Cd, errfmt))
  | maskbit_v(offsetof(Cd, mem));
}

extern int WITH_LINE_NUMBERS;
extern int WITHOUT_LINE_NUMBERS;
extern int SINGLE_LINE;
void _PrintDirStack(state::DirStack* dir_stack, int style, Str* home_dir);
class Pushd : public vm::_Builtin {
 public:
  Pushd(state::Mem* mem, state::DirStack* dir_stack, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  state::DirStack* dir_stack;
  ui::ErrorFormatter* errfmt;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(Pushd)
};

constexpr uint16_t maskof_Pushd() {
  return
    maskbit_v(offsetof(Pushd, dir_stack))
  | maskbit_v(offsetof(Pushd, errfmt))
  | maskbit_v(offsetof(Pushd, mem));
}

bool _PopDirStack(Str* label, state::Mem* mem, state::DirStack* dir_stack, ui::ErrorFormatter* errfmt, List<bool>* out_errs);
class Popd : public vm::_Builtin {
 public:
  Popd(state::Mem* mem, state::DirStack* dir_stack, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  state::DirStack* dir_stack;
  ui::ErrorFormatter* errfmt;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(Popd)
};

constexpr uint16_t maskof_Popd() {
  return
    maskbit_v(offsetof(Popd, dir_stack))
  | maskbit_v(offsetof(Popd, errfmt))
  | maskbit_v(offsetof(Popd, mem));
}

class Dirs : public vm::_Builtin {
 public:
  Dirs(state::Mem* mem, state::DirStack* dir_stack, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  state::DirStack* dir_stack;
  ui::ErrorFormatter* errfmt;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(Dirs)
};

constexpr uint16_t maskof_Dirs() {
  return
    maskbit_v(offsetof(Dirs, dir_stack))
  | maskbit_v(offsetof(Dirs, errfmt))
  | maskbit_v(offsetof(Dirs, mem));
}

class Pwd : public vm::_Builtin {
 public:
  Pwd(state::Mem* mem, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(Pwd)
};

constexpr uint16_t maskof_Pwd() {
  return
    maskbit_v(offsetof(Pwd, errfmt))
  | maskbit_v(offsetof(Pwd, mem));
}

class Help : public vm::_Builtin {
 public:
  Help(pyutil::_ResourceLoader* loader, ui::ErrorFormatter* errfmt);
  List<Str*>* _Groups();
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  pyutil::_ResourceLoader* loader;

  DISALLOW_COPY_AND_ASSIGN(Help)
};

constexpr uint16_t maskof_Help() {
  return
    maskbit_v(offsetof(Help, errfmt))
  | maskbit_v(offsetof(Help, loader));
}

class Cat : public vm::_Builtin {
 public:
  Cat();
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  DISALLOW_COPY_AND_ASSIGN(Cat)
};


inline Str* fmt158(Str* a0) {
  gBuf.reset();
  gBuf.write_const("read error: ", 12);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt159(Str* a0) {
  gBuf.reset();
  gBuf.write_const("mapfile: read() error: ", 23);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt160(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("cd ", 3);
  gBuf.format_r(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt161(int a0, Str* a1) {
  gBuf.reset();
  gBuf.format_d(a0);
  gBuf.write_const("  ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt162() {
  gBuf.reset();
  gBuf.write_const("got too many arguments", 22);
  return gBuf.getvalue();
}

inline Str* fmt163(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("pushd: ", 7);
  gBuf.format_r(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt164(Str* a0) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(": directory stack is empty", 26);
  return gBuf.getvalue();
}

inline Str* fmt165(Str* a0, Str* a1, Str* a2) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_r(a1);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a2);
  return gBuf.getvalue();
}

inline Str* fmt166() {
  gBuf.reset();
  gBuf.write_const("got extra argument", 18);
  return gBuf.getvalue();
}

inline Str* fmt167(Str* a0) {
  gBuf.reset();
  gBuf.write_const("_devbuild/help/", 15);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt168(Str* a0) {
  gBuf.reset();
  gBuf.write_const("no help topics match ", 21);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt169(Str* a0) {
  gBuf.reset();
  gBuf.write_const("osh I/O error: ", 15);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}


}  // declare namespace builtin_misc

namespace builtin_printf {  // declare

class _FormatStringParser : public Obj {
 public:
  _FormatStringParser(lexer::Lexer* lexer);
  void _Next(types_asdl::lex_mode_t lex_mode);
  syntax_asdl::printf_part_t* _ParseFormatStr();
  List<syntax_asdl::printf_part_t*>* Parse();

  syntax_asdl::Token* cur_token;
  lexer::Lexer* lexer;
  id_kind_asdl::Kind_t token_kind;
  int token_type;

  DISALLOW_COPY_AND_ASSIGN(_FormatStringParser)
};

constexpr uint16_t maskof__FormatStringParser() {
  return
    maskbit(offsetof(_FormatStringParser, cur_token))
  | maskbit(offsetof(_FormatStringParser, lexer));
}

class Printf : public vm::_Builtin {
 public:
  Printf(state::Mem* mem, parse_lib::ParseContext* parse_ctx, sh_expr_eval::UnsafeArith* unsafe_arith, ui::ErrorFormatter* errfmt);
  int _Format(List<syntax_asdl::printf_part_t*>* parts, List<Str*>* varargs, List<int>* spids, List<Str*>* out);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  state::Mem* mem;
  Dict<Str*, List<syntax_asdl::printf_part_t*>*>* parse_cache;
  parse_lib::ParseContext* parse_ctx;
  double shell_start_time;
  sh_expr_eval::UnsafeArith* unsafe_arith;

  DISALLOW_COPY_AND_ASSIGN(Printf)
};

constexpr uint16_t maskof_Printf() {
  return
    maskbit_v(offsetof(Printf, errfmt))
  | maskbit_v(offsetof(Printf, mem))
  | maskbit_v(offsetof(Printf, parse_cache))
  | maskbit_v(offsetof(Printf, parse_ctx))
  | maskbit_v(offsetof(Printf, unsafe_arith));
}


inline Str* fmt170(Str* a0) {
  gBuf.reset();
  gBuf.write_const("osh printf doesn't support the ", 31);
  gBuf.format_r(a0);
  gBuf.write_const(" flag", 5);
  return gBuf.getvalue();
}

inline Str* fmt171() {
  gBuf.reset();
  gBuf.write_const("osh printf doesn't support floating point", 41);
  return gBuf.getvalue();
}

inline Str* fmt172() {
  gBuf.reset();
  gBuf.write_const("osh printf doesn't support single characters (bytes)", 52);
  return gBuf.getvalue();
}

inline Str* fmt173() {
  gBuf.reset();
  gBuf.write_const("Invalid printf format character", 31);
  return gBuf.getvalue();
}

inline Str* fmt174() {
  gBuf.reset();
  gBuf.write_const("Expected a printf format character", 34);
  return gBuf.getvalue();
}

inline Str* fmt175(Str* a0) {
  gBuf.reset();
  gBuf.write_const("printf got invalid width ", 25);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt176(Str* a0) {
  gBuf.reset();
  gBuf.write_const("printf got invalid precision ", 29);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt177(Str* a0) {
  gBuf.reset();
  gBuf.write_const("printf expected an integer, got ", 32);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt178(int a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Can't format negative number ", 29);
  gBuf.format_d(a0);
  gBuf.write_const(" with ", 6);
  gBuf.write_const("%", 1);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}


}  // declare namespace builtin_printf

namespace builtin_process2 {  // declare

class Exec : public vm::_Builtin {
 public:
  Exec(state::Mem* mem, process::ExternalProgram* ext_prog, process::FdState* fd_state, state::SearchPath* search_path, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  process::ExternalProgram* ext_prog;
  process::FdState* fd_state;
  state::Mem* mem;
  state::SearchPath* search_path;

  DISALLOW_COPY_AND_ASSIGN(Exec)
};

constexpr uint16_t maskof_Exec() {
  return
    maskbit_v(offsetof(Exec, errfmt))
  | maskbit_v(offsetof(Exec, ext_prog))
  | maskbit_v(offsetof(Exec, fd_state))
  | maskbit_v(offsetof(Exec, mem))
  | maskbit_v(offsetof(Exec, search_path));
}

class Wait : public vm::_Builtin {
 public:
  Wait(process::Waiter* waiter, process::JobState* job_state, state::Mem* mem, dev::Tracer* tracer, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);
  int _Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  process::JobState* job_state;
  state::Mem* mem;
  dev::Tracer* tracer;
  process::Waiter* waiter;

  DISALLOW_COPY_AND_ASSIGN(Wait)
};

constexpr uint16_t maskof_Wait() {
  return
    maskbit_v(offsetof(Wait, errfmt))
  | maskbit_v(offsetof(Wait, job_state))
  | maskbit_v(offsetof(Wait, mem))
  | maskbit_v(offsetof(Wait, tracer))
  | maskbit_v(offsetof(Wait, waiter));
}

class Umask : public vm::_Builtin {
 public:
  Umask();
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  DISALLOW_COPY_AND_ASSIGN(Umask)
};


inline Str* fmt179(Str* a0) {
  gBuf.reset();
  gBuf.write_const("exec: ", 6);
  gBuf.format_r(a0);
  gBuf.write_const(" not found", 10);
  return gBuf.getvalue();
}

inline Str* fmt180(Str* a0) {
  gBuf.reset();
  gBuf.write_const("doesn't support bash-style jobspecs (got ", 41);
  gBuf.format_r(a0);
  gBuf.write_const(")", 1);
  return gBuf.getvalue();
}

inline Str* fmt181(Str* a0) {
  gBuf.reset();
  gBuf.write_const("expected PID or jobspec, got ", 29);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt182(int a0) {
  gBuf.reset();
  gBuf.format_d(a0);
  gBuf.write_const(" isn't a child of this shell", 28);
  return gBuf.getvalue();
}

inline Str* fmt183(int a0) {
  gBuf.reset();
  gBuf.write_const("0", 1);
  gBuf.format_o(a0);
  return gBuf.getvalue();
}


}  // declare namespace builtin_process2

namespace builtin_pure {  // declare

class Boolean : public vm::_Builtin {
 public:
  Boolean(int status);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  int status;

  DISALLOW_COPY_AND_ASSIGN(Boolean)
};

class Alias : public vm::_Builtin {
 public:
  Alias(Dict<Str*, Str*>* aliases, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  Dict<Str*, Str*>* aliases;
  ui::ErrorFormatter* errfmt;

  DISALLOW_COPY_AND_ASSIGN(Alias)
};

constexpr uint16_t maskof_Alias() {
  return
    maskbit_v(offsetof(Alias, aliases))
  | maskbit_v(offsetof(Alias, errfmt));
}

class UnAlias : public vm::_Builtin {
 public:
  UnAlias(Dict<Str*, Str*>* aliases, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  Dict<Str*, Str*>* aliases;
  ui::ErrorFormatter* errfmt;

  DISALLOW_COPY_AND_ASSIGN(UnAlias)
};

constexpr uint16_t maskof_UnAlias() {
  return
    maskbit_v(offsetof(UnAlias, aliases))
  | maskbit_v(offsetof(UnAlias, errfmt));
}

void SetOptionsFromFlags(state::MutableOpts* exec_opts, List<Tuple2<Str*, bool>*>* opt_changes, List<Tuple2<Str*, bool>*>* shopt_changes);
class Set : public vm::_Builtin {
 public:
  Set(state::MutableOpts* exec_opts, state::Mem* mem);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  state::MutableOpts* exec_opts;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(Set)
};

constexpr uint16_t maskof_Set() {
  return
    maskbit_v(offsetof(Set, exec_opts))
  | maskbit_v(offsetof(Set, mem));
}

class Shopt : public vm::_Builtin {
 public:
  Shopt(state::MutableOpts* mutable_opts, cmd_eval::CommandEvaluator* cmd_ev);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  cmd_eval::CommandEvaluator* cmd_ev;
  state::MutableOpts* mutable_opts;

  DISALLOW_COPY_AND_ASSIGN(Shopt)
};

constexpr uint16_t maskof_Shopt() {
  return
    maskbit_v(offsetof(Shopt, cmd_ev))
  | maskbit_v(offsetof(Shopt, mutable_opts));
}

class Hash : public vm::_Builtin {
 public:
  Hash(state::SearchPath* search_path);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  state::SearchPath* search_path;

  DISALLOW_COPY_AND_ASSIGN(Hash)
};

constexpr uint16_t maskof_Hash() {
  return
    maskbit_v(offsetof(Hash, search_path));
}

Dict<Str*, bool>* _ParseOptSpec(Str* spec_str);
class GetOptsState : public Obj {
 public:
  GetOptsState(state::Mem* mem, ui::ErrorFormatter* errfmt);
  int _OptInd();
  Str* GetArg(List<Str*>* argv);
  void IncIndex();
  void SetArg(Str* optarg);
  void Fail();

  int _optind;
  ui::ErrorFormatter* errfmt;
  int flag_pos;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(GetOptsState)
};

constexpr uint16_t maskof_GetOptsState() {
  return
    maskbit(offsetof(GetOptsState, errfmt))
  | maskbit(offsetof(GetOptsState, mem));
}

Tuple2<int, Str*> _GetOpts(Dict<Str*, bool>* spec, List<Str*>* argv, builtin_pure::GetOptsState* my_state, ui::ErrorFormatter* errfmt);
class GetOpts : public vm::_Builtin {
 public:
  GetOpts(state::Mem* mem, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  state::Mem* mem;
  builtin_pure::GetOptsState* my_state;
  Dict<Str*, Dict<Str*, bool>*>* spec_cache;

  DISALLOW_COPY_AND_ASSIGN(GetOpts)
};

constexpr uint16_t maskof_GetOpts() {
  return
    maskbit_v(offsetof(GetOpts, errfmt))
  | maskbit_v(offsetof(GetOpts, mem))
  | maskbit_v(offsetof(GetOpts, my_state))
  | maskbit_v(offsetof(GetOpts, spec_cache));
}

class Echo : public vm::_Builtin {
 public:
  Echo(optview::Exec* exec_opts);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  optview::Exec* exec_opts;
  mylib::Writer* f;

  DISALLOW_COPY_AND_ASSIGN(Echo)
};

constexpr uint16_t maskof_Echo() {
  return
    maskbit_v(offsetof(Echo, exec_opts))
  | maskbit_v(offsetof(Echo, f));
}

class Module : public vm::_Builtin {
 public:
  Module(Dict<Str*, bool>* modules, optview::Exec* exec_opts, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  optview::Exec* exec_opts;
  Dict<Str*, bool>* modules;

  DISALLOW_COPY_AND_ASSIGN(Module)
};

constexpr uint16_t maskof_Module() {
  return
    maskbit_v(offsetof(Module, errfmt))
  | maskbit_v(offsetof(Module, exec_opts))
  | maskbit_v(offsetof(Module, modules));
}

class Use : public vm::_Builtin {
 public:
  Use(state::Mem* mem, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(Use)
};

constexpr uint16_t maskof_Use() {
  return
    maskbit_v(offsetof(Use, errfmt))
  | maskbit_v(offsetof(Use, mem));
}

class Shvar : public vm::_Builtin {
 public:
  Shvar(state::Mem* mem, state::SearchPath* search_path, cmd_eval::CommandEvaluator* cmd_ev);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  cmd_eval::CommandEvaluator* cmd_ev;
  state::Mem* mem;
  state::SearchPath* search_path;

  DISALLOW_COPY_AND_ASSIGN(Shvar)
};

constexpr uint16_t maskof_Shvar() {
  return
    maskbit_v(offsetof(Shvar, cmd_ev))
  | maskbit_v(offsetof(Shvar, mem))
  | maskbit_v(offsetof(Shvar, search_path));
}

class PushRegisters : public vm::_Builtin {
 public:
  PushRegisters(state::Mem* mem, cmd_eval::CommandEvaluator* cmd_ev);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  cmd_eval::CommandEvaluator* cmd_ev;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(PushRegisters)
};

constexpr uint16_t maskof_PushRegisters() {
  return
    maskbit_v(offsetof(PushRegisters, cmd_ev))
  | maskbit_v(offsetof(PushRegisters, mem));
}

class Fopen : public vm::_Builtin {
 public:
  Fopen(state::Mem* mem, cmd_eval::CommandEvaluator* cmd_ev);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  cmd_eval::CommandEvaluator* cmd_ev;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(Fopen)
};

constexpr uint16_t maskof_Fopen() {
  return
    maskbit_v(offsetof(Fopen, cmd_ev))
  | maskbit_v(offsetof(Fopen, mem));
}


inline Str* fmt184(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("alias ", 6);
  gBuf.format_s(a0);
  gBuf.write_const("=", 1);
  gBuf.format_r(a1);
  return gBuf.getvalue();
}

inline Str* fmt185(Str* a0) {
  gBuf.reset();
  gBuf.write_const("No alias named ", 15);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt186(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("alias ", 6);
  gBuf.format_s(a0);
  gBuf.write_const("=", 1);
  gBuf.format_r(a1);
  return gBuf.getvalue();
}

inline Str* fmt187(Str* a0) {
  gBuf.reset();
  gBuf.write_const("No alias named ", 15);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt188(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const("=", 1);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt189(Str* a0) {
  gBuf.reset();
  gBuf.write_const("got invalid option ", 19);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt190(Str* a0) {
  gBuf.reset();
  gBuf.write_const("hash: ", 6);
  gBuf.format_r(a0);
  gBuf.write_const(" not found", 10);
  return gBuf.getvalue();
}

inline Str* fmt191(Str* a0) {
  gBuf.reset();
  gBuf.write_const("getopts: option ", 16);
  gBuf.format_r(a0);
  gBuf.write_const(" requires an argument.", 22);
  return gBuf.getvalue();
}

inline Str* fmt192(Str* a0) {
  gBuf.reset();
  gBuf.write_const("(getopts argv: ", 15);
  gBuf.format_s(a0);
  gBuf.write_const(")", 1);
  return gBuf.getvalue();
}

inline Str* fmt193(Str* a0) {
  gBuf.reset();
  gBuf.write_const("got invalid variable name ", 26);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt194(Str* a0) {
  gBuf.reset();
  gBuf.write_const("(interactive) Reloading module ", 31);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt195(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Expected dialect ", 17);
  gBuf.format_r(a0);
  gBuf.write_const(", got ", 6);
  gBuf.format_r(a1);
  return gBuf.getvalue();
}

inline Str* fmt196(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Expected dialect ", 17);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt197(Str* a0) {
  gBuf.reset();
  gBuf.write_const("bin ", 4);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}


}  // declare namespace builtin_pure

namespace builtin_trap {  // declare

class TrapState : public Obj {
 public:
  TrapState();
  syntax_asdl::command_t* GetHook(Str* hook_name);
  void AddUserHook(Str* hook_name, syntax_asdl::command_t* handler);
  void RemoveUserHook(Str* hook_name);
  void AddUserTrap(int sig_num, syntax_asdl::command_t* handler);
  void RemoveUserTrap(int sig_num);
  void InitShell();
  void InitInteractiveShell(comp_ui::_IDisplay* display, int my_pid);
  int GetLastSignal();
  List<syntax_asdl::command_t*>* TakeRunList();

  comp_ui::_IDisplay* display;
  Dict<Str*, syntax_asdl::command_t*>* hooks;
  Dict<int, syntax_asdl::command_t*>* traps;

  DISALLOW_COPY_AND_ASSIGN(TrapState)
};

constexpr uint16_t maskof_TrapState() {
  return
    maskbit(offsetof(TrapState, display))
  | maskbit(offsetof(TrapState, hooks))
  | maskbit(offsetof(TrapState, traps));
}

int _GetSignalNumber(Str* sig_spec);
extern List<Str*>* _HOOK_NAMES;
class Trap : public vm::_Builtin {
 public:
  Trap(builtin_trap::TrapState* trap_state, parse_lib::ParseContext* parse_ctx, dev::Tracer* tracer, ui::ErrorFormatter* errfmt);
  syntax_asdl::command_t* _ParseTrapCode(Str* code_str);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  alloc::Arena* arena;
  ui::ErrorFormatter* errfmt;
  parse_lib::ParseContext* parse_ctx;
  dev::Tracer* tracer;
  builtin_trap::TrapState* trap_state;

  DISALLOW_COPY_AND_ASSIGN(Trap)
};

constexpr uint16_t maskof_Trap() {
  return
    maskbit_v(offsetof(Trap, arena))
  | maskbit_v(offsetof(Trap, errfmt))
  | maskbit_v(offsetof(Trap, parse_ctx))
  | maskbit_v(offsetof(Trap, tracer))
  | maskbit_v(offsetof(Trap, trap_state));
}


inline Str* fmt198(Str* a0) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(" TrapState", 10);
  return gBuf.getvalue();
}

inline Str* fmt199(int a0) {
  gBuf.reset();
  gBuf.format_d(a0);
  gBuf.write_const(" TrapState", 10);
  return gBuf.getvalue();
}

inline Str* fmt200(Str* a0) {
  gBuf.reset();
  gBuf.write_const("   ", 3);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt201(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid signal or hook ", 23);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt202(Str* a0) {
  gBuf.reset();
  gBuf.write_const("osh warning: The ", 17);
  gBuf.format_r(a0);
  gBuf.write_const(" hook isn't implemented", 23);
  return gBuf.getvalue();
}

inline Str* fmt203(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Signal ", 7);
  gBuf.format_r(a0);
  gBuf.write_const(" can't be handled", 17);
  return gBuf.getvalue();
}


}  // declare namespace builtin_trap

namespace cmd_eval {  // declare

extern int IsMainProgram;
extern int RaiseControlFlow;
extern int Optimize;
extern Dict<Str*, Str*>* OIL_TYPE_NAMES;
class Deps : public Obj {
 public:
  Deps();

  util::_DebugFile* debug_f;
  dev::CrashDumper* dumper;
  state::MutableOpts* mutable_opts;

  DISALLOW_COPY_AND_ASSIGN(Deps)
};

constexpr uint16_t maskof_Deps() {
  return
    maskbit(offsetof(Deps, debug_f))
  | maskbit(offsetof(Deps, dumper))
  | maskbit(offsetof(Deps, mutable_opts));
}

int _PackFlags(int keyword_id);
int _PackFlags(int keyword_id, int flags);
bool _HasManyStatuses(syntax_asdl::command_t* node);
runtime_asdl::value_t* PlusEquals(runtime_asdl::value_t* old_val, runtime_asdl::value_t* val);
class ctx_LoopLevel : public Obj {
 public:
  ctx_LoopLevel(cmd_eval::CommandEvaluator* cmd_ev);
  ~ctx_LoopLevel();

  cmd_eval::CommandEvaluator* cmd_ev;

  DISALLOW_COPY_AND_ASSIGN(ctx_LoopLevel)
};

constexpr uint16_t maskof_ctx_LoopLevel() {
  return
    maskbit(offsetof(ctx_LoopLevel, cmd_ev));
}

class CommandEvaluator : public Obj {
 public:
  CommandEvaluator(state::Mem* mem, optview::Exec* exec_opts, ui::ErrorFormatter* errfmt, Dict<Str*, runtime_asdl::Proc*>* procs, Dict<int, vm::_AssignBuiltin*>* assign_builtins, alloc::Arena* arena, cmd_eval::Deps* cmd_deps, builtin_trap::TrapState* trap_state);
  void CheckCircularDeps();
  int _RunAssignBuiltin(runtime_asdl::cmd_value__Assign* cmd_val);
  int _SpanIdForShAssignment(syntax_asdl::command__ShAssignment* node);
  void _CheckStatus(int status, runtime_asdl::CommandStatus* cmd_st, syntax_asdl::command_t* node, int blame_spid);
  runtime_asdl::redirect* _EvalRedirect(syntax_asdl::redir* r);
  List<runtime_asdl::redirect*>* _EvalRedirects(syntax_asdl::command_t* node);
  int _RunSimpleCommand(runtime_asdl::cmd_value_t* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork);
  void _EvalTempEnv(List<syntax_asdl::env_pair*>* more_env, int flags);
  void _StrictErrExit(syntax_asdl::command_t* node);
  void _StrictErrExitList(List<syntax_asdl::command_t*>* node_list);
  bool _EvalCondition(syntax_asdl::condition_t* cond, int spid);
  int _Dispatch(syntax_asdl::command_t* node, runtime_asdl::CommandStatus* cmd_st);
  void RunPendingTraps();
  int _Execute(syntax_asdl::command_t* node);
  int _ExecuteList(List<syntax_asdl::command_t*>* children);
  int LastStatus();
  void _NoForkLast(syntax_asdl::command_t* node);
  syntax_asdl::command_t* _RemoveSubshells(syntax_asdl::command_t* node);
  Tuple2<bool, bool> ExecuteAndCatch(syntax_asdl::command_t* node);
  Tuple2<bool, bool> ExecuteAndCatch(syntax_asdl::command_t* node, int cmd_flags);
  void MaybeRunExitTrap(List<int>* mut_status);
  int RunProc(runtime_asdl::Proc* proc, List<Str*>* argv, int arg0_spid);
  Dict<Str*, runtime_asdl::cell*>* EvalBlock(syntax_asdl::command_t* block);
  int RunFuncForCompletion(runtime_asdl::Proc* proc, List<Str*>* argv);

  alloc::Arena* arena;
  sh_expr_eval::ArithEvaluator* arith_ev;
  Dict<int, vm::_AssignBuiltin*>* assign_builtins;
  sh_expr_eval::BoolEvaluator* bool_ev;
  bool check_command_sub_status;
  util::_DebugFile* debug_f;
  dev::CrashDumper* dumper;
  ui::ErrorFormatter* errfmt;
  optview::Exec* exec_opts;
  expr_eval::OilEvaluator* expr_ev;
  int loop_level;
  state::Mem* mem;
  state::MutableOpts* mutable_opts;
  Dict<Str*, runtime_asdl::Proc*>* procs;
  vm::_Executor* shell_ex;
  dev::Tracer* tracer;
  builtin_trap::TrapState* trap_state;
  word_eval::AbstractWordEvaluator* word_ev;

  DISALLOW_COPY_AND_ASSIGN(CommandEvaluator)
};

constexpr uint16_t maskof_CommandEvaluator() {
  return
    maskbit(offsetof(CommandEvaluator, arena))
  | maskbit(offsetof(CommandEvaluator, arith_ev))
  | maskbit(offsetof(CommandEvaluator, assign_builtins))
  | maskbit(offsetof(CommandEvaluator, bool_ev))
  | maskbit(offsetof(CommandEvaluator, debug_f))
  | maskbit(offsetof(CommandEvaluator, dumper))
  | maskbit(offsetof(CommandEvaluator, errfmt))
  | maskbit(offsetof(CommandEvaluator, exec_opts))
  | maskbit(offsetof(CommandEvaluator, expr_ev))
  | maskbit(offsetof(CommandEvaluator, mem))
  | maskbit(offsetof(CommandEvaluator, mutable_opts))
  | maskbit(offsetof(CommandEvaluator, procs))
  | maskbit(offsetof(CommandEvaluator, shell_ex))
  | maskbit(offsetof(CommandEvaluator, tracer))
  | maskbit(offsetof(CommandEvaluator, trap_state))
  | maskbit(offsetof(CommandEvaluator, word_ev));
}


inline Str* fmt204(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Assignment builtin ", 19);
  gBuf.format_r(a0);
  gBuf.write_const(" not configured", 15);
  return gBuf.getvalue();
}

inline Str* fmt205(Str* a0) {
  gBuf.reset();
  gBuf.format_r(a0);
  gBuf.write_const(" ", 1);
  return gBuf.getvalue();
}

inline Str* fmt206(Str* a0, int a1) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(" failed with status ", 20);
  gBuf.format_d(a1);
  return gBuf.getvalue();
}

inline Str* fmt207(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid descriptor ", 19);
  gBuf.format_r(a0);
  gBuf.write_const(".  Expected D, -, or D- where D is an integer", 45);
  return gBuf.getvalue();
}

inline Str* fmt208(Str* a0) {
  gBuf.reset();
  gBuf.write_const("strict_errexit only allows simple commands in conditionals (got ", 64);
  gBuf.format_s(a0);
  gBuf.write_const("). ", 3);
  return gBuf.getvalue();
}

inline Str* fmt209() {
  gBuf.reset();
  gBuf.write_const("strict_errexit only allows a single command.  Hint: use 'try'.", 62);
  return gBuf.getvalue();
}

inline Str* fmt210(Str* a0) {
  gBuf.reset();
  gBuf.write_const("strict_errexit only allows simple commands in conditionals (got ", 64);
  gBuf.format_s(a0);
  gBuf.write_const("). ", 3);
  return gBuf.getvalue();
}

inline Str* fmt211() {
  gBuf.reset();
  gBuf.write_const("ShAssignment builtins don't accept blocks", 41);
  return gBuf.getvalue();
}

inline Str* fmt212() {
  gBuf.reset();
  gBuf.write_const("|& isn't supported", 18);
  return gBuf.getvalue();
}

inline Str* fmt213(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.format_r(a0);
  gBuf.write_const(" expected a number, got ", 24);
  gBuf.format_r(a1);
  return gBuf.getvalue();
}

inline Str* fmt214(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Function ", 9);
  gBuf.format_s(a0);
  gBuf.write_const(" was already defined (redefine_proc)", 36);
  return gBuf.getvalue();
}

inline Str* fmt215(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Proc ", 5);
  gBuf.format_s(a0);
  gBuf.write_const(" was already defined (redefine_proc)", 36);
  return gBuf.getvalue();
}

inline Str* fmt216(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid argument ", 17);
  gBuf.format_r(a0);
  gBuf.write_const(".  Expected a name starting with :", 34);
  return gBuf.getvalue();
}

inline Str* fmt217(Str* a0) {
  gBuf.reset();
  gBuf.write_const("No value provided for param ", 28);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt218(Str* a0, int a1, int a2) {
  gBuf.reset();
  gBuf.write_const("proc ", 5);
  gBuf.format_r(a0);
  gBuf.write_const(" expected ", 10);
  gBuf.format_d(a1);
  gBuf.write_const(" arguments, but got ", 20);
  gBuf.format_d(a2);
  return gBuf.getvalue();
}

inline Str* fmt219(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Unexpected ", 11);
  gBuf.format_r(a0);
  gBuf.write_const(" (in function call)", 19);
  return gBuf.getvalue();
}

inline Str* fmt220() {
  gBuf.reset();
  gBuf.write_const("Unexpected control flow in block", 32);
  return gBuf.getvalue();
}


}  // declare namespace cmd_eval

namespace cmd_parse {  // declare

extern int TAB_CH;
extern int SPACE_CH;
int _KeywordSpid(syntax_asdl::word_t* w);
syntax_asdl::Token* _KeywordToken(syntax_asdl::word_t* UP_w);
Tuple2<List<Tuple3<int, Str*, int>*>*, Tuple3<int, Str*, int>*> _ReadHereLines(reader::_Reader* line_reader, syntax_asdl::redir* h, Str* delimiter);
List<syntax_asdl::word_part_t*>* _MakeLiteralHereLines(List<Tuple3<int, Str*, int>*>* here_lines, alloc::Arena* arena);
void _ParseHereDocBody(parse_lib::ParseContext* parse_ctx, syntax_asdl::redir* r, reader::_Reader* line_reader, alloc::Arena* arena);
syntax_asdl::assign_pair* _MakeAssignPair(parse_lib::ParseContext* parse_ctx, Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>* preparsed, alloc::Arena* arena);
void _AppendMoreEnv(List<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*>* preparsed_list, List<syntax_asdl::env_pair*>* more_env);
Tuple2<List<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*>*, List<syntax_asdl::compound_word*>*> _SplitSimpleCommandPrefix(List<syntax_asdl::compound_word*>* words);
syntax_asdl::command__Simple* _MakeSimpleCommand(List<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*>* preparsed_list, List<syntax_asdl::compound_word*>* suffix_words, List<syntax_asdl::redir*>* redirects, syntax_asdl::ArgList* typed_args, syntax_asdl::BraceGroup* block);
class VarChecker : public Obj {
 public:
  VarChecker();
  void Push(syntax_asdl::Token* blame_tok);
  void Pop();
  void Check(int keyword_id, syntax_asdl::Token* name_tok);

  List<Dict<Str*, int>*>* names;
  List<syntax_asdl::Token*>* tokens;

  DISALLOW_COPY_AND_ASSIGN(VarChecker)
};

constexpr uint16_t maskof_VarChecker() {
  return
    maskbit(offsetof(VarChecker, names))
  | maskbit(offsetof(VarChecker, tokens));
}

class ctx_VarChecker : public Obj {
 public:
  ctx_VarChecker(cmd_parse::VarChecker* var_checker, syntax_asdl::Token* blame_tok);
  ~ctx_VarChecker();

  cmd_parse::VarChecker* var_checker;

  DISALLOW_COPY_AND_ASSIGN(ctx_VarChecker)
};

constexpr uint16_t maskof_ctx_VarChecker() {
  return
    maskbit(offsetof(ctx_VarChecker, var_checker));
}

extern List<int>* SECONDARY_KEYWORDS;
class CommandParser : public Obj {
 public:
  CommandParser(parse_lib::ParseContext* parse_ctx, optview::Parse* parse_opts, word_parse::WordParser* w_parser, lexer::Lexer* lexer, reader::_Reader* line_reader);
  void Init_EofId(int eof_id);
  void Init_AliasesInFlight(List<Tuple2<Str*, int>*>* aliases_in_flight);
  void Reset();
  void ResetInputObjects();
  void _Next();
  void _Peek();
  void _Eat(int c_id);
  void _Eat2(int c_id, Str* msg);
  void _NewlineOk();
  bool _AtSecondaryKeyword();
  syntax_asdl::redir* ParseRedirect();
  List<syntax_asdl::redir*>* _ParseRedirectList();
  Tuple4<List<syntax_asdl::redir*>*, List<syntax_asdl::compound_word*>*, syntax_asdl::ArgList*, syntax_asdl::BraceGroup*> _ScanSimpleCommand();
  syntax_asdl::command_t* _MaybeExpandAliases(List<syntax_asdl::compound_word*>* words);
  syntax_asdl::command_t* ParseSimpleCommand();
  syntax_asdl::BraceGroup* ParseBraceGroup();
  syntax_asdl::command__DoGroup* ParseDoGroup();
  Tuple2<List<syntax_asdl::compound_word*>*, int> ParseForWords();
  syntax_asdl::command__ForExpr* _ParseForExprLoop();
  syntax_asdl::command__ForEach* _ParseForEachLoop(int for_spid);
  syntax_asdl::command_t* ParseFor();
  syntax_asdl::command__WhileUntil* ParseWhileUntil(syntax_asdl::Token* keyword);
  syntax_asdl::case_arm* ParseCaseItem();
  void ParseCaseList(List<syntax_asdl::case_arm*>* arms);
  syntax_asdl::command__Case* ParseCase();
  void _ParseOilElifElse(syntax_asdl::command__If* if_node);
  syntax_asdl::command__If* _ParseOilIf(int if_spid, syntax_asdl::condition_t* cond);
  void _ParseElifElse(syntax_asdl::command__If* if_node);
  syntax_asdl::command__If* ParseIf();
  syntax_asdl::command_t* ParseTime();
  syntax_asdl::command_t* ParseCompoundCommand();
  syntax_asdl::command__ShFunction* ParseFunctionDef();
  syntax_asdl::command__ShFunction* ParseKshFunctionDef();
  syntax_asdl::command__Proc* ParseOilProc();
  syntax_asdl::command_t* ParseCoproc();
  syntax_asdl::command__Subshell* ParseSubshell();
  syntax_asdl::command__DBracket* ParseDBracket();
  syntax_asdl::command__DParen* ParseDParen();
  syntax_asdl::command_t* ParseCommand();
  syntax_asdl::command_t* ParsePipeline();
  syntax_asdl::command_t* ParseAndOr();
  syntax_asdl::command_t* _ParseAndOr();
  syntax_asdl::command_t* _ParseCommandLine();
  syntax_asdl::command__CommandList* _ParseCommandTerm();
  syntax_asdl::command__CommandList* _ParseCommandList();
  syntax_asdl::command_t* ParseLogicalLine();
  syntax_asdl::parse_result_t* ParseInteractiveLine();
  syntax_asdl::command_t* ParseCommandSub();
  void CheckForPendingHereDocs();

  Dict<Str*, Str*>* aliases;
  List<Tuple2<Str*, int>*>* aliases_in_flight;
  bool allow_block;
  List<bool>* allow_block_attrs;
  alloc::Arena* arena;
  int c_id;
  id_kind_asdl::Kind_t c_kind;
  syntax_asdl::word_t* cur_word;
  int eof_id;
  lexer::Lexer* lexer;
  reader::_Reader* line_reader;
  types_asdl::lex_mode_t next_lex_mode;
  parse_lib::ParseContext* parse_ctx;
  optview::Parse* parse_opts;
  List<syntax_asdl::redir*>* pending_here_docs;
  cmd_parse::VarChecker* var_checker;
  word_parse::WordParser* w_parser;

  DISALLOW_COPY_AND_ASSIGN(CommandParser)
};

constexpr uint16_t maskof_CommandParser() {
  return
    maskbit(offsetof(CommandParser, aliases))
  | maskbit(offsetof(CommandParser, aliases_in_flight))
  | maskbit(offsetof(CommandParser, allow_block_attrs))
  | maskbit(offsetof(CommandParser, arena))
  | maskbit(offsetof(CommandParser, cur_word))
  | maskbit(offsetof(CommandParser, lexer))
  | maskbit(offsetof(CommandParser, line_reader))
  | maskbit(offsetof(CommandParser, parse_ctx))
  | maskbit(offsetof(CommandParser, parse_opts))
  | maskbit(offsetof(CommandParser, pending_here_docs))
  | maskbit(offsetof(CommandParser, var_checker))
  | maskbit(offsetof(CommandParser, w_parser));
}


inline Str* fmt221() {
  gBuf.reset();
  gBuf.write_const("Couldn't find terminator for here doc that starts here", 54);
  return gBuf.getvalue();
}

inline Str* fmt222() {
  gBuf.reset();
  gBuf.write_const("Invalid here doc delimiter", 26);
  return gBuf.getvalue();
}

inline Str* fmt223(int a0, int a1) {
  gBuf.reset();
  gBuf.format_d(a0);
  gBuf.write_const(" != ", 4);
  gBuf.format_d(a1);
  return gBuf.getvalue();
}

inline Str* fmt224() {
  gBuf.reset();
  gBuf.write_const("Environment binding shouldn't look like an array assignment", 59);
  return gBuf.getvalue();
}

inline Str* fmt225() {
  gBuf.reset();
  gBuf.write_const("Expected = in environment binding, got +=", 41);
  return gBuf.getvalue();
}

inline Str* fmt226() {
  gBuf.reset();
  gBuf.write_const("Environment bindings can't contain array literals", 49);
  return gBuf.getvalue();
}

inline Str* fmt227() {
  gBuf.reset();
  gBuf.write_const("procs and shell functions can't be nested", 41);
  return gBuf.getvalue();
}

inline Str* fmt228(Str* a0) {
  gBuf.reset();
  gBuf.format_r(a0);
  gBuf.write_const(" was already declared", 21);
  return gBuf.getvalue();
}

inline Str* fmt229(Str* a0) {
  gBuf.reset();
  gBuf.format_r(a0);
  gBuf.write_const(" hasn't been declared", 21);
  return gBuf.getvalue();
}

inline Str* fmt230(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Can't modify constant ", 22);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt231(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Expected word type ", 19);
  gBuf.format_s(a0);
  gBuf.write_const(", got ", 6);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt232() {
  gBuf.reset();
  gBuf.write_const("Invalid token after redirect operator", 37);
  return gBuf.getvalue();
}

inline Str* fmt233() {
  gBuf.reset();
  gBuf.write_const("Space required before (", 23);
  return gBuf.getvalue();
}

inline Str* fmt234() {
  gBuf.reset();
  gBuf.write_const("Unexpected left paren (might need a space before it)", 52);
  return gBuf.getvalue();
}

inline Str* fmt235() {
  gBuf.reset();
  gBuf.write_const("Empty arg list not allowed", 26);
  return gBuf.getvalue();
}

inline Str* fmt236(int a0, int a1) {
  gBuf.reset();
  gBuf.write_const("line IDs ", 9);
  gBuf.format_d(a0);
  gBuf.write_const(" != ", 4);
  gBuf.format_d(a1);
  return gBuf.getvalue();
}

inline Str* fmt237() {
  gBuf.reset();
  gBuf.write_const("Unexpected typed args", 21);
  return gBuf.getvalue();
}

inline Str* fmt238() {
  gBuf.reset();
  gBuf.write_const("=word isn't allowed.  Hint: either quote it or add a space after =\nto pretty print an expression", 96);
  return gBuf.getvalue();
}

inline Str* fmt239() {
  gBuf.reset();
  gBuf.write_const("Use const or var/setvar to assign in Oil (parse_sh_assign)", 58);
  return gBuf.getvalue();
}

inline Str* fmt240() {
  gBuf.reset();
  gBuf.write_const("Unexpected typed args", 21);
  return gBuf.getvalue();
}

inline Str* fmt241() {
  gBuf.reset();
  gBuf.write_const("Unexpected typed args", 21);
  return gBuf.getvalue();
}

inline Str* fmt242() {
  gBuf.reset();
  gBuf.write_const("Control flow shouldn't have redirects", 37);
  return gBuf.getvalue();
}

inline Str* fmt243() {
  gBuf.reset();
  gBuf.write_const("Control flow shouldn't have environment bindings", 48);
  return gBuf.getvalue();
}

inline Str* fmt244(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Unexpected argument to ", 23);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt245() {
  gBuf.reset();
  gBuf.write_const("Invalid word in for loop", 24);
  return gBuf.getvalue();
}

inline Str* fmt246() {
  gBuf.reset();
  gBuf.write_const("Invalid word after for expression", 33);
  return gBuf.getvalue();
}

inline Str* fmt247() {
  gBuf.reset();
  gBuf.write_const("Expected loop variable (a constant word)", 40);
  return gBuf.getvalue();
}

inline Str* fmt248() {
  gBuf.reset();
  gBuf.write_const("Loop variables look like x, y (fix spaces)", 42);
  return gBuf.getvalue();
}

inline Str* fmt249(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid loop variable name ", 27);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt250() {
  gBuf.reset();
  gBuf.write_const("Unexpected word after 3 loop variables", 38);
  return gBuf.getvalue();
}

inline Str* fmt251() {
  gBuf.reset();
  gBuf.write_const("Expected { after iterable expression", 36);
  return gBuf.getvalue();
}

inline Str* fmt252() {
  gBuf.reset();
  gBuf.write_const("Surround this word with either parens or quotes (parse_bare_word)", 65);
  return gBuf.getvalue();
}

inline Str* fmt253() {
  gBuf.reset();
  gBuf.write_const("Expected at most 2 loop variables", 33);
  return gBuf.getvalue();
}

inline Str* fmt254() {
  gBuf.reset();
  gBuf.write_const("Unexpected word after for loop variable", 39);
  return gBuf.getvalue();
}

inline Str* fmt255() {
  gBuf.reset();
  gBuf.write_const("Bash for loops aren't allowed (parse_dparen)", 44);
  return gBuf.getvalue();
}

inline Str* fmt256() {
  gBuf.reset();
  gBuf.write_const("Expected left paren (parse_sloppy_case)", 39);
  return gBuf.getvalue();
}

inline Str* fmt257() {
  gBuf.reset();
  gBuf.write_const("Constant pattern should be quoted (parse_bare_word)", 51);
  return gBuf.getvalue();
}

inline Str* fmt258() {
  gBuf.reset();
  gBuf.write_const("Expected ;; or esac", 19);
  return gBuf.getvalue();
}

inline Str* fmt259() {
  gBuf.reset();
  gBuf.write_const("This is a constant string.  You may want a variable like $x (parse_bare_word)", 77);
  return gBuf.getvalue();
}

inline Str* fmt260() {
  gBuf.reset();
  gBuf.write_const("You may want a space between parens (parse_dparen)", 50);
  return gBuf.getvalue();
}

inline Str* fmt261() {
  gBuf.reset();
  gBuf.write_const("Unexpected word while parsing compound command", 46);
  return gBuf.getvalue();
}

inline Str* fmt262() {
  gBuf.reset();
  gBuf.write_const("Invalid function name", 21);
  return gBuf.getvalue();
}

inline Str* fmt263() {
  gBuf.reset();
  gBuf.write_const("Expected ) in function definition", 33);
  return gBuf.getvalue();
}

inline Str* fmt264() {
  gBuf.reset();
  gBuf.write_const("Invalid KSH-style function name", 31);
  return gBuf.getvalue();
}

inline Str* fmt265() {
  gBuf.reset();
  gBuf.write_const("Unexpected word when parsing command", 36);
  return gBuf.getvalue();
}

inline Str* fmt266() {
  gBuf.reset();
  gBuf.write_const("Enable Oil to use procs (parse_proc)", 36);
  return gBuf.getvalue();
}

inline Str* fmt267() {
  gBuf.reset();
  gBuf.write_const("Unexpected right brace", 22);
  return gBuf.getvalue();
}

inline Str* fmt268() {
  gBuf.reset();
  gBuf.write_const("Unexpected = (Hint: use const/var/setvar, or quote it)", 54);
  return gBuf.getvalue();
}

inline Str* fmt269() {
  gBuf.reset();
  gBuf.write_const("Unexpected EOF while parsing command", 36);
  return gBuf.getvalue();
}

inline Str* fmt270() {
  gBuf.reset();
  gBuf.write_const("Invalid word while parsing command", 34);
  return gBuf.getvalue();
}

inline Str* fmt271() {
  gBuf.reset();
  gBuf.write_const("Invalid word while parsing command line", 39);
  return gBuf.getvalue();
}

inline Str* fmt272() {
  gBuf.reset();
  gBuf.write_const("Invalid word while parsing command list", 39);
  return gBuf.getvalue();
}

inline Str* fmt273() {
  gBuf.reset();
  gBuf.write_const("Unterminated here doc began here", 32);
  return gBuf.getvalue();
}


}  // declare namespace cmd_parse

namespace glob_ {  // declare

bool LooksLikeGlob(Str* s);
bool LooksLikeStaticGlob(syntax_asdl::compound_word* w);
extern Str* GLOB_META_CHARS;
Str* GlobEscape(Str* s);
extern Str* ERE_META_CHARS;
Str* ExtendedRegexEscape(Str* s);
Str* GlobUnescape(Str* s);
class _GlobParser : public Obj {
 public:
  _GlobParser(match::SimpleLexer* lexer);
  void _Next();
  List<syntax_asdl::glob_part_t*>* _ParseCharClass();
  Tuple2<List<syntax_asdl::glob_part_t*>*, List<Str*>*> Parse();

  match::SimpleLexer* lexer;
  int token_type;
  Str* token_val;
  List<Str*>* warnings;

  DISALLOW_COPY_AND_ASSIGN(_GlobParser)
};

constexpr uint16_t maskof__GlobParser() {
  return
    maskbit(offsetof(_GlobParser, lexer))
  | maskbit(offsetof(_GlobParser, token_val))
  | maskbit(offsetof(_GlobParser, warnings));
}

extern Str* _REGEX_CHARS_TO_ESCAPE;
Str* _GenerateERE(List<syntax_asdl::glob_part_t*>* parts);
Tuple2<Str*, List<Str*>*> GlobToERE(Str* pat);
class Globber : public Obj {
 public:
  Globber(optview::Exec* exec_opts);
  int _Glob(Str* arg, List<Str*>* out);
  int Expand(Str* arg, List<Str*>* out);
  int ExpandExtended(Str* glob_pat, Str* fnmatch_pat, List<Str*>* out);
  List<Str*>* OilFuncCall(Str* arg);

  optview::Exec* exec_opts;

  DISALLOW_COPY_AND_ASSIGN(Globber)
};

constexpr uint16_t maskof_Globber() {
  return
    maskbit(offsetof(Globber, exec_opts));
}


inline Str* fmt274(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Error expanding glob ", 21);
  gBuf.format_r(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}


}  // declare namespace glob_

namespace prompt {  // declare

extern Str* PROMPT_ERROR;
class _PromptEvaluatorCache : public Obj {
 public:
  _PromptEvaluatorCache();
  int _GetEuid();
  Str* Get(Str* name);

  Dict<Str*, Str*>* cache;
  int euid;

  DISALLOW_COPY_AND_ASSIGN(_PromptEvaluatorCache)
};

constexpr uint16_t maskof__PromptEvaluatorCache() {
  return
    maskbit(offsetof(_PromptEvaluatorCache, cache));
}

class Evaluator : public Obj {
 public:
  Evaluator(Str* lang, Str* version_str, parse_lib::ParseContext* parse_ctx, state::Mem* mem);
  void CheckCircularDeps();
  Str* _ReplaceBackslashCodes(List<Tuple2<int, Str*>*>* tokens);
  Str* EvalPrompt(runtime_asdl::value_t* UP_val);
  Str* EvalFirstPrompt();

  prompt::_PromptEvaluatorCache* cache;
  Str* lang;
  state::Mem* mem;
  Dict<Str*, syntax_asdl::compound_word*>* parse_cache;
  parse_lib::ParseContext* parse_ctx;
  Dict<Str*, List<Tuple2<int, Str*>*>*>* tokens_cache;
  Str* version_str;
  word_eval::AbstractWordEvaluator* word_ev;

  DISALLOW_COPY_AND_ASSIGN(Evaluator)
};

constexpr uint16_t maskof_Evaluator() {
  return
    maskbit(offsetof(Evaluator, cache))
  | maskbit(offsetof(Evaluator, lang))
  | maskbit(offsetof(Evaluator, mem))
  | maskbit(offsetof(Evaluator, parse_cache))
  | maskbit(offsetof(Evaluator, parse_ctx))
  | maskbit(offsetof(Evaluator, tokens_cache))
  | maskbit(offsetof(Evaluator, version_str))
  | maskbit(offsetof(Evaluator, word_ev));
}

extern Str* PROMPT_COMMAND;
class UserPlugin : public Obj {
 public:
  UserPlugin(state::Mem* mem, parse_lib::ParseContext* parse_ctx, cmd_eval::CommandEvaluator* cmd_ev, ui::ErrorFormatter* errfmt);
  void Run();

  alloc::Arena* arena;
  cmd_eval::CommandEvaluator* cmd_ev;
  ui::ErrorFormatter* errfmt;
  state::Mem* mem;
  Dict<Str*, syntax_asdl::command_t*>* parse_cache;
  parse_lib::ParseContext* parse_ctx;

  DISALLOW_COPY_AND_ASSIGN(UserPlugin)
};

constexpr uint16_t maskof_UserPlugin() {
  return
    maskbit(offsetof(UserPlugin, arena))
  | maskbit(offsetof(UserPlugin, cmd_ev))
  | maskbit(offsetof(UserPlugin, errfmt))
  | maskbit(offsetof(UserPlugin, mem))
  | maskbit(offsetof(UserPlugin, parse_cache))
  | maskbit(offsetof(UserPlugin, parse_ctx));
}


inline Str* fmt275(Str* a0) {
  gBuf.reset();
  gBuf.write_const("<Error: ", 8);
  gBuf.format_s(a0);
  gBuf.write_const(">", 1);
  return gBuf.getvalue();
}

inline Str* fmt276(Str* a0) {
  gBuf.reset();
  gBuf.write_const("<Error: \\", 9);
  gBuf.format_s(a0);
  gBuf.write_const(" not implemented in $PS1> ", 26);
  return gBuf.getvalue();
}

inline Str* fmt277(Str* a0) {
  gBuf.reset();
  gBuf.write_const("<ERROR: Can't parse PS1: ", 25);
  gBuf.format_s(a0);
  gBuf.write_const(">", 1);
  return gBuf.getvalue();
}


}  // declare namespace prompt

namespace sh_expr_eval {  // declare

runtime_asdl::value_t* OldValue(runtime_asdl::lvalue_t* lval, state::Mem* mem, optview::Exec* exec_opts);
class UnsafeArith : public Obj {
 public:
  UnsafeArith(state::Mem* mem, optview::Exec* exec_opts, parse_lib::ParseContext* parse_ctx, sh_expr_eval::ArithEvaluator* arith_ev, ui::ErrorFormatter* errfmt);
  runtime_asdl::lvalue_t* ParseLValue(Str* s, int span_id);
  syntax_asdl::braced_var_sub* ParseVarRef(Str* ref_str, syntax_asdl::Token* token);

  alloc::Arena* arena;
  sh_expr_eval::ArithEvaluator* arith_ev;
  ui::ErrorFormatter* errfmt;
  optview::Exec* exec_opts;
  state::Mem* mem;
  parse_lib::ParseContext* parse_ctx;

  DISALLOW_COPY_AND_ASSIGN(UnsafeArith)
};

constexpr uint16_t maskof_UnsafeArith() {
  return
    maskbit(offsetof(UnsafeArith, arena))
  | maskbit(offsetof(UnsafeArith, arith_ev))
  | maskbit(offsetof(UnsafeArith, errfmt))
  | maskbit(offsetof(UnsafeArith, exec_opts))
  | maskbit(offsetof(UnsafeArith, mem))
  | maskbit(offsetof(UnsafeArith, parse_ctx));
}

class ArithEvaluator : public Obj {
 public:
  ArithEvaluator(state::Mem* mem, optview::Exec* exec_opts, parse_lib::ParseContext* parse_ctx, ui::ErrorFormatter* errfmt);
  void CheckCircularDeps();
  int _StringToInteger(Str* s, int span_id);
  int _ValToIntOrError(runtime_asdl::value_t* val);
  int _ValToIntOrError(runtime_asdl::value_t* val, int span_id);
  Tuple2<int, runtime_asdl::lvalue_t*> _EvalLhsAndLookupArith(syntax_asdl::arith_expr_t* node);
  void _Store(runtime_asdl::lvalue_t* lval, int new_int);
  int EvalToInt(syntax_asdl::arith_expr_t* node);
  runtime_asdl::value_t* Eval(syntax_asdl::arith_expr_t* node);
  Str* EvalWordToString(syntax_asdl::arith_expr_t* node);
  runtime_asdl::lvalue_t* EvalShellLhs(syntax_asdl::sh_lhs_expr_t* node, int spid, runtime_asdl::scope_t which_scopes);
  Tuple2<Str*, int> _VarRefOrWord(syntax_asdl::arith_expr_t* anode);
  runtime_asdl::lvalue_t* EvalArithLhs(syntax_asdl::arith_expr_t* anode, int span_id);

  ui::ErrorFormatter* errfmt;
  optview::Exec* exec_opts;
  state::Mem* mem;
  parse_lib::ParseContext* parse_ctx;
  word_eval::StringWordEvaluator* word_ev;

  DISALLOW_COPY_AND_ASSIGN(ArithEvaluator)
};

constexpr uint16_t maskof_ArithEvaluator() {
  return
    maskbit_v(offsetof(ArithEvaluator, errfmt))
  | maskbit_v(offsetof(ArithEvaluator, exec_opts))
  | maskbit_v(offsetof(ArithEvaluator, mem))
  | maskbit_v(offsetof(ArithEvaluator, parse_ctx))
  | maskbit_v(offsetof(ArithEvaluator, word_ev));
}

class BoolEvaluator : public ArithEvaluator {
 public:
  BoolEvaluator(state::Mem* mem, optview::Exec* exec_opts, parse_lib::ParseContext* parse_ctx, ui::ErrorFormatter* errfmt);
  void Init_AlwaysStrict();
  int _StringToIntegerOrError(Str* s);
  int _StringToIntegerOrError(Str* s, syntax_asdl::word_t* blame_word);
  Str* _EvalCompoundWord(syntax_asdl::word_t* word);
  Str* _EvalCompoundWord(syntax_asdl::word_t* word, int eval_flags);
  bool EvalB(syntax_asdl::bool_expr_t* node);

  bool always_strict;

  DISALLOW_COPY_AND_ASSIGN(BoolEvaluator)
};


inline Str* fmt278(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Undefined variable ", 19);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt279(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Can't use [] on value of type ", 30);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt280(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Can't use [] on value of type ", 30);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt281() {
  gBuf.reset();
  gBuf.write_const("got invalid place expression", 28);
  return gBuf.getvalue();
}

inline Str* fmt282() {
  gBuf.reset();
  gBuf.write_const("expected a var name.  shopt -s eval_unsafe_arith allows a[i]", 60);
  return gBuf.getvalue();
}

inline Str* fmt283() {
  gBuf.reset();
  gBuf.write_const("Invalid var ref", 15);
  return gBuf.getvalue();
}

inline Str* fmt284(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid hex constant ", 21);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt285(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid octal constant ", 23);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt286(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid base for numeric constant ", 34);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt287(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid digits for numeric constant ", 36);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt288(Str* a0, int a1) {
  gBuf.reset();
  gBuf.write_const("Digits ", 7);
  gBuf.format_r(a0);
  gBuf.write_const(" out of range for base ", 23);
  gBuf.format_d(a1);
  return gBuf.getvalue();
}

inline Str* fmt289() {
  gBuf.reset();
  gBuf.write_const("Parse error in recursive arithmetic", 35);
  return gBuf.getvalue();
}

inline Str* fmt290(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid integer constant ", 25);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt291(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid integer constant ", 25);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt292(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid integer constant ", 25);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt293() {
  gBuf.reset();
  gBuf.write_const("Undefined value in arithmetic context", 37);
  return gBuf.getvalue();
}

inline Str* fmt294(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Expected a value convertible to integer, got ", 45);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt295(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Undefined variable ", 19);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt296(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Expected array or assoc in index expression, got ", 49);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt297() {
  gBuf.reset();
  gBuf.write_const("Divide by zero", 14);
  return gBuf.getvalue();
}

inline Str* fmt298() {
  gBuf.reset();
  gBuf.write_const("Divide by zero", 14);
  return gBuf.getvalue();
}

inline Str* fmt299(Str* a0) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(" isn't implemented", 18);
  return gBuf.getvalue();
}

inline Str* fmt300(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Invalid regex ", 14);
  gBuf.format_r(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}


}  // declare namespace sh_expr_eval

namespace split {  // declare

extern Str* DEFAULT_IFS;
List<Str*>* _SpansToParts(Str* s, List<Tuple2<runtime_asdl::span_t, int>*>* spans);
class SplitContext : public Obj {
 public:
  SplitContext(state::Mem* mem);
  split::IfsSplitter* _GetSplitter();
  split::IfsSplitter* _GetSplitter(Str* ifs);
  Str* GetJoinChar();
  Str* Escape(Str* s);
  List<Str*>* SplitForWordEval(Str* s);
  List<Str*>* SplitForWordEval(Str* s, Str* ifs);
  List<Tuple2<runtime_asdl::span_t, int>*>* SplitForRead(Str* line, bool allow_escape);
  List<Str*>* SplitFuncBuiltin(Str* s, Str* ifs);

  state::Mem* mem;
  Dict<Str*, split::IfsSplitter*>* splitters;

  DISALLOW_COPY_AND_ASSIGN(SplitContext)
};

constexpr uint16_t maskof_SplitContext() {
  return
    maskbit(offsetof(SplitContext, mem))
  | maskbit(offsetof(SplitContext, splitters));
}

class _BaseSplitter : public Obj {
 public:
  _BaseSplitter(Str* escape_chars);
  Str* Escape(Str* s);

  Str* escape_chars;

  DISALLOW_COPY_AND_ASSIGN(_BaseSplitter)
};

constexpr uint16_t maskof__BaseSplitter() {
  return
    maskbit_v(offsetof(_BaseSplitter, escape_chars));
}

class IfsSplitter : public _BaseSplitter {
 public:
  IfsSplitter(Str* ifs_whitespace, Str* ifs_other);
  List<Tuple2<runtime_asdl::span_t, int>*>* Split(Str* s, bool allow_escape);

  Str* ifs_other;
  Str* ifs_whitespace;

  DISALLOW_COPY_AND_ASSIGN(IfsSplitter)
};

constexpr uint16_t maskof_IfsSplitter() {
  return
    maskbit_v(offsetof(IfsSplitter, ifs_other))
  | maskbit_v(offsetof(IfsSplitter, ifs_whitespace));
}



}  // declare namespace split

namespace string_ops {  // declare

Str* Utf8Encode(int code);
extern Str* INCOMPLETE_CHAR;
extern Str* INVALID_CONT;
extern Str* INVALID_START;
void _CheckContinuationByte(Str* byte);
int _Utf8CharLen(int starting_byte);
int _NextUtf8Char(Str* s, int i);
int PreviousUtf8Char(Str* s, int i);
int CountUtf8Chars(Str* s);
int AdvanceUtf8Chars(Str* s, int num_chars, int byte_offset);
Str* DoUnarySuffixOp(Str* s, syntax_asdl::suffix_op__Unary* op, Str* arg, bool is_extglob);
List<Tuple2<int, int>*>* _AllMatchPositions(Str* s, Str* regex);
Str* _PatSubAll(Str* s, Str* regex, Str* replace_str);
class GlobReplacer : public Obj {
 public:
  GlobReplacer(Str* regex, Str* replace_str, int slash_spid);
  Str* Replace(Str* s, syntax_asdl::suffix_op__PatSub* op);

  Str* regex;
  Str* replace_str;
  int slash_spid;

  DISALLOW_COPY_AND_ASSIGN(GlobReplacer)
};

constexpr uint16_t maskof_GlobReplacer() {
  return
    maskbit(offsetof(GlobReplacer, regex))
  | maskbit(offsetof(GlobReplacer, replace_str));
}

Str* ShellQuoteB(Str* s);

inline Str* fmt301(Str* a0) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(" can't have an argument", 23);
  return gBuf.getvalue();
}

inline Str* fmt302(Str* a0) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(" can't have an argument", 23);
  return gBuf.getvalue();
}

inline Str* fmt303(Str* a0) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(" can't have an argument", 23);
  return gBuf.getvalue();
}

inline Str* fmt304(Str* a0) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const(" can't have an argument", 23);
  return gBuf.getvalue();
}

inline Str* fmt305(Str* a0) {
  gBuf.reset();
  gBuf.write_const("(", 1);
  gBuf.format_s(a0);
  gBuf.write_const(")", 1);
  return gBuf.getvalue();
}

inline Str* fmt306(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Error matching regex ", 21);
  gBuf.format_r(a0);
  gBuf.write_const(": ", 2);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}


}  // declare namespace string_ops

namespace tdop {  // declare

bool IsIndexable(syntax_asdl::arith_expr_t* node, bool parse_dynamic_arith);
bool _VarRefOrWord(syntax_asdl::arith_expr_t* node, bool dynamic_arith);
void CheckLhsExpr(syntax_asdl::arith_expr_t* node, bool dynamic_arith, syntax_asdl::word_t* blame_word);
syntax_asdl::arith_expr_t* NullError(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp);
syntax_asdl::arith_expr_t* NullConstant(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp);
syntax_asdl::arith_expr_t* NullParen(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp);
syntax_asdl::arith_expr_t* NullPrefixOp(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp);
syntax_asdl::arith_expr_t* LeftError(tdop::TdopParser* p, syntax_asdl::word_t* t, syntax_asdl::arith_expr_t* left, int rbp);
syntax_asdl::arith_expr_t* LeftBinaryOp(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp);
syntax_asdl::arith_expr_t* LeftAssign(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp);
class TdopParser : public Obj {
 public:
  TdopParser(tdop::ParserSpec* spec, word_parse::WordParser* w_parser, optview::Parse* parse_opts);
  int CurrentId();
  bool AtToken(int token_type);
  void Eat(int token_type);
  bool Next();
  syntax_asdl::arith_expr_t* ParseUntil(int rbp);
  syntax_asdl::arith_expr_t* Parse();

  syntax_asdl::word_t* cur_word;
  int op_id;
  optview::Parse* parse_opts;
  tdop::ParserSpec* spec;
  word_parse::WordParser* w_parser;

  DISALLOW_COPY_AND_ASSIGN(TdopParser)
};

constexpr uint16_t maskof_TdopParser() {
  return
    maskbit(offsetof(TdopParser, cur_word))
  | maskbit(offsetof(TdopParser, parse_opts))
  | maskbit(offsetof(TdopParser, spec))
  | maskbit(offsetof(TdopParser, w_parser));
}


inline Str* fmt307() {
  gBuf.reset();
  gBuf.write_const("Left-hand side of this assignment is invalid", 44);
  return gBuf.getvalue();
}

inline Str* fmt308() {
  gBuf.reset();
  gBuf.write_const("Token can't be used in prefix position", 38);
  return gBuf.getvalue();
}

inline Str* fmt309() {
  gBuf.reset();
  gBuf.write_const("Token can't be used in infix position", 37);
  return gBuf.getvalue();
}

inline Str* fmt310(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Parser expected ", 16);
  gBuf.format_s(a0);
  gBuf.write_const(", got ", 6);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}

inline Str* fmt311() {
  gBuf.reset();
  gBuf.write_const("Unexpected end of input", 23);
  return gBuf.getvalue();
}


}  // declare namespace tdop

namespace word_ {  // declare

int LiteralId(syntax_asdl::word_part_t* p);
Tuple3<bool, Str*, bool> _EvalWordPart(syntax_asdl::word_part_t* part);
Tuple3<bool, Str*, bool> StaticEval(syntax_asdl::word_t* UP_w);
int LeftMostSpanForPart(syntax_asdl::word_part_t* part);
int _RightMostSpanForPart(syntax_asdl::word_part_t* part);
int LeftMostSpanForWord(syntax_asdl::word_t* w);
int RightMostSpanForWord(syntax_asdl::word_t* w);
syntax_asdl::compound_word* TildeDetect(syntax_asdl::word_t* UP_w);
void TildeDetectAssign(syntax_asdl::compound_word* w);
List<syntax_asdl::word_t*>* TildeDetectAll(List<syntax_asdl::word_t*>* words);
bool HasArrayPart(syntax_asdl::compound_word* w);
Str* ShFunctionName(syntax_asdl::compound_word* w);
syntax_asdl::Token* LooksLikeArithVar(syntax_asdl::word_t* UP_w);
bool IsVarLike(syntax_asdl::compound_word* w);
Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int> DetectShAssignment(syntax_asdl::compound_word* w);
Tuple2<syntax_asdl::compound_word*, syntax_asdl::compound_word*>* DetectAssocPair(syntax_asdl::compound_word* w);
Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*> KeywordToken(syntax_asdl::compound_word* w);
syntax_asdl::Token* LiteralToken(syntax_asdl::word_t* UP_w);
int ArithId(syntax_asdl::word_t* w);
int BoolId(syntax_asdl::word_t* w);
int CommandId(syntax_asdl::word_t* w);
id_kind_asdl::Kind_t CommandKind(syntax_asdl::word_t* w);
bool IsVarSub(syntax_asdl::word_t* w);
int SpanForLhsExpr(syntax_asdl::sh_lhs_expr_t* node);
int SpanIdFromError(error::_ErrorWithLocation* error);
syntax_asdl::compound_word* ErrorWord(Str* error_str);
Str* Pretty(syntax_asdl::word_t* w);
class ctx_EmitDocToken : public Obj {
 public:
  ctx_EmitDocToken(word_parse::WordParser* w_parser);
  ~ctx_EmitDocToken();

  word_parse::WordParser* w_parser;

  DISALLOW_COPY_AND_ASSIGN(ctx_EmitDocToken)
};

constexpr uint16_t maskof_ctx_EmitDocToken() {
  return
    maskbit(offsetof(ctx_EmitDocToken, w_parser));
}

class ctx_Multiline : public Obj {
 public:
  ctx_Multiline(word_parse::WordParser* w_parser);
  ~ctx_Multiline();

  word_parse::WordParser* w_parser;

  DISALLOW_COPY_AND_ASSIGN(ctx_Multiline)
};

constexpr uint16_t maskof_ctx_Multiline() {
  return
    maskbit(offsetof(ctx_Multiline, w_parser));
}



}  // declare namespace word_

namespace word_compile {  // declare

syntax_asdl::CharCode* EvalCharLiteralForRegex(syntax_asdl::Token* tok);
Str* EvalCStringToken(syntax_asdl::Token* tok);
Str* EvalSingleQuoted(syntax_asdl::single_quoted* part);
bool IsLeadingSpace(Str* s);
void RemoveLeadingSpaceDQ(List<syntax_asdl::word_part_t*>* parts);
void RemoveLeadingSpaceSQ(List<syntax_asdl::Token*>* tokens);


}  // declare namespace word_compile

namespace word_eval {  // declare

extern int QUOTED;
extern int IS_SUBST;
extern int EXTGLOB_FILES;
extern int EXTGLOB_MATCH;
extern int EXTGLOB_NESTED;
extern int QUOTE_FNMATCH;
extern int QUOTE_ERE;
extern List<Str*>* _STRING_AND_ARRAY;
bool ShouldArrayDecay(Str* var_name, optview::Exec* exec_opts);
bool ShouldArrayDecay(Str* var_name, optview::Exec* exec_opts, bool is_plain_var_sub);
runtime_asdl::value_t* DecayArray(runtime_asdl::value_t* val);
Str* GetArrayItem(List<Str*>* strs, int index);
extern Str* ASSIGN_ARG_RE;
runtime_asdl::assign_arg* _SplitAssignArg(Str* arg, int word_spid);
Str* _BackslashEscape(Str* s);
runtime_asdl::part_value_t* _ValueToPartValue(runtime_asdl::value_t* val, bool quoted);
List<List<Tuple3<Str*, bool, bool>*>*>* _MakeWordFrames(List<runtime_asdl::part_value_t*>* part_vals);
Str* _DecayPartValuesToString(List<runtime_asdl::part_value_t*>* part_vals, Str* join_char);
runtime_asdl::value_t* _PerformSlice(runtime_asdl::value_t* val, int begin, int length, bool has_length, syntax_asdl::braced_var_sub* part, runtime_asdl::value__Str* arg0_val);
class StringWordEvaluator : public Obj {
 public:
  StringWordEvaluator();
  runtime_asdl::value__Str* EvalWordToString(syntax_asdl::word_t* w);
  virtual runtime_asdl::value__Str* EvalWordToString(syntax_asdl::word_t* w, int eval_flags);

  DISALLOW_COPY_AND_ASSIGN(StringWordEvaluator)
};

Str* _GetDollarHyphen(optview::Exec* exec_opts);
class TildeEvaluator : public Obj {
 public:
  TildeEvaluator(state::Mem* mem, optview::Exec* exec_opts);
  Str* Eval(syntax_asdl::Token* token);

  optview::Exec* exec_opts;
  state::Mem* mem;

  DISALLOW_COPY_AND_ASSIGN(TildeEvaluator)
};

constexpr uint16_t maskof_TildeEvaluator() {
  return
    maskbit(offsetof(TildeEvaluator, exec_opts))
  | maskbit(offsetof(TildeEvaluator, mem));
}

class AbstractWordEvaluator : public StringWordEvaluator {
 public:
  AbstractWordEvaluator(state::Mem* mem, optview::Exec* exec_opts, state::MutableOpts* mutable_opts, split::SplitContext* splitter, ui::ErrorFormatter* errfmt);
  virtual void CheckCircularDeps();
  virtual runtime_asdl::part_value_t* _EvalCommandSub(syntax_asdl::command_sub* cs_part, bool quoted);
  virtual runtime_asdl::part_value_t* _EvalProcessSub(syntax_asdl::command_sub* cs_part);
  runtime_asdl::value_t* _EvalVarNum(int var_num);
  runtime_asdl::value_t* _EvalSpecialVar(int op_id, bool quoted, runtime_asdl::VarSubState* vsub_state);
  bool _ApplyTestOp(runtime_asdl::value_t* val, syntax_asdl::suffix_op__Unary* op, bool quoted, List<runtime_asdl::part_value_t*>* part_vals, runtime_asdl::VTestPlace* vtest_place, syntax_asdl::Token* blame_token);
  runtime_asdl::value_t* _Length(runtime_asdl::value_t* val, syntax_asdl::Token* token);
  runtime_asdl::value_t* _Keys(runtime_asdl::value_t* val, syntax_asdl::Token* token);
  runtime_asdl::value_t* _EvalVarRef(runtime_asdl::value_t* val, syntax_asdl::Token* token, bool quoted, runtime_asdl::VarSubState* vsub_state, runtime_asdl::VTestPlace* vtest_place);
  runtime_asdl::value_t* _ApplyUnarySuffixOp(runtime_asdl::value_t* val, syntax_asdl::suffix_op__Unary* op);
  runtime_asdl::value_t* _PatSub(runtime_asdl::value_t* val, syntax_asdl::suffix_op__PatSub* op);
  runtime_asdl::value_t* _Slice(runtime_asdl::value_t* val, syntax_asdl::suffix_op__Slice* op, Str* var_name, syntax_asdl::braced_var_sub* part);
  Tuple2<runtime_asdl::value__Str*, bool> _Nullary(runtime_asdl::value_t* val, syntax_asdl::Token* op, Str* var_name);
  runtime_asdl::value_t* _WholeArray(runtime_asdl::value_t* val, syntax_asdl::braced_var_sub* part, bool quoted, runtime_asdl::VarSubState* vsub_state);
  runtime_asdl::value_t* _ArrayIndex(runtime_asdl::value_t* val, syntax_asdl::braced_var_sub* part, runtime_asdl::VTestPlace* vtest_place);
  void _EvalDoubleQuoted(List<syntax_asdl::word_part_t*>* parts, List<runtime_asdl::part_value_t*>* part_vals);
  Str* EvalDoubleQuotedToString(syntax_asdl::double_quoted* dq_part);
  runtime_asdl::value__Str* _DecayArray(runtime_asdl::value__MaybeStrArray* val);
  runtime_asdl::value_t* _EmptyStrOrError(runtime_asdl::value_t* val, syntax_asdl::Token* token);
  runtime_asdl::value_t* _EmptyMaybeStrArrayOrError(syntax_asdl::Token* token);
  runtime_asdl::value_t* _EvalBracketOp(runtime_asdl::value_t* val, syntax_asdl::braced_var_sub* part, bool quoted, runtime_asdl::VarSubState* vsub_state, runtime_asdl::VTestPlace* vtest_place);
  runtime_asdl::value_t* _VarRefValue(syntax_asdl::braced_var_sub* part, bool quoted, runtime_asdl::VarSubState* vsub_state, runtime_asdl::VTestPlace* vtest_place);
  void _EvalBracedVarSub(syntax_asdl::braced_var_sub* part, List<runtime_asdl::part_value_t*>* part_vals, bool quoted);
  Str* _ConcatPartVals(List<runtime_asdl::part_value_t*>* part_vals, int span_id);
  Str* EvalBracedVarSubToString(syntax_asdl::braced_var_sub* part);
  void _EvalSimpleVarSub(syntax_asdl::Token* token, List<runtime_asdl::part_value_t*>* part_vals, bool quoted);
  Str* EvalSimpleVarSubToString(syntax_asdl::Token* tok);
  void _EvalExtGlob(syntax_asdl::word_part__ExtGlob* part, List<runtime_asdl::part_value_t*>* part_vals);
  void _TranslateExtGlob(List<runtime_asdl::part_value_t*>* part_vals, syntax_asdl::compound_word* w, List<Str*>* glob_parts, List<Str*>* fnmatch_parts);
  void _EvalWordPart(syntax_asdl::word_part_t* part, List<runtime_asdl::part_value_t*>* part_vals, int flags);
  void _EvalWordToParts(syntax_asdl::word_t* w, List<runtime_asdl::part_value_t*>* part_vals, int eval_flags);
  void _PartValsToString(List<runtime_asdl::part_value_t*>* part_vals, syntax_asdl::compound_word* w, int eval_flags, List<Str*>* strs);
  runtime_asdl::value__Str* EvalWordToString(syntax_asdl::word_t* UP_w);
  virtual runtime_asdl::value__Str* EvalWordToString(syntax_asdl::word_t* UP_w, int eval_flags);
  Tuple2<runtime_asdl::value__Str*, bool> EvalWordToPattern(syntax_asdl::word_t* UP_w);
  runtime_asdl::value__Str* EvalForPlugin(syntax_asdl::compound_word* w);
  runtime_asdl::value_t* EvalRhsWord(syntax_asdl::word_t* UP_w);
  void _EvalWordFrame(List<Tuple3<Str*, bool, bool>*>* frame, List<Str*>* argv);
  List<Str*>* _EvalWordToArgv(syntax_asdl::compound_word* w);
  runtime_asdl::cmd_value__Assign* _EvalAssignBuiltin(int builtin_id, Str* arg0, List<syntax_asdl::compound_word*>* words);
  runtime_asdl::cmd_value_t* SimpleEvalWordSequence2(List<syntax_asdl::compound_word*>* words, bool allow_assign);
  runtime_asdl::cmd_value_t* EvalWordSequence2(List<syntax_asdl::compound_word*>* words);
  runtime_asdl::cmd_value_t* EvalWordSequence2(List<syntax_asdl::compound_word*>* words, bool allow_assign);
  List<Str*>* EvalWordSequence(List<syntax_asdl::compound_word*>* words);

  sh_expr_eval::ArithEvaluator* arith_ev;
  ui::ErrorFormatter* errfmt;
  optview::Exec* exec_opts;
  expr_eval::OilEvaluator* expr_ev;
  glob_::Globber* globber;
  state::Mem* mem;
  state::MutableOpts* mutable_opts;
  prompt::Evaluator* prompt_ev;
  split::SplitContext* splitter;
  word_eval::TildeEvaluator* tilde_ev;
  sh_expr_eval::UnsafeArith* unsafe_arith;

  DISALLOW_COPY_AND_ASSIGN(AbstractWordEvaluator)
};

constexpr uint16_t maskof_AbstractWordEvaluator() {
  return
    maskbit_v(offsetof(AbstractWordEvaluator, arith_ev))
  | maskbit_v(offsetof(AbstractWordEvaluator, errfmt))
  | maskbit_v(offsetof(AbstractWordEvaluator, exec_opts))
  | maskbit_v(offsetof(AbstractWordEvaluator, expr_ev))
  | maskbit_v(offsetof(AbstractWordEvaluator, globber))
  | maskbit_v(offsetof(AbstractWordEvaluator, mem))
  | maskbit_v(offsetof(AbstractWordEvaluator, mutable_opts))
  | maskbit_v(offsetof(AbstractWordEvaluator, prompt_ev))
  | maskbit_v(offsetof(AbstractWordEvaluator, splitter))
  | maskbit_v(offsetof(AbstractWordEvaluator, tilde_ev))
  | maskbit_v(offsetof(AbstractWordEvaluator, unsafe_arith));
}

class NormalWordEvaluator : public AbstractWordEvaluator {
 public:
  NormalWordEvaluator(state::Mem* mem, optview::Exec* exec_opts, state::MutableOpts* mutable_opts, split::SplitContext* splitter, ui::ErrorFormatter* errfmt);
  virtual void CheckCircularDeps();
  virtual runtime_asdl::part_value_t* _EvalCommandSub(syntax_asdl::command_sub* cs_part, bool quoted);
  virtual runtime_asdl::part_value__String* _EvalProcessSub(syntax_asdl::command_sub* cs_part);

  vm::_Executor* shell_ex;

  DISALLOW_COPY_AND_ASSIGN(NormalWordEvaluator)
};

constexpr uint16_t maskof_NormalWordEvaluator() {
  return
    maskbit_v(offsetof(NormalWordEvaluator, shell_ex));
}

extern Str* _DUMMY;
class CompletionWordEvaluator : public AbstractWordEvaluator {
 public:
  virtual void CheckCircularDeps();
  virtual runtime_asdl::part_value_t* _EvalCommandSub(syntax_asdl::command_sub* cs_part, bool quoted);
  virtual runtime_asdl::part_value__String* _EvalProcessSub(syntax_asdl::command_sub* cs_part);

  DISALLOW_COPY_AND_ASSIGN(CompletionWordEvaluator)
};


inline Str* fmt312(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Assignment builtin expected NAME=value, got ", 44);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt313(int a0) {
  gBuf.reset();
  gBuf.write_const("The length index of a array slice can't be negative: ", 53);
  gBuf.format_d(a0);
  return gBuf.getvalue();
}

inline Str* fmt314() {
  gBuf.reset();
  gBuf.write_const("Can't slice associative arrays", 30);
  return gBuf.getvalue();
}

inline Str* fmt315() {
  gBuf.reset();
  gBuf.write_const("Error expanding tilde (e.g. invalid user)", 41);
  return gBuf.getvalue();
}

inline Str* fmt316(Str* a0) {
  gBuf.reset();
  gBuf.write_const("unset variable ", 15);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt317() {
  gBuf.reset();
  gBuf.write_const("a[i] not allowed without shopt -s eval_unsafe_arith", 51);
  return gBuf.getvalue();
}

inline Str* fmt318() {
  gBuf.reset();
  gBuf.write_const("extended globs not supported in ${x//GLOB/}", 43);
  return gBuf.getvalue();
}

inline Str* fmt319(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Can't use @P on ", 16);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt320(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Can't use @Q on ", 16);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt321(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Var op ", 7);
  gBuf.format_r(a0);
  gBuf.write_const(" not implemented", 16);
  return gBuf.getvalue();
}

inline Str* fmt322() {
  gBuf.reset();
  gBuf.write_const("Can't index string with @", 25);
  return gBuf.getvalue();
}

inline Str* fmt323() {
  gBuf.reset();
  gBuf.write_const("Can't index string with *", 25);
  return gBuf.getvalue();
}

inline Str* fmt324(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Can't index string ", 19);
  gBuf.format_r(a0);
  gBuf.write_const(" with integer", 13);
  return gBuf.getvalue();
}

inline Str* fmt325(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Undefined variable ", 19);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt326(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Undefined array ", 16);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt327(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Array ", 6);
  gBuf.format_r(a0);
  gBuf.write_const(" can't be referred to as a scalar (without @ or *)", 50);
  return gBuf.getvalue();
}

inline Str* fmt328() {
  gBuf.reset();
  gBuf.write_const("Test operation not allowed with ${!array[@]}", 44);
  return gBuf.getvalue();
}

inline Str* fmt329() {
  gBuf.reset();
  gBuf.write_const("Not implemented", 15);
  return gBuf.getvalue();
}

inline Str* fmt330() {
  gBuf.reset();
  gBuf.write_const("Illegal array word part (strict_array)", 38);
  return gBuf.getvalue();
}

inline Str* fmt331(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Array ", 6);
  gBuf.format_r(a0);
  gBuf.write_const(" can't be referred to as a scalar (without @ or *)", 50);
  return gBuf.getvalue();
}

inline Str* fmt332() {
  gBuf.reset();
  gBuf.write_const("Extended globs and arrays can't appear in the same word", 55);
  return gBuf.getvalue();
}

inline Str* fmt333() {
  gBuf.reset();
  gBuf.write_const("Unexpected array literal", 24);
  return gBuf.getvalue();
}

inline Str* fmt334() {
  gBuf.reset();
  gBuf.write_const("Unexpected associative array literal", 36);
  return gBuf.getvalue();
}

inline Str* fmt335(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Can't splice ", 13);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt336(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Extended glob ", 14);
  gBuf.format_r(a0);
  gBuf.write_const(" matched no files", 17);
  return gBuf.getvalue();
}

inline Str* fmt337() {
  gBuf.reset();
  gBuf.write_const("Extended glob not allowed in this word", 38);
  return gBuf.getvalue();
}

inline Str* fmt338() {
  gBuf.reset();
  gBuf.write_const("This word should yield a string, but it contains an array", 57);
  return gBuf.getvalue();
}

inline Str* fmt339() {
  gBuf.reset();
  gBuf.write_const("extended glob not allowed in this word", 38);
  return gBuf.getvalue();
}

inline Str* fmt340(Str* a0) {
  gBuf.reset();
  gBuf.write_const("<Runtime error: ", 16);
  gBuf.format_s(a0);
  gBuf.write_const(">", 1);
  return gBuf.getvalue();
}

inline Str* fmt341(Str* a0) {
  gBuf.reset();
  gBuf.write_const("<I/O error: ", 12);
  gBuf.format_s(a0);
  gBuf.write_const(">", 1);
  return gBuf.getvalue();
}

inline Str* fmt342(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Pattern ", 8);
  gBuf.format_r(a0);
  gBuf.write_const(" matched no files", 17);
  return gBuf.getvalue();
}

inline Str* fmt343() {
  gBuf.reset();
  gBuf.write_const("LHS array not allowed in assignment builtin", 43);
  return gBuf.getvalue();
}

inline Str* fmt344(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Pattern ", 8);
  gBuf.format_r(a0);
  gBuf.write_const(" matched no files", 17);
  return gBuf.getvalue();
}


}  // declare namespace word_eval

namespace word_parse {  // declare

extern List<id_kind_asdl::Kind_t>* KINDS_THAT_END_WORDS;
class WordEmitter : public Obj {
 public:
  WordEmitter();
  virtual syntax_asdl::word_t* ReadWord(types_asdl::lex_mode_t lex_mode);

  DISALLOW_COPY_AND_ASSIGN(WordEmitter)
};

class WordParser : public WordEmitter {
 public:
  WordParser(parse_lib::ParseContext* parse_ctx, lexer::Lexer* lexer, reader::_Reader* line_reader);
  void Init(types_asdl::lex_mode_t lex_mode);
  void Reset();
  void _Peek();
  void _Next(types_asdl::lex_mode_t lex_mode);
  syntax_asdl::word_t* _ReadVarOpArg(types_asdl::lex_mode_t arg_lex_mode);
  syntax_asdl::compound_word* _ReadVarOpArg2(types_asdl::lex_mode_t arg_lex_mode, int eof_type);
  syntax_asdl::compound_word* _ReadVarOpArg2(types_asdl::lex_mode_t arg_lex_mode, int eof_type, bool empty_ok);
  syntax_asdl::suffix_op__Slice* _ReadSliceVarOp();
  syntax_asdl::suffix_op__PatSub* _ReadPatSubVarOp();
  syntax_asdl::bracket_op_t* _ReadSubscript();
  syntax_asdl::braced_var_sub* _ParseVarOf();
  syntax_asdl::braced_var_sub* _ParseVarExpr(types_asdl::lex_mode_t arg_lex_mode);
  syntax_asdl::braced_var_sub* _ParseVarExpr(types_asdl::lex_mode_t arg_lex_mode, bool allow_query);
  Tuple2<syntax_asdl::braced_var_sub*, syntax_asdl::Token*> ReadBracedVarSub(syntax_asdl::Token* left_token);
  syntax_asdl::braced_var_sub* _ReadBracedVarSub(syntax_asdl::Token* left_token, bool d_quoted);
  syntax_asdl::single_quoted* _ReadSingleQuoted(syntax_asdl::Token* left_token, types_asdl::lex_mode_t lex_mode);
  syntax_asdl::Token* ReadSingleQuoted(types_asdl::lex_mode_t lex_mode, syntax_asdl::Token* left_token, List<syntax_asdl::Token*>* tokens, bool is_oil_expr);
  syntax_asdl::word_part_t* _ReadDoubleQuotedLeftParts();
  syntax_asdl::word_part_t* _ReadUnquotedLeftParts(bool try_triple_quote, List<bool>* triple_out);
  syntax_asdl::word_part__ExtGlob* _ReadExtGlob();
  void _ReadLikeDQ(syntax_asdl::Token* left_token, bool is_oil_expr, List<syntax_asdl::word_part_t*>* out_parts);
  syntax_asdl::double_quoted* _ReadDoubleQuoted(syntax_asdl::Token* left_token);
  syntax_asdl::Token* ReadDoubleQuoted(syntax_asdl::Token* left_token, List<syntax_asdl::word_part_t*>* parts);
  syntax_asdl::command_sub* _ReadCommandSub(int left_id);
  syntax_asdl::word_part__ExprSub* _ReadExprSub(types_asdl::lex_mode_t lex_mode);
  syntax_asdl::command__VarDecl* ParseVarDecl(syntax_asdl::Token* kw_token);
  syntax_asdl::command__PlaceMutation* ParsePlaceMutation(syntax_asdl::Token* kw_token, cmd_parse::VarChecker* var_checker);
  syntax_asdl::expr_t* ParseBareDecl();
  syntax_asdl::expr_t* ParseCommandExpr();
  void ParseProc(syntax_asdl::command__Proc* node);
  void ParseImport(syntax_asdl::command__Import* node);
  syntax_asdl::arith_expr_t* _ReadArithExpr(int end_id);
  syntax_asdl::word_part__ArithSub* _ReadArithSub();
  syntax_asdl::arith_expr_t* ReadDParen();
  void _NextNonSpace();
  syntax_asdl::command__ForExpr* ReadForExpression();
  syntax_asdl::word_part_t* _ReadArrayLiteral();
  void _ParseInlineCallArgs(syntax_asdl::ArgList* arglist);
  syntax_asdl::ArgList* ParseProcCallArgs();
  bool _MaybeReadWholeWord(bool is_first, types_asdl::lex_mode_t lex_mode, List<syntax_asdl::word_part_t*>* parts);
  syntax_asdl::compound_word* _ReadCompoundWord(types_asdl::lex_mode_t lex_mode);
  syntax_asdl::compound_word* _ReadCompoundWord3(types_asdl::lex_mode_t lex_mode, int eof_type, bool empty_ok);
  Tuple2<syntax_asdl::word_t*, bool> _ReadArithWord();
  Tuple2<syntax_asdl::word_t*, bool> _ReadWord(types_asdl::lex_mode_t lex_mode);
  syntax_asdl::braced_var_sub* ParseVarRef();
  int LookPastSpace();
  bool LookAheadFuncParens();
  virtual syntax_asdl::word_t* ReadWord(types_asdl::lex_mode_t lex_mode);
  void ReadHereDocBody(List<syntax_asdl::word_part_t*>* parts);
  syntax_asdl::compound_word* ReadForPlugin();
  void EmitDocToken(bool b);
  void Multiline(bool b);

  tdop::TdopParser* a_parser;
  alloc::Arena* arena;
  syntax_asdl::word_t* buffered_word;
  syntax_asdl::Token* cur_token;
  bool emit_doc_token;
  lexer::Lexer* lexer;
  reader::_Reader* line_reader;
  bool multiline;
  int newline_state;
  types_asdl::lex_mode_t next_lex_mode;
  parse_lib::ParseContext* parse_ctx;
  optview::Parse* parse_opts;
  bool returned_newline;
  id_kind_asdl::Kind_t token_kind;
  int token_type;

  DISALLOW_COPY_AND_ASSIGN(WordParser)
};

constexpr uint16_t maskof_WordParser() {
  return
    maskbit_v(offsetof(WordParser, a_parser))
  | maskbit_v(offsetof(WordParser, arena))
  | maskbit_v(offsetof(WordParser, buffered_word))
  | maskbit_v(offsetof(WordParser, cur_token))
  | maskbit_v(offsetof(WordParser, lexer))
  | maskbit_v(offsetof(WordParser, line_reader))
  | maskbit_v(offsetof(WordParser, parse_ctx))
  | maskbit_v(offsetof(WordParser, parse_opts));
}


inline Str* fmt345() {
  gBuf.reset();
  gBuf.write_const("Expected : or } in slice", 24);
  return gBuf.getvalue();
}

inline Str* fmt346() {
  gBuf.reset();
  gBuf.write_const("Pattern in ${x/pat/replace} must not be empty", 45);
  return gBuf.getvalue();
}

inline Str* fmt347(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Expected } after replacement string, got ", 41);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt348() {
  gBuf.reset();
  gBuf.write_const("Expected } or / to close pattern", 32);
  return gBuf.getvalue();
}

inline Str* fmt349() {
  gBuf.reset();
  gBuf.write_const("Expected ] to close subscript", 29);
  return gBuf.getvalue();
}

inline Str* fmt350() {
  gBuf.reset();
  gBuf.write_const("Expected } to close ${", 22);
  return gBuf.getvalue();
}

inline Str* fmt351() {
  gBuf.reset();
  gBuf.write_const("Expected } to close ${", 22);
  return gBuf.getvalue();
}

inline Str* fmt352() {
  gBuf.reset();
  gBuf.write_const("Expected a constant argument", 28);
  return gBuf.getvalue();
}

inline Str* fmt353() {
  gBuf.reset();
  gBuf.write_const("Expected } to close ${", 22);
  return gBuf.getvalue();
}

inline Str* fmt354() {
  gBuf.reset();
  gBuf.write_const("Expected } to close ${", 22);
  return gBuf.getvalue();
}

inline Str* fmt355(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Unexpected token in ${} (", 25);
  gBuf.format_s(a0);
  gBuf.write_const(")", 1);
  return gBuf.getvalue();
}

inline Str* fmt356(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Unexpected token in ${} (", 25);
  gBuf.format_s(a0);
  gBuf.write_const(")", 1);
  return gBuf.getvalue();
}

inline Str* fmt357() {
  gBuf.reset();
  gBuf.write_const("Expected } to close ${", 22);
  return gBuf.getvalue();
}

inline Str* fmt358() {
  gBuf.reset();
  gBuf.write_const("Expected } after length expression", 34);
  return gBuf.getvalue();
}

inline Str* fmt359() {
  gBuf.reset();
  gBuf.write_const("TODO: ${.myproc builtin sub}", 28);
  return gBuf.getvalue();
}

inline Str* fmt360() {
  gBuf.reset();
  gBuf.write_const("Unexpected token in ${}", 23);
  return gBuf.getvalue();
}

inline Str* fmt361() {
  gBuf.reset();
  gBuf.write_const("Strings with backslashes should look like r'\\n' or $'\\n'", 56);
  return gBuf.getvalue();
}

inline Str* fmt362() {
  gBuf.reset();
  gBuf.write_const("Use \\xhh or \\u{...} instead of octal escapes in Oil strings", 59);
  return gBuf.getvalue();
}

inline Str* fmt363() {
  gBuf.reset();
  gBuf.write_const("Invalid hex escape in Oil string (must be \\xHH)", 47);
  return gBuf.getvalue();
}

inline Str* fmt364() {
  gBuf.reset();
  gBuf.write_const("Invalid char escape in C-style string literal", 45);
  return gBuf.getvalue();
}

inline Str* fmt365() {
  gBuf.reset();
  gBuf.write_const("Unexpected EOF in single-quoted string that began here", 54);
  return gBuf.getvalue();
}

inline Str* fmt366() {
  gBuf.reset();
  gBuf.write_const("Unexpected EOF reading extended glob that began here", 52);
  return gBuf.getvalue();
}

inline Str* fmt367() {
  gBuf.reset();
  gBuf.write_const("Invalid char escape in double quoted string", 43);
  return gBuf.getvalue();
}

inline Str* fmt368() {
  gBuf.reset();
  gBuf.write_const("Literal $ should be quoted like \\$", 34);
  return gBuf.getvalue();
}

inline Str* fmt369() {
  gBuf.reset();
  gBuf.write_const("Invalid backtick: use $(cmd) or \\` in Oil strings", 49);
  return gBuf.getvalue();
}

inline Str* fmt370() {
  gBuf.reset();
  gBuf.write_const("Unexpected EOF reading double-quoted string that began here", 59);
  return gBuf.getvalue();
}

inline Str* fmt371() {
  gBuf.reset();
  gBuf.write_const("Use $(cmd) instead of backticks (parse_backticks)", 49);
  return gBuf.getvalue();
}

inline Str* fmt372() {
  gBuf.reset();
  gBuf.write_const("Unexpected EOF while looking for closing backtick", 49);
  return gBuf.getvalue();
}

inline Str* fmt373(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Invalid proc name ", 18);
  gBuf.format_s(a0);
  return gBuf.getvalue();
}

inline Str* fmt374(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.write_const("Unexpected token after arithmetic expression (", 46);
  gBuf.format_s(a0);
  gBuf.write_const(" != ", 4);
  gBuf.format_s(a1);
  gBuf.write_const(")", 1);
  return gBuf.getvalue();
}

inline Str* fmt375() {
  gBuf.reset();
  gBuf.write_const("Expected second ) to end arith sub", 34);
  return gBuf.getvalue();
}

inline Str* fmt376() {
  gBuf.reset();
  gBuf.write_const("Expected second ) to end arith statement", 40);
  return gBuf.getvalue();
}

inline Str* fmt377() {
  gBuf.reset();
  gBuf.write_const("Expected ; here", 15);
  return gBuf.getvalue();
}

inline Str* fmt378() {
  gBuf.reset();
  gBuf.write_const("Expected ; here", 15);
  return gBuf.getvalue();
}

inline Str* fmt379() {
  gBuf.reset();
  gBuf.write_const("Expected ) to end for loop expression", 37);
  return gBuf.getvalue();
}

inline Str* fmt380() {
  gBuf.reset();
  gBuf.write_const("Expected ( after =", 18);
  return gBuf.getvalue();
}

inline Str* fmt381() {
  gBuf.reset();
  gBuf.write_const("Unexpected token in array literal", 33);
  return gBuf.getvalue();
}

inline Str* fmt382() {
  gBuf.reset();
  gBuf.write_const("Expected associative array pair", 31);
  return gBuf.getvalue();
}

inline Str* fmt383() {
  gBuf.reset();
  gBuf.write_const("Invalid char escape (parse_backslash)", 37);
  return gBuf.getvalue();
}

inline Str* fmt384() {
  gBuf.reset();
  gBuf.write_const("Unexpected token after array literal", 36);
  return gBuf.getvalue();
}

inline Str* fmt385() {
  gBuf.reset();
  gBuf.write_const("Unexpected token after array splice", 35);
  return gBuf.getvalue();
}

inline Str* fmt386() {
  gBuf.reset();
  gBuf.write_const("TODO: @{.myproc builtin sub}", 28);
  return gBuf.getvalue();
}

inline Str* fmt387() {
  gBuf.reset();
  gBuf.write_const("Literal @ starting a word must be quoted (parse_at_all)", 55);
  return gBuf.getvalue();
}

inline Str* fmt388(Str* a0) {
  gBuf.reset();
  gBuf.write_const("next_byte ", 10);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt389() {
  gBuf.reset();
  gBuf.write_const("Literal $ should be quoted like \\$", 34);
  return gBuf.getvalue();
}

inline Str* fmt390() {
  gBuf.reset();
  gBuf.write_const("Unexpected token after @()", 26);
  return gBuf.getvalue();
}

inline Str* fmt391() {
  gBuf.reset();
  gBuf.write_const("Word has unbalanced { }.  Maybe add a space or quote it like \\{", 63);
  return gBuf.getvalue();
}

inline Str* fmt392() {
  gBuf.reset();
  gBuf.write_const("Unexpected parts after triple quoted string", 43);
  return gBuf.getvalue();
}

inline Str* fmt393(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Unexpected token while parsing arithmetic: ", 43);
  gBuf.format_r(a0);
  return gBuf.getvalue();
}

inline Str* fmt394() {
  gBuf.reset();
  gBuf.write_const("Invalid blank line in multiline mode", 36);
  return gBuf.getvalue();
}

inline Str* fmt395() {
  gBuf.reset();
  gBuf.write_const("Invalid var ref", 15);
  return gBuf.getvalue();
}

inline Str* fmt396() {
  gBuf.reset();
  gBuf.write_const("Expected end of var ref", 23);
  return gBuf.getvalue();
}


}  // declare namespace word_parse

namespace grammar {  // declare

class Grammar : public Obj {
 public:
  Grammar();

  Dict<int, Tuple2<List<List<Tuple2<int, int>*>*>*, Dict<int, int>*>*>* dfas;
  Dict<Str*, int>* keywords;
  List<int>* labels;
  Dict<int, Str*>* number2symbol;
  int start;
  List<List<Tuple2<int, int>*>*>* states;
  Dict<Str*, int>* symbol2label;
  Dict<Str*, int>* symbol2number;
  Dict<int, int>* tokens;

  DISALLOW_COPY_AND_ASSIGN(Grammar)
};

constexpr uint16_t maskof_Grammar() {
  return
    maskbit(offsetof(Grammar, dfas))
  | maskbit(offsetof(Grammar, keywords))
  | maskbit(offsetof(Grammar, labels))
  | maskbit(offsetof(Grammar, number2symbol))
  | maskbit(offsetof(Grammar, states))
  | maskbit(offsetof(Grammar, symbol2label))
  | maskbit(offsetof(Grammar, symbol2number))
  | maskbit(offsetof(Grammar, tokens));
}



}  // declare namespace grammar

namespace pnode {  // declare

class PNode : public Obj {
 public:
  PNode(int typ, syntax_asdl::Token* tok, List<pnode::PNode*>* children);

  List<pnode::PNode*>* children;
  syntax_asdl::Token* tok;
  int typ;

  DISALLOW_COPY_AND_ASSIGN(PNode)
};

constexpr uint16_t maskof_PNode() {
  return
    maskbit(offsetof(PNode, children))
  | maskbit(offsetof(PNode, tok));
}



}  // declare namespace pnode

namespace cgi {  // declare

Str* escape(Str* s);


}  // declare namespace cgi

namespace os_path {  // declare

extern Str* extsep;
extern Str* sep;
Str* join(Str* s1, Str* s2);
Tuple2<Str*, Str*> split(Str* p);
Tuple2<Str*, Str*> _splitext(Str* p, Str* sep, Str* extsep);
Tuple2<Str*, Str*> splitext(Str* p);
Str* basename(Str* p);
Str* dirname(Str* p);
Str* normpath(Str* path);
bool isabs(Str* s);
Str* abspath(Str* path);

inline Str* fmt397(Str* a0, Str* a1) {
  gBuf.reset();
  gBuf.format_s(a0);
  gBuf.write_const("/", 1);
  gBuf.format_s(a1);
  return gBuf.getvalue();
}


}  // declare namespace os_path

namespace qsn {  // declare

extern int BIT8_UTF8;
extern int BIT8_U_ESCAPE;
extern int BIT8_X_ESCAPE;
extern int MUST_QUOTE;
bool _encode(Str* s, int bit8_display, bool shell_compat, List<Str*>* parts);
Str* maybe_shell_encode(Str* s);
Str* maybe_shell_encode(Str* s, int flags);
Str* maybe_encode(Str* s);
Str* maybe_encode(Str* s, int bit8_display);
Str* encode(Str* s, int bit8_display);
void _encode_bytes_x(Str* s, bool shell_compat, List<Str*>* parts);
extern int Ascii;
extern int Begin2;
extern int Begin3;
extern int Begin4;
extern int Cont;
extern int Invalid;
extern int Start;
extern int B2_1;
extern int B3_1;
extern int B4_1;
extern int B3_2;
extern int B4_2;
extern int B4_3;
bool _encode_runes(Str* s, int bit8_display, bool shell_compat, List<Str*>* parts);
Str* maybe_qtt_encode(Str* s, int bit8_display);


}  // declare namespace qsn

namespace qsn_native {  // declare

bool IsWhitespace(Str* s);
List<syntax_asdl::Token*>* Parse(lexer::Lexer* lexer);

inline Str* fmt398() {
  gBuf.reset();
  gBuf.write_const("Unexpected token in QSN string", 30);
  return gBuf.getvalue();
}

inline Str* fmt399() {
  gBuf.reset();
  gBuf.write_const("Expected closing single quote in QSN string", 43);
  return gBuf.getvalue();
}

inline Str* fmt400() {
  gBuf.reset();
  gBuf.write_const("Unexpected data after closing quote", 35);
  return gBuf.getvalue();
}

inline Str* fmt401() {
  gBuf.reset();
  gBuf.write_const("Unexpected token after QSN string", 33);
  return gBuf.getvalue();
}


}  // declare namespace qsn_native

namespace builtin_bracket {  // declare

class _StringWordEmitter : public word_parse::WordEmitter {
 public:
  _StringWordEmitter(runtime_asdl::cmd_value__Argv* cmd_val);
  virtual syntax_asdl::word__String* ReadWord(types_asdl::lex_mode_t unused_lex_mode);
  syntax_asdl::word__String* Read();
  Str* Peek(int offset);
  void Rewind(int offset);

  runtime_asdl::cmd_value__Argv* cmd_val;
  int i;
  int n;

  DISALLOW_COPY_AND_ASSIGN(_StringWordEmitter)
};

constexpr uint16_t maskof__StringWordEmitter() {
  return
    maskbit_v(offsetof(_StringWordEmitter, cmd_val));
}

class _WordEvaluator : public word_eval::StringWordEvaluator {
 public:
  _WordEvaluator();
  runtime_asdl::value__Str* EvalWordToString(syntax_asdl::word_t* w);
  virtual runtime_asdl::value__Str* EvalWordToString(syntax_asdl::word_t* w, int eval_flags);

  DISALLOW_COPY_AND_ASSIGN(_WordEvaluator)
};

syntax_asdl::bool_expr_t* _TwoArgs(builtin_bracket::_StringWordEmitter* w_parser);
syntax_asdl::bool_expr_t* _ThreeArgs(builtin_bracket::_StringWordEmitter* w_parser);
class Test : public vm::_Builtin {
 public:
  Test(bool need_right_bracket, optview::Exec* exec_opts, state::Mem* mem, ui::ErrorFormatter* errfmt);
  virtual int Run(runtime_asdl::cmd_value__Argv* cmd_val);

  ui::ErrorFormatter* errfmt;
  optview::Exec* exec_opts;
  state::Mem* mem;
  bool need_right_bracket;

  DISALLOW_COPY_AND_ASSIGN(Test)
};

constexpr uint16_t maskof_Test() {
  return
    maskbit_v(offsetof(Test, errfmt))
  | maskbit_v(offsetof(Test, exec_opts))
  | maskbit_v(offsetof(Test, mem));
}


inline Str* fmt402(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Expected unary operator, got ", 29);
  gBuf.format_r(a0);
  gBuf.write_const(" (2 args)", 9);
  return gBuf.getvalue();
}

inline Str* fmt403(Str* a0) {
  gBuf.reset();
  gBuf.write_const("Expected binary operator, got ", 30);
  gBuf.format_r(a0);
  gBuf.write_const(" (3 args)", 9);
  return gBuf.getvalue();
}


}  // declare namespace builtin_bracket

namespace runtime {  // define

using hnode_asdl::hnode__Record;
using hnode_asdl::hnode__Leaf;
using hnode_asdl::color_t;
using hnode_asdl::color_e;
int NO_SPID = -1;

hnode_asdl::hnode__Record* NewRecord(Str* node_type) {
  StackRoots _roots({&node_type});

  return Alloc<hnode__Record>(node_type, Alloc<List<hnode_asdl::field*>>(), false, str0, str1, Alloc<List<hnode_asdl::hnode_t*>>());
}

hnode_asdl::hnode__Leaf* NewLeaf(Str* s, hnode_asdl::color_t e_color) {
  StackRoots _roots({&s});

  if (s == nullptr) {
    return Alloc<hnode__Leaf>(str2, color_e::OtherConst);
  }
  else {
    return Alloc<hnode__Leaf>(s, e_color);
  }
}
Str* TRUE_STR = str3;
Str* FALSE_STR = str4;

}  // define namespace runtime

namespace vm {  // define

using runtime_asdl::CommandStatus;
using runtime_asdl::StatusArray;

void InitUnsafeArith(state::Mem* mem, word_eval::NormalWordEvaluator* word_ev, sh_expr_eval::UnsafeArith* unsafe_arith) {
  StackRoots _roots({&mem, &word_ev, &unsafe_arith});

  mem->unsafe_arith = unsafe_arith;
  word_ev->unsafe_arith = unsafe_arith;
}

void InitCircularDeps(sh_expr_eval::ArithEvaluator* arith_ev, sh_expr_eval::BoolEvaluator* bool_ev, expr_eval::OilEvaluator* expr_ev, word_eval::NormalWordEvaluator* word_ev, cmd_eval::CommandEvaluator* cmd_ev, vm::_Executor* shell_ex, prompt::Evaluator* prompt_ev, dev::Tracer* tracer) {
  StackRoots _roots({&arith_ev, &bool_ev, &expr_ev, &word_ev, &cmd_ev, &shell_ex, &prompt_ev, &tracer});

  arith_ev->word_ev = word_ev;
  bool_ev->word_ev = word_ev;
  if (expr_ev) {
    expr_ev->shell_ex = shell_ex;
    expr_ev->word_ev = word_ev;
  }
  word_ev->arith_ev = arith_ev;
  word_ev->expr_ev = expr_ev;
  word_ev->prompt_ev = prompt_ev;
  word_ev->shell_ex = shell_ex;
  cmd_ev->shell_ex = shell_ex;
  cmd_ev->arith_ev = arith_ev;
  cmd_ev->bool_ev = bool_ev;
  cmd_ev->expr_ev = expr_ev;
  cmd_ev->word_ev = word_ev;
  cmd_ev->tracer = tracer;
  shell_ex->cmd_ev = cmd_ev;
  prompt_ev->word_ev = word_ev;
  tracer->word_ev = word_ev;
  arith_ev->CheckCircularDeps();
  bool_ev->CheckCircularDeps();
  if (expr_ev) {
    expr_ev->CheckCircularDeps();
  }
  word_ev->CheckCircularDeps();
  cmd_ev->CheckCircularDeps();
  shell_ex->CheckCircularDeps();
  prompt_ev->CheckCircularDeps();
  tracer->CheckCircularDeps();
}

_Executor::_Executor() 
    : Obj(Tag::FixedSize, maskof__Executor(), sizeof(_Executor))  {
  this->cmd_ev = nullptr;
}

void _Executor::CheckCircularDeps() {
  ;  // pass
}

int _Executor::RunBuiltin(int builtin_id, runtime_asdl::cmd_value__Argv* cmd_val) {
  StackRoots _roots({&cmd_val});

  return 0;
}

int _Executor::RunSimpleCommand(runtime_asdl::cmd_value__Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork) {
  return RunSimpleCommand(cmd_val, cmd_st, do_fork, true);
}

int _Executor::RunSimpleCommand(runtime_asdl::cmd_value__Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork, bool call_procs) {
  StackRoots _roots({&cmd_val, &cmd_st});

  return 0;
}

int _Executor::RunBackgroundJob(syntax_asdl::command_t* node) {
  StackRoots _roots({&node});

  return 0;
}

void _Executor::RunPipeline(syntax_asdl::command__Pipeline* node, runtime_asdl::CommandStatus* status_out) {
  StackRoots _roots({&node, &status_out});

  ;  // pass
}

int _Executor::RunSubshell(syntax_asdl::command_t* node) {
  StackRoots _roots({&node});

  return 0;
}

Str* _Executor::RunCommandSub(syntax_asdl::command_sub* cs_part) {
  StackRoots _roots({&cs_part});

  return str5;
}

Str* _Executor::RunProcessSub(syntax_asdl::command_sub* cs_part) {
  StackRoots _roots({&cs_part});

  return str6;
}

void _Executor::Time() {
  ;  // pass
}

bool _Executor::PushRedirects(List<runtime_asdl::redirect*>* redirects) {
  StackRoots _roots({&redirects});

  return true;
}

void _Executor::PopRedirects() {
  ;  // pass
}

void _Executor::PushProcessSub() {
  ;  // pass
}

void _Executor::PopProcessSub(runtime_asdl::StatusArray* compound_st) {
  StackRoots _roots({&compound_st});

  ;  // pass
}

_AssignBuiltin::_AssignBuiltin() 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(_AssignBuiltin))  {
  ;  // pass
}

int _AssignBuiltin::Run(runtime_asdl::cmd_value__Assign* cmd_val) {
  StackRoots _roots({&cmd_val});

  throw Alloc<NotImplementedError>();
}

_Builtin::_Builtin() 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(_Builtin))  {
  ;  // pass
}

int _Builtin::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  StackRoots _roots({&cmd_val});

  throw Alloc<NotImplementedError>();
}

ctx_Redirect::ctx_Redirect(vm::_Executor* shell_ex) 
    : Obj(Tag::FixedSize, maskof_ctx_Redirect(), sizeof(ctx_Redirect))  {
  this->shell_ex = shell_ex;
}

ctx_Redirect::~ctx_Redirect(){
  this->shell_ex->PopRedirects();
}

ctx_ProcessSub::ctx_ProcessSub(vm::_Executor* shell_ex, runtime_asdl::StatusArray* process_sub_status) 
    : Obj(Tag::FixedSize, maskof_ctx_ProcessSub(), sizeof(ctx_ProcessSub))  {
  shell_ex->PushProcessSub();
  this->shell_ex = shell_ex;
  this->process_sub_status = process_sub_status;
}

ctx_ProcessSub::~ctx_ProcessSub(){
  this->shell_ex->PopProcessSub(this->process_sub_status);
}

}  // define namespace vm

namespace format {  // define

namespace hnode_e = hnode_asdl::hnode_e;
using hnode_asdl::hnode_t;
using hnode_asdl::hnode__Record;
using hnode_asdl::hnode__Array;
using hnode_asdl::hnode__Leaf;
using hnode_asdl::hnode__External;
using hnode_asdl::color_e;
using hnode_asdl::color_t;

format::ColorOutput* DetectConsoleOutput(mylib::Writer* f) {
  StackRoots _roots({&f});

  if (f->isatty()) {
    return Alloc<AnsiOutput>(f);
  }
  else {
    return Alloc<TextOutput>(f);
  }
}

ColorOutput::ColorOutput(mylib::Writer* f) 
    : Obj(Tag::FixedSize, maskof_ColorOutput(), sizeof(ColorOutput))  {
  this->f = f;
  this->num_chars = 0;
}

format::ColorOutput* ColorOutput::NewTempBuffer() {
  throw Alloc<NotImplementedError>();
}

void ColorOutput::FileHeader() {
  ;  // pass
}

void ColorOutput::FileFooter() {
  ;  // pass
}

void ColorOutput::PushColor(hnode_asdl::color_t e_color) {
  throw Alloc<NotImplementedError>();
}

void ColorOutput::PopColor() {
  throw Alloc<NotImplementedError>();
}

void ColorOutput::write(Str* s) {
  StackRoots _roots({&s});

  this->f->write(s);
  this->num_chars += len(s);
}

void ColorOutput::WriteRaw(Tuple2<Str*, int>* raw) {
  Str* s = nullptr;
  int num_chars;
  StackRoots _roots({&raw, &s});

  Tuple2<Str*, int>* tup0 = raw;
  s = tup0->at0();
  num_chars = tup0->at1();
  this->f->write(s);
  this->num_chars += num_chars;
}

int ColorOutput::NumChars() {
  return this->num_chars;
}

Tuple2<Str*, int> ColorOutput::GetRaw() {
  mylib::BufWriter* f = static_cast<mylib::BufWriter*>(this->f);
  return (Tuple2<Str*, int>(f->getvalue(), this->num_chars));
}

TextOutput::TextOutput(mylib::Writer* f) : ColorOutput(f) {
}

format::TextOutput* TextOutput::NewTempBuffer() {
  return Alloc<TextOutput>(Alloc<mylib::BufWriter>());
}

void TextOutput::PushColor(hnode_asdl::color_t e_color) {
  ;  // pass
}

void TextOutput::PopColor() {
  ;  // pass
}

HtmlOutput::HtmlOutput(mylib::Writer* f) : ColorOutput(f) {
}

format::HtmlOutput* HtmlOutput::NewTempBuffer() {
  return Alloc<HtmlOutput>(Alloc<mylib::BufWriter>());
}

void HtmlOutput::FileHeader() {
  this->f->write(str7);
}

void HtmlOutput::FileFooter() {
  this->f->write(str8);
}

void HtmlOutput::PushColor(hnode_asdl::color_t e_color) {
  Str* css_class = nullptr;
  StackRoots _roots({&css_class});

  if (e_color == color_e::TypeName) {
    css_class = str9;
  }
  else {
    if (e_color == color_e::StringConst) {
      css_class = str10;
    }
    else {
      if (e_color == color_e::OtherConst) {
        css_class = str11;
      }
      else {
        if (e_color == color_e::External) {
          css_class = str12;
        }
        else {
          if (e_color == color_e::UserType) {
            css_class = str13;
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
  }
  this->f->write(fmt0(css_class));
}

void HtmlOutput::PopColor() {
  this->f->write(str15);
}

void HtmlOutput::write(Str* s) {
  StackRoots _roots({&s});

  this->f->write(cgi::escape(s));
  this->num_chars += len(s);
}

AnsiOutput::AnsiOutput(mylib::Writer* f) : ColorOutput(f) {
}

format::AnsiOutput* AnsiOutput::NewTempBuffer() {
  return Alloc<AnsiOutput>(Alloc<mylib::BufWriter>());
}

void AnsiOutput::PushColor(hnode_asdl::color_t e_color) {
  if (e_color == color_e::TypeName) {
    this->f->write(ansi::YELLOW);
  }
  else {
    if (e_color == color_e::StringConst) {
      this->f->write(ansi::BOLD);
    }
    else {
      if (e_color == color_e::OtherConst) {
        this->f->write(ansi::GREEN);
      }
      else {
        if (e_color == color_e::External) {
          this->f->write(str_concat(ansi::BOLD, ansi::BLUE));
        }
        else {
          if (e_color == color_e::UserType) {
            this->f->write(ansi::GREEN);
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
  }
}

void AnsiOutput::PopColor() {
  this->f->write(ansi::RESET);
}
int INDENT = 2;

_PrettyPrinter::_PrettyPrinter(int max_col) 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(_PrettyPrinter))  {
  this->max_col = max_col;
}

bool _PrettyPrinter::_PrintWrappedArray(List<hnode_asdl::hnode_t*>* array, int prefix_len, format::ColorOutput* f, int indent) {
  bool all_fit;
  int chars_so_far;
  int i;
  format::ColorOutput* single_f = nullptr;
  Str* s = nullptr;
  int num_chars;
  StackRoots _roots({&array, &f, &single_f, &s});

  all_fit = true;
  chars_so_far = prefix_len;
  i = 0;
  for (ListIter<hnode_asdl::hnode_t*> it(array); !it.Done(); it.Next(), ++i) {
    hnode_asdl::hnode_t* val = it.Value();
    StackRoots _for({&val  });
    if (i != 0) {
      f->write(str16);
    }
    single_f = f->NewTempBuffer();
    if (_TrySingleLine(val, single_f, (this->max_col - chars_so_far))) {
      Tuple2<Str*, int> tup1 = single_f->GetRaw();
      s = tup1.at0();
      num_chars = tup1.at1();
      f->WriteRaw((Alloc<Tuple2<Str*, int>>(s, num_chars)));
      chars_so_far += single_f->NumChars();
    }
    else {
      f->write(str17);
      this->PrintNode(val, f, (indent + INDENT));
      chars_so_far = 0;
      all_fit = false;
    }
  }
  return all_fit;
}

bool _PrettyPrinter::_PrintWholeArray(List<hnode_asdl::hnode_t*>* array, int prefix_len, format::ColorOutput* f, int indent) {
  bool all_fit;
  List<Tuple2<Str*, int>*>* pieces = nullptr;
  int chars_so_far;
  format::ColorOutput* single_f = nullptr;
  Str* s = nullptr;
  int num_chars;
  int i;
  StackRoots _roots({&array, &f, &pieces, &single_f, &s});

  all_fit = true;
  pieces = Alloc<List<Tuple2<Str*, int>*>>();
  chars_so_far = prefix_len;
  for (ListIter<hnode_asdl::hnode_t*> it(array); !it.Done(); it.Next()) {
    hnode_asdl::hnode_t* item = it.Value();
    StackRoots _for({&item  });
    single_f = f->NewTempBuffer();
    if (_TrySingleLine(item, single_f, (this->max_col - chars_so_far))) {
      Tuple2<Str*, int> tup2 = single_f->GetRaw();
      s = tup2.at0();
      num_chars = tup2.at1();
      pieces->append((Alloc<Tuple2<Str*, int>>(s, num_chars)));
      chars_so_far += single_f->NumChars();
    }
    else {
      all_fit = false;
      break;
    }
  }
  if (all_fit) {
    i = 0;
    for (ListIter<Tuple2<Str*, int>*> it(pieces); !it.Done(); it.Next(), ++i) {
      Tuple2<Str*, int>* p = it.Value();
      StackRoots _for({&p    });
      if (i != 0) {
        f->write(str18);
      }
      f->WriteRaw(p);
    }
    f->write(str19);
  }
  return all_fit;
}

void _PrettyPrinter::_PrintRecord(hnode_asdl::hnode__Record* node, format::ColorOutput* f, int indent) {
  Str* ind = nullptr;
  Str* prefix = nullptr;
  int prefix_len;
  bool all_fit;
  Str* name = nullptr;
  hnode_asdl::hnode_t* val = nullptr;
  Str* ind1 = nullptr;
  hnode_asdl::hnode_t* UP_val = nullptr;
  int tag;
  Str* name_str = nullptr;
  format::ColorOutput* single_f = nullptr;
  Str* s = nullptr;
  int num_chars;
  StackRoots _roots({&node, &f, &ind, &prefix, &name, &val, &ind1, &UP_val, &name_str, &single_f, &s});

  ind = str_repeat(str20, indent);
  if (node->abbrev) {
    prefix = str_concat(ind, node->left);
    f->write(prefix);
    if (len(node->node_type)) {
      f->PushColor(color_e::TypeName);
      f->write(node->node_type);
      f->PopColor();
      f->write(str21);
    }
    prefix_len = ((len(prefix) + len(node->node_type)) + 1);
    all_fit = this->_PrintWrappedArray(node->unnamed_fields, prefix_len, f, indent);
    if (!all_fit) {
      f->write(str22);
      f->write(ind);
    }
    f->write(node->right);
  }
  else {
    f->write(str_concat(ind, node->left));
    f->PushColor(color_e::TypeName);
    f->write(node->node_type);
    f->PopColor();
    f->write(str23);
    for (ListIter<hnode_asdl::field*> it(node->fields); !it.Done(); it.Next()) {
      hnode_asdl::field* field = it.Value();
      StackRoots _for({&field    });
      name = field->name;
      val = field->val;
      ind1 = str_repeat(str24, (indent + INDENT));
      UP_val = val;
      tag = val->tag_();
      if (tag == hnode_e::Array) {
        hnode__Array* val = static_cast<hnode__Array*>(UP_val);
        name_str = fmt1(ind1, name);
        f->write(name_str);
        prefix_len = len(name_str);
        if (!this->_PrintWholeArray(val->children, prefix_len, f, indent)) {
          f->write(str26);
          for (ListIter<hnode_asdl::hnode_t*> it(val->children); !it.Done(); it.Next()) {
            hnode_asdl::hnode_t* child = it.Value();
            StackRoots _for({&child          });
            this->PrintNode(child, f, ((indent + INDENT) + INDENT));
            f->write(str27);
          }
          f->write(fmt2(ind1));
        }
      }
      else {
        name_str = fmt3(ind1, name);
        f->write(name_str);
        prefix_len = len(name_str);
        single_f = f->NewTempBuffer();
        if (_TrySingleLine(val, single_f, (this->max_col - prefix_len))) {
          Tuple2<Str*, int> tup3 = single_f->GetRaw();
          s = tup3.at0();
          num_chars = tup3.at1();
          f->WriteRaw((Alloc<Tuple2<Str*, int>>(s, num_chars)));
        }
        else {
          f->write(str30);
          this->PrintNode(val, f, ((indent + INDENT) + INDENT));
        }
      }
      f->write(str31);
    }
    f->write(str_concat(ind, node->right));
  }
}

void _PrettyPrinter::PrintNode(hnode_asdl::hnode_t* node, format::ColorOutput* f, int indent) {
  Str* ind = nullptr;
  format::ColorOutput* single_f = nullptr;
  Str* s = nullptr;
  int num_chars;
  hnode_asdl::hnode_t* UP_node = nullptr;
  int tag;
  StackRoots _roots({&node, &f, &ind, &single_f, &s, &UP_node});

  ind = str_repeat(str32, indent);
  single_f = f->NewTempBuffer();
  single_f->write(ind);
  if (_TrySingleLine(node, single_f, (this->max_col - indent))) {
    Tuple2<Str*, int> tup4 = single_f->GetRaw();
    s = tup4.at0();
    num_chars = tup4.at1();
    f->WriteRaw((Alloc<Tuple2<Str*, int>>(s, num_chars)));
    return ;
  }
  UP_node = node;
  tag = node->tag_();
  if (tag == hnode_e::Leaf) {
    hnode__Leaf* node = static_cast<hnode__Leaf*>(UP_node);
    f->PushColor(node->color);
    f->write(qsn::maybe_encode(node->s));
    f->PopColor();
  }
  else {
    if (tag == hnode_e::External) {
      hnode__External* node = static_cast<hnode__External*>(UP_node);
      f->PushColor(color_e::External);
      f->write(repr(node->obj));
      f->PopColor();
    }
    else {
      if (tag == hnode_e::Record) {
        hnode__Record* node = static_cast<hnode__Record*>(UP_node);
        this->_PrintRecord(node, f, indent);
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
}

bool _TrySingleLineObj(hnode_asdl::hnode__Record* node, format::ColorOutput* f, int max_chars) {
  int i;
  StackRoots _roots({&node, &f});

  f->write(node->left);
  if (node->abbrev) {
    if (len(node->node_type)) {
      f->PushColor(color_e::TypeName);
      f->write(node->node_type);
      f->PopColor();
      f->write(str33);
    }
    i = 0;
    for (ListIter<hnode_asdl::hnode_t*> it(node->unnamed_fields); !it.Done(); it.Next(), ++i) {
      hnode_asdl::hnode_t* val = it.Value();
      StackRoots _for({&val    });
      if (i != 0) {
        f->write(str34);
      }
      if (!_TrySingleLine(val, f, max_chars)) {
        return false;
      }
    }
  }
  else {
    f->PushColor(color_e::TypeName);
    f->write(node->node_type);
    f->PopColor();
    for (ListIter<hnode_asdl::field*> it(node->fields); !it.Done(); it.Next()) {
      hnode_asdl::field* field = it.Value();
      StackRoots _for({&field    });
      f->write(fmt4(field->name));
      if (!_TrySingleLine(field->val, f, max_chars)) {
        return false;
      }
    }
  }
  f->write(node->right);
  return true;
}

bool _TrySingleLine(hnode_asdl::hnode_t* node, format::ColorOutput* f, int max_chars) {
  hnode_asdl::hnode_t* UP_node = nullptr;
  int tag;
  int i;
  int num_chars_so_far;
  StackRoots _roots({&node, &f, &UP_node});

  UP_node = node;
  tag = node->tag_();
  if (tag == hnode_e::Leaf) {
    hnode__Leaf* node = static_cast<hnode__Leaf*>(UP_node);
    f->PushColor(node->color);
    f->write(qsn::maybe_encode(node->s));
    f->PopColor();
  }
  else {
    if (tag == hnode_e::External) {
      hnode__External* node = static_cast<hnode__External*>(UP_node);
      f->PushColor(color_e::External);
      f->write(repr(node->obj));
      f->PopColor();
    }
    else {
      if (tag == hnode_e::Array) {
        hnode__Array* node = static_cast<hnode__Array*>(UP_node);
        f->write(str36);
        i = 0;
        for (ListIter<hnode_asdl::hnode_t*> it(node->children); !it.Done(); it.Next(), ++i) {
          hnode_asdl::hnode_t* item = it.Value();
          StackRoots _for({&item        });
          if (i != 0) {
            f->write(str37);
          }
          if (!_TrySingleLine(item, f, max_chars)) {
            return false;
          }
        }
        f->write(str38);
      }
      else {
        if (tag == hnode_e::Record) {
          hnode__Record* node = static_cast<hnode__Record*>(UP_node);
          return _TrySingleLineObj(node, f, max_chars);
        }
        else {
          assert(0);  // AssertionError
        }
      }
    }
  }
  num_chars_so_far = f->NumChars();
  if (num_chars_so_far > max_chars) {
    return false;
  }
  return true;
}

void PrintTree(hnode_asdl::hnode_t* node, format::ColorOutput* f) {
  format::_PrettyPrinter* pp = nullptr;
  StackRoots _roots({&node, &f, &pp});

  pp = Alloc<_PrettyPrinter>(100);
  pp->PrintNode(node, f, 0);
}

}  // define namespace format

namespace osh_eval {  // define


int main(List<Str*>* argv) {
  pyutil::_ResourceLoader* loader = nullptr;
  bool login_shell;
  Dict<Str*, Str*>* environ = nullptr;
  args::Reader* arg_r = nullptr;
  int status;
  Str* msg = nullptr;
  StackRoots _roots({&argv, &loader, &environ, &arg_r, &msg});

  loader = pyutil::GetResourceLoader();
  login_shell = false;
  environ = pyos::Environ();
  arg_r = Alloc<args::Reader>(argv, list_repeat(runtime::NO_SPID, len(argv)));
  try {
    status = shell_native::Main(str39, arg_r, environ, login_shell, loader, nullptr);
    return status;
  }
  catch (error::Usage* e) {
    println_stderr(fmt5(e->msg));
    return 2;
  }
  catch (RuntimeError* e) {
    msg = e->message;
    println_stderr(fmt6(msg));
    return 1;
  }
  catch (KeyboardInterrupt*) {
    print(str42);
    return 130;
  }
  catch (IOError_OSError* e) {
    println_stderr(fmt7(pyutil::strerror(e)));
    return 2;
  }
}

}  // define namespace osh_eval

namespace alloc {  // define

using syntax_asdl::line_span;
using syntax_asdl::source_t;

ctx_Location::ctx_Location(alloc::Arena* arena, syntax_asdl::source_t* src) 
    : Obj(Tag::FixedSize, maskof_ctx_Location(), sizeof(ctx_Location))  {
  arena->PushSource(src);
  this->arena = arena;
}

ctx_Location::~ctx_Location(){
  this->arena->PopSource();
}

Arena::Arena() 
    : Obj(Tag::FixedSize, maskof_Arena(), sizeof(Arena))  {
  this->line_vals = Alloc<List<Str*>>();
  this->line_nums = Alloc<List<int>>();
  this->line_srcs = Alloc<List<syntax_asdl::source_t*>>();
  this->line_num_strs = Alloc<Dict<int, Str*>>();
  this->spans = Alloc<List<syntax_asdl::line_span*>>();
  this->source_instances = Alloc<List<syntax_asdl::source_t*>>();
}

void Arena::PushSource(syntax_asdl::source_t* src) {
  StackRoots _roots({&src});

  this->source_instances->append(src);
}

void Arena::PopSource() {
  this->source_instances->pop();
}

int Arena::AddLine(Str* line, int line_num) {
  int line_id;
  StackRoots _roots({&line});

  line_id = len(this->line_vals);
  this->line_vals->append(line);
  this->line_nums->append(line_num);
  this->line_srcs->append(this->source_instances->index_(-1));
  return line_id;
}

Str* Arena::GetLine(int line_id) {
  return this->line_vals->index_(line_id);
}

int Arena::GetLineNumber(int line_id) {
  return this->line_nums->index_(line_id);
}

Str* Arena::GetLineNumStr(int line_id) {
  int line_num;
  Str* s = nullptr;
  StackRoots _roots({&s});

  line_num = this->line_nums->index_(line_id);
  s = this->line_num_strs->get(line_num);
  if (s == nullptr) {
    s = str(line_num);
    this->line_num_strs->set(line_num, s);
  }
  return s;
}

Str* Arena::GetCodeString(int lbrace_spid, int rbrace_spid) {
  syntax_asdl::line_span* left_span = nullptr;
  syntax_asdl::line_span* right_span = nullptr;
  int left_id;
  int right_id;
  int left_col;
  int right_col;
  List<Str*>* parts = nullptr;
  StackRoots _roots({&left_span, &right_span, &parts});

  left_span = this->GetLineSpan(lbrace_spid);
  right_span = this->GetLineSpan(rbrace_spid);
  left_id = left_span->line_id;
  right_id = right_span->line_id;
  left_col = left_span->col;
  right_col = right_span->col;
  parts = Alloc<List<Str*>>();
  parts->append(str_repeat(str44, (left_col + 1)));
  if (left_id == right_id) {
    parts->append(this->line_vals->index_(left_id)->slice((left_col + 1), right_col));
  }
  else {
    parts->append(this->line_vals->index_(left_id)->slice((left_col + 1)));
    for (int line_id = (left_id + 1); line_id < right_id; ++line_id) {
      parts->append(this->line_vals->index_(line_id));
    }
    parts->append(this->line_vals->index_(right_id)->slice(0, right_col));
  }
  return str45->join(parts);
}

syntax_asdl::source_t* Arena::GetLineSource(int line_id) {
  return this->line_srcs->index_(line_id);
}

int Arena::AddLineSpan(int line_id, int col, int length) {
  int span_id;
  syntax_asdl::line_span* span = nullptr;
  StackRoots _roots({&span});

  span_id = len(this->spans);
  span = Alloc<line_span>(line_id, col, length);
  this->spans->append(span);
  return span_id;
}

syntax_asdl::line_span* Arena::GetLineSpan(int span_id) {
  return this->spans->index_(span_id);
}

int Arena::LastSpanId() {
  return len(this->spans);
}

}  // define namespace alloc

namespace ansi {  // define

Str* RESET = str46;
Str* BOLD = str47;
Str* UNDERLINE = str48;
Str* REVERSE = str49;
Str* RED = str50;
Str* GREEN = str51;
Str* YELLOW = str52;
Str* BLUE = str53;

}  // define namespace ansi

namespace dev {  // define

namespace option_i = option_asdl::option_i;
namespace builtin_i = option_asdl::builtin_i;
using option_asdl::builtin_t;
namespace value = runtime_asdl::value;
namespace value_e = runtime_asdl::value_e;
using runtime_asdl::value__Str;
using runtime_asdl::value__MaybeStrArray;
using runtime_asdl::value__AssocArray;
namespace lvalue = runtime_asdl::lvalue;
namespace lvalue_e = runtime_asdl::lvalue_e;
using runtime_asdl::lvalue__Named;
using runtime_asdl::lvalue__Indexed;
using runtime_asdl::lvalue__Keyed;
using runtime_asdl::cmd_value__Assign;
using runtime_asdl::scope_e;
namespace trace_e = runtime_asdl::trace_e;
using runtime_asdl::trace_t;
using runtime_asdl::trace__External;
using syntax_asdl::assign_op_e;

CrashDumper::CrashDumper(Str* crash_dump_dir) 
    : Obj(Tag::FixedSize, maskof_CrashDumper(), sizeof(CrashDumper))  {
  this->crash_dump_dir = crash_dump_dir;
  this->do_collect = to_bool(crash_dump_dir);
  this->collected = false;
  this->var_stack = nullptr;
  this->argv_stack = nullptr;
  this->debug_stack = nullptr;
  this->error = nullptr;
}

void CrashDumper::MaybeCollect(void* cmd_ev, error::_ErrorWithLocation* err) {
  StackRoots _roots({&cmd_ev, &err});

  if (!this->do_collect) {
    return ;
  }
}

void CrashDumper::MaybeDump(int status) {
  if (!this->collected) {
    return ;
  }
}

ctx_Tracer::ctx_Tracer(dev::Tracer* tracer, Str* label, List<Str*>* argv) 
    : Obj(Tag::FixedSize, maskof_ctx_Tracer(), sizeof(ctx_Tracer))  {
  this->arg = nullptr;
  if (str_equals(label, str54)) {
    this->arg = argv->index_(0);
  }
  else {
    if (str_equals(label, str55)) {
      this->arg = argv->index_(1);
    }
  }
  tracer->PushMessage(label, argv);
  this->label = label;
  this->tracer = tracer;
}

ctx_Tracer::~ctx_Tracer(){
  this->tracer->PopMessage(this->label, this->arg);
}

void _PrintShValue(runtime_asdl::value_t* val, mylib::BufWriter* buf) {
  Str* result = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  List<Str*>* parts = nullptr;
  StackRoots _roots({&val, &buf, &result, &UP_val, &parts});

  result = str56;
  UP_val = val;
  switch (val->tag_()) {
    case value_e::Str: {
      value__Str* val = static_cast<value__Str*>(UP_val);
      result = qsn::maybe_shell_encode(val->s);
    }
      break;
    case value_e::MaybeStrArray: {
      value__MaybeStrArray* val = static_cast<value__MaybeStrArray*>(UP_val);
      parts = NewList<Str*>(std::initializer_list<Str*>{str57});
      for (ListIter<Str*> it(val->strs); !it.Done(); it.Next()) {
        Str* s = it.Value();
        StackRoots _for({&s      });
        parts->append(qsn::maybe_shell_encode(s));
      }
      parts->append(str58);
      result = str59->join(parts);
    }
      break;
    case value_e::AssocArray: {
      value__AssocArray* val = static_cast<value__AssocArray*>(UP_val);
      parts = NewList<Str*>(std::initializer_list<Str*>{str60});
      for (DictIter<Str*, Str*> it(val->d); !it.Done(); it.Next()) {
        Str* k = it.Key();
        Str* v = it.Value();
        parts->append(fmt8(qsn::maybe_shell_encode(k), qsn::maybe_shell_encode(v)));
      }
      parts->append(str62);
      result = str63->join(parts);
    }
      break;
  }
  buf->write(result);
}

void _PrintArgv(List<Str*>* argv, mylib::BufWriter* buf) {
  StackRoots _roots({&argv, &buf});

  for (ListIter<Str*> it(argv); !it.Done(); it.Next()) {
    Str* arg = it.Value();
    StackRoots _for({&arg  });
    buf->write(str64);
    buf->write(qsn::maybe_encode(arg));
  }
  buf->write(str65);
}

Tracer::Tracer(parse_lib::ParseContext* parse_ctx, optview::Exec* exec_opts, state::MutableOpts* mutable_opts, state::Mem* mem, util::_DebugFile* f) 
    : Obj(Tag::FixedSize, maskof_Tracer(), sizeof(Tracer))  {
  this->parse_ctx = parse_ctx;
  this->exec_opts = exec_opts;
  this->mutable_opts = mutable_opts;
  this->mem = mem;
  this->f = f;
  this->word_ev = nullptr;
  this->ind = 0;
  this->indents = NewList<Str*>(std::initializer_list<Str*>{str66});
  this->parse_cache = Alloc<Dict<Str*, syntax_asdl::compound_word*>>();
  this->val_indent = Alloc<value::Str>(str67);
  this->val_punct = Alloc<value::Str>(str68);
  this->val_pid_str = Alloc<value::Str>(str69);
  this->lval_indent = Alloc<lvalue::Named>(str70);
  this->lval_punct = Alloc<lvalue::Named>(str71);
  this->lval_pid_str = Alloc<lvalue::Named>(str72);
}

void Tracer::CheckCircularDeps() {
}

Str* Tracer::_EvalPS4(Str* punct) {
  runtime_asdl::value_t* val = nullptr;
  Str* ps4 = nullptr;
  syntax_asdl::compound_word* ps4_word = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  runtime_asdl::value__Str* prefix = nullptr;
  StackRoots _roots({&punct, &val, &ps4, &ps4_word, &w_parser, &prefix});

  val = this->mem->GetValue(str73);
  if (val->tag_() == value_e::Str) {
    ps4 = static_cast<value__Str*>(val)->s;
  }
  else {
    ps4 = str74;
  }
  ps4_word = this->parse_cache->get(ps4);
  if (ps4_word == nullptr) {
    w_parser = this->parse_ctx->MakeWordParserForPlugin(ps4);
    try {
      ps4_word = w_parser->ReadForPlugin();
    }
    catch (error::Parse* e) {
      ps4_word = word_::ErrorWord(fmt9(e->UserErrorString()));
    }
    this->parse_cache->set(ps4, ps4_word);
  }
  if (this->exec_opts->xtrace_rich()) {
    this->val_indent->s = this->indents->index_(this->ind);
  }
  else {
    this->val_indent->s = str76;
  }
  this->val_punct->s = punct;
  {  // with
    state::ctx_Option ctx(this->mutable_opts, NewList<int>(std::initializer_list<int>{option_i::xtrace}), false);

    {  // with
      state::ctx_Temp ctx(this->mem);

      this->mem->SetValue(this->lval_indent, this->val_indent, scope_e::LocalOnly);
      this->mem->SetValue(this->lval_punct, this->val_punct, scope_e::LocalOnly);
      this->mem->SetValue(this->lval_pid_str, this->val_pid_str, scope_e::LocalOnly);
      prefix = this->word_ev->EvalForPlugin(ps4_word);
    }
  }
  return prefix->s;
}

void Tracer::_Inc() {
  this->ind += 1;
  if (this->ind >= len(this->indents)) {
    this->indents->append(str_repeat(str77, this->ind));
  }
}

void Tracer::_Dec() {
  this->ind -= 1;
}

mylib::BufWriter* Tracer::_ShTraceBegin() {
  Str* prefix = nullptr;
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&prefix, &buf});

  if ((!this->exec_opts->xtrace() or !this->exec_opts->xtrace_details())) {
    return nullptr;
  }
  prefix = this->_EvalPS4(str78);
  buf = Alloc<mylib::BufWriter>();
  buf->write(prefix);
  return buf;
}

mylib::BufWriter* Tracer::_RichTraceBegin(Str* punct) {
  Str* prefix = nullptr;
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&punct, &prefix, &buf});

  if ((!this->exec_opts->xtrace() or !this->exec_opts->xtrace_rich())) {
    return nullptr;
  }
  prefix = this->_EvalPS4(punct);
  buf = Alloc<mylib::BufWriter>();
  buf->write(prefix);
  return buf;
}

void Tracer::OnProcessStart(int pid, runtime_asdl::trace_t* why) {
  mylib::BufWriter* buf = nullptr;
  runtime_asdl::trace_t* UP_why = nullptr;
  StackRoots _roots({&why, &buf, &UP_why});

  buf = this->_RichTraceBegin(str79);
  if (!buf) {
    return ;
  }
  UP_why = why;
  switch (why->tag_()) {
    case trace_e::External: {
      trace__External* why = static_cast<trace__External*>(UP_why);
      buf->write(fmt10(pid));
      _PrintArgv(why->argv, buf);
    }
      break;
    case trace_e::ForkWait: {
      buf->write(fmt11(pid));
    }
      break;
    case trace_e::CommandSub: {
      buf->write(fmt12(pid));
    }
      break;
    case trace_e::ProcessSub: {
      buf->write(fmt13(pid));
    }
      break;
    case trace_e::HereDoc: {
      buf->write(fmt14(pid));
    }
      break;
    case trace_e::Fork: {
      buf->write(fmt15(pid));
    }
      break;
    case trace_e::PipelinePart: {
      buf->write(fmt16(pid));
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  this->f->write(buf->getvalue());
}

void Tracer::OnProcessEnd(int pid, int status) {
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&buf});

  buf = this->_RichTraceBegin(str87);
  if (!buf) {
    return ;
  }
  buf->write(fmt17(pid, status));
  this->f->write(buf->getvalue());
}

void Tracer::SetProcess(int pid) {
  this->val_pid_str->s = fmt18(pid);
  this->_Inc();
}

void Tracer::PushMessage(Str* label, List<Str*>* argv) {
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&label, &argv, &buf});

  buf = this->_RichTraceBegin(str90);
  if (buf) {
    buf->write(label);
    if (str_equals(label, str91)) {
      _PrintArgv(argv, buf);
    }
    else {
      if (str_equals(label, str92)) {
        _PrintArgv(argv->slice(1), buf);
      }
      else {
        if (str_equals(label, str93)) {
          _PrintArgv(argv->slice(1), buf);
        }
        else {
          buf->write(str94);
        }
      }
    }
    this->f->write(buf->getvalue());
  }
  this->_Inc();
}

void Tracer::PopMessage(Str* label, Str* arg) {
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&label, &arg, &buf});

  this->_Dec();
  buf = this->_RichTraceBegin(str95);
  if (buf) {
    buf->write(label);
    if (arg != nullptr) {
      buf->write(str96);
      buf->write(qsn::maybe_encode(arg));
    }
    buf->write(str97);
    this->f->write(buf->getvalue());
  }
}

void Tracer::PrintMessage(Str* message) {
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&message, &buf});

  buf = this->_RichTraceBegin(str98);
  if (!buf) {
    return ;
  }
  buf->write(message);
  buf->write(str99);
  this->f->write(buf->getvalue());
}

void Tracer::OnExec(List<Str*>* argv) {
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&argv, &buf});

  buf = this->_RichTraceBegin(str100);
  if (!buf) {
    return ;
  }
  buf->write(str101);
  _PrintArgv(argv, buf);
  this->f->write(buf->getvalue());
}

void Tracer::OnBuiltin(int builtin_id, List<Str*>* argv) {
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&argv, &buf});

  if ((builtin_id == builtin_i::eval || builtin_id == builtin_i::source || builtin_id == builtin_i::wait)) {
    return ;
  }
  buf = this->_RichTraceBegin(str102);
  if (!buf) {
    return ;
  }
  buf->write(str103);
  _PrintArgv(argv, buf);
  this->f->write(buf->getvalue());
}

void Tracer::OnSimpleCommand(List<Str*>* argv) {
  mylib::BufWriter* buf = nullptr;
  int i;
  StackRoots _roots({&argv, &buf});

  buf = this->_ShTraceBegin();
  if (!buf) {
    return ;
  }
  if (this->exec_opts->xtrace_rich()) {
    return ;
  }
  i = 0;
  for (ListIter<Str*> it(argv); !it.Done(); it.Next(), ++i) {
    Str* arg = it.Value();
    StackRoots _for({&arg  });
    if (i != 0) {
      buf->write(str104);
    }
    buf->write(qsn::maybe_shell_encode(arg));
  }
  buf->write(str105);
  this->f->write(buf->getvalue());
}

void Tracer::OnAssignBuiltin(runtime_asdl::cmd_value__Assign* cmd_val) {
  mylib::BufWriter* buf = nullptr;
  int i;
  StackRoots _roots({&cmd_val, &buf});

  buf = this->_ShTraceBegin();
  if (!buf) {
    return ;
  }
  i = 0;
  for (ListIter<Str*> it(cmd_val->argv); !it.Done(); it.Next(), ++i) {
    Str* arg = it.Value();
    StackRoots _for({&arg  });
    if (i != 0) {
      buf->write(str106);
    }
    buf->write(arg);
  }
  for (ListIter<runtime_asdl::assign_arg*> it(cmd_val->pairs); !it.Done(); it.Next()) {
    runtime_asdl::assign_arg* pair = it.Value();
    StackRoots _for({&pair  });
    buf->write(str107);
    buf->write(pair->var_name);
    buf->write(str108);
    if (pair->rval) {
      _PrintShValue(pair->rval, buf);
    }
  }
  buf->write(str109);
  this->f->write(buf->getvalue());
}

void Tracer::OnShAssignment(runtime_asdl::lvalue_t* lval, syntax_asdl::assign_op_t op, runtime_asdl::value_t* val, int flags, runtime_asdl::scope_t which_scopes) {
  mylib::BufWriter* buf = nullptr;
  Str* left = nullptr;
  runtime_asdl::lvalue_t* UP_lval = nullptr;
  StackRoots _roots({&lval, &val, &buf, &left, &UP_lval});

  buf = this->_ShTraceBegin();
  if (!buf) {
    return ;
  }
  left = str110;
  UP_lval = lval;
  switch (lval->tag_()) {
    case lvalue_e::Named: {
      lvalue__Named* lval = static_cast<lvalue__Named*>(UP_lval);
      left = lval->name;
    }
      break;
    case lvalue_e::Indexed: {
      lvalue__Indexed* lval = static_cast<lvalue__Indexed*>(UP_lval);
      left = fmt19(lval->name, lval->index);
    }
      break;
    case lvalue_e::Keyed: {
      lvalue__Keyed* lval = static_cast<lvalue__Keyed*>(UP_lval);
      left = fmt20(lval->name, qsn::maybe_shell_encode(lval->key));
    }
      break;
  }
  buf->write(left);
  buf->write(op == assign_op_e::PlusEqual ? str113 : str114);
  _PrintShValue(val, buf);
  buf->write(str115);
  this->f->write(buf->getvalue());
}

void Tracer::OnControlFlow(Str* keyword, int arg) {
  Str* prefix = nullptr;
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&keyword, &prefix, &buf});

  if (!this->exec_opts->xtrace()) {
    return ;
  }
  prefix = this->_EvalPS4(str116);
  buf = Alloc<mylib::BufWriter>();
  buf->write(prefix);
  buf->write(keyword);
  if (arg != 0) {
    buf->write(str117);
    buf->write(str(arg));
  }
  buf->write(str118);
  this->f->write(buf->getvalue());
}

void Tracer::PrintSourceCode(int left_spid, int right_spid, alloc::Arena* arena) {
  mylib::BufWriter* buf = nullptr;
  syntax_asdl::line_span* left_span = nullptr;
  syntax_asdl::line_span* right_span = nullptr;
  Str* line = nullptr;
  int start;
  int end;
  StackRoots _roots({&arena, &buf, &left_span, &right_span, &line});

  buf = this->_ShTraceBegin();
  if (!buf) {
    return ;
  }
  left_span = arena->GetLineSpan(left_spid);
  right_span = arena->GetLineSpan(right_spid);
  line = arena->GetLine(left_span->line_id);
  start = left_span->col;
  if (left_span->line_id == right_span->line_id) {
    end = right_span->col;
    buf->write(line->slice(start, end));
  }
  else {
    line = arena->GetLine(left_span->line_id);
    end = line->endswith(str119) ? -1 : len(line);
    buf->write(line->slice(start, end));
    buf->write(str120);
  }
  buf->write(str121);
  this->f->write(buf->getvalue());
}

}  // define namespace dev

namespace error {  // define

int NO_SPID = -1;

_ControlFlow::_ControlFlow(syntax_asdl::Token* token, int arg) 
    : Obj(Tag::FixedSize, maskof__ControlFlow(), sizeof(_ControlFlow))  {
  this->token = token;
  this->arg = arg;
}

bool _ControlFlow::IsReturn() {
  namespace Id = id_kind_asdl::Id;
  return this->token->id == Id::ControlFlow_Return;
}

bool _ControlFlow::IsBreak() {
  namespace Id = id_kind_asdl::Id;
  return this->token->id == Id::ControlFlow_Break;
}

bool _ControlFlow::IsContinue() {
  namespace Id = id_kind_asdl::Id;
  return this->token->id == Id::ControlFlow_Continue;
}

int _ControlFlow::StatusCode() {
  return (this->arg & 255);
}

}  // define namespace error

namespace executor {  // define

namespace Id = id_kind_asdl::Id;
namespace builtin_i = option_asdl::builtin_i;
using runtime_asdl::redirect;
namespace trace = runtime_asdl::trace;
namespace command_e = syntax_asdl::command_e;
using syntax_asdl::command__Simple;
using syntax_asdl::command__Pipeline;
using syntax_asdl::command__ControlFlow;
using syntax_asdl::command_sub;
using syntax_asdl::compound_word;
using syntax_asdl::Token;

_ProcessSubFrame::_ProcessSubFrame() 
    : Obj(Tag::FixedSize, maskof__ProcessSubFrame(), sizeof(_ProcessSubFrame))  {
  this->to_close = Alloc<List<int>>();
  this->to_wait = Alloc<List<process::Process*>>();
  this->span_ids = Alloc<List<int>>();
}

ShellExecutor::ShellExecutor(state::Mem* mem, optview::Exec* exec_opts, state::MutableOpts* mutable_opts, Dict<Str*, runtime_asdl::Proc*>* procs, state::Hay* hay_state, Dict<int, vm::_Builtin*>* builtins, state::SearchPath* search_path, process::ExternalProgram* ext_prog, process::Waiter* waiter, dev::Tracer* tracer, process::JobState* job_state, process::FdState* fd_state, ui::ErrorFormatter* errfmt) : vm::_Executor() {
  field_mask_ |= maskof_ShellExecutor();
  this->mem = mem;
  this->exec_opts = exec_opts;
  this->mutable_opts = mutable_opts;
  this->procs = procs;
  this->hay_state = hay_state;
  this->builtins = builtins;
  this->search_path = search_path;
  this->ext_prog = ext_prog;
  this->waiter = waiter;
  this->tracer = tracer;
  this->job_state = job_state;
  this->fd_state = fd_state;
  this->errfmt = errfmt;
  this->process_sub_stack = Alloc<List<executor::_ProcessSubFrame*>>();
}

void ShellExecutor::CheckCircularDeps() {
}

process::Process* ShellExecutor::_MakeProcess(syntax_asdl::command_t* node) {
  return _MakeProcess(node, true);
}

process::Process* ShellExecutor::_MakeProcess(syntax_asdl::command_t* node, bool inherit_errexit) {
  syntax_asdl::command_t* UP_node = nullptr;
  process::SubProgramThunk* thunk = nullptr;
  process::Process* p = nullptr;
  StackRoots _roots({&node, &UP_node, &thunk, &p});

  UP_node = node;
  if (node->tag_() == command_e::ControlFlow) {
    command__ControlFlow* node = static_cast<command__ControlFlow*>(UP_node);
    if (node->token->id != Id::ControlFlow_Exit) {
      e_die(fmt21(node->token->val), node->token);
    }
  }
  thunk = Alloc<process::SubProgramThunk>(this->cmd_ev, node, inherit_errexit);
  p = Alloc<process::Process>(thunk, this->job_state, this->tracer);
  return p;
}

int ShellExecutor::RunBuiltin(int builtin_id, runtime_asdl::cmd_value__Argv* cmd_val) {
  vm::_Builtin* builtin_func = nullptr;
  int status;
  Str* arg0 = nullptr;
  StackRoots _roots({&cmd_val, &builtin_func, &arg0});

  this->tracer->OnBuiltin(builtin_id, cmd_val->argv);
  builtin_func = this->builtins->index_(builtin_id);
  {  // with
    ui::ctx_Location ctx(this->errfmt, cmd_val->arg_spids->index_(0));

    try {
      try {
        status = builtin_func->Run(cmd_val);
      }
      catch (error::Usage* e) {
        arg0 = cmd_val->argv->index_(0);
        if (e->span_id == runtime::NO_SPID) {
          e->span_id = this->errfmt->CurrentLocation();
        }
        this->errfmt->PrefixPrint(e->msg, fmt22(arg0), e->span_id);
        status = 2;
      }
    }
    catch (std::exception) { }
  }
  return status;
}

int ShellExecutor::RunSimpleCommand(runtime_asdl::cmd_value__Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork) {
  return RunSimpleCommand(cmd_val, cmd_st, do_fork, true);
}

int ShellExecutor::RunSimpleCommand(runtime_asdl::cmd_value__Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork, bool call_procs) {
  List<Str*>* argv = nullptr;
  int arg0_spid;
  Str* arg0 = nullptr;
  int builtin_id;
  int status;
  runtime_asdl::Proc* proc_node = nullptr;
  int disabled_spid;
  Dict<Str*, Str*>* environ = nullptr;
  Str* argv0_path = nullptr;
  process::ExternalThunk* thunk = nullptr;
  process::Process* p = nullptr;
  StackRoots _roots({&cmd_val, &cmd_st, &argv, &arg0, &proc_node, &environ, &argv0_path, &thunk, &p});

  argv = cmd_val->argv;
  arg0_spid = len(cmd_val->arg_spids) ? cmd_val->arg_spids->index_(0) : runtime::NO_SPID;
  if (len(argv) == 0) {
    if (this->exec_opts->strict_argv()) {
      e_die(fmt23(), arg0_spid);
    }
    else {
      return 0;
    }
  }
  arg0 = argv->index_(0);
  builtin_id = consts::LookupAssignBuiltin(arg0);
  if (builtin_id != consts::NO_INDEX) {
    this->errfmt->Print_(str126, arg0_spid);
    return 1;
  }
  builtin_id = consts::LookupSpecialBuiltin(arg0);
  if (builtin_id != consts::NO_INDEX) {
    cmd_st->show_code = true;
    status = this->RunBuiltin(builtin_id, cmd_val);
    return status;
  }
  if (call_procs) {
    proc_node = this->procs->get(arg0);
    if (proc_node != nullptr) {
      if (this->exec_opts->strict_errexit()) {
        disabled_spid = this->mutable_opts->ErrExitDisabledSpanId();
        if (disabled_spid != runtime::NO_SPID) {
          this->errfmt->Print_(str127, disabled_spid);
          this->errfmt->StderrLine(str128);
          e_die(fmt24(), arg0_spid);
        }
      }
      {  // with
        dev::ctx_Tracer ctx(this->tracer, str130, argv);

        status = this->cmd_ev->RunProc(proc_node, argv->slice(1), arg0_spid);
      }
      return status;
    }
  }
  if (this->hay_state->Resolve(arg0)) {
    return this->RunBuiltin(builtin_i::haynode, cmd_val);
  }
  builtin_id = consts::LookupNormalBuiltin(arg0);
  if (this->exec_opts->_running_hay()) {
    if ((builtin_id == builtin_i::haynode || builtin_id == builtin_i::use || builtin_id == builtin_i::echo || builtin_id == builtin_i::write)) {
      cmd_st->show_code = true;
      return this->RunBuiltin(builtin_id, cmd_val);
    }
    this->errfmt->Print_(fmt25(arg0), arg0_spid);
    return 127;
  }
  if (builtin_id != consts::NO_INDEX) {
    cmd_st->show_code = true;
    return this->RunBuiltin(builtin_id, cmd_val);
  }
  environ = this->mem->GetExported();
  if (cmd_val->typed_args) {
    e_die(fmt26(arg0), cmd_val->typed_args->spids->index_(0));
  }
  argv0_path = this->search_path->CachedLookup(arg0);
  if (argv0_path == nullptr) {
    this->errfmt->Print_(fmt27(arg0), arg0_spid);
    return 127;
  }
  if (do_fork) {
    thunk = Alloc<process::ExternalThunk>(this->ext_prog, argv0_path, cmd_val, environ);
    p = Alloc<process::Process>(thunk, this->job_state, this->tracer);
    status = p->RunWait(this->waiter, Alloc<trace::External>(cmd_val->argv));
    cmd_st->show_code = true;
    return status;
  }
  this->tracer->OnExec(cmd_val->argv);
  this->ext_prog->Exec(argv0_path, cmd_val, environ);
  assert(0);  // AssertionError
}

int ShellExecutor::RunBackgroundJob(syntax_asdl::command_t* node) {
  syntax_asdl::command_t* UP_node = nullptr;
  process::Pipeline* pi = nullptr;
  process::Process* p = nullptr;
  int last_pid;
  int pid;
  StackRoots _roots({&node, &UP_node, &pi, &p});

  UP_node = node;
  if (UP_node->tag_() == command_e::Pipeline) {
    command__Pipeline* node = static_cast<command__Pipeline*>(UP_node);
    pi = Alloc<process::Pipeline>(this->exec_opts->sigpipe_status_ok());
    for (ListIter<syntax_asdl::command_t*> it(node->children); !it.Done(); it.Next()) {
      syntax_asdl::command_t* child = it.Value();
      StackRoots _for({&child    });
      p = this->_MakeProcess(child);
      p->Init_ParentPipeline(pi);
      pi->Add(p);
    }
    pi->Start(this->waiter);
    last_pid = pi->LastPid();
    this->mem->last_bg_pid = last_pid;
    this->job_state->AddJob(pi);
  }
  else {
    p = this->_MakeProcess(node);
    pid = p->Start(Alloc<trace::Fork>());
    this->mem->last_bg_pid = pid;
    this->job_state->AddJob(p);
  }
  return 0;
}

void ShellExecutor::RunPipeline(syntax_asdl::command__Pipeline* node, runtime_asdl::CommandStatus* status_out) {
  process::Pipeline* pi = nullptr;
  int n;
  syntax_asdl::command_t* child = nullptr;
  process::Process* p = nullptr;
  syntax_asdl::command_t* last_child = nullptr;
  StackRoots _roots({&node, &status_out, &pi, &child, &p, &last_child});

  pi = Alloc<process::Pipeline>(this->exec_opts->sigpipe_status_ok());
  this->job_state->AddPipeline(pi);
  n = len(node->children);
  for (int i = 0; i < (n - 1); ++i) {
    child = node->children->index_(i);
    status_out->pipe_spids->append(location::SpanForCommand(child));
    p = this->_MakeProcess(child);
    p->Init_ParentPipeline(pi);
    pi->Add(p);
  }
  last_child = node->children->index_((n - 1));
  pi->AddLast((Alloc<Tuple2<cmd_eval::CommandEvaluator*, syntax_asdl::command_t*>>(this->cmd_ev, last_child)));
  status_out->pipe_spids->append(location::SpanForCommand(last_child));
  {  // with
    dev::ctx_Tracer ctx(this->tracer, str135, nullptr);

    status_out->pipe_status = pi->Run(this->waiter, this->fd_state);
  }
}

int ShellExecutor::RunSubshell(syntax_asdl::command_t* node) {
  process::Process* p = nullptr;
  StackRoots _roots({&node, &p});

  p = this->_MakeProcess(node);
  return p->RunWait(this->waiter, Alloc<trace::ForkWait>());
}

Str* ShellExecutor::RunCommandSub(syntax_asdl::command_sub* cs_part) {
  syntax_asdl::command_t* node = nullptr;
  syntax_asdl::Token* tok = nullptr;
  syntax_asdl::compound_word* cat_word = nullptr;
  process::Process* p = nullptr;
  int r;
  int w;
  List<Str*>* chunks = nullptr;
  int n;
  int err_num;
  int status;
  Str* msg = nullptr;
  StackRoots _roots({&cs_part, &node, &tok, &cat_word, &p, &chunks, &msg});

  if (!this->exec_opts->allow_csub_psub()) {
    e_die(fmt28(), word_::LeftMostSpanForPart(cs_part));
  }
  node = cs_part->child;
  if (node->tag_() == command_e::Simple) {
    command__Simple* simple = static_cast<command__Simple*>(node);
    if ((len(simple->words) == 0 and (len(simple->redirects) == 1 and simple->redirects->index_(0)->op->id == Id::Redir_Less))) {
      tok = Alloc<Token>(Id::Lit_Chars, runtime::NO_SPID, str137);
      cat_word = Alloc<compound_word>(NewList<syntax_asdl::word_part_t*>(std::initializer_list<syntax_asdl::word_part_t*>{tok}));
      simple->words->append(cat_word);
    }
  }
  p = this->_MakeProcess(node, this->exec_opts->inherit_errexit());
  Tuple2<int, int> tup0 = posix::pipe();
  r = tup0.at0();
  w = tup0.at1();
  p->AddStateChange(Alloc<process::StdoutToPipe>(r, w));
  p->Start(Alloc<trace::CommandSub>());
  chunks = Alloc<List<Str*>>();
  posix::close(w);
  while (true) {
    Tuple2<int, int> tup1 = pyos::Read(r, 4096, chunks);
    n = tup1.at0();
    err_num = tup1.at1();
    if (n < 0) {
      if (err_num == EINTR) {
        ;  // pass
      }
      else {
        e_die_status(2, fmt29(posix::strerror(err_num)));
      }
    }
    else {
      if (n == 0) {
        break;
      }
    }
  }
  posix::close(r);
  status = p->Wait(this->waiter);
  if (this->exec_opts->command_sub_errexit()) {
    if (status != 0) {
      msg = fmt30(status);
      throw Alloc<error::ErrExit>(msg, cs_part->left_token->span_id, status);
    }
  }
  else {
    this->cmd_ev->check_command_sub_status = true;
    this->mem->SetLastStatus(status);
  }
  return str140->join(chunks)->rstrip(str141);
}

Str* ShellExecutor::RunProcessSub(syntax_asdl::command_sub* cs_part) {
  process::Process* p = nullptr;
  int r;
  int w;
  int op_id;
  process::ChildStateChange* redir = nullptr;
  executor::_ProcessSubFrame* ps_frame = nullptr;
  StackRoots _roots({&cs_part, &p, &redir, &ps_frame});

  if (!this->exec_opts->allow_csub_psub()) {
    e_die(fmt31(), word_::LeftMostSpanForPart(cs_part));
  }
  p = this->_MakeProcess(cs_part->child);
  Tuple2<int, int> tup2 = posix::pipe();
  r = tup2.at0();
  w = tup2.at1();
  op_id = cs_part->left_token->id;
  if (op_id == Id::Left_ProcSubIn) {
    redir = Alloc<process::StdoutToPipe>(r, w);
  }
  else {
    if (op_id == Id::Left_ProcSubOut) {
      redir = Alloc<process::StdinFromPipe>(r, w);
    }
    else {
      assert(0);  // AssertionError
    }
  }
  p->AddStateChange(redir);
  p->Start(Alloc<trace::ProcessSub>());
  ps_frame = this->process_sub_stack->index_(-1);
  ps_frame->to_wait->append(p);
  ps_frame->span_ids->append(cs_part->left_token->span_id);
  if (op_id == Id::Left_ProcSubIn) {
    posix::close(w);
    ps_frame->to_close->append(r);
  }
  else {
    if (op_id == Id::Left_ProcSubOut) {
      posix::close(r);
      ps_frame->to_close->append(w);
    }
    else {
      assert(0);  // AssertionError
    }
  }
  if (op_id == Id::Left_ProcSubIn) {
    return fmt32(r);
  }
  else {
    if (op_id == Id::Left_ProcSubOut) {
      return fmt33(w);
    }
    else {
      assert(0);  // AssertionError
    }
  }
}

void ShellExecutor::MaybeWaitOnProcessSubs(executor::_ProcessSubFrame* frame, runtime_asdl::StatusArray* compound_st) {
  int i;
  int st;
  StackRoots _roots({&frame, &compound_st});

  for (ListIter<int> it(frame->to_close); !it.Done(); it.Next()) {
    int fd = it.Value();
    posix::close(fd);
  }
  i = 0;
  for (ListIter<process::Process*> it(frame->to_wait); !it.Done(); it.Next(), ++i) {
    process::Process* p = it.Value();
    StackRoots _for({&p  });
    st = p->Wait(this->waiter);
    compound_st->codes->append(st);
    compound_st->spids->append(frame->span_ids->index_(i));
  }
}

void ShellExecutor::Time() {
  ;  // pass
}

bool ShellExecutor::PushRedirects(List<runtime_asdl::redirect*>* redirects) {
  StackRoots _roots({&redirects});

  return this->fd_state->Push(redirects);
}

void ShellExecutor::PopRedirects() {
  this->fd_state->Pop();
}

void ShellExecutor::PushProcessSub() {
  this->process_sub_stack->append(Alloc<_ProcessSubFrame>());
}

void ShellExecutor::PopProcessSub(runtime_asdl::StatusArray* compound_st) {
  executor::_ProcessSubFrame* frame = nullptr;
  StackRoots _roots({&compound_st, &frame});

  frame = this->process_sub_stack->pop();
  this->MaybeWaitOnProcessSubs(frame, compound_st);
}

}  // define namespace executor

namespace main_loop {  // define

using syntax_asdl::command_t;
namespace command = syntax_asdl::command;
using syntax_asdl::parse_result__Node;
namespace parse_result_e = syntax_asdl::parse_result_e;

ctx_Descriptors::ctx_Descriptors(List<int>* fds) 
    : Obj(Tag::FixedSize, maskof_ctx_Descriptors(), sizeof(ctx_Descriptors))  {
  this->saved0 = process::SaveFd(0);
  this->saved1 = process::SaveFd(1);
  this->saved2 = process::SaveFd(2);
  posix::dup2(fds->index_(0), 0);
  posix::dup2(fds->index_(1), 1);
  posix::dup2(fds->index_(2), 2);
  this->fds = fds;
}

ctx_Descriptors::~ctx_Descriptors(){
  posix::dup2(this->saved0, 0);
  posix::dup2(this->saved1, 1);
  posix::dup2(this->saved2, 2);
  posix::close(this->saved0);
  posix::close(this->saved1);
  posix::close(this->saved2);
  posix::close(this->fds->index_(0));
  posix::close(this->fds->index_(1));
  posix::close(this->fds->index_(2));
}

int Batch(cmd_eval::CommandEvaluator* cmd_ev, cmd_parse::CommandParser* c_parser, ui::ErrorFormatter* errfmt) {
  return Batch(cmd_ev, c_parser, errfmt, 0);
}

int Batch(cmd_eval::CommandEvaluator* cmd_ev, cmd_parse::CommandParser* c_parser, ui::ErrorFormatter* errfmt, int cmd_flags) {
  int status;
  syntax_asdl::command_t* node = nullptr;
  bool is_return;
  bool is_fatal;
  StackRoots _roots({&cmd_ev, &c_parser, &errfmt, &node});

  status = 0;
  while (true) {
    try {
      node = c_parser->ParseLogicalLine();
      if (node == nullptr) {
        c_parser->CheckForPendingHereDocs();
        break;
      }
    }
    catch (error::Parse* e) {
      errfmt->PrettyPrintError(e);
      status = 2;
      break;
    }
    if (((cmd_flags & cmd_eval::IsMainProgram) and c_parser->line_reader->LastLineHint())) {
      cmd_flags |= cmd_eval::Optimize;
    }
    Tuple2<bool, bool> tup0 = cmd_ev->ExecuteAndCatch(node, cmd_flags);
    is_return = tup0.at0();
    is_fatal = tup0.at1();
    status = cmd_ev->LastStatus();
    if ((is_return or is_fatal)) {
      break;
    }
  }
  return status;
}

syntax_asdl::command_t* ParseWholeFile(cmd_parse::CommandParser* c_parser) {
  List<syntax_asdl::command_t*>* children = nullptr;
  syntax_asdl::command_t* node = nullptr;
  StackRoots _roots({&c_parser, &children, &node});

  children = Alloc<List<syntax_asdl::command_t*>>();
  while (true) {
    node = c_parser->ParseLogicalLine();
    if (node == nullptr) {
      c_parser->CheckForPendingHereDocs();
      break;
    }
    children->append(node);
  }
  if (len(children) == 1) {
    return children->index_(0);
  }
  else {
    return Alloc<command::CommandList>(children);
  }
}

}  // define namespace main_loop

namespace process {  // define

namespace Id = id_kind_asdl::Id;
using runtime_asdl::job_state_e;
using runtime_asdl::job_state_t;
using runtime_asdl::job_state_str;
namespace wait_status = runtime_asdl::wait_status;
using runtime_asdl::wait_status_t;
using runtime_asdl::redirect;
namespace redirect_arg_e = runtime_asdl::redirect_arg_e;
using runtime_asdl::redirect_arg__Path;
using runtime_asdl::redirect_arg__CopyFd;
using runtime_asdl::redirect_arg__MoveFd;
using runtime_asdl::redirect_arg__HereDoc;
namespace value = runtime_asdl::value;
namespace value_e = runtime_asdl::value_e;
namespace lvalue = runtime_asdl::lvalue;
using runtime_asdl::value__Str;
namespace trace = runtime_asdl::trace;
using runtime_asdl::trace_t;
namespace redir_loc = syntax_asdl::redir_loc;
namespace redir_loc_e = syntax_asdl::redir_loc_e;
using syntax_asdl::redir_loc_t;
using syntax_asdl::redir_loc__VarName;
using syntax_asdl::redir_loc__Fd;
using mylib::StrFromC;
int NO_FD = -1;
int _SHELL_MIN_FD = 100;
int STYLE_DEFAULT = 0;
int STYLE_LONG = 1;
int STYLE_PID_ONLY = 2;

int SaveFd(int fd) {
  int saved;
  saved = fcntl_::fcntl(fd, F_DUPFD, _SHELL_MIN_FD);
  return saved;
}

_RedirFrame::_RedirFrame(int saved_fd, int orig_fd, bool forget) 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(_RedirFrame))  {
  this->saved_fd = saved_fd;
  this->orig_fd = orig_fd;
  this->forget = forget;
}

_FdFrame::_FdFrame() 
    : Obj(Tag::FixedSize, maskof__FdFrame(), sizeof(_FdFrame))  {
  this->saved = Alloc<List<process::_RedirFrame*>>();
  this->need_wait = Alloc<List<process::Process*>>();
}

void _FdFrame::Forget() {
  for (ReverseListIter<process::_RedirFrame*> it(this->saved); !it.Done(); it.Next()) {
    process::_RedirFrame* rf = it.Value();
    StackRoots _for({&rf  });
    if ((rf->saved_fd != NO_FD and rf->forget)) {
      posix::close(rf->saved_fd);
    }
  }
  this->saved->clear();
  this->need_wait->clear();
}

FdState::FdState(ui::ErrorFormatter* errfmt, process::JobState* job_state, state::Mem* mem, dev::Tracer* tracer, process::Waiter* waiter) 
    : Obj(Tag::FixedSize, maskof_FdState(), sizeof(FdState))  {
  this->errfmt = errfmt;
  this->job_state = job_state;
  this->cur_frame = Alloc<_FdFrame>();
  this->stack = NewList<process::_FdFrame*>(std::initializer_list<process::_FdFrame*>{this->cur_frame});
  this->mem = mem;
  this->tracer = tracer;
  this->waiter = waiter;
}

mylib::LineReader* FdState::Open(Str* path) {
  int fd_mode;
  StackRoots _roots({&path});

  fd_mode = O_RDONLY;
  return this->_Open(path, str146, fd_mode);
}

mylib::LineReader* FdState::_Open(Str* path, Str* c_mode, int fd_mode) {
  int fd;
  int new_fd;
  mylib::LineReader* f = nullptr;
  StackRoots _roots({&path, &c_mode, &f});

  fd = posix::open(path, fd_mode, 438);
  new_fd = SaveFd(fd);
  posix::close(fd);
  f = posix::fdopen(new_fd, c_mode);
  return f;
}

void FdState::_WriteFdToMem(Str* fd_name, int fd) {
  StackRoots _roots({&fd_name});

  if (this->mem) {
    state::OshLanguageSetValue(this->mem, Alloc<lvalue::Named>(fd_name), Alloc<value::Str>(str(fd)));
  }
}

int FdState::_ReadFdFromMem(Str* fd_name) {
  runtime_asdl::value_t* val = nullptr;
  StackRoots _roots({&fd_name, &val});

  val = this->mem->GetValue(fd_name);
  if (val->tag_() == value_e::Str) {
    try {
      return to_int(static_cast<value__Str*>(val)->s);
    }
    catch (ValueError*) {
      return NO_FD;
    }
  }
  return NO_FD;
}

bool FdState::_PushSave(int fd) {
  bool ok;
  int new_fd;
  ok = true;
  try {
    new_fd = SaveFd(fd);
  }
  catch (IOError* e) {
    ok = false;
    if (e->errno_ != EBADF) {
      throw ;
    }
  }
  if (ok) {
    posix::close(fd);
    fcntl_::fcntl(new_fd, F_SETFD, FD_CLOEXEC);
    this->cur_frame->saved->append(Alloc<_RedirFrame>(new_fd, fd, true));
  }
  else {
    this->_PushClose(fd);
  }
  return ok;
}

int FdState::_PushDup(int fd1, syntax_asdl::redir_loc_t* loc) {
  syntax_asdl::redir_loc_t* UP_loc = nullptr;
  Str* fd2_name = nullptr;
  int new_fd;
  int fd2;
  bool need_restore;
  process::_RedirFrame* rf = nullptr;
  StackRoots _roots({&loc, &UP_loc, &fd2_name, &rf});

  UP_loc = loc;
  if (loc->tag_() == redir_loc_e::VarName) {
    fd2_name = static_cast<redir_loc__VarName*>(UP_loc)->name;
    try {
      new_fd = fcntl_::fcntl(fd1, F_DUPFD, _SHELL_MIN_FD);
    }
    catch (IOError* e) {
      if (e->errno_ == EBADF) {
        this->errfmt->Print_(fmt34(fd1, pyutil::strerror(e)));
        return NO_FD;
      }
      else {
        throw ;
      }
    }
    this->_WriteFdToMem(fd2_name, new_fd);
  }
  else {
    if (loc->tag_() == redir_loc_e::Fd) {
      fd2 = static_cast<redir_loc__Fd*>(UP_loc)->fd;
      if (fd1 == fd2) {
        return NO_FD;
      }
      try {
        fcntl_::fcntl(fd1, F_GETFD);
      }
      catch (IOError* e) {
        this->errfmt->Print_(fmt35(fd1, pyutil::strerror(e)));
        throw ;
      }
      need_restore = this->_PushSave(fd2);
      try {
        posix::dup2(fd1, fd2);
      }
      catch (OSError* e) {
        this->errfmt->Print_(fmt36(fd1, pyutil::strerror(e)));
        if (need_restore) {
          rf = this->cur_frame->saved->pop();
          posix::dup2(rf->saved_fd, rf->orig_fd);
          posix::close(rf->saved_fd);
        }
        throw ;
      }
      new_fd = fd2;
    }
    else {
      assert(0);  // AssertionError
    }
  }
  return new_fd;
}

bool FdState::_PushCloseFd(syntax_asdl::redir_loc_t* loc) {
  syntax_asdl::redir_loc_t* UP_loc = nullptr;
  Str* fd_name = nullptr;
  int fd;
  StackRoots _roots({&loc, &UP_loc, &fd_name});

  UP_loc = loc;
  if (loc->tag_() == redir_loc_e::VarName) {
    fd_name = static_cast<redir_loc__VarName*>(UP_loc)->name;
    fd = this->_ReadFdFromMem(fd_name);
    if (fd == NO_FD) {
      return false;
    }
  }
  else {
    if (loc->tag_() == redir_loc_e::Fd) {
      fd = static_cast<redir_loc__Fd*>(UP_loc)->fd;
    }
    else {
      assert(0);  // AssertionError
    }
  }
  this->_PushSave(fd);
  return true;
}

void FdState::_PushClose(int fd) {
  this->cur_frame->saved->append(Alloc<_RedirFrame>(NO_FD, fd, false));
}

void FdState::_PushWait(process::Process* proc) {
  StackRoots _roots({&proc});

  this->cur_frame->need_wait->append(proc);
}

void FdState::_ApplyRedirect(runtime_asdl::redirect* r) {
  runtime_asdl::redirect_arg_t* arg = nullptr;
  runtime_asdl::redirect_arg_t* UP_arg = nullptr;
  int mode;
  int open_fd;
  int new_fd;
  syntax_asdl::redir_loc_t* UP_loc = nullptr;
  int fd;
  int read_fd;
  int write_fd;
  process::_HereDocWriterThunk* thunk = nullptr;
  bool start_process;
  process::Process* here_proc = nullptr;
  StackRoots _roots({&r, &arg, &UP_arg, &UP_loc, &thunk, &here_proc});

  arg = r->arg;
  UP_arg = arg;
  switch (arg->tag_()) {
    case redirect_arg_e::Path: {
      redirect_arg__Path* arg = static_cast<redirect_arg__Path*>(UP_arg);
      if ((r->op_id == Id::Redir_Great || r->op_id == Id::Redir_AndGreat)) {
        mode = ((O_CREAT | O_WRONLY) | O_TRUNC);
      }
      else {
        if (r->op_id == Id::Redir_Clobber) {
          mode = ((O_CREAT | O_WRONLY) | O_TRUNC);
        }
        else {
          if ((r->op_id == Id::Redir_DGreat || r->op_id == Id::Redir_AndDGreat)) {
            mode = ((O_CREAT | O_WRONLY) | O_APPEND);
          }
          else {
            if (r->op_id == Id::Redir_Less) {
              mode = O_RDONLY;
            }
            else {
              if (r->op_id == Id::Redir_LessGreat) {
                mode = (O_CREAT | O_RDWR);
              }
              else {
                throw Alloc<NotImplementedError>(r->op_id);
              }
            }
          }
        }
      }
      try {
        open_fd = posix::open(arg->filename, mode, 438);
      }
      catch (OSError* e) {
        this->errfmt->Print_(fmt37(arg->filename, pyutil::strerror(e)), r->op_spid);
        throw ;
      }
      new_fd = this->_PushDup(open_fd, r->loc);
      if (new_fd != NO_FD) {
        posix::close(open_fd);
      }
      if ((r->op_id == Id::Redir_AndGreat || r->op_id == Id::Redir_AndDGreat)) {
        this->_PushDup(new_fd, Alloc<redir_loc::Fd>(2));
      }
    }
      break;
    case redirect_arg_e::CopyFd: {
      redirect_arg__CopyFd* arg = static_cast<redirect_arg__CopyFd*>(UP_arg);
      if (r->op_id == Id::Redir_GreatAnd) {
        this->_PushDup(arg->target_fd, r->loc);
      }
      else {
        if (r->op_id == Id::Redir_LessAnd) {
          this->_PushDup(arg->target_fd, r->loc);
        }
        else {
          throw Alloc<NotImplementedError>();
        }
      }
    }
      break;
    case redirect_arg_e::MoveFd: {
      redirect_arg__MoveFd* arg = static_cast<redirect_arg__MoveFd*>(UP_arg);
      new_fd = this->_PushDup(arg->target_fd, r->loc);
      if (new_fd != NO_FD) {
        posix::close(arg->target_fd);
        UP_loc = r->loc;
        if (r->loc->tag_() == redir_loc_e::Fd) {
          fd = static_cast<redir_loc__Fd*>(UP_loc)->fd;
        }
        else {
          fd = NO_FD;
        }
        this->cur_frame->saved->append(Alloc<_RedirFrame>(new_fd, fd, false));
      }
    }
      break;
    case redirect_arg_e::CloseFd: {
      this->_PushCloseFd(r->loc);
    }
      break;
    case redirect_arg_e::HereDoc: {
      redirect_arg__HereDoc* arg = static_cast<redirect_arg__HereDoc*>(UP_arg);
      Tuple2<int, int> tup0 = posix::pipe();
      read_fd = tup0.at0();
      write_fd = tup0.at1();
      this->_PushDup(read_fd, r->loc);
      this->_PushClose(read_fd);
      thunk = Alloc<_HereDocWriterThunk>(write_fd, arg->body);
      start_process = true;
      if (start_process) {
        here_proc = Alloc<Process>(thunk, this->job_state, this->tracer);
        here_proc->Start(Alloc<trace::HereDoc>());
        this->_PushWait(here_proc);
        posix::close(write_fd);
      }
      else {
        posix::write(write_fd, arg->body);
        posix::close(write_fd);
      }
    }
      break;
  }
}

bool FdState::Push(List<runtime_asdl::redirect*>* redirects) {
  process::_FdFrame* new_frame = nullptr;
  StackRoots _roots({&redirects, &new_frame});

  new_frame = Alloc<_FdFrame>();
  this->stack->append(new_frame);
  this->cur_frame = new_frame;
  for (ListIter<runtime_asdl::redirect*> it(redirects); !it.Done(); it.Next()) {
    runtime_asdl::redirect* r = it.Value();
    StackRoots _for({&r  });
    {  // with
      ui::ctx_Location ctx(this->errfmt, r->op_spid);

      try {
        this->_ApplyRedirect(r);
      }
      catch (IOError_OSError* e) {
        this->Pop();
        return false;
      }
    }
  }
  return true;
}

bool FdState::PushStdinFromPipe(int r) {
  process::_FdFrame* new_frame = nullptr;
  StackRoots _roots({&new_frame});

  new_frame = Alloc<_FdFrame>();
  this->stack->append(new_frame);
  this->cur_frame = new_frame;
  this->_PushDup(r, Alloc<redir_loc::Fd>(0));
  return true;
}

void FdState::Pop() {
  process::_FdFrame* frame = nullptr;
  StackRoots _roots({&frame});

  frame = this->stack->pop();
  for (ReverseListIter<process::_RedirFrame*> it(frame->saved); !it.Done(); it.Next()) {
    process::_RedirFrame* rf = it.Value();
    StackRoots _for({&rf  });
    if (rf->saved_fd == NO_FD) {
      try {
        posix::close(rf->orig_fd);
      }
      catch (OSError* e) {
        println_stderr(fmt38(rf->orig_fd, pyutil::strerror(e)));
        throw ;
      }
    }
    else {
      try {
        posix::dup2(rf->saved_fd, rf->orig_fd);
      }
      catch (OSError* e) {
        println_stderr(fmt39(rf->saved_fd, rf->orig_fd, pyutil::strerror(e)));
        throw ;
      }
      posix::close(rf->saved_fd);
    }
  }
  for (ListIter<process::Process*> it(frame->need_wait); !it.Done(); it.Next()) {
    process::Process* proc = it.Value();
    StackRoots _for({&proc  });
  }
}

void FdState::MakePermanent() {
  this->cur_frame->Forget();
}

ChildStateChange::ChildStateChange() 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(ChildStateChange))  {
  ;  // pass
}

void ChildStateChange::Apply() {
  throw Alloc<NotImplementedError>();
}

StdinFromPipe::StdinFromPipe(int pipe_read_fd, int w)  {
  this->r = pipe_read_fd;
  this->w = w;
}

void StdinFromPipe::Apply() {
  posix::dup2(this->r, 0);
  posix::close(this->r);
  posix::close(this->w);
}

StdoutToPipe::StdoutToPipe(int r, int pipe_write_fd)  {
  this->r = r;
  this->w = pipe_write_fd;
}

void StdoutToPipe::Apply() {
  posix::dup2(this->w, 1);
  posix::close(this->w);
  posix::close(this->r);
}

ExternalProgram::ExternalProgram(Str* hijack_shebang, process::FdState* fd_state, ui::ErrorFormatter* errfmt, util::_DebugFile* debug_f) 
    : Obj(Tag::FixedSize, maskof_ExternalProgram(), sizeof(ExternalProgram))  {
  this->hijack_shebang = hijack_shebang;
  this->fd_state = fd_state;
  this->errfmt = errfmt;
  this->debug_f = debug_f;
}

void ExternalProgram::Exec(Str* argv0_path, runtime_asdl::cmd_value__Argv* cmd_val, Dict<Str*, Str*>* environ) {
  StackRoots _roots({&argv0_path, &cmd_val, &environ});

  this->_Exec(argv0_path, cmd_val->argv, cmd_val->arg_spids->index_(0), environ, true);
}

void ExternalProgram::_Exec(Str* argv0_path, List<Str*>* argv, int argv0_spid, Dict<Str*, Str*>* environ, bool should_retry) {
  bool ok;
  mylib::LineReader* f = nullptr;
  Str* line = nullptr;
  List<Str*>* h_argv = nullptr;
  List<Str*>* new_argv = nullptr;
  int status;
  StackRoots _roots({&argv0_path, &argv, &environ, &f, &line, &h_argv, &new_argv});

  if (len(this->hijack_shebang)) {
    ok = true;
    try {
      f = this->fd_state->Open(argv0_path);
    }
    catch (IOError_OSError* e) {
      ok = false;
    }
    if (ok) {
      try {
        line = f->readline();
        if (match::ShouldHijack(line)) {
          h_argv = NewList<Str*>(std::initializer_list<Str*>{this->hijack_shebang, argv0_path});
          h_argv->extend(argv->slice(1));
          argv = h_argv;
          argv0_path = this->hijack_shebang;
          println_stderr(fmt40(argv0_path));
        }
        else {
          ;  // pass
        }
      }
      catch (std::exception) { }
    }
  }
  try {
    posix::execve(argv0_path, argv, environ);
  }
  catch (OSError* e) {
    if ((e->errno_ == ENOEXEC and should_retry)) {
      new_argv = NewList<Str*>(std::initializer_list<Str*>{str156, argv0_path});
      new_argv->extend(argv->slice(1));
      this->_Exec(str157, new_argv, argv0_spid, environ, false);
    }
    this->errfmt->Print_(fmt41(argv0_path, pyutil::strerror(e)), argv0_spid);
    if (e->errno_ == EACCES) {
      status = 126;
    }
    else {
      if (e->errno_ == ENOENT) {
        status = 127;
      }
      else {
        status = 127;
      }
    }
    posix::_exit(status);
  }
}

Thunk::Thunk() 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(Thunk))  {
  ;  // pass
}

void Thunk::Run() {
  throw Alloc<NotImplementedError>();
}

Str* Thunk::UserString() {
  throw Alloc<NotImplementedError>();
}

ExternalThunk::ExternalThunk(process::ExternalProgram* ext_prog, Str* argv0_path, runtime_asdl::cmd_value__Argv* cmd_val, Dict<Str*, Str*>* environ)  {
  field_mask_ |= maskof_ExternalThunk();
  this->ext_prog = ext_prog;
  this->argv0_path = argv0_path;
  this->cmd_val = cmd_val;
  this->environ = environ;
}

Str* ExternalThunk::UserString() {
  List<Str*>* tmp = nullptr;
  StackRoots _roots({&tmp});

  tmp = Alloc<List<Str*>>();
  for (ListIter<Str*> it(this->cmd_val->argv); !it.Done(); it.Next()) {
    Str* a = it.Value();
    tmp->append(qsn::maybe_shell_encode(a));
  }
  return fmt42(str160->join(tmp));
}

void ExternalThunk::Run() {
  this->ext_prog->Exec(this->argv0_path, this->cmd_val, this->environ);
}

SubProgramThunk::SubProgramThunk(cmd_eval::CommandEvaluator* cmd_ev, syntax_asdl::command_t* node, bool inherit_errexit)  {
  field_mask_ |= maskof_SubProgramThunk();
  this->cmd_ev = cmd_ev;
  this->node = node;
  this->inherit_errexit = inherit_errexit;
}

Str* SubProgramThunk::UserString() {
  Str* thunk_str = nullptr;
  StackRoots _roots({&thunk_str});

  thunk_str = ui::CommandType(this->node);
  return fmt43(thunk_str);
}

void SubProgramThunk::Run() {
  int status;
  if (!this->inherit_errexit) {
    this->cmd_ev->mutable_opts->DisableErrExit();
  }
  try {
    this->cmd_ev->ExecuteAndCatch(this->node, cmd_eval::Optimize);
    status = this->cmd_ev->LastStatus();
  }
  catch (util::UserExit* e) {
    status = e->status;
  }
  catch (KeyboardInterrupt*) {
    print(str162);
    status = 130;
  }
  catch (IOError_OSError* e) {
    println_stderr(fmt44(pyutil::strerror(e)));
    status = 2;
  }
  posix::_exit(status);
}

_HereDocWriterThunk::_HereDocWriterThunk(int w, Str* body_str)  {
  field_mask_ |= maskof__HereDocWriterThunk();
  this->w = w;
  this->body_str = body_str;
}

Str* _HereDocWriterThunk::UserString() {
  return str164;
}

void _HereDocWriterThunk::Run() {
  posix::write(this->w, this->body_str);
  posix::close(this->w);
  posix::_exit(0);
}

Job::Job() 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(Job))  {
  this->state = job_state_e::Running;
}

void Job::DisplayJob(int job_id, mylib::Writer* f, int style) {
  StackRoots _roots({&f});

  throw Alloc<NotImplementedError>();
}

runtime_asdl::job_state_t Job::State() {
  return this->state;
}

runtime_asdl::wait_status_t* Job::JobWait(process::Waiter* waiter) {
  StackRoots _roots({&waiter});

  throw Alloc<NotImplementedError>();
}

Process::Process(process::Thunk* thunk, process::JobState* job_state, dev::Tracer* tracer) : Job() {
  field_mask_ |= maskof_Process();
  this->thunk = thunk;
  this->job_state = job_state;
  this->tracer = tracer;
  this->parent_pipeline = nullptr;
  this->state_changes = Alloc<List<process::ChildStateChange*>>();
  this->close_r = -1;
  this->close_w = -1;
  this->pid = -1;
  this->status = -1;
}

void Process::Init_ParentPipeline(process::Pipeline* pi) {
  StackRoots _roots({&pi});

  this->parent_pipeline = pi;
}

void Process::DisplayJob(int job_id, mylib::Writer* f, int style) {
  Str* job_id_str = nullptr;
  StackRoots _roots({&f, &job_id_str});

  if (job_id == -1) {
    job_id_str = str166;
  }
  else {
    job_id_str = fmt45(job_id);
  }
  if (style == STYLE_PID_ONLY) {
    f->write(fmt46(this->pid));
  }
  else {
    f->write(fmt47(job_id_str, this->pid, _JobStateStr(this->state)));
    f->write(this->thunk->UserString());
    f->write(str170);
  }
}

void Process::AddStateChange(process::ChildStateChange* s) {
  StackRoots _roots({&s});

  this->state_changes->append(s);
}

void Process::AddPipeToClose(int r, int w) {
  this->close_r = r;
  this->close_w = w;
}

void Process::MaybeClosePipe() {
  if (this->close_r != -1) {
    posix::close(this->close_r);
    posix::close(this->close_w);
  }
}

int Process::Start(runtime_asdl::trace_t* why) {
  int pid;
  StackRoots _roots({&why});

  pid = posix::fork();
  if (pid < 0) {
    throw Alloc<RuntimeError>(str171);
  }
  else {
    if (pid == 0) {
      pyos::Sigaction(SIGPIPE, SIG_DFL);
      pyos::Sigaction(SIGQUIT, SIG_DFL);
      pyos::Sigaction(SIGTSTP, SIG_DFL);
      pyos::Sigaction(SIGTTOU, SIG_DFL);
      pyos::Sigaction(SIGTTIN, SIG_DFL);
      for (ListIter<process::ChildStateChange*> it(this->state_changes); !it.Done(); it.Next()) {
        process::ChildStateChange* st = it.Value();
        StackRoots _for({&st      });
        st->Apply();
      }
      this->tracer->SetProcess(posix::getpid());
      this->thunk->Run();
    }
  }
  this->tracer->OnProcessStart(pid, why);
  this->pid = pid;
  this->job_state->AddChildProcess(pid, this);
  return pid;
}

int Process::Wait(process::Waiter* waiter) {
  StackRoots _roots({&waiter});

  while (this->state == job_state_e::Running) {
    if (waiter->WaitForOne() == W1_ECHILD) {
      break;
    }
  }
  return this->status;
}

runtime_asdl::wait_status_t* Process::JobWait(process::Waiter* waiter) {
  int result;
  StackRoots _roots({&waiter});

  while (this->state == job_state_e::Running) {
    result = waiter->WaitForOne();
    if (result >= 0) {
      return Alloc<wait_status::Cancelled>(result);
    }
    if (result == W1_ECHILD) {
      break;
    }
  }
  return Alloc<wait_status::Proc>(this->status);
}

void Process::WhenStopped() {
  this->state = job_state_e::Stopped;
}

void Process::WhenDone(int pid, int status) {
  this->status = status;
  this->state = job_state_e::Done;
  if (this->parent_pipeline) {
    this->parent_pipeline->WhenDone(pid, status);
  }
}

int Process::RunWait(process::Waiter* waiter, runtime_asdl::trace_t* why) {
  StackRoots _roots({&waiter, &why});

  this->Start(why);
  return this->Wait(waiter);
}

ctx_Pipe::ctx_Pipe(process::FdState* fd_state, int fd) 
    : Obj(Tag::FixedSize, maskof_ctx_Pipe(), sizeof(ctx_Pipe))  {
  fd_state->PushStdinFromPipe(fd);
  this->fd_state = fd_state;
}

ctx_Pipe::~ctx_Pipe(){
  this->fd_state->Pop();
}

Pipeline::Pipeline(bool sigpipe_status_ok) : Job() {
  field_mask_ |= maskof_Pipeline();
  this->procs = Alloc<List<process::Process*>>();
  this->pids = Alloc<List<int>>();
  this->pipe_status = Alloc<List<int>>();
  this->status = -1;
  this->last_thunk = nullptr;
  this->last_pipe = nullptr;
  this->sigpipe_status_ok = sigpipe_status_ok;
}

void Pipeline::DisplayJob(int job_id, mylib::Writer* f, int style) {
  int i;
  Str* job_id_str = nullptr;
  StackRoots _roots({&f, &job_id_str});

  if (style == STYLE_PID_ONLY) {
    f->write(fmt48(this->procs->index_(0)->pid));
  }
  else {
    i = 0;
    for (ListIter<process::Process*> it(this->procs); !it.Done(); it.Next(), ++i) {
      process::Process* proc = it.Value();
      StackRoots _for({&proc    });
      if (i == 0) {
        job_id_str = fmt49(job_id);
      }
      else {
        job_id_str = str174;
        f->write(fmt50(job_id_str, proc->pid, _JobStateStr(proc->state)));
        f->write(proc->thunk->UserString());
        f->write(str176);
      }
    }
  }
}

void Pipeline::DebugPrint() {
  print(fmt51(_JobStateStr(this->state)));
}

void Pipeline::Add(process::Process* p) {
  int r;
  int w;
  process::Process* prev = nullptr;
  StackRoots _roots({&p, &prev});

  if (len(this->procs) == 0) {
    this->procs->append(p);
    return ;
  }
  Tuple2<int, int> tup1 = posix::pipe();
  r = tup1.at0();
  w = tup1.at1();
  prev = this->procs->index_(-1);
  prev->AddStateChange(Alloc<StdoutToPipe>(r, w));
  p->AddStateChange(Alloc<StdinFromPipe>(r, w));
  p->AddPipeToClose(r, w);
  this->procs->append(p);
}

void Pipeline::AddLast(Tuple2<cmd_eval::CommandEvaluator*, syntax_asdl::command_t*>* thunk) {
  int r;
  int w;
  process::Process* prev = nullptr;
  StackRoots _roots({&thunk, &prev});

  this->last_thunk = thunk;
  if (len(this->procs) == 0) {
    return ;
  }
  Tuple2<int, int> tup2 = posix::pipe();
  r = tup2.at0();
  w = tup2.at1();
  prev = this->procs->index_(-1);
  prev->AddStateChange(Alloc<StdoutToPipe>(r, w));
  this->last_pipe = (Alloc<Tuple2<int, int>>(r, w));
}

void Pipeline::Start(process::Waiter* waiter) {
  int i;
  int pid;
  StackRoots _roots({&waiter});

  i = 0;
  for (ListIter<process::Process*> it(this->procs); !it.Done(); it.Next(), ++i) {
    process::Process* proc = it.Value();
    StackRoots _for({&proc  });
    pid = proc->Start(Alloc<trace::PipelinePart>());
    this->pids->append(pid);
    this->pipe_status->append(-1);
    proc->MaybeClosePipe();
  }
  if (this->last_thunk) {
    this->pipe_status->append(-1);
  }
}

int Pipeline::LastPid() {
  return this->pids->index_(-1);
}

List<int>* Pipeline::Wait(process::Waiter* waiter) {
  StackRoots _roots({&waiter});

  while (this->state == job_state_e::Running) {
    if (waiter->WaitForOne() == W1_ECHILD) {
      break;
    }
  }
  return this->pipe_status;
}

runtime_asdl::wait_status_t* Pipeline::JobWait(process::Waiter* waiter) {
  int result;
  StackRoots _roots({&waiter});

  while (this->state == job_state_e::Running) {
    result = waiter->WaitForOne();
    if (result >= 0) {
      return Alloc<wait_status::Cancelled>(result);
    }
    if (result == W1_ECHILD) {
      break;
    }
  }
  return Alloc<wait_status::Pipeline>(this->pipe_status);
}

List<int>* Pipeline::Run(process::Waiter* waiter, process::FdState* fd_state) {
  cmd_eval::CommandEvaluator* cmd_ev = nullptr;
  syntax_asdl::command_t* last_node = nullptr;
  int r;
  int w;
  StackRoots _roots({&waiter, &fd_state, &cmd_ev, &last_node});

  this->Start(waiter);
  Tuple2<cmd_eval::CommandEvaluator*, syntax_asdl::command_t*>* tup3 = this->last_thunk;
  cmd_ev = tup3->at0();
  last_node = tup3->at1();
  if (this->last_pipe != nullptr) {
    Tuple2<int, int>* tup4 = this->last_pipe;
    r = tup4->at0();
    w = tup4->at1();
    posix::close(w);
    {  // with
      ctx_Pipe ctx(fd_state, r);

      cmd_ev->ExecuteAndCatch(last_node);
    }
    posix::close(r);
  }
  else {
    if (len(this->procs)) {
      cmd_ev->ExecuteAndCatch(last_node);
    }
    else {
      cmd_ev->_Execute(last_node);
    }
  }
  this->pipe_status->set(-1, cmd_ev->LastStatus());
  if (this->AllDone()) {
    this->state = job_state_e::Done;
  }
  if (len(this->procs)) {
    return this->Wait(waiter);
  }
  else {
    return this->pipe_status;
  }
}

bool Pipeline::AllDone() {
  for (ListIter<int> it(this->pipe_status); !it.Done(); it.Next()) {
    int status = it.Value();
    if (status == -1) {
      return false;
    }
  }
  return true;
}

void Pipeline::WhenDone(int pid, int status) {
  int i;
  i = this->pids->index(pid);
  if ((status == 141 and this->sigpipe_status_ok)) {
    status = 0;
  }
  this->pipe_status->set(i, status);
  if (this->AllDone()) {
    this->status = this->pipe_status->index_(-1);
    this->state = job_state_e::Done;
  }
}

Str* _JobStateStr(runtime_asdl::job_state_t i) {
  return StrFromC(job_state_str(i))->slice(10);
}

JobState::JobState() 
    : Obj(Tag::FixedSize, maskof_JobState(), sizeof(JobState))  {
  this->jobs = Alloc<Dict<int, process::Job*>>();
  this->child_procs = Alloc<Dict<int, process::Process*>>();
  this->debug_pipelines = Alloc<List<process::Pipeline*>>();
  this->last_stopped_pid = -1;
  this->job_id = 1;
}

void JobState::WhenStopped(int pid) {
  this->last_stopped_pid = pid;
}

int JobState::GetLastStopped() {
  return this->last_stopped_pid;
}

int JobState::WhenContinued(int pid, process::Waiter* waiter) {
  process::Process* job = nullptr;
  StackRoots _roots({&waiter, &job});

  if (pid == this->last_stopped_pid) {
    this->last_stopped_pid = -1;
  }
  job = this->JobFromPid(pid);
  job->state = job_state_e::Running;
  return job->Wait(waiter);
}

void JobState::WhenDone(int pid) {
  if (pid == this->last_stopped_pid) {
    this->last_stopped_pid = -1;
  }
  if (dict_contains(this->jobs, pid)) {
    this->jobs->remove(pid);
  }
  else {
    return ;
  }
}

int JobState::AddJob(process::Job* job) {
  int job_id;
  StackRoots _roots({&job});

  job_id = this->job_id;
  this->jobs->set(job_id, job);
  this->job_id += 1;
  return job_id;
}

void JobState::AddChildProcess(int pid, process::Process* proc) {
  StackRoots _roots({&proc});

  this->child_procs->set(pid, proc);
}

void JobState::AddPipeline(process::Pipeline* pi) {
  StackRoots _roots({&pi});

}

process::Process* JobState::JobFromPid(int pid) {
  return this->child_procs->get(pid);
}

void JobState::DisplayJobs(int style) {
  mylib::Writer* f = nullptr;
  StackRoots _roots({&f});

  f = mylib::Stdout();
  for (DictIter<int, process::Job*> it(this->jobs); !it.Done(); it.Next()) {
    int job_id = it.Key();
    process::Job* job = it.Value();
    job->DisplayJob(job_id, f, style);
  }
}

void JobState::DebugPrint() {
  mylib::Writer* f = nullptr;
  StackRoots _roots({&f});

  f = mylib::Stdout();
  f->write(str178);
  f->write(str179);
  for (DictIter<int, process::Process*> it(this->child_procs); !it.Done(); it.Next()) {
    int pid = it.Key();
    process::Process* proc = it.Value();
    proc->DisplayJob(-1, f, STYLE_DEFAULT);
  }
  if (len(this->debug_pipelines)) {
    f->write(str180);
    f->write(str181);
    for (ListIter<process::Pipeline*> it(this->debug_pipelines); !it.Done(); it.Next()) {
      process::Pipeline* pi = it.Value();
      StackRoots _for({&pi    });
      pi->DebugPrint();
    }
  }
}

void JobState::ListRecent() {
  ;  // pass
}

int JobState::NumRunning() {
  int count;
  count = 0;
  for (DictIter<int, process::Job*> it(this->jobs); !it.Done(); it.Next()) {
    int _ = it.Key();
    process::Job* job = it.Value();
    if (job->State() == job_state_e::Running) {
      count += 1;
    }
  }
  return count;
}
int W1_OK = -2;
int W1_ECHILD = -3;

Waiter::Waiter(process::JobState* job_state, optview::Exec* exec_opts, builtin_trap::TrapState* trap_state, dev::Tracer* tracer) 
    : Obj(Tag::FixedSize, maskof_Waiter(), sizeof(Waiter))  {
  this->job_state = job_state;
  this->exec_opts = exec_opts;
  this->trap_state = trap_state;
  this->tracer = tracer;
  this->last_status = 127;
}

int Waiter::WaitForOne() {
  int pid;
  int status;
  int err_num;
  process::Process* proc = nullptr;
  int term_sig;
  StackRoots _roots({&proc});

  Tuple2<int, int> tup5 = pyos::WaitPid();
  pid = tup5.at0();
  status = tup5.at1();
  if (pid < 0) {
    err_num = status;
    if (err_num == ECHILD) {
      return W1_ECHILD;
    }
    else {
      if (err_num == EINTR) {
        return this->trap_state->GetLastSignal();
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  if (!dict_contains(this->job_state->child_procs, pid)) {
    println_stderr(fmt52(pid));
    return W1_OK;
  }
  proc = this->job_state->child_procs->index_(pid);
  if (WIFSIGNALED(status)) {
    term_sig = WTERMSIG(status);
    status = (128 + term_sig);
    if (term_sig == SIGINT) {
      print(str183);
    }
    this->job_state->WhenDone(pid);
    proc->WhenDone(pid, status);
  }
  else {
    if (WIFEXITED(status)) {
      status = WEXITSTATUS(status);
      this->job_state->WhenDone(pid);
      proc->WhenDone(pid, status);
    }
    else {
      if (WIFSTOPPED(status)) {
        println_stderr(str184);
        println_stderr(fmt53(pid));
        this->job_state->WhenStopped(pid);
        proc->WhenStopped();
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  this->last_status = status;
  this->tracer->OnProcessEnd(pid, status);
  return W1_OK;
}

}  // define namespace process

namespace shell_native {  // define

namespace builtin_i = option_asdl::builtin_i;
namespace cmd_value = runtime_asdl::cmd_value;
namespace source = syntax_asdl::source;

runtime_asdl::cmd_value__Argv* MakeBuiltinArgv(List<Str*>* argv1) {
  List<Str*>* argv = nullptr;
  StackRoots _roots({&argv1, &argv});

  argv = NewList<Str*>(std::initializer_list<Str*>{str186});
  argv->extend(argv1);
  return Alloc<cmd_value::Argv>(argv, list_repeat(runtime::NO_SPID, len(argv)), nullptr);
}

void AddPure(Dict<int, vm::_Builtin*>* b, state::Mem* mem, Dict<Str*, runtime_asdl::Proc*>* procs, Dict<Str*, bool>* modules, state::MutableOpts* mutable_opts, Dict<Str*, Str*>* aliases, state::SearchPath* search_path, ui::ErrorFormatter* errfmt) {
  builtin_pure::Boolean* true_ = nullptr;
  StackRoots _roots({&b, &mem, &procs, &modules, &mutable_opts, &aliases, &search_path, &errfmt, &true_});

  b->set(builtin_i::set, Alloc<builtin_pure::Set>(mutable_opts, mem));
  b->set(builtin_i::alias, Alloc<builtin_pure::Alias>(aliases, errfmt));
  b->set(builtin_i::unalias, Alloc<builtin_pure::UnAlias>(aliases, errfmt));
  b->set(builtin_i::hash, Alloc<builtin_pure::Hash>(search_path));
  b->set(builtin_i::getopts, Alloc<builtin_pure::GetOpts>(mem, errfmt));
  true_ = Alloc<builtin_pure::Boolean>(0);
  b->set(builtin_i::colon, true_);
  b->set(builtin_i::true_, true_);
  b->set(builtin_i::false_, Alloc<builtin_pure::Boolean>(1));
  b->set(builtin_i::shift, Alloc<builtin_assign::Shift>(mem));
  b->set(builtin_i::type, Alloc<builtin_meta::Type>(procs, aliases, search_path, errfmt));
  b->set(builtin_i::module, Alloc<builtin_pure::Module>(modules, mem->exec_opts, errfmt));
}

void AddIO(Dict<int, vm::_Builtin*>* b, state::Mem* mem, state::DirStack* dir_stack, optview::Exec* exec_opts, split::SplitContext* splitter, parse_lib::ParseContext* parse_ctx, ui::ErrorFormatter* errfmt) {
  StackRoots _roots({&b, &mem, &dir_stack, &exec_opts, &splitter, &parse_ctx, &errfmt});

  b->set(builtin_i::echo, Alloc<builtin_pure::Echo>(exec_opts));
  b->set(builtin_i::cat, Alloc<builtin_misc::Cat>());
  b->set(builtin_i::test, Alloc<builtin_bracket::Test>(false, exec_opts, mem, errfmt));
  b->set(builtin_i::bracket, Alloc<builtin_bracket::Test>(true, exec_opts, mem, errfmt));
  b->set(builtin_i::pushd, Alloc<builtin_misc::Pushd>(mem, dir_stack, errfmt));
  b->set(builtin_i::popd, Alloc<builtin_misc::Popd>(mem, dir_stack, errfmt));
  b->set(builtin_i::dirs, Alloc<builtin_misc::Dirs>(mem, dir_stack, errfmt));
  b->set(builtin_i::pwd, Alloc<builtin_misc::Pwd>(mem, errfmt));
  b->set(builtin_i::times, Alloc<builtin_misc::Times>());
}

void AddProcess(Dict<int, vm::_Builtin*>* b, state::Mem* mem, vm::_Executor* shell_ex, process::ExternalProgram* ext_prog, process::FdState* fd_state, process::JobState* job_state, process::Waiter* waiter, dev::Tracer* tracer, state::SearchPath* search_path, ui::ErrorFormatter* errfmt) {
  StackRoots _roots({&b, &mem, &shell_ex, &ext_prog, &fd_state, &job_state, &waiter, &tracer, &search_path, &errfmt});

  b->set(builtin_i::exec_, Alloc<builtin_process2::Exec>(mem, ext_prog, fd_state, search_path, errfmt));
  b->set(builtin_i::umask, Alloc<builtin_process2::Umask>());
  b->set(builtin_i::wait, Alloc<builtin_process2::Wait>(waiter, job_state, mem, tracer, errfmt));
}

void AddMeta(Dict<int, vm::_Builtin*>* builtins, vm::_Executor* shell_ex, state::MutableOpts* mutable_opts, state::Mem* mem, Dict<Str*, runtime_asdl::Proc*>* procs, Dict<Str*, Str*>* aliases, state::SearchPath* search_path, ui::ErrorFormatter* errfmt) {
  StackRoots _roots({&builtins, &shell_ex, &mutable_opts, &mem, &procs, &aliases, &search_path, &errfmt});

  builtins->set(builtin_i::builtin, Alloc<builtin_meta::Builtin>(shell_ex, errfmt));
  builtins->set(builtin_i::command, Alloc<builtin_meta::Command>(shell_ex, procs, aliases, search_path));
  builtins->set(builtin_i::runproc, Alloc<builtin_meta::RunProc>(shell_ex, procs, errfmt));
  builtins->set(builtin_i::boolstatus, Alloc<builtin_meta::BoolStatus>(shell_ex, errfmt));
}

void AddBlock(Dict<int, vm::_Builtin*>* builtins, state::Mem* mem, state::MutableOpts* mutable_opts, state::DirStack* dir_stack, cmd_eval::CommandEvaluator* cmd_ev, vm::_Executor* shell_ex, state::Hay* hay_state, ui::ErrorFormatter* errfmt) {
  StackRoots _roots({&builtins, &mem, &mutable_opts, &dir_stack, &cmd_ev, &shell_ex, &hay_state, &errfmt});

  builtins->set(builtin_i::cd, Alloc<builtin_misc::Cd>(mem, dir_stack, cmd_ev, errfmt));
  builtins->set(builtin_i::shopt, Alloc<builtin_pure::Shopt>(mutable_opts, cmd_ev));
  builtins->set(builtin_i::try_, Alloc<builtin_meta::Try>(mutable_opts, mem, cmd_ev, shell_ex, errfmt));
}

Dict<int, vm::_AssignBuiltin*>* InitAssignmentBuiltins(state::Mem* mem, Dict<Str*, runtime_asdl::Proc*>* procs, ui::ErrorFormatter* errfmt) {
  Dict<int, vm::_AssignBuiltin*>* assign_b = nullptr;
  builtin_assign::NewVar* new_var = nullptr;
  StackRoots _roots({&mem, &procs, &errfmt, &assign_b, &new_var});

  assign_b = Alloc<Dict<int, vm::_AssignBuiltin*>>();
  new_var = Alloc<builtin_assign::NewVar>(mem, procs, errfmt);
  assign_b->set(builtin_i::declare, new_var);
  assign_b->set(builtin_i::typeset, new_var);
  assign_b->set(builtin_i::local, new_var);
  assign_b->set(builtin_i::export_, Alloc<builtin_assign::Export>(mem, errfmt));
  assign_b->set(builtin_i::readonly, Alloc<builtin_assign::Readonly>(mem, errfmt));
  return assign_b;
}

int Main(Str* lang, args::Reader* arg_r, Dict<Str*, Str*>* environ, bool login_shell, pyutil::_ResourceLoader* loader, void* line_input) {
  Str* argv0 = nullptr;
  args::_Attributes* attrs = nullptr;
  arg_types::main* flag = nullptr;
  alloc::Arena* arena = nullptr;
  ui::ErrorFormatter* errfmt = nullptr;
  builtin_misc::Help* help_builtin = nullptr;
  Str* no_str = nullptr;
  List<state::DebugFrame*>* debug_stack = nullptr;
  Str* dollar0 = nullptr;
  state::DebugFrame* frame0 = nullptr;
  state::DebugFrame* frame1 = nullptr;
  Str* script_name = nullptr;
  state::Mem* mem = nullptr;
  state::OptHook* opt_hook = nullptr;
  optview::Parse* parse_opts = nullptr;
  optview::Exec* exec_opts = nullptr;
  state::MutableOpts* mutable_opts = nullptr;
  Str* version_str = nullptr;
  Dict<Str*, runtime_asdl::Proc*>* procs = nullptr;
  state::Hay* hay_tree = nullptr;
  Dict<Str*, Str*>* aliases = nullptr;
  grammar::Grammar* oil_grammar = nullptr;
  parse_lib::ParseContext* parse_ctx = nullptr;
  alloc::Arena* comp_arena = nullptr;
  parse_lib::Trail* trail1 = nullptr;
  parse_lib::ParseContext* comp_ctx = nullptr;
  alloc::Arena* hist_arena = nullptr;
  parse_lib::Trail* trail2 = nullptr;
  parse_lib::ParseContext* hist_ctx = nullptr;
  cmd_eval::Deps* cmd_deps = nullptr;
  int my_pid;
  Str* debug_path = nullptr;
  Str* debug_dir = nullptr;
  util::_DebugFile* debug_f = nullptr;
  util::_DebugFile* trace_f = nullptr;
  dev::Tracer* tracer = nullptr;
  builtin_trap::TrapState* trap_state = nullptr;
  process::JobState* job_state = nullptr;
  process::FdState* fd_state = nullptr;
  process::Waiter* waiter = nullptr;
  Str* interp = nullptr;
  state::SearchPath* search_path = nullptr;
  process::ExternalProgram* ext_prog = nullptr;
  split::SplitContext* splitter = nullptr;
  funcs::ParseHay* parse_config = nullptr;
  Str* crash_dump_dir = nullptr;
  state::DirStack* dir_stack = nullptr;
  Dict<int, vm::_Builtin*>* builtins = nullptr;
  Dict<Str*, bool>* modules = nullptr;
  executor::ShellExecutor* shell_ex = nullptr;
  sh_expr_eval::ArithEvaluator* arith_ev = nullptr;
  sh_expr_eval::BoolEvaluator* bool_ev = nullptr;
  expr_eval::OilEvaluator* expr_ev = nullptr;
  word_eval::NormalWordEvaluator* word_ev = nullptr;
  Dict<int, vm::_AssignBuiltin*>* assign_b = nullptr;
  cmd_eval::CommandEvaluator* cmd_ev = nullptr;
  prompt::Evaluator* prompt_ev = nullptr;
  sh_expr_eval::UnsafeArith* unsafe_arith = nullptr;
  builtin_misc::MapFile* mapfile = nullptr;
  builtin_meta::Source* source_builtin = nullptr;
  reader::_Reader* line_reader = nullptr;
  mylib::LineReader* stdin = nullptr;
  mylib::LineReader* f = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  int status;
  syntax_asdl::command_t* node = nullptr;
  Str* input_path = nullptr;
  List<int>* box = nullptr;
  StackRoots _roots({&lang, &arg_r, &environ, &loader, &line_input, &argv0, &attrs, &flag, &arena, &errfmt, &help_builtin, &no_str, &debug_stack, &dollar0, &frame0, &frame1, &script_name, &mem, &opt_hook, &parse_opts, &exec_opts, &mutable_opts, &version_str, &procs, &hay_tree, &aliases, &oil_grammar, &parse_ctx, &comp_arena, &trail1, &comp_ctx, &hist_arena, &trail2, &hist_ctx, &cmd_deps, &debug_path, &debug_dir, &debug_f, &trace_f, &tracer, &trap_state, &job_state, &fd_state, &waiter, &interp, &search_path, &ext_prog, &splitter, &parse_config, &crash_dump_dir, &dir_stack, &builtins, &modules, &shell_ex, &arith_ev, &bool_ev, &expr_ev, &word_ev, &assign_b, &cmd_ev, &prompt_ev, &unsafe_arith, &mapfile, &source_builtin, &line_reader, &stdin, &f, &c_parser, &node, &input_path, &box});

  argv0 = arg_r->Peek();
  arg_r->Next();
  try {
    attrs = flag_spec::ParseMore(str187, arg_r);
  }
  catch (error::Usage* e) {
    println_stderr(fmt54(e->msg));
    return 2;
  }
  flag = Alloc<arg_types::main>(attrs->attrs);
  arena = Alloc<alloc::Arena>();
  errfmt = Alloc<ui::ErrorFormatter>(arena);
  help_builtin = Alloc<builtin_misc::Help>(loader, errfmt);
  if (flag->help) {
    help_builtin->Run(MakeBuiltinArgv(NewList<Str*>(std::initializer_list<Str*>{fmt55(lang)})));
    return 0;
  }
  if (flag->version) {
    pyutil::ShowAppVersion(str190, loader);
    return 0;
  }
  no_str = nullptr;
  debug_stack = Alloc<List<state::DebugFrame*>>();
  if (arg_r->AtEnd()) {
    dollar0 = argv0;
  }
  else {
    dollar0 = arg_r->Peek();
    frame0 = Alloc<state::DebugFrame>(dollar0, str191, no_str, state::LINE_ZERO, 0, 0);
    debug_stack->append(frame0);
  }
  frame1 = Alloc<state::DebugFrame>(no_str, no_str, no_str, runtime::NO_SPID, 0, 0);
  debug_stack->append(frame1);
  script_name = arg_r->Peek();
  arg_r->Next();
  mem = Alloc<state::Mem>(dollar0, arg_r->Rest(), arena, debug_stack);
  opt_hook = Alloc<state::OptHook>();
  Tuple3<optview::Parse*, optview::Exec*, state::MutableOpts*> tup0 = state::MakeOpts(mem, opt_hook);
  parse_opts = tup0.at0();
  exec_opts = tup0.at1();
  mutable_opts = tup0.at2();
  mem->exec_opts = exec_opts;
  mutable_opts->Init();
  version_str = pyutil::GetVersion(loader);
  state::InitMem(mem, environ, version_str);
  procs = Alloc<Dict<Str*, runtime_asdl::Proc*>>();
  hay_tree = Alloc<state::Hay>();
  if (attrs->show_options) {
    mutable_opts->ShowOptions(Alloc<List<Str*>>());
    return 0;
  }
  if (str_equals(lang, str192)) {
    mutable_opts->SetAnyOption(str193, true);
  }
  builtin_pure::SetOptionsFromFlags(mutable_opts, attrs->opt_changes, attrs->shopt_changes);
  aliases = Alloc<Dict<Str*, Str*>>();
  oil_grammar = nullptr;
  if ((flag->one_pass_parse and !exec_opts->noexec())) {
    e_usage(str194);
  }
  parse_ctx = Alloc<parse_lib::ParseContext>(arena, parse_opts, aliases, oil_grammar);
  parse_ctx->Init_OnePassParse(flag->one_pass_parse);
  comp_arena = Alloc<alloc::Arena>();
  comp_arena->PushSource(Alloc<source::Unused>(str195));
  trail1 = Alloc<parse_lib::Trail>();
  comp_ctx = Alloc<parse_lib::ParseContext>(comp_arena, parse_opts, aliases, oil_grammar);
  comp_ctx->Init_Trail(trail1);
  comp_ctx->Init_OnePassParse(true);
  hist_arena = Alloc<alloc::Arena>();
  hist_arena->PushSource(Alloc<source::Unused>(str196));
  trail2 = Alloc<parse_lib::Trail>();
  hist_ctx = Alloc<parse_lib::ParseContext>(hist_arena, parse_opts, aliases, oil_grammar);
  hist_ctx->Init_Trail(trail2);
  cmd_deps = Alloc<cmd_eval::Deps>();
  cmd_deps->mutable_opts = mutable_opts;
  my_pid = posix::getpid();
  debug_path = str197;
  debug_dir = environ->get(str198);
  if (flag->debug_file != nullptr) {
    debug_path = flag->debug_file;
  }
  else {
    if (debug_dir != nullptr) {
      debug_path = os_path::join(debug_dir, fmt56(my_pid));
    }
  }
  if (len(debug_path)) {
    throw Alloc<NotImplementedError>();
  }
  else {
    debug_f = Alloc<util::NullDebugFile>();
  }
  cmd_deps->debug_f = debug_f;
  if (len(debug_path)) {
    println_stderr(fmt57(debug_path));
  }
  if (flag->xtrace_to_debug_file) {
    trace_f = debug_f;
  }
  else {
    trace_f = Alloc<util::DebugFile>(mylib::Stderr());
  }
  tracer = Alloc<dev::Tracer>(parse_ctx, exec_opts, mutable_opts, mem, trace_f);
  trap_state = Alloc<builtin_trap::TrapState>();
  trap_state->InitShell();
  job_state = Alloc<process::JobState>();
  fd_state = Alloc<process::FdState>(errfmt, job_state, mem, tracer, nullptr);
  waiter = Alloc<process::Waiter>(job_state, exec_opts, trap_state, tracer);
  fd_state->waiter = waiter;
  interp = environ->get(str201, str202);
  search_path = Alloc<state::SearchPath>(mem);
  ext_prog = Alloc<process::ExternalProgram>(interp, fd_state, errfmt, debug_f);
  splitter = Alloc<split::SplitContext>(mem);
  parse_config = Alloc<funcs::ParseHay>(fd_state, parse_ctx, errfmt);
  crash_dump_dir = environ->get(str203, str204);
  cmd_deps->dumper = Alloc<dev::CrashDumper>(crash_dump_dir);
  dir_stack = Alloc<state::DirStack>();
  builtins = Alloc<Dict<int, vm::_Builtin*>>();
  modules = Alloc<Dict<Str*, bool>>();
  shell_ex = Alloc<executor::ShellExecutor>(mem, exec_opts, mutable_opts, procs, hay_tree, builtins, search_path, ext_prog, waiter, tracer, job_state, fd_state, errfmt);
  AddPure(builtins, mem, procs, modules, mutable_opts, aliases, search_path, errfmt);
  AddIO(builtins, mem, dir_stack, exec_opts, splitter, parse_ctx, errfmt);
  AddProcess(builtins, mem, shell_ex, ext_prog, fd_state, job_state, waiter, tracer, search_path, errfmt);
  builtins->set(builtin_i::help, help_builtin);
  arith_ev = Alloc<sh_expr_eval::ArithEvaluator>(mem, exec_opts, parse_ctx, errfmt);
  bool_ev = Alloc<sh_expr_eval::BoolEvaluator>(mem, exec_opts, parse_ctx, errfmt);
  expr_ev = nullptr;
  word_ev = Alloc<word_eval::NormalWordEvaluator>(mem, exec_opts, mutable_opts, splitter, errfmt);
  assign_b = InitAssignmentBuiltins(mem, procs, errfmt);
  cmd_ev = Alloc<cmd_eval::CommandEvaluator>(mem, exec_opts, errfmt, procs, assign_b, arena, cmd_deps, trap_state);
  prompt_ev = Alloc<prompt::Evaluator>(lang, version_str, parse_ctx, mem);
  vm::InitCircularDeps(arith_ev, bool_ev, expr_ev, word_ev, cmd_ev, shell_ex, prompt_ev, tracer);
  unsafe_arith = Alloc<sh_expr_eval::UnsafeArith>(mem, exec_opts, parse_ctx, arith_ev, errfmt);
  vm::InitUnsafeArith(mem, word_ev, unsafe_arith);
  builtins->set(builtin_i::printf, Alloc<builtin_printf::Printf>(mem, parse_ctx, unsafe_arith, errfmt));
  builtins->set(builtin_i::unset, Alloc<builtin_assign::Unset>(mem, procs, unsafe_arith, errfmt));
  builtins->set(builtin_i::eval, Alloc<builtin_meta::Eval>(parse_ctx, exec_opts, cmd_ev, tracer, errfmt));
  builtins->set(builtin_i::read, Alloc<builtin_misc::Read>(splitter, mem, parse_ctx, cmd_ev, errfmt));
  mapfile = Alloc<builtin_misc::MapFile>(mem, errfmt, cmd_ev);
  builtins->set(builtin_i::mapfile, mapfile);
  builtins->set(builtin_i::readarray, mapfile);
  source_builtin = Alloc<builtin_meta::Source>(parse_ctx, search_path, cmd_ev, fd_state, tracer, errfmt);
  builtins->set(builtin_i::source, source_builtin);
  builtins->set(builtin_i::dot, source_builtin);
  AddMeta(builtins, shell_ex, mutable_opts, mem, procs, aliases, search_path, errfmt);
  AddBlock(builtins, mem, mutable_opts, dir_stack, cmd_ev, shell_ex, hay_tree, errfmt);
  builtins->set(builtin_i::trap, Alloc<builtin_trap::Trap>(trap_state, parse_ctx, tracer, errfmt));
  if (flag->c != nullptr) {
    arena->PushSource(Alloc<source::CFlag>());
    line_reader = reader::StringLineReader(flag->c, arena);
    if (flag->i) {
      mutable_opts->set_interactive();
    }
  }
  else {
    if (flag->i) {
      throw Alloc<NotImplementedError>();
    }
    else {
      if (script_name == nullptr) {
        stdin = mylib::Stdin();
        arena->PushSource(Alloc<source::Stdin>(str205));
        line_reader = Alloc<reader::FileLineReader>(stdin, arena);
      }
      else {
        arena->PushSource(Alloc<source::MainFile>(script_name));
        try {
          f = fd_state->Open(script_name);
        }
        catch (IOError_OSError* e) {
          println_stderr(fmt58(script_name, pyutil::strerror(e)));
          return 1;
        }
        line_reader = Alloc<reader::FileLineReader>(f, arena);
      }
    }
  }
  c_parser = parse_ctx->MakeOshParser(line_reader);
  if (exec_opts->interactive()) {
    throw Alloc<NotImplementedError>();
  }
  if (exec_opts->noexec()) {
    status = 0;
    try {
      node = main_loop::ParseWholeFile(c_parser);
    }
    catch (error::Parse* e) {
      errfmt->PrettyPrintError(e);
      status = 2;
    }
    if (status == 0) {
      if (flag->parser_mem_dump != nullptr) {
        input_path = fmt59(posix::getpid());
        pyutil::CopyFile(input_path, flag->parser_mem_dump);
      }
      ui::PrintAst(node, flag);
    }
  }
  else {
    if (flag->parser_mem_dump != nullptr) {
      e_usage(str208);
    }
    {  // with
      state::ctx_ThisDir ctx(mem, script_name);

      try {
        status = main_loop::Batch(cmd_ev, c_parser, errfmt, cmd_eval::IsMainProgram);
      }
      catch (util::UserExit* e) {
        status = e->status;
      }
    }
    box = NewList<int>(std::initializer_list<int>{status});
    cmd_ev->MaybeRunExitTrap(box);
    status = box->index_(0);
  }
  if (flag->runtime_mem_dump != nullptr) {
    input_path = fmt60(posix::getpid());
    pyutil::CopyFile(input_path, flag->runtime_mem_dump);
  }
  return status;
}

}  // define namespace shell_native

namespace state {  // define

namespace Id = id_kind_asdl::Id;
namespace option_i = option_asdl::option_i;
namespace value = runtime_asdl::value;
namespace value_e = runtime_asdl::value_e;
using runtime_asdl::value_t;
using runtime_asdl::value__Str;
using runtime_asdl::value__MaybeStrArray;
using runtime_asdl::value__AssocArray;
namespace lvalue = runtime_asdl::lvalue;
namespace lvalue_e = runtime_asdl::lvalue_e;
using runtime_asdl::lvalue_t;
using runtime_asdl::lvalue__Named;
using runtime_asdl::lvalue__Indexed;
using runtime_asdl::lvalue__Keyed;
using runtime_asdl::scope_e;
using runtime_asdl::scope_t;
using runtime_asdl::hay_node;
namespace opt_group_i = types_asdl::opt_group_i;
Str* _READLINE_DELIMS = str210;
int LINE_ZERO = -2;
int SetReadOnly = (1 << 0);
int ClearReadOnly = (1 << 1);
int SetExport = (1 << 2);
int ClearExport = (1 << 3);
int SetNameref = (1 << 4);
int ClearNameref = (1 << 5);

SearchPath::SearchPath(state::Mem* mem) 
    : Obj(Tag::FixedSize, maskof_SearchPath(), sizeof(SearchPath))  {
  this->mem = mem;
  this->cache = Alloc<Dict<Str*, Str*>>();
}

Str* SearchPath::Lookup(Str* name) {
  return Lookup(name, true);
}

Str* SearchPath::Lookup(Str* name, bool exec_required) {
  runtime_asdl::value_t* val = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  List<Str*>* path_list = nullptr;
  Str* full_path = nullptr;
  bool found;
  StackRoots _roots({&name, &val, &UP_val, &path_list, &full_path});

  if (str_contains(name, str211)) {
    if (path_stat::exists(name)) {
      return name;
    }
    else {
      return nullptr;
    }
  }
  val = this->mem->GetValue(str212);
  UP_val = val;
  if (val->tag_() == value_e::Str) {
    value__Str* val = static_cast<value__Str*>(UP_val);
    path_list = val->s->split(str213);
  }
  else {
    path_list = Alloc<List<Str*>>();
  }
  for (ListIter<Str*> it(path_list); !it.Done(); it.Next()) {
    Str* path_dir = it.Value();
    StackRoots _for({&path_dir  });
    full_path = os_path::join(path_dir, name);
    if (exec_required) {
      found = posix::access(full_path, X_OK);
    }
    else {
      found = path_stat::exists(full_path);
    }
    if (found) {
      return full_path;
    }
  }
  return nullptr;
}

Str* SearchPath::CachedLookup(Str* name) {
  Str* full_path = nullptr;
  StackRoots _roots({&name, &full_path});

  if (dict_contains(this->cache, name)) {
    return this->cache->index_(name);
  }
  full_path = this->Lookup(name);
  if (full_path != nullptr) {
    this->cache->set(name, full_path);
  }
  return full_path;
}

void SearchPath::MaybeRemoveEntry(Str* name) {
  StackRoots _roots({&name});

  mylib::dict_remove(this->cache, name);
}

void SearchPath::ClearCache() {
  this->cache->clear();
}

List<Str*>* SearchPath::CachedCommands() {
  return this->cache->values();
}

ctx_Source::ctx_Source(state::Mem* mem, Str* source_name, List<Str*>* argv) 
    : Obj(Tag::FixedSize, maskof_ctx_Source(), sizeof(ctx_Source))  {
  mem->PushSource(source_name, argv);
  this->mem = mem;
  this->argv = argv;
}

ctx_Source::~ctx_Source(){
  this->mem->PopSource(this->argv);
}

ctx_Option::ctx_Option(state::MutableOpts* mutable_opts, List<int>* opt_nums, bool b) 
    : Obj(Tag::FixedSize, maskof_ctx_Option(), sizeof(ctx_Option))  {
  for (ListIter<int> it(opt_nums); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    mutable_opts->Push(opt_num, b);
    if (opt_num == option_i::errexit) {
      mutable_opts->errexit_disabled_spid->append(runtime::NO_SPID);
    }
  }
  this->mutable_opts = mutable_opts;
  this->opt_nums = opt_nums;
}

ctx_Option::~ctx_Option(){
  for (ListIter<int> it(this->opt_nums); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    if (opt_num == option_i::errexit) {
      this->mutable_opts->errexit_disabled_spid->pop();
    }
    this->mutable_opts->Pop(opt_num);
  }
}

ctx_AssignBuiltin::ctx_AssignBuiltin(state::MutableOpts* mutable_opts) 
    : Obj(Tag::FixedSize, maskof_ctx_AssignBuiltin(), sizeof(ctx_AssignBuiltin))  {
  this->strict = false;
  if (mutable_opts->Get(option_i::strict_errexit)) {
    mutable_opts->Push(option_i::allow_csub_psub, false);
    this->strict = true;
  }
  this->mutable_opts = mutable_opts;
}

ctx_AssignBuiltin::~ctx_AssignBuiltin(){
  if (this->strict) {
    this->mutable_opts->Pop(option_i::allow_csub_psub);
  }
}

ctx_OilExpr::ctx_OilExpr(state::MutableOpts* mutable_opts) 
    : Obj(Tag::FixedSize, maskof_ctx_OilExpr(), sizeof(ctx_OilExpr))  {
  mutable_opts->Push(option_i::command_sub_errexit, true);
  this->mutable_opts = mutable_opts;
}

ctx_OilExpr::~ctx_OilExpr(){
  this->mutable_opts->Pop(option_i::command_sub_errexit);
}

ctx_ErrExit::ctx_ErrExit(state::MutableOpts* mutable_opts, bool b, int span_id) 
    : Obj(Tag::FixedSize, maskof_ctx_ErrExit(), sizeof(ctx_ErrExit))  {
  mutable_opts->Push(option_i::errexit, b);
  mutable_opts->errexit_disabled_spid->append(span_id);
  this->strict = false;
  if (mutable_opts->Get(option_i::strict_errexit)) {
    mutable_opts->Push(option_i::allow_csub_psub, false);
    this->strict = true;
  }
  this->mutable_opts = mutable_opts;
}

ctx_ErrExit::~ctx_ErrExit(){
  this->mutable_opts->errexit_disabled_spid->pop();
  this->mutable_opts->Pop(option_i::errexit);
  if (this->strict) {
    this->mutable_opts->Pop(option_i::allow_csub_psub);
  }
}

ctx_HayNode::ctx_HayNode(state::Hay* hay_state, Str* hay_name) 
    : Obj(Tag::FixedSize, maskof_ctx_HayNode(), sizeof(ctx_HayNode))  {
  this->hay_state = hay_state;
  this->hay_state->Push(hay_name);
}

ctx_HayNode::~ctx_HayNode(){
  this->hay_state->Pop();
}

ctx_HayEval::ctx_HayEval(state::Hay* hay_state, state::MutableOpts* mutable_opts, state::Mem* mem) 
    : Obj(Tag::FixedSize, maskof_ctx_HayEval(), sizeof(ctx_HayEval))  {
  this->hay_state = hay_state;
  this->mutable_opts = mutable_opts;
  this->mem = mem;
  if (mutable_opts->Get(option_i::_running_hay)) {
    e_die(str214);
  }
  for (ListIter<int> it(consts::OIL_ALL); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    mutable_opts->Push(opt_num, true);
  }
  mutable_opts->Push(option_i::_running_hay, true);
  this->hay_state->PushEval();
  this->mem->PushTemp();
}

ctx_HayEval::~ctx_HayEval(){
  this->mem->PopTemp();
  this->hay_state->PopEval();
  this->mutable_opts->Pop(option_i::_running_hay);
  for (ListIter<int> it(consts::OIL_ALL); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    this->mutable_opts->Pop(opt_num);
  }
}

Hay::Hay() 
    : Obj(Tag::FixedSize, maskof_Hay(), sizeof(Hay))  {
  this->root_defs = Alloc<hay_node>();
  this->cur_defs = this->root_defs;
  this->def_stack = NewList<runtime_asdl::hay_node*>(std::initializer_list<runtime_asdl::hay_node*>{this->root_defs});
  Dict<Str*, void*>* node = this->_MakeOutputNode();
  this->result_stack = NewList<Dict<Str*, void*>*>(std::initializer_list<Dict<Str*, void*>*>{node});
  this->output = nullptr;
}

Dict<Str*, void*>* Hay::_MakeOutputNode() {
  auto* d = NewDict<Str*, void*>();
  d->set(str215, nullptr);
  d->set(str216, Alloc<List<void*>>());
  return d;
}

void Hay::PushEval() {
  Dict<Str*, void*>* node = nullptr;
  StackRoots _roots({&node});

  node = this->_MakeOutputNode();
  this->result_stack = NewList<Dict<Str*, void*>*>(std::initializer_list<Dict<Str*, void*>*>{node});
  this->output = nullptr;
}

void Hay::PopEval() {
  Dict<Str*, void*>* node = nullptr;
  StackRoots _roots({&node});

  this->output = this->result_stack->index_(0);
  node = this->_MakeOutputNode();
  this->result_stack = NewList<Dict<Str*, void*>*>(std::initializer_list<Dict<Str*, void*>*>{node});
}

bool Hay::Resolve(Str* first_word) {
  StackRoots _roots({&first_word});

  return dict_contains(this->cur_defs->children, first_word);
}

void Hay::DefinePath(List<Str*>* path) {
  runtime_asdl::hay_node* current = nullptr;
  StackRoots _roots({&path, &current});

  current = this->root_defs;
  for (ListIter<Str*> it(path); !it.Done(); it.Next()) {
    Str* name = it.Value();
    StackRoots _for({&name  });
    if (!dict_contains(current->children, name)) {
      current->children->set(name, Alloc<hay_node>());
    }
    current = current->children->index_(name);
  }
}

void Hay::Reset() {
  this->root_defs = Alloc<hay_node>();
  this->cur_defs = this->root_defs;
  this->PopEval();
}

void Hay::Push(Str* hay_name) {
  StackRoots _roots({&hay_name});

  if (hay_name == nullptr) {
    this->def_stack->append(this->cur_defs);
  }
  else {
    this->cur_defs = this->cur_defs->children->index_(hay_name);
    this->def_stack->append(this->cur_defs);
  }
}

void Hay::Pop() {
  this->def_stack->pop();
  this->cur_defs = this->def_stack->index_(-1);
}

OptHook::OptHook() 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(OptHook))  {
  ;  // pass
}

bool OptHook::OnChange(List<bool>* opt0_array, Str* opt_name, bool b) {
  StackRoots _roots({&opt0_array, &opt_name});

  return true;
}

List<bool>* InitOpts() {
  List<bool>* opt0_array = nullptr;
  StackRoots _roots({&opt0_array});

  opt0_array = list_repeat(false, option_i::ARRAY_SIZE);
  for (ListIter<int> it(consts::DEFAULT_TRUE); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    opt0_array->set(opt_num, true);
  }
  return opt0_array;
}

Tuple3<optview::Parse*, optview::Exec*, state::MutableOpts*> MakeOpts(state::Mem* mem, state::OptHook* opt_hook) {
  List<bool>* opt0_array = nullptr;
  List<bool>* no_stack = nullptr;
  List<List<bool>*>* opt_stacks = nullptr;
  optview::Parse* parse_opts = nullptr;
  optview::Exec* exec_opts = nullptr;
  state::MutableOpts* mutable_opts = nullptr;
  StackRoots _roots({&mem, &opt_hook, &opt0_array, &no_stack, &opt_stacks, &parse_opts, &exec_opts, &mutable_opts});

  opt0_array = InitOpts();
  no_stack = nullptr;
  opt_stacks = list_repeat(no_stack, option_i::ARRAY_SIZE);
  parse_opts = Alloc<optview::Parse>(opt0_array, opt_stacks);
  exec_opts = Alloc<optview::Exec>(opt0_array, opt_stacks);
  mutable_opts = Alloc<MutableOpts>(mem, opt0_array, opt_stacks, opt_hook);
  return (Tuple3<optview::Parse*, optview::Exec*, state::MutableOpts*>(parse_opts, exec_opts, mutable_opts));
}

void _SetGroup(List<bool>* opt0_array, List<int>* opt_nums, bool b) {
  bool b2;
  StackRoots _roots({&opt0_array, &opt_nums});

  for (ListIter<int> it(opt_nums); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    b2 = list_contains(consts::DEFAULT_TRUE, opt_num) ? !b : b;
    opt0_array->set(opt_num, b2);
  }
}

optview::Parse* MakeOilOpts() {
  List<bool>* opt0_array = nullptr;
  List<bool>* no_stack = nullptr;
  List<List<bool>*>* opt_stacks = nullptr;
  optview::Parse* parse_opts = nullptr;
  StackRoots _roots({&opt0_array, &no_stack, &opt_stacks, &parse_opts});

  opt0_array = InitOpts();
  _SetGroup(opt0_array, consts::OIL_ALL, true);
  no_stack = nullptr;
  opt_stacks = list_repeat(no_stack, option_i::ARRAY_SIZE);
  parse_opts = Alloc<optview::Parse>(opt0_array, opt_stacks);
  return parse_opts;
}

int _AnyOptionNum(Str* opt_name) {
  int opt_num;
  StackRoots _roots({&opt_name});

  opt_num = consts::OptionNum(opt_name);
  if (opt_num == 0) {
    e_usage(fmt61(opt_name));
  }
  return opt_num;
}

int _SetOptionNum(Str* opt_name) {
  int opt_num;
  StackRoots _roots({&opt_name});

  opt_num = consts::OptionNum(opt_name);
  if (opt_num == 0) {
    e_usage(fmt62(opt_name));
  }
  if (!list_contains(consts::SET_OPTION_NUMS, opt_num)) {
    e_usage(fmt63(opt_name));
  }
  return opt_num;
}

MutableOpts::MutableOpts(state::Mem* mem, List<bool>* opt0_array, List<List<bool>*>* opt_stacks, state::OptHook* opt_hook) 
    : Obj(Tag::FixedSize, maskof_MutableOpts(), sizeof(MutableOpts))  {
  this->mem = mem;
  this->opt0_array = opt0_array;
  this->opt_stacks = opt_stacks;
  this->errexit_disabled_spid = Alloc<List<int>>();
  this->opt_hook = opt_hook;
}

void MutableOpts::Init() {
  runtime_asdl::value_t* UP_shellopts = nullptr;
  StackRoots _roots({&UP_shellopts});

  UP_shellopts = this->mem->GetValue(str220);
  if (UP_shellopts->tag_() == value_e::Str) {
    value__Str* shellopts = static_cast<value__Str*>(UP_shellopts);
    this->_InitOptionsFromEnv(shellopts->s);
  }
}

void MutableOpts::_InitOptionsFromEnv(Str* shellopts) {
  List<Str*>* lookup = nullptr;
  Str* name = nullptr;
  StackRoots _roots({&shellopts, &lookup, &name});

  lookup = shellopts->split(str221);
  for (ListIter<int> it(consts::SET_OPTION_NUMS); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    name = consts::OptionName(opt_num);
    if (list_contains(lookup, name)) {
      this->_SetOldOption(name, true);
    }
  }
}

void MutableOpts::Push(int opt_num, bool b) {
  List<bool>* overlay = nullptr;
  StackRoots _roots({&overlay});

  overlay = this->opt_stacks->index_(opt_num);
  if ((overlay == nullptr or len(overlay) == 0)) {
    this->opt_stacks->set(opt_num, NewList<bool>(std::initializer_list<bool>{b}));
  }
  else {
    overlay->append(b);
  }
}

bool MutableOpts::Pop(int opt_num) {
  List<bool>* overlay = nullptr;
  StackRoots _roots({&overlay});

  overlay = this->opt_stacks->index_(opt_num);
  return overlay->pop();
}

void MutableOpts::PushDynamicScope(bool b) {
  if (!this->Get(option_i::dynamic_scope)) {
    b = false;
  }
  this->Push(option_i::dynamic_scope, b);
}

void MutableOpts::PopDynamicScope() {
  this->Pop(option_i::dynamic_scope);
}

bool MutableOpts::Get(int opt_num) {
  List<bool>* overlay = nullptr;
  StackRoots _roots({&overlay});

  overlay = this->opt_stacks->index_(opt_num);
  if ((overlay == nullptr or len(overlay) == 0)) {
    return this->opt0_array->index_(opt_num);
  }
  else {
    return overlay->index_(-1);
  }
}

void MutableOpts::_Set(int opt_num, bool b) {
  List<bool>* overlay = nullptr;
  StackRoots _roots({&overlay});

  overlay = this->opt_stacks->index_(opt_num);
  if ((overlay == nullptr or len(overlay) == 0)) {
    this->opt0_array->set(opt_num, b);
  }
  else {
    overlay->set(-1, b);
  }
}

void MutableOpts::set_interactive() {
  this->_Set(option_i::interactive, true);
}

void MutableOpts::set_redefine_proc() {
  this->_Set(option_i::redefine_proc, true);
}

void MutableOpts::set_redefine_module() {
  this->_Set(option_i::redefine_module, true);
}

void MutableOpts::set_emacs() {
  this->_Set(option_i::emacs, true);
}

void MutableOpts::set_xtrace(bool b) {
  this->_Set(option_i::xtrace, b);
}

void MutableOpts::_SetArrayByNum(int opt_num, bool b) {
  if ((list_contains(consts::PARSE_OPTION_NUMS, opt_num) and !this->mem->InGlobalNamespace())) {
    e_die(str222);
  }
  this->_Set(opt_num, b);
}

void MutableOpts::SetDeferredErrExit(bool b) {
  this->opt0_array->set(option_i::errexit, b);
}

void MutableOpts::DisableErrExit() {
  this->_Set(option_i::errexit, false);
}

int MutableOpts::ErrExitDisabledSpanId() {
  if (this->Get(option_i::_running_trap)) {
    return runtime::NO_SPID;
  }
  if (len(this->errexit_disabled_spid) == 0) {
    return runtime::NO_SPID;
  }
  return this->errexit_disabled_spid->index_(-1);
}

void MutableOpts::_SetOldOption(Str* opt_name, bool b) {
  int opt_num;
  bool success;
  StackRoots _roots({&opt_name});

  opt_num = consts::OptionNum(opt_name);
  if (opt_num == option_i::errexit) {
    this->SetDeferredErrExit(b);
  }
  else {
    if ((opt_num == option_i::verbose and b)) {
      println_stderr(str223);
    }
    this->_SetArrayByNum(opt_num, b);
  }
  success = this->opt_hook->OnChange(this->opt0_array, opt_name, b);
}

void MutableOpts::SetOldOption(Str* opt_name, bool b) {
  runtime_asdl::value_t* UP_val = nullptr;
  Str* shellopts = nullptr;
  runtime_asdl::value__Str* new_val = nullptr;
  List<Str*>* names = nullptr;
  StackRoots _roots({&opt_name, &UP_val, &shellopts, &new_val, &names});

  this->_SetOldOption(opt_name, b);
  UP_val = this->mem->GetValue(str224);
  value__Str* val = static_cast<value__Str*>(UP_val);
  shellopts = val->s;
  if (b) {
    if (!str_contains(shellopts, opt_name)) {
      new_val = Alloc<value::Str>(fmt64(shellopts, opt_name));
      this->mem->InternalSetGlobal(str226, new_val);
    }
  }
  else {
    if (str_contains(shellopts, opt_name)) {
      names = Alloc<List<Str*>>();
      for (ListIter<Str*> it(shellopts->split(str227)); !it.Done(); it.Next()) {
        Str* n = it.Value();
        if (!(str_equals(n, opt_name))) {
          names->append(n);
        }
      }
      new_val = Alloc<value::Str>(str228->join(names));
      this->mem->InternalSetGlobal(str229, new_val);
    }
  }
}

void MutableOpts::SetAnyOption(Str* opt_name, bool b) {
  int opt_group;
  int opt_num;
  StackRoots _roots({&opt_name});

  opt_group = consts::OptionGroupNum(opt_name);
  if (opt_group == opt_group_i::OilUpgrade) {
    _SetGroup(this->opt0_array, consts::OIL_UPGRADE, b);
    this->SetDeferredErrExit(b);
    return ;
  }
  if (opt_group == opt_group_i::OilAll) {
    _SetGroup(this->opt0_array, consts::OIL_ALL, b);
    this->SetDeferredErrExit(b);
    return ;
  }
  if (opt_group == opt_group_i::StrictAll) {
    _SetGroup(this->opt0_array, consts::STRICT_ALL, b);
    return ;
  }
  opt_num = _AnyOptionNum(opt_name);
  if (opt_num == option_i::errexit) {
    this->SetDeferredErrExit(b);
    return ;
  }
  this->_SetArrayByNum(opt_num, b);
}

void MutableOpts::ShowOptions(List<Str*>* opt_names) {
  int opt_num;
  bool b;
  StackRoots _roots({&opt_names});

  if (len(opt_names) == 0) {
    opt_names = Alloc<List<Str*>>();
    for (ListIter<int> it(consts::SET_OPTION_NUMS); !it.Done(); it.Next()) {
      int i = it.Value();
      opt_names->append(consts::OptionName(i));
    }
  }
  for (ListIter<Str*> it(opt_names); !it.Done(); it.Next()) {
    Str* opt_name = it.Value();
    StackRoots _for({&opt_name  });
    opt_num = _SetOptionNum(opt_name);
    b = this->Get(opt_num);
    print(fmt65(b ? str231 : str232, opt_name));
  }
}

void MutableOpts::ShowShoptOptions(List<Str*>* opt_names) {
  List<int>* opt_nums = nullptr;
  int opt_group;
  int index;
  bool b;
  StackRoots _roots({&opt_names, &opt_nums});

  opt_nums = Alloc<List<int>>();
  for (ListIter<Str*> it(opt_names); !it.Done(); it.Next()) {
    Str* opt_name = it.Value();
    StackRoots _for({&opt_name  });
    opt_group = consts::OptionGroupNum(opt_name);
    if (opt_group == opt_group_i::OilUpgrade) {
      opt_nums->extend(consts::OIL_UPGRADE);
    }
    else {
      if (opt_group == opt_group_i::OilAll) {
        opt_nums->extend(consts::OIL_ALL);
      }
      else {
        if (opt_group == opt_group_i::StrictAll) {
          opt_nums->extend(consts::STRICT_ALL);
        }
        else {
          index = consts::OptionNum(opt_name);
          if (index == 0) {
            e_usage(fmt66(opt_name));
          }
          opt_nums->append(index);
        }
      }
    }
  }
  if (len(opt_names) == 0) {
    opt_nums->extend(consts::VISIBLE_SHOPT_NUMS);
  }
  for (ListIter<int> it(opt_nums); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    b = this->Get(opt_num);
    print(fmt67(b ? str235 : str236, consts::OptionName(opt_num)));
  }
}

_ArgFrame::_ArgFrame(List<Str*>* argv) 
    : Obj(Tag::FixedSize, maskof__ArgFrame(), sizeof(_ArgFrame))  {
  this->argv = argv;
  this->num_shifted = 0;
}

runtime_asdl::value_t* _ArgFrame::GetArgNum(int arg_num) {
  int index;
  index = ((this->num_shifted + arg_num) - 1);
  if (index >= len(this->argv)) {
    return Alloc<value::Undef>();
  }
  return Alloc<value::Str>(this->argv->index_(index));
}

List<Str*>* _ArgFrame::GetArgv() {
  return this->argv->slice(this->num_shifted);
}

int _ArgFrame::GetNumArgs() {
  return (len(this->argv) - this->num_shifted);
}

void _ArgFrame::SetArgv(List<Str*>* argv) {
  StackRoots _roots({&argv});

  this->argv = argv;
  this->num_shifted = 0;
}

DirStack::DirStack() 
    : Obj(Tag::FixedSize, maskof_DirStack(), sizeof(DirStack))  {
  this->stack = Alloc<List<Str*>>();
  this->Reset();
}

void DirStack::Reset() {
  this->stack->clear();
  this->stack->append(posix::getcwd());
}

void DirStack::Push(Str* entry) {
  StackRoots _roots({&entry});

  this->stack->append(entry);
}

Str* DirStack::Pop() {
  if (len(this->stack) <= 1) {
    return nullptr;
  }
  this->stack->pop();
  return this->stack->index_(-1);
}

List<Str*>* DirStack::Iter() {
  List<Str*>* ret = nullptr;
  StackRoots _roots({&ret});

  ret = Alloc<List<Str*>>();
  ret->extend(this->stack);
  ret->reverse();
  return ret;
}

Str* _GetWorkingDir() {
  try {
    return posix::getcwd();
  }
  catch (OSError* e) {
    e_die(fmt68(pyutil::strerror(e)));
  }
}

DebugFrame::DebugFrame(Str* bash_source, Str* func_name, Str* source_name, int call_spid, int argv_i, int var_i) 
    : Obj(Tag::FixedSize, maskof_DebugFrame(), sizeof(DebugFrame))  {
  this->bash_source = bash_source;
  this->func_name = func_name;
  this->source_name = source_name;
  this->call_spid = call_spid;
  this->argv_i = argv_i;
  this->var_i = var_i;
}

void _InitDefaults(state::Mem* mem) {
  StackRoots _roots({&mem});

  SetGlobalString(mem, str239, split::DEFAULT_IFS);
  SetGlobalString(mem, str240, str(posix::getuid()));
  SetGlobalString(mem, str241, str(posix::geteuid()));
  SetGlobalString(mem, str242, str(posix::getppid()));
  SetGlobalString(mem, str243, libc::gethostname());
  SetGlobalString(mem, str244, pyos::OsType());
  SetGlobalString(mem, str245, str246);
  SetGlobalString(mem, str247, str248);
  SetGlobalString(mem, str249, _READLINE_DELIMS);
}

void _InitVarsFromEnv(state::Mem* mem, Dict<Str*, Str*>* environ) {
  runtime_asdl::value_t* val = nullptr;
  StackRoots _roots({&mem, &environ, &val});

  for (DictIter<Str*, Str*> it(environ); !it.Done(); it.Next()) {
    Str* n = it.Key();
    Str* v = it.Value();
    mem->SetValue(Alloc<lvalue::Named>(n), Alloc<value::Str>(v), scope_e::GlobalOnly, SetExport);
  }
  val = mem->GetValue(str250);
  if (val->tag_() == value_e::Undef) {
    SetGlobalString(mem, str251, str252);
  }
  mem->SetValue(Alloc<lvalue::Named>(str253), nullptr, scope_e::GlobalOnly, SetReadOnly);
  val = mem->GetValue(str254);
  if (val->tag_() == value_e::Undef) {
    SetGlobalString(mem, str255, _GetWorkingDir());
  }
  mem->SetValue(Alloc<lvalue::Named>(str256), nullptr, scope_e::GlobalOnly, SetExport);
  val = mem->GetValue(str257);
  if (val->tag_() == value_e::Undef) {
    SetGlobalString(mem, str258, str259);
  }
}

void InitMem(state::Mem* mem, Dict<Str*, Str*>* environ, Str* version_str) {
  runtime_asdl::value_t* val = nullptr;
  Str* pwd = nullptr;
  StackRoots _roots({&mem, &environ, &version_str, &val, &pwd});

  SetGlobalString(mem, str260, version_str);
  _InitDefaults(mem);
  _InitVarsFromEnv(mem, environ);
  val = mem->GetValue(str261);
  pwd = static_cast<value__Str*>(val)->s;
  mem->SetPwd(pwd);
}

void InitInteractive(state::Mem* mem) {
  StackRoots _roots({&mem});

  if (mem->GetValue(str262)->tag_() == value_e::Undef) {
    SetGlobalString(mem, str263, str264);
  }
}

ctx_Call::ctx_Call(state::Mem* mem, state::MutableOpts* mutable_opts, runtime_asdl::Proc* proc, List<Str*>* argv) 
    : Obj(Tag::FixedSize, maskof_ctx_Call(), sizeof(ctx_Call))  {
  mem->PushCall(proc->name, proc->name_spid, argv);
  mutable_opts->PushDynamicScope(proc->dynamic_scope);
  this->mem = mem;
  this->mutable_opts = mutable_opts;
}

ctx_Call::~ctx_Call(){
  this->mutable_opts->PopDynamicScope();
  this->mem->PopCall();
}

ctx_Temp::ctx_Temp(state::Mem* mem) 
    : Obj(Tag::FixedSize, maskof_ctx_Temp(), sizeof(ctx_Temp))  {
  mem->PushTemp();
  this->mem = mem;
}

ctx_Temp::~ctx_Temp(){
  this->mem->PopTemp();
}

ctx_Shvar::ctx_Shvar(state::Mem* mem, List<Tuple2<Str*, Str*>*>* pairs) 
    : Obj(Tag::FixedSize, maskof_ctx_Shvar(), sizeof(ctx_Shvar))  {
  this->mem = mem;
  this->restore = Alloc<List<Tuple2<runtime_asdl::lvalue_t*, runtime_asdl::value_t*>*>>();
  this->_Push(pairs);
}

ctx_Shvar::~ctx_Shvar(){
  this->_Pop();
}

void ctx_Shvar::_Push(List<Tuple2<Str*, Str*>*>* pairs) {
  Str* name = nullptr;
  Str* s = nullptr;
  runtime_asdl::lvalue_t* lval = nullptr;
  runtime_asdl::value_t* old_val = nullptr;
  StackRoots _roots({&pairs, &name, &s, &lval, &old_val});

  for (ListIter<Tuple2<Str*, Str*>*> it(pairs); !it.Done(); it.Next()) {
    Tuple2<Str*, Str*>* tup0 = it.Value();
    name = tup0->at0();
    s = tup0->at1();
    lval = Alloc<lvalue::Named>(name);
    old_val = this->mem->GetValue(name, scope_e::LocalOnly);
    this->restore->append((Alloc<Tuple2<runtime_asdl::lvalue_t*, runtime_asdl::value_t*>>(lval, old_val)));
    this->mem->SetValue(lval, Alloc<value::Str>(s), scope_e::LocalOnly);
  }
}

void ctx_Shvar::_Pop() {
  runtime_asdl::lvalue_t* lval = nullptr;
  runtime_asdl::value_t* old_val = nullptr;
  StackRoots _roots({&lval, &old_val});

  for (ListIter<Tuple2<runtime_asdl::lvalue_t*, runtime_asdl::value_t*>*> it(this->restore); !it.Done(); it.Next()) {
    Tuple2<runtime_asdl::lvalue_t*, runtime_asdl::value_t*>* tup1 = it.Value();
    lval = tup1->at0();
    old_val = tup1->at1();
    if (old_val->tag_() == value_e::Undef) {
      this->mem->Unset(lval, scope_e::LocalOnly);
    }
    else {
      this->mem->SetValue(lval, old_val, scope_e::LocalOnly);
    }
  }
}

ctx_Registers::ctx_Registers(state::Mem* mem) 
    : Obj(Tag::FixedSize, maskof_ctx_Registers(), sizeof(ctx_Registers))  {
  int last = mem->last_status->index_(-1);
  mem->last_status->append(last);
  mem->try_status->append(0);
  mem->pipe_status->append(Alloc<List<int>>());
  mem->process_sub_status->append(Alloc<List<int>>());
  mem->regex_matches->append(Alloc<List<Str*>>());
  this->mem = mem;
}

ctx_Registers::~ctx_Registers(){
  this->mem->regex_matches->pop();
  this->mem->process_sub_status->pop();
  this->mem->pipe_status->pop();
  this->mem->try_status->pop();
  this->mem->last_status->pop();
}

ctx_ThisDir::ctx_ThisDir(state::Mem* mem, Str* filename) 
    : Obj(Tag::FixedSize, maskof_ctx_ThisDir(), sizeof(ctx_ThisDir))  {
  this->do_pop = false;
  if (filename != nullptr) {
    Str* d = os_path::dirname(os_path::abspath(filename));
    mem->this_dir->append(d);
    this->do_pop = true;
  }
  this->mem = mem;
}

ctx_ThisDir::~ctx_ThisDir(){
  if (this->do_pop) {
    this->mem->this_dir->pop();
  }
}

Mem::Mem(Str* dollar0, List<Str*>* argv, alloc::Arena* arena, List<state::DebugFrame*>* debug_stack) 
    : Obj(Tag::FixedSize, maskof_Mem(), sizeof(Mem))  {
  this->exec_opts = nullptr;
  this->unsafe_arith = nullptr;
  this->dollar0 = dollar0;
  this->argv_stack = NewList<state::_ArgFrame*>(std::initializer_list<state::_ArgFrame*>{Alloc<_ArgFrame>(argv)});
  auto* frame = NewDict<Str*, runtime_asdl::cell*>();
  this->var_stack = NewList<Dict<Str*, runtime_asdl::cell*>*>(std::initializer_list<Dict<Str*, runtime_asdl::cell*>*>{frame});
  this->arena = arena;
  this->debug_stack = debug_stack;
  this->pwd = nullptr;
  this->current_spid = runtime::NO_SPID;
  this->line_num = Alloc<value::Str>(str265);
  this->root_pid = posix::getpid();
  this->last_status = NewList<int>(std::initializer_list<int>{0});
  this->try_status = NewList<int>(std::initializer_list<int>{0});
  this->pipe_status = NewList<List<int>*>(std::initializer_list<List<int>*>{Alloc<List<int>>()});
  this->process_sub_status = NewList<List<int>*>(std::initializer_list<List<int>*>{Alloc<List<int>>()});
  this->this_dir = Alloc<List<Str*>>();
  this->regex_matches = NewList<List<Str*>*>(std::initializer_list<List<Str*>*>{Alloc<List<Str*>>()});
  this->last_bg_pid = -1;
}

void Mem::SetPwd(Str* pwd) {
  StackRoots _roots({&pwd});

  this->pwd = pwd;
}

bool Mem::InGlobalNamespace() {
  return len(this->argv_stack) == 1;
}

Tuple3<void*, void*, void*> Mem::Dump() {
  assert(0);  // AssertionError
}

void Mem::SetCurrentSpanId(int span_id) {
  if (span_id == runtime::NO_SPID) {
    println_stderr(str272);
    return ;
  }
  this->current_spid = span_id;
}

int Mem::CurrentSpanId() {
  return this->current_spid;
}

int Mem::LastStatus() {
  return this->last_status->index_(-1);
}

int Mem::TryStatus() {
  return this->try_status->index_(-1);
}

List<int>* Mem::PipeStatus() {
  return this->pipe_status->index_(-1);
}

void Mem::SetLastStatus(int x) {
  this->last_status->set(-1, x);
}

void Mem::SetTryStatus(int x) {
  this->try_status->set(-1, x);
}

void Mem::SetPipeStatus(List<int>* x) {
  StackRoots _roots({&x});

  this->pipe_status->set(-1, x);
}

void Mem::SetProcessSubStatus(List<int>* x) {
  StackRoots _roots({&x});

  this->process_sub_status->set(-1, x);
}

void Mem::PushCall(Str* func_name, int def_spid, List<Str*>* argv) {
  syntax_asdl::line_span* span = nullptr;
  Str* source_str = nullptr;
  StackRoots _roots({&func_name, &argv, &span, &source_str});

  this->argv_stack->append(Alloc<_ArgFrame>(argv));
  auto* frame = NewDict<Str*, runtime_asdl::cell*>();
  this->var_stack->append(frame);
  span = this->arena->GetLineSpan(def_spid);
  source_str = ui::GetLineSourceString(this->arena, span->line_id);
  this->_PushDebugStack(source_str, func_name, nullptr);
}

void Mem::PopCall() {
  this->_PopDebugStack();
  this->var_stack->pop();
  this->argv_stack->pop();
}

void Mem::PushSource(Str* source_name, List<Str*>* argv) {
  StackRoots _roots({&source_name, &argv});

  if (len(argv)) {
    this->argv_stack->append(Alloc<_ArgFrame>(argv));
  }
  this->_PushDebugStack(source_name, nullptr, source_name);
}

void Mem::PopSource(List<Str*>* argv) {
  StackRoots _roots({&argv});

  this->_PopDebugStack();
  if (len(argv)) {
    this->argv_stack->pop();
  }
}

void Mem::PushTemp() {
  auto* frame = NewDict<Str*, runtime_asdl::cell*>();
  this->var_stack->append(frame);
  this->_PushDebugStack(nullptr, nullptr, nullptr);
}

void Mem::PopTemp() {
  this->_PopDebugStack();
  this->var_stack->pop();
}

Dict<Str*, runtime_asdl::cell*>* Mem::TopNamespace() {
  return this->var_stack->index_(-1);
}

void Mem::_PushDebugStack(Str* bash_source, Str* func_name, Str* source_name) {
  int argv_i;
  int var_i;
  StackRoots _roots({&bash_source, &func_name, &source_name});

  argv_i = (len(this->argv_stack) - 1);
  var_i = (len(this->var_stack) - 1);
  this->debug_stack->append(Alloc<DebugFrame>(bash_source, func_name, source_name, this->current_spid, argv_i, var_i));
}

void Mem::_PopDebugStack() {
  this->debug_stack->pop();
}

int Mem::Shift(int n) {
  state::_ArgFrame* frame = nullptr;
  int num_args;
  StackRoots _roots({&frame});

  frame = this->argv_stack->index_(-1);
  num_args = len(frame->argv);
  if ((frame->num_shifted + n) <= num_args) {
    frame->num_shifted += n;
    return 0;
  }
  else {
    return 1;
  }
}

runtime_asdl::value__Str* Mem::GetArg0() {
  return Alloc<value::Str>(this->dollar0);
}

runtime_asdl::value_t* Mem::GetArgNum(int arg_num) {
  if (arg_num == 0) {
    return Alloc<value::Str>(this->dollar0);
  }
  return this->argv_stack->index_(-1)->GetArgNum(arg_num);
}

List<Str*>* Mem::GetArgv() {
  return this->argv_stack->index_(-1)->GetArgv();
}

void Mem::SetArgv(List<Str*>* argv) {
  StackRoots _roots({&argv});

  this->argv_stack->index_(-1)->SetArgv(argv);
}

runtime_asdl::value_t* Mem::GetSpecialVar(int op_id) {
  int n;
  if (op_id == Id::VSub_Bang) {
    n = this->last_bg_pid;
    if (n == -1) {
      return Alloc<value::Undef>();
    }
  }
  else {
    if (op_id == Id::VSub_QMark) {
      n = this->last_status->index_(-1);
    }
    else {
      if (op_id == Id::VSub_Pound) {
        n = this->argv_stack->index_(-1)->GetNumArgs();
      }
      else {
        if (op_id == Id::VSub_Dollar) {
          n = this->root_pid;
        }
        else {
          throw Alloc<NotImplementedError>(op_id);
        }
      }
    }
  }
  return Alloc<value::Str>(str(n));
}

Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*> Mem::_ResolveNameOnly(Str* name, runtime_asdl::scope_t which_scopes) {
  Dict<Str*, runtime_asdl::cell*>* name_map = nullptr;
  runtime_asdl::cell* cell = nullptr;
  runtime_asdl::cell* no_cell = nullptr;
  StackRoots _roots({&name, &name_map, &cell, &no_cell});

  if (which_scopes == scope_e::Dynamic) {
    for (int i = (len(this->var_stack) - 1); i > -1; i += -1) {
      name_map = this->var_stack->index_(i);
      if (dict_contains(name_map, name)) {
        cell = name_map->index_(name);
        return (Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*>(cell, name_map));
      }
    }
    no_cell = nullptr;
    return (Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*>(no_cell, this->var_stack->index_(0)));
  }
  if (which_scopes == scope_e::LocalOnly) {
    name_map = this->var_stack->index_(-1);
    return (Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*>(name_map->get(name), name_map));
  }
  if (which_scopes == scope_e::GlobalOnly) {
    name_map = this->var_stack->index_(0);
    return (Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*>(name_map->get(name), name_map));
  }
  if (which_scopes == scope_e::LocalOrGlobal) {
    name_map = this->var_stack->index_(-1);
    cell = name_map->get(name);
    if (cell) {
      return (Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*>(cell, name_map));
    }
    name_map = this->var_stack->index_(0);
    return (Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*>(name_map->get(name), name_map));
  }
  if (which_scopes == scope_e::Parent) {
    name_map = this->var_stack->index_(-2);
    return (Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*>(name_map->get(name), name_map));
  }
  assert(0);  // AssertionError
}

Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*> Mem::_ResolveNameOrRef(Str* name, runtime_asdl::scope_t which_scopes, bool is_setref) {
  return _ResolveNameOrRef(name, which_scopes, is_setref, nullptr);
}

Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*> Mem::_ResolveNameOrRef(Str* name, runtime_asdl::scope_t which_scopes, bool is_setref, List<Str*>* ref_trail) {
  runtime_asdl::cell* cell = nullptr;
  Dict<Str*, runtime_asdl::cell*>* name_map = nullptr;
  runtime_asdl::value_t* val = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  Str* new_name = nullptr;
  Str* cell_name = nullptr;
  StackRoots _roots({&name, &ref_trail, &cell, &name_map, &val, &UP_val, &new_name, &cell_name});

  Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*> tup2 = this->_ResolveNameOnly(name, which_scopes);
  cell = tup2.at0();
  name_map = tup2.at1();
  if ((cell == nullptr or !cell->nameref)) {
    if (is_setref) {
      e_die(str273);
    }
    return (Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*>(cell, name_map, name));
  }
  val = cell->val;
  UP_val = val;
  switch (val->tag_()) {
    case value_e::Undef: {
      if (this->exec_opts->strict_nameref()) {
        e_die(fmt69(name));
      }
      else {
        return (Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*>(cell, name_map, name));
      }
    }
      break;
    case value_e::Str: {
      value__Str* val = static_cast<value__Str*>(UP_val);
      new_name = val->s;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  if (!match::IsValidVarName(new_name)) {
    if (this->exec_opts->strict_nameref()) {
      e_die(fmt70(name, new_name));
    }
    else {
      cell->nameref = false;
      return (Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*>(cell, name_map, name));
    }
  }
  if (ref_trail == nullptr) {
    ref_trail = NewList<Str*>(std::initializer_list<Str*>{name});
  }
  else {
    if (list_contains(ref_trail, new_name)) {
      e_die(fmt71(str277->join(ref_trail)));
    }
  }
  ref_trail->append(new_name);
  which_scopes = is_setref ? scope_e::Parent : scope_e::Dynamic;
  Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*> tup3 = this->_ResolveNameOrRef(new_name, which_scopes, false, ref_trail);
  cell = tup3.at0();
  name_map = tup3.at1();
  cell_name = tup3.at2();
  return (Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*>(cell, name_map, cell_name));
}

bool Mem::IsAssocArray(Str* name) {
  runtime_asdl::cell* cell = nullptr;
  StackRoots _roots({&name, &cell});

  Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*> tup4 = this->_ResolveNameOrRef(name, this->ScopesForReading(), false);
  cell = tup4.at0();
  if (cell) {
    if (cell->val->tag_() == value_e::AssocArray) {
      return true;
    }
  }
  return false;
}

void Mem::SetValue(runtime_asdl::lvalue_t* lval, runtime_asdl::value_t* val, runtime_asdl::scope_t which_scopes) {
  SetValue(lval, val, which_scopes, 0);
}

void Mem::SetValue(runtime_asdl::lvalue_t* lval, runtime_asdl::value_t* val, runtime_asdl::scope_t which_scopes, int flags) {
  int keyword_id;
  bool is_setref;
  runtime_asdl::lvalue_t* UP_lval = nullptr;
  runtime_asdl::cell* cell = nullptr;
  Dict<Str*, runtime_asdl::cell*>* name_map = nullptr;
  Str* cell_name = nullptr;
  int left_spid;
  runtime_asdl::value_t* UP_cell_val = nullptr;
  List<Str*>* strs = nullptr;
  int n;
  int index;
  StackRoots _roots({&lval, &val, &UP_lval, &cell, &name_map, &cell_name, &UP_cell_val, &strs});

  keyword_id = (flags >> 8);
  is_setref = keyword_id == Id::KW_SetRef;
  UP_lval = lval;
  switch (lval->tag_()) {
    case lvalue_e::Named: {
      lvalue__Named* lval = static_cast<lvalue__Named*>(UP_lval);
      if (keyword_id == Id::KW_SetRef) {
        lval->name = str_concat(str278, lval->name);
      }
      if (((flags & SetNameref) or (flags & ClearNameref))) {
        Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*> tup5 = this->_ResolveNameOnly(lval->name, which_scopes);
        cell = tup5.at0();
        name_map = tup5.at1();
        cell_name = lval->name;
      }
      else {
        Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*> tup6 = this->_ResolveNameOrRef(lval->name, which_scopes, is_setref);
        cell = tup6.at0();
        name_map = tup6.at1();
        cell_name = tup6.at2();
      }
      if (cell) {
        if ((flags & ClearExport)) {
          cell->exported = false;
        }
        if ((flags & ClearReadOnly)) {
          cell->readonly = false;
        }
        if ((flags & ClearNameref)) {
          cell->nameref = false;
        }
        if (val != nullptr) {
          if (cell->readonly) {
            e_die(fmt72(lval->name));
          }
          cell->val = val;
        }
        if ((flags & SetExport)) {
          cell->exported = true;
        }
        if ((flags & SetReadOnly)) {
          cell->readonly = true;
        }
        if ((flags & SetNameref)) {
          cell->nameref = true;
        }
      }
      else {
        if (val == nullptr) {
          val = Alloc<value::Undef>();
        }
        cell = Alloc<runtime_asdl::cell>(to_bool((flags & SetExport)), to_bool((flags & SetReadOnly)), to_bool((flags & SetNameref)), val);
        name_map->set(cell_name, cell);
      }
      if ((cell->val->tag_() != value_e::Undef && cell->val->tag_() != value_e::Str)) {
        if (cell->exported) {
          e_die(str280);
        }
        if (cell->nameref) {
          e_die(str281);
        }
      }
    }
      break;
    case lvalue_e::Indexed: {
      lvalue__Indexed* lval = static_cast<lvalue__Indexed*>(UP_lval);
      value__Str* rval = static_cast<value__Str*>(val);
      left_spid = len(lval->spids) ? lval->spids->index_(0) : runtime::NO_SPID;
      Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*> tup7 = this->_ResolveNameOrRef(lval->name, which_scopes, is_setref);
      cell = tup7.at0();
      name_map = tup7.at1();
      if (!cell) {
        this->_BindNewArrayWithEntry(name_map, lval, rval, flags);
        return ;
      }
      if (cell->readonly) {
        e_die(fmt73(), left_spid);
      }
      UP_cell_val = cell->val;
      switch (UP_cell_val->tag_()) {
        case value_e::Undef: {
          this->_BindNewArrayWithEntry(name_map, lval, rval, flags);
          return ;
        }
          break;
        case value_e::Str: {
          e_die(fmt74(), left_spid);
        }
          break;
        case value_e::MaybeStrArray: {
          value__MaybeStrArray* cell_val = static_cast<value__MaybeStrArray*>(UP_cell_val);
          strs = cell_val->strs;
          n = len(strs);
          index = lval->index;
          if (index < 0) {
            index += n;
          }
          if ((0 <= index and index < n)) {
            strs->set(index, rval->s);
          }
          else {
            n = ((index - len(strs)) + 1);
            for (int i = 0; i < n; ++i) {
              strs->append(nullptr);
            }
            strs->set(lval->index, rval->s);
          }
          return ;
        }
          break;
      }
      e_die(fmt75(ui::ValType(cell->val)), left_spid);
    }
      break;
    case lvalue_e::Keyed: {
      lvalue__Keyed* lval = static_cast<lvalue__Keyed*>(UP_lval);
      value__Str* rval = static_cast<value__Str*>(val);
      left_spid = len(lval->spids) ? lval->spids->index_(0) : runtime::NO_SPID;
      Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*> tup8 = this->_ResolveNameOrRef(lval->name, which_scopes, is_setref);
      cell = tup8.at0();
      name_map = tup8.at1();
      if (cell->readonly) {
        e_die(fmt76(), left_spid);
      }
      value__AssocArray* cell_val2 = static_cast<value__AssocArray*>(cell->val);
      cell_val2->d->set(lval->key, rval->s);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

void Mem::_BindNewArrayWithEntry(Dict<Str*, runtime_asdl::cell*>* name_map, runtime_asdl::lvalue__Indexed* lval, runtime_asdl::value__Str* val, int flags) {
  Str* no_str = nullptr;
  List<Str*>* items = nullptr;
  runtime_asdl::value__MaybeStrArray* new_value = nullptr;
  bool readonly;
  StackRoots _roots({&name_map, &lval, &val, &no_str, &items, &new_value});

  no_str = nullptr;
  items = list_repeat(no_str, lval->index);
  items->append(val->s);
  new_value = Alloc<value::MaybeStrArray>(items);
  readonly = to_bool((flags & SetReadOnly));
  name_map->set(lval->name, Alloc<runtime_asdl::cell>(false, readonly, false, new_value));
}

void Mem::InternalSetGlobal(Str* name, runtime_asdl::value_t* new_val) {
  runtime_asdl::cell* cell = nullptr;
  StackRoots _roots({&name, &new_val, &cell});

  cell = this->var_stack->index_(0)->index_(name);
  cell->val = new_val;
}

runtime_asdl::value_t* Mem::GetValue(Str* name) {
  return GetValue(name, scope_e::Shopt);
}

runtime_asdl::value_t* Mem::GetValue(Str* name, runtime_asdl::scope_t which_scopes) {
  List<Str*>* pipe_strs = nullptr;
  List<Str*>* sub_strs = nullptr;
  List<Str*>* strs = nullptr;
  syntax_asdl::line_span* span = nullptr;
  int line_num;
  runtime_asdl::cell* cell = nullptr;
  StackRoots _roots({&name, &pipe_strs, &sub_strs, &strs, &span, &cell});

  if (which_scopes == scope_e::Shopt) {
    which_scopes = this->ScopesForReading();
  }
  if (str_equals(name, str286)) {
    return Alloc<value::MaybeStrArray>(this->GetArgv());
  }
  if (str_equals(name, str287)) {
    // if not PYTHON
    {
      return Alloc<value::Undef>();
    }
    // endif MYCPP
  }
  if (str_equals(name, str288)) {
    if (len(this->this_dir) == 0) {
      return Alloc<value::Undef>();
    }
    else {
      return Alloc<value::Str>(this->this_dir->index_(-1));
    }
  }
  if ((str_equals(name, str289) || str_equals(name, str290))) {
    pipe_strs = Alloc<List<Str*>>();
    for (ListIter<int> it(this->pipe_status->index_(-1)); !it.Done(); it.Next()) {
      int i = it.Value();
      pipe_strs->append(str(i));
    }
    return Alloc<value::MaybeStrArray>(pipe_strs);
  }
  if (str_equals(name, str291)) {
    sub_strs = Alloc<List<Str*>>();
    for (ListIter<int> it(this->process_sub_status->index_(-1)); !it.Done(); it.Next()) {
      int i = it.Value();
      sub_strs->append(str(i));
    }
    return Alloc<value::MaybeStrArray>(sub_strs);
  }
  if (str_equals(name, str292)) {
    return Alloc<value::MaybeStrArray>(this->regex_matches->index_(-1));
  }
  if (str_equals(name, str293)) {
    strs = Alloc<List<Str*>>();
    for (ReverseListIter<state::DebugFrame*> it(this->debug_stack); !it.Done(); it.Next()) {
      state::DebugFrame* frame = it.Value();
      StackRoots _for({&frame    });
      if (frame->func_name != nullptr) {
        strs->append(frame->func_name);
      }
      if (frame->source_name != nullptr) {
        strs->append(str294);
      }
    }
    return Alloc<value::MaybeStrArray>(strs);
  }
  if (str_equals(name, str295)) {
    strs = Alloc<List<Str*>>();
    for (ReverseListIter<state::DebugFrame*> it(this->debug_stack); !it.Done(); it.Next()) {
      state::DebugFrame* frame = it.Value();
      StackRoots _for({&frame    });
      if (frame->bash_source != nullptr) {
        strs->append(frame->bash_source);
      }
    }
    return Alloc<value::MaybeStrArray>(strs);
  }
  if (str_equals(name, str296)) {
    strs = Alloc<List<Str*>>();
    for (ReverseListIter<state::DebugFrame*> it(this->debug_stack); !it.Done(); it.Next()) {
      state::DebugFrame* frame = it.Value();
      StackRoots _for({&frame    });
      if (frame->call_spid == runtime::NO_SPID) {
        continue;
      }
      if (frame->call_spid == LINE_ZERO) {
        strs->append(str297);
        continue;
      }
      span = this->arena->GetLineSpan(frame->call_spid);
      line_num = this->arena->GetLineNumber(span->line_id);
      strs->append(str(line_num));
    }
    return Alloc<value::MaybeStrArray>(strs);
  }
  if (str_equals(name, str298)) {
    span = this->arena->GetLineSpan(this->current_spid);
    this->line_num->s = str(this->arena->GetLineNumber(span->line_id));
    return this->line_num;
  }
  if (str_equals(name, str299)) {
    return Alloc<value::Str>(str(posix::getpid()));
  }
  Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*> tup9 = this->_ResolveNameOrRef(name, which_scopes, false);
  cell = tup9.at0();
  if (cell) {
    return cell->val;
  }
  return Alloc<value::Undef>();
}

runtime_asdl::cell* Mem::GetCell(Str* name) {
  return GetCell(name, scope_e::Shopt);
}

runtime_asdl::cell* Mem::GetCell(Str* name, runtime_asdl::scope_t which_scopes) {
  runtime_asdl::cell* cell = nullptr;
  StackRoots _roots({&name, &cell});

  if (which_scopes == scope_e::Shopt) {
    which_scopes = this->ScopesForReading();
  }
  Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*> tup10 = this->_ResolveNameOnly(name, which_scopes);
  cell = tup10.at0();
  return cell;
}

bool Mem::Unset(runtime_asdl::lvalue_t* lval, runtime_asdl::scope_t which_scopes) {
  runtime_asdl::lvalue_t* UP_lval = nullptr;
  Str* var_name = nullptr;
  runtime_asdl::cell* cell = nullptr;
  Dict<Str*, runtime_asdl::cell*>* name_map = nullptr;
  Str* cell_name = nullptr;
  runtime_asdl::value_t* val = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  List<Str*>* strs = nullptr;
  int n;
  int last_index;
  int index;
  StackRoots _roots({&lval, &UP_lval, &var_name, &cell, &name_map, &cell_name, &val, &UP_val, &strs});

  UP_lval = lval;
  switch (lval->tag_()) {
    case lvalue_e::Named: {
      lvalue__Named* lval = static_cast<lvalue__Named*>(UP_lval);
      var_name = lval->name;
    }
      break;
    case lvalue_e::Indexed: {
      lvalue__Indexed* lval = static_cast<lvalue__Indexed*>(UP_lval);
      var_name = lval->name;
    }
      break;
    case lvalue_e::Keyed: {
      lvalue__Keyed* lval = static_cast<lvalue__Keyed*>(UP_lval);
      var_name = lval->name;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  if (which_scopes == scope_e::Shopt) {
    which_scopes = this->ScopesForWriting();
  }
  Tuple3<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*, Str*> tup11 = this->_ResolveNameOrRef(var_name, which_scopes, false);
  cell = tup11.at0();
  name_map = tup11.at1();
  cell_name = tup11.at2();
  if (!cell) {
    return false;
  }
  if (cell->readonly) {
    throw Alloc<error::Runtime>(fmt77(var_name));
  }
  switch (lval->tag_()) {
    case lvalue_e::Named: {
      name_map->remove(cell_name);
    }
      break;
    case lvalue_e::Indexed: {
      lvalue__Indexed* lval = static_cast<lvalue__Indexed*>(UP_lval);
      val = cell->val;
      UP_val = val;
      if (val->tag_() != value_e::MaybeStrArray) {
        throw Alloc<error::Runtime>(fmt78(var_name));
      }
      value__MaybeStrArray* val = static_cast<value__MaybeStrArray*>(UP_val);
      strs = val->strs;
      n = len(strs);
      last_index = (n - 1);
      index = lval->index;
      if (index < 0) {
        index += n;
      }
      if (index == last_index) {
        strs->pop();
      }
      else {
        if ((0 <= index and index < last_index)) {
          strs->set(index, nullptr);
        }
        else {
          ;  // pass
        }
      }
    }
      break;
    case lvalue_e::Keyed: {
      lvalue__Keyed* lval = static_cast<lvalue__Keyed*>(UP_lval);
      val = cell->val;
      UP_val = val;
      value__AssocArray* val = static_cast<value__AssocArray*>(UP_val);
      mylib::dict_remove(val->d, lval->key);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return true;
}

runtime_asdl::scope_t Mem::ScopesForReading() {
  return this->exec_opts->dynamic_scope() ? scope_e::Dynamic : scope_e::LocalOrGlobal;
}

runtime_asdl::scope_t Mem::ScopesForWriting() {
  return this->exec_opts->dynamic_scope() ? scope_e::Dynamic : scope_e::LocalOnly;
}

bool Mem::ClearFlag(Str* name, int flag) {
  runtime_asdl::cell* cell = nullptr;
  Dict<Str*, runtime_asdl::cell*>* name_map = nullptr;
  StackRoots _roots({&name, &cell, &name_map});

  Tuple2<runtime_asdl::cell*, Dict<Str*, runtime_asdl::cell*>*> tup12 = this->_ResolveNameOnly(name, this->ScopesForReading());
  cell = tup12.at0();
  name_map = tup12.at1();
  if (cell) {
    if ((flag & ClearExport)) {
      cell->exported = false;
    }
    if ((flag & ClearNameref)) {
      cell->nameref = false;
    }
    return true;
  }
  else {
    return false;
  }
}

Dict<Str*, Str*>* Mem::GetExported() {
  Dict<Str*, Str*>* exported = nullptr;
  StackRoots _roots({&exported});

  exported = Alloc<Dict<Str*, Str*>>();
  for (ListIter<Dict<Str*, runtime_asdl::cell*>*> it(this->var_stack); !it.Done(); it.Next()) {
    Dict<Str*, runtime_asdl::cell*>* scope = it.Value();
    StackRoots _for({&scope  });
    for (DictIter<Str*, runtime_asdl::cell*> it(scope); !it.Done(); it.Next()) {
      Str* name = it.Key();
      runtime_asdl::cell* cell = it.Value();
      if ((cell->exported and cell->val->tag_() == value_e::Str)) {
        value__Str* val = static_cast<value__Str*>(cell->val);
        exported->set(name, val->s);
      }
    }
  }
  return exported;
}

List<Str*>* Mem::VarNames() {
  List<Str*>* ret = nullptr;
  StackRoots _roots({&ret});

  ret = Alloc<List<Str*>>();
  for (ListIter<Dict<Str*, runtime_asdl::cell*>*> it(this->var_stack); !it.Done(); it.Next()) {
    Dict<Str*, runtime_asdl::cell*>* scope = it.Value();
    StackRoots _for({&scope  });
    for (DictIter<Str*, runtime_asdl::cell*> it(scope); !it.Done(); it.Next()) {
      Str* name = it.Key();
      StackRoots _for({&name    });
      ret->append(name);
    }
  }
  return ret;
}

List<Str*>* Mem::VarNamesStartingWith(Str* prefix) {
  List<Str*>* names = nullptr;
  StackRoots _roots({&prefix, &names});

  names = Alloc<List<Str*>>();
  for (ListIter<Dict<Str*, runtime_asdl::cell*>*> it(this->var_stack); !it.Done(); it.Next()) {
    Dict<Str*, runtime_asdl::cell*>* scope = it.Value();
    StackRoots _for({&scope  });
    for (DictIter<Str*, runtime_asdl::cell*> it(scope); !it.Done(); it.Next()) {
      Str* name = it.Key();
      StackRoots _for({&name    });
      if (name->startswith(prefix)) {
        names->append(name);
      }
    }
  }
  return names;
}

Dict<Str*, Str*>* Mem::GetAllVars() {
  Dict<Str*, Str*>* result = nullptr;
  runtime_asdl::value_t* val = nullptr;
  StackRoots _roots({&result, &val});

  result = Alloc<Dict<Str*, Str*>>();
  for (ListIter<Dict<Str*, runtime_asdl::cell*>*> it(this->var_stack); !it.Done(); it.Next()) {
    Dict<Str*, runtime_asdl::cell*>* scope = it.Value();
    StackRoots _for({&scope  });
    for (DictIter<Str*, runtime_asdl::cell*> it(scope); !it.Done(); it.Next()) {
      Str* name = it.Key();
      runtime_asdl::cell* cell = it.Value();
      val = cell->val;
      if (val->tag_() == value_e::Str) {
        value__Str* str_val = static_cast<value__Str*>(val);
        result->set(name, str_val->s);
      }
    }
  }
  return result;
}

Dict<Str*, runtime_asdl::cell*>* Mem::GetAllCells(runtime_asdl::scope_t which_scopes) {
  Dict<Str*, runtime_asdl::cell*>* result = nullptr;
  List<Dict<Str*, runtime_asdl::cell*>*>* scopes = nullptr;
  StackRoots _roots({&result, &scopes});

  result = Alloc<Dict<Str*, runtime_asdl::cell*>>();
  if (which_scopes == scope_e::Dynamic) {
    scopes = this->var_stack;
  }
  else {
    if (which_scopes == scope_e::LocalOnly) {
      scopes = this->var_stack->slice(-1);
    }
    else {
      if (which_scopes == scope_e::GlobalOnly) {
        scopes = this->var_stack->slice(0, 1);
      }
      else {
        if (which_scopes == scope_e::LocalOrGlobal) {
          scopes = NewList<Dict<Str*, runtime_asdl::cell*>*>(std::initializer_list<Dict<Str*, runtime_asdl::cell*>*>{this->var_stack->index_(0)});
          if (len(this->var_stack) > 1) {
            scopes->append(this->var_stack->index_(-1));
          }
        }
        else {
          assert(0);  // AssertionError
        }
      }
    }
  }
  for (ListIter<Dict<Str*, runtime_asdl::cell*>*> it(scopes); !it.Done(); it.Next()) {
    Dict<Str*, runtime_asdl::cell*>* scope = it.Value();
    StackRoots _for({&scope  });
    for (DictIter<Str*, runtime_asdl::cell*> it(scope); !it.Done(); it.Next()) {
      Str* name = it.Key();
      runtime_asdl::cell* cell = it.Value();
      result->set(name, cell);
    }
  }
  return result;
}

bool Mem::IsGlobalScope() {
  return len(this->var_stack) == 1;
}

void Mem::ClearMatches() {
  List<Str*>* top = nullptr;
  StackRoots _roots({&top});

  top = this->regex_matches->index_(-1);
  top->clear();
}

void Mem::SetMatches(List<Str*>* matches) {
  StackRoots _roots({&matches});

  this->regex_matches->set(-1, matches);
}

Str* Mem::GetMatch(int i) {
  List<Str*>* top = nullptr;
  StackRoots _roots({&top});

  top = this->regex_matches->index_(-1);
  if (i < len(top)) {
    return top->index_(i);
  }
  else {
    return nullptr;
  }
}

void OshLanguageSetValue(state::Mem* mem, runtime_asdl::lvalue_t* lval, runtime_asdl::value_t* val) {
  OshLanguageSetValue(mem, lval, val, 0);
}

void OshLanguageSetValue(state::Mem* mem, runtime_asdl::lvalue_t* lval, runtime_asdl::value_t* val, int flags) {
  runtime_asdl::scope_t which_scopes;
  StackRoots _roots({&mem, &lval, &val});

  which_scopes = mem->ScopesForWriting();
  mem->SetValue(lval, val, which_scopes, flags);
}

void BuiltinSetValue(state::Mem* mem, runtime_asdl::lvalue_t* lval, runtime_asdl::value_t* val) {
  StackRoots _roots({&mem, &lval, &val});

  mem->SetValue(lval, val, mem->ScopesForWriting());
}

void BuiltinSetString(state::Mem* mem, Str* name, Str* s) {
  StackRoots _roots({&mem, &name, &s});

  BuiltinSetValue(mem, Alloc<lvalue::Named>(name), Alloc<value::Str>(s));
}

void BuiltinSetArray(state::Mem* mem, Str* name, List<Str*>* a) {
  StackRoots _roots({&mem, &name, &a});

  BuiltinSetValue(mem, Alloc<lvalue::Named>(name), Alloc<value::MaybeStrArray>(a));
}

void SetGlobalString(state::Mem* mem, Str* name, Str* s) {
  runtime_asdl::value__Str* val = nullptr;
  StackRoots _roots({&mem, &name, &s, &val});

  val = Alloc<value::Str>(s);
  mem->SetValue(Alloc<lvalue::Named>(name), val, scope_e::GlobalOnly);
}

void SetGlobalArray(state::Mem* mem, Str* name, List<Str*>* a) {
  StackRoots _roots({&mem, &name, &a});

  mem->SetValue(Alloc<lvalue::Named>(name), Alloc<value::MaybeStrArray>(a), scope_e::GlobalOnly);
}

void ExportGlobalString(state::Mem* mem, Str* name, Str* s) {
  runtime_asdl::value__Str* val = nullptr;
  StackRoots _roots({&mem, &name, &s, &val});

  val = Alloc<value::Str>(s);
  mem->SetValue(Alloc<lvalue::Named>(name), val, scope_e::GlobalOnly, SetExport);
}

Str* GetString(state::Mem* mem, Str* name) {
  runtime_asdl::value_t* val = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  StackRoots _roots({&mem, &name, &val, &UP_val});

  val = mem->GetValue(name);
  UP_val = val;
  switch (val->tag_()) {
    case value_e::Undef: {
      throw Alloc<error::Runtime>(fmt79(name));
    }
      break;
    case value_e::Str: {
      return static_cast<value__Str*>(UP_val)->s;
    }
      break;
    default: {
      throw Alloc<error::Runtime>(fmt80(name));
    }
  }
}

Str* MaybeString(state::Mem* mem, Str* name) {
  StackRoots _roots({&mem, &name});

  try {
    return GetString(mem, name);
  }
  catch (error::Runtime*) {
    return nullptr;
  }
}

int GetInteger(state::Mem* mem, Str* name) {
  runtime_asdl::value_t* val = nullptr;
  Str* s = nullptr;
  int i;
  StackRoots _roots({&mem, &name, &val, &s});

  val = mem->GetValue(name);
  if (val->tag_() != value_e::Str) {
    throw Alloc<error::Runtime>(fmt81(name, ui::ValType(val)));
  }
  s = static_cast<value__Str*>(val)->s;
  try {
    i = to_int(s);
  }
  catch (ValueError*) {
    throw Alloc<error::Runtime>(fmt82(name, s));
  }
  return i;
}

}  // define namespace state

namespace ui {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using id_kind_asdl::Id_str;
using syntax_asdl::Token;
using syntax_asdl::command_t;
using syntax_asdl::command_str;
namespace source_e = syntax_asdl::source_e;
using syntax_asdl::source__Stdin;
using syntax_asdl::source__MainFile;
using syntax_asdl::source__SourcedFile;
using syntax_asdl::source__Alias;
using syntax_asdl::source__Reparsed;
using syntax_asdl::source__Variable;
using syntax_asdl::source__ArgvWord;
using syntax_asdl::source__Synthetic;
using runtime_asdl::value_str;
using runtime_asdl::value_t;
namespace fmt = format;
using mylib::StrFromC;

Str* ValType(runtime_asdl::value_t* val) {
  StackRoots _roots({&val});

  return StrFromC(value_str(val->tag_()));
}

Str* CommandType(syntax_asdl::command_t* cmd) {
  StackRoots _roots({&cmd});

  return StrFromC(command_str(cmd->tag_()));
}

Str* PrettyId(int id_) {
  return StrFromC(Id_str(id_));
}

Str* PrettyToken(syntax_asdl::Token* tok, alloc::Arena* arena) {
  syntax_asdl::line_span* span = nullptr;
  Str* line = nullptr;
  Str* val = nullptr;
  StackRoots _roots({&tok, &arena, &span, &line, &val});

  if (tok->id == Id::Eof_Real) {
    return str306;
  }
  span = arena->GetLineSpan(tok->span_id);
  line = arena->GetLine(span->line_id);
  val = line->slice(span->col, (span->col + span->length));
  return repr(val);
}

Str* PrettyDir(Str* dir_name, Str* home_dir) {
  StackRoots _roots({&dir_name, &home_dir});

  if (home_dir != nullptr) {
    if ((str_equals(dir_name, home_dir) or dir_name->startswith(str_concat(home_dir, str307)))) {
      return str_concat(str308, dir_name->slice(len(home_dir)));
    }
  }
  return dir_name;
}

void _PrintCodeExcerpt(Str* line, int col, int length, mylib::Writer* f) {
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&line, &f, &buf});

  buf = Alloc<mylib::BufWriter>();
  buf->write(str309);
  buf->write(line->rstrip());
  buf->write(str310);
  for (StrIter it(line->slice(0, col)); !it.Done(); it.Next()) {
    Str* c = it.Value();
    StackRoots _for({&c  });
    buf->write(str_equals(c, str311) ? str312 : str313);
  }
  buf->write(str314);
  buf->write(str_repeat(str315, (length - 1)));
  buf->write(str316);
  f->write(buf->getvalue());
}

Str* GetLineSourceString(alloc::Arena* arena, int line_id) {
  return GetLineSourceString(arena, line_id, false);
}

Str* GetLineSourceString(alloc::Arena* arena, int line_id, bool quote_filename) {
  syntax_asdl::source_t* src = nullptr;
  syntax_asdl::source_t* UP_src = nullptr;
  Str* s = nullptr;
  syntax_asdl::line_span* span = nullptr;
  int line_num;
  Str* outer_source = nullptr;
  Str* var_name = nullptr;
  Str* where = nullptr;
  syntax_asdl::line_span* span2 = nullptr;
  StackRoots _roots({&arena, &src, &UP_src, &s, &span, &outer_source, &var_name, &where, &span2});

  src = arena->GetLineSource(line_id);
  UP_src = src;
  switch (src->tag_()) {
    case source_e::Interactive: {
      s = str317;
    }
      break;
    case source_e::Headless: {
      s = str318;
    }
      break;
    case source_e::CFlag: {
      s = str319;
    }
      break;
    case source_e::Stdin: {
      source__Stdin* src = static_cast<source__Stdin*>(UP_src);
      s = fmt83(src->comment);
    }
      break;
    case source_e::MainFile: {
      source__MainFile* src = static_cast<source__MainFile*>(UP_src);
      s = src->path;
      if (quote_filename) {
        s = qsn::maybe_encode(s);
      }
    }
      break;
    case source_e::SourcedFile: {
      source__SourcedFile* src = static_cast<source__SourcedFile*>(UP_src);
      s = src->path;
      if (quote_filename) {
        s = qsn::maybe_encode(s);
      }
    }
      break;
    case source_e::ArgvWord: {
      source__ArgvWord* src = static_cast<source__ArgvWord*>(UP_src);
      if (src->span_id == runtime::NO_SPID) {
        s = fmt84(src->what);
      }
      else {
        span = arena->GetLineSpan(src->span_id);
        line_num = arena->GetLineNumber(span->line_id);
        outer_source = GetLineSourceString(arena, span->line_id, quote_filename);
        s = fmt85(src->what, line_num, outer_source);
      }
    }
      break;
    case source_e::Variable: {
      source__Variable* src = static_cast<source__Variable*>(UP_src);
      if (src->var_name == nullptr) {
        var_name = str323;
      }
      else {
        var_name = repr(src->var_name);
      }
      if (src->span_id == runtime::NO_SPID) {
        where = str324;
      }
      else {
        span = arena->GetLineSpan(src->span_id);
        line_num = arena->GetLineNumber(span->line_id);
        outer_source = GetLineSourceString(arena, span->line_id, quote_filename);
        where = fmt86(line_num, outer_source);
      }
      s = fmt87(var_name, where);
    }
      break;
    case source_e::Alias: {
      source__Alias* src = static_cast<source__Alias*>(UP_src);
      s = fmt88(src->argv0);
    }
      break;
    case source_e::Reparsed: {
      source__Reparsed* src = static_cast<source__Reparsed*>(UP_src);
      span2 = arena->GetLineSpan(src->left_spid);
      outer_source = GetLineSourceString(arena, span2->line_id, quote_filename);
      s = fmt89(src->what, outer_source);
    }
      break;
    case source_e::Synthetic: {
      source__Synthetic* src = static_cast<source__Synthetic*>(UP_src);
      s = fmt90(src->s);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return s;
}

void _PrintWithSpanId(Str* prefix, Str* msg, int span_id, alloc::Arena* arena, bool show_code) {
  mylib::Writer* f = nullptr;
  syntax_asdl::line_span* line_span = nullptr;
  int orig_col;
  int line_id;
  syntax_asdl::source_t* src = nullptr;
  Str* line = nullptr;
  int line_num;
  syntax_asdl::source_t* UP_src = nullptr;
  syntax_asdl::line_span* span2 = nullptr;
  Str* line2 = nullptr;
  int lbracket_col;
  Str* source_str = nullptr;
  StackRoots _roots({&prefix, &msg, &arena, &f, &line_span, &src, &line, &UP_src, &span2, &line2, &source_str});

  f = mylib::Stderr();
  if (span_id == runtime::NO_SPID) {
    f->write(fmt91(prefix, msg));
    return ;
  }
  line_span = arena->GetLineSpan(span_id);
  orig_col = line_span->col;
  line_id = line_span->line_id;
  src = arena->GetLineSource(line_id);
  line = arena->GetLine(line_id);
  line_num = arena->GetLineNumber(line_id);
  if (show_code) {
    UP_src = src;
    if (src->tag_() == source_e::Reparsed) {
      source__Reparsed* src = static_cast<source__Reparsed*>(UP_src);
      span2 = arena->GetLineSpan(src->left_spid);
      line_num = arena->GetLineNumber(span2->line_id);
      line2 = arena->GetLine(span2->line_id);
      lbracket_col = (span2->col + span2->length);
      _PrintCodeExcerpt(line2, (orig_col + lbracket_col), 1, f);
    }
    else {
      _PrintCodeExcerpt(line, line_span->col, line_span->length, f);
    }
  }
  source_str = GetLineSourceString(arena, line_id, true);
  f->write(fmt92(source_str, line_num, prefix, msg));
}

ctx_Location::ctx_Location(ui::ErrorFormatter* errfmt, int spid) 
    : Obj(Tag::FixedSize, maskof_ctx_Location(), sizeof(ctx_Location))  {
  errfmt->spid_stack->append(spid);
  this->errfmt = errfmt;
}

ctx_Location::~ctx_Location(){
  this->errfmt->spid_stack->pop();
}

ErrorFormatter::ErrorFormatter(alloc::Arena* arena) 
    : Obj(Tag::FixedSize, maskof_ErrorFormatter(), sizeof(ErrorFormatter))  {
  this->arena = arena;
  this->last_spid = runtime::NO_SPID;
  this->spid_stack = Alloc<List<int>>();
  this->one_line_errexit = false;
}

void ErrorFormatter::OneLineErrExit() {
  this->one_line_errexit = true;
}

int ErrorFormatter::CurrentLocation() {
  if (len(this->spid_stack)) {
    return this->spid_stack->index_(-1);
  }
  else {
    return runtime::NO_SPID;
  }
}

void ErrorFormatter::PrefixPrint(Str* msg, Str* prefix, int span_id) {
  StackRoots _roots({&msg, &prefix});

  _PrintWithSpanId(prefix, msg, span_id, this->arena, true);
}

void ErrorFormatter::Print_(Str* msg) {
  Print_(msg, runtime::NO_SPID);
}

void ErrorFormatter::Print_(Str* msg, int span_id) {
  StackRoots _roots({&msg});

  if (span_id == runtime::NO_SPID) {
    span_id = this->CurrentLocation();
  }
  _PrintWithSpanId(str332, msg, span_id, this->arena, true);
}

void ErrorFormatter::PrintMessage(Str* msg) {
  PrintMessage(msg, runtime::NO_SPID);
}

void ErrorFormatter::PrintMessage(Str* msg, int span_id) {
  StackRoots _roots({&msg});

  if (span_id == runtime::NO_SPID) {
    span_id = this->CurrentLocation();
  }
  _PrintWithSpanId(str333, msg, span_id, this->arena, false);
}

void ErrorFormatter::StderrLine(Str* msg) {
  StackRoots _roots({&msg});

  println_stderr(msg);
}

void ErrorFormatter::PrettyPrintError(error::_ErrorWithLocation* err) {
  PrettyPrintError(err, str334);
}

void ErrorFormatter::PrettyPrintError(error::_ErrorWithLocation* err, Str* prefix) {
  Str* msg = nullptr;
  int span_id;
  StackRoots _roots({&err, &prefix, &msg});

  msg = err->UserErrorString();
  span_id = word_::SpanIdFromError(err);
  _PrintWithSpanId(prefix, msg, span_id, this->arena, true);
}

void ErrorFormatter::PrintErrExit(error::_ErrorWithLocation* err, int pid) {
  Str* prefix = nullptr;
  Str* msg = nullptr;
  int span_id;
  StackRoots _roots({&err, &prefix, &msg});

  prefix = fmt93(pid);
  msg = err->UserErrorString();
  span_id = word_::SpanIdFromError(err);
  _PrintWithSpanId(prefix, msg, span_id, this->arena, err->show_code);
}

void PrintAst(syntax_asdl::command_t* node, arg_types::main* flag) {
  mylib::Writer* f = nullptr;
  Str* afmt = nullptr;
  format::ColorOutput* ast_f = nullptr;
  hnode_asdl::hnode_t* tree = nullptr;
  StackRoots _roots({&node, &flag, &f, &afmt, &ast_f, &tree});

  if (maybe_str_equals(flag->ast_format, str336)) {
    println_stderr(str337);
  }
  else {
    f = mylib::Stdout();
    afmt = flag->ast_format;
    if ((maybe_str_equals(afmt, str338) || maybe_str_equals(afmt, str339))) {
      ast_f = fmt::DetectConsoleOutput(f);
    }
    else {
      if ((maybe_str_equals(afmt, str340) || maybe_str_equals(afmt, str341))) {
        ast_f = Alloc<fmt::HtmlOutput>(f);
      }
      else {
        assert(0);  // AssertionError
      }
    }
    if (str_contains(afmt, str342)) {
      // if not PYTHON
      {
        tree = node->PrettyTree();
      }
      // endif MYCPP
    }
    else {
      tree = node->PrettyTree();
    }
    ast_f->FileHeader();
    fmt::PrintTree(tree, ast_f);
    ast_f->FileFooter();
    ast_f->write(str343);
  }
}

}  // define namespace ui

namespace util {  // define


UserExit::UserExit(int status) 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(UserExit))  {
  this->status = status;
}

_DebugFile::_DebugFile() 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(_DebugFile))  {
  ;  // pass
}

void _DebugFile::log(Str* msg, void* args) {
  StackRoots _roots({&msg, &args});

  ;  // pass
}

void _DebugFile::write(Str* s) {
  StackRoots _roots({&s});

  ;  // pass
}

bool _DebugFile::isatty() {
  return false;
}

NullDebugFile::NullDebugFile() : _DebugFile() {
}

DebugFile::DebugFile(mylib::Writer* f) : _DebugFile() {
  field_mask_ |= maskof_DebugFile();
  this->f = f;
}

void DebugFile::log(Str* msg, void* args) {
  StackRoots _roots({&msg, &args});

  this->f->write(msg);
  this->f->write(str344);
  this->f->flush();
}

void DebugFile::write(Str* s) {
  StackRoots _roots({&s});

  this->f->write(s);
}

bool DebugFile::isatty() {
  return this->f->isatty();
}

}  // define namespace util

namespace args {  // define

namespace value = runtime_asdl::value;
namespace value_e = runtime_asdl::value_e;
using runtime_asdl::value_t;
using runtime_asdl::value__Bool;
using runtime_asdl::value__Int;
using runtime_asdl::value__Float;
using runtime_asdl::value__Str;
int String = 1;
int Int = 2;
int Float = 3;
int Bool = 4;

_Attributes::_Attributes(Dict<Str*, runtime_asdl::value_t*>* defaults) 
    : Obj(Tag::FixedSize, maskof__Attributes(), sizeof(_Attributes))  {
  this->attrs = Alloc<Dict<Str*, runtime_asdl::value_t*>>();
  this->opt_changes = Alloc<List<Tuple2<Str*, bool>*>>();
  this->shopt_changes = Alloc<List<Tuple2<Str*, bool>*>>();
  this->show_options = false;
  this->actions = Alloc<List<Str*>>();
  this->saw_double_dash = false;
  for (DictIter<Str*, runtime_asdl::value_t*> it(defaults); !it.Done(); it.Next()) {
    Str* name = it.Key();
    runtime_asdl::value_t* v = it.Value();
    this->Set(name, v);
  }
}

void _Attributes::SetTrue(Str* name) {
  StackRoots _roots({&name});

  this->Set(name, Alloc<value::Bool>(true));
}

void _Attributes::Set(Str* name, runtime_asdl::value_t* val) {
  StackRoots _roots({&name, &val});

  name = name->replace(str345, str346);
  this->attrs->set(name, val);
}

Reader::Reader(List<Str*>* argv, List<int>* spids) 
    : Obj(Tag::FixedSize, maskof_Reader(), sizeof(Reader))  {
  this->argv = argv;
  this->spids = spids;
  this->n = len(argv);
  this->i = 0;
}

void Reader::Next() {
  this->i += 1;
}

Str* Reader::Peek() {
  if (this->i >= this->n) {
    return nullptr;
  }
  else {
    return this->argv->index_(this->i);
  }
}

Tuple2<Str*, int> Reader::Peek2() {
  Str* no_str = nullptr;
  StackRoots _roots({&no_str});

  if (this->i >= this->n) {
    no_str = nullptr;
    return (Tuple2<Str*, int>(no_str, -1));
  }
  else {
    return (Tuple2<Str*, int>(this->argv->index_(this->i), this->spids->index_(this->i)));
  }
}

Str* Reader::ReadRequired(Str* error_msg) {
  Str* arg = nullptr;
  StackRoots _roots({&error_msg, &arg});

  arg = this->Peek();
  if (arg == nullptr) {
    e_usage(dynamic_fmt_dummy(), this->_FirstSpanId());
  }
  this->Next();
  return arg;
}

Tuple2<Str*, int> Reader::ReadRequired2(Str* error_msg) {
  Str* arg = nullptr;
  int spid;
  StackRoots _roots({&error_msg, &arg});

  arg = this->Peek();
  if (arg == nullptr) {
    e_usage(dynamic_fmt_dummy(), this->_FirstSpanId());
  }
  spid = this->spids->index_(this->i);
  this->Next();
  return (Tuple2<Str*, int>(arg, spid));
}

List<Str*>* Reader::Rest() {
  return this->argv->slice(this->i);
}

Tuple2<List<Str*>*, List<int>*> Reader::Rest2() {
  return (Tuple2<List<Str*>*, List<int>*>(this->argv->slice(this->i), this->spids->slice(this->i)));
}

bool Reader::AtEnd() {
  return this->i >= this->n;
}

int Reader::_FirstSpanId() {
  if (this->spids) {
    return this->spids->index_(0);
  }
  else {
    return runtime::NO_SPID;
  }
}

int Reader::SpanId() {
  int i;
  if (this->spids) {
    if (this->i == this->n) {
      i = (this->n - 1);
    }
    else {
      i = this->i;
    }
    return this->spids->index_(i);
  }
  else {
    return runtime::NO_SPID;
  }
}

_Action::_Action() 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(_Action))  {
  ;  // pass
}

bool _Action::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  StackRoots _roots({&attached_arg, &arg_r, &out});

  throw Alloc<NotImplementedError>();
}

_ArgAction::_ArgAction(Str* name, bool quit_parsing_flags, List<Str*>* valid)  {
  field_mask_ |= maskof__ArgAction();
  this->name = name;
  this->quit_parsing_flags = quit_parsing_flags;
  this->valid = valid;
}

runtime_asdl::value_t* _ArgAction::_Value(Str* arg, int span_id) {
  StackRoots _roots({&arg});

  throw Alloc<NotImplementedError>();
}

bool _ArgAction::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  Str* arg = nullptr;
  runtime_asdl::value_t* val = nullptr;
  StackRoots _roots({&attached_arg, &arg_r, &out, &arg, &val});

  if (attached_arg != nullptr) {
    arg = attached_arg;
  }
  else {
    arg_r->Next();
    arg = arg_r->Peek();
    if (arg == nullptr) {
      e_usage(dynamic_fmt_dummy(), arg_r->SpanId());
    }
  }
  val = this->_Value(arg, arg_r->SpanId());
  out->Set(this->name, val);
  return this->quit_parsing_flags;
}

SetToInt::SetToInt(Str* name) : _ArgAction(name, false, nullptr) {
}

runtime_asdl::value_t* SetToInt::_Value(Str* arg, int span_id) {
  int i;
  StackRoots _roots({&arg});

  try {
    i = to_int(arg);
  }
  catch (ValueError*) {
    e_usage(dynamic_fmt_dummy(), span_id);
  }
  if (i < 0) {
    e_usage(dynamic_fmt_dummy(), span_id);
  }
  return Alloc<value::Int>(i);
}

SetToFloat::SetToFloat(Str* name) : _ArgAction(name, false, nullptr) {
}

runtime_asdl::value_t* SetToFloat::_Value(Str* arg, int span_id) {
  double f;
  StackRoots _roots({&arg});

  try {
    f = to_float(arg);
  }
  catch (ValueError*) {
    e_usage(dynamic_fmt_dummy(), span_id);
  }
  if (f < 0) {
    e_usage(dynamic_fmt_dummy(), span_id);
  }
  return Alloc<value::Float>(f);
}

SetToString::SetToString(Str* name, bool quit_parsing_flags, List<Str*>* valid) : _ArgAction(name, quit_parsing_flags, valid) {
}

runtime_asdl::value_t* SetToString::_Value(Str* arg, int span_id) {
  StackRoots _roots({&arg});

  if ((this->valid != nullptr and !list_contains(this->valid, arg))) {
    e_usage(dynamic_fmt_dummy(), span_id);
  }
  return Alloc<value::Str>(arg);
}

SetAttachedBool::SetAttachedBool(Str* name)  {
  field_mask_ |= maskof_SetAttachedBool();
  this->name = name;
}

bool SetAttachedBool::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  bool b;
  StackRoots _roots({&attached_arg, &arg_r, &out});

  if (attached_arg != nullptr) {
    if ((str_equals(attached_arg, str362) || str_equals(attached_arg, str363) || str_equals(attached_arg, str364) || str_equals(attached_arg, str365))) {
      b = false;
    }
    else {
      if ((str_equals(attached_arg, str366) || str_equals(attached_arg, str367) || str_equals(attached_arg, str368) || str_equals(attached_arg, str369))) {
        b = true;
      }
      else {
        e_usage(fmt94(attached_arg));
      }
    }
  }
  else {
    b = true;
  }
  out->Set(this->name, Alloc<value::Bool>(b));
  return false;
}

SetToTrue::SetToTrue(Str* name)  {
  field_mask_ |= maskof_SetToTrue();
  this->name = name;
}

bool SetToTrue::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  StackRoots _roots({&attached_arg, &arg_r, &out});

  out->SetTrue(this->name);
  return false;
}

SetOption::SetOption(Str* name)  {
  field_mask_ |= maskof_SetOption();
  this->name = name;
}

bool SetOption::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  bool b;
  StackRoots _roots({&attached_arg, &arg_r, &out});

  b = maybe_str_equals(attached_arg, str371);
  out->opt_changes->append((Alloc<Tuple2<Str*, bool>>(this->name, b)));
  return false;
}

SetNamedOption::SetNamedOption(bool shopt)  {
  field_mask_ |= maskof_SetNamedOption();
  this->names = Alloc<List<Str*>>();
  this->shopt = shopt;
}

void SetNamedOption::ArgName(Str* name) {
  StackRoots _roots({&name});

  this->names->append(name);
}

bool SetNamedOption::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  bool b;
  Str* arg = nullptr;
  Str* attr_name = nullptr;
  List<Tuple2<Str*, bool>*>* changes = nullptr;
  StackRoots _roots({&attached_arg, &arg_r, &out, &arg, &attr_name, &changes});

  b = maybe_str_equals(attached_arg, str372);
  arg_r->Next();
  arg = arg_r->Peek();
  if (arg == nullptr) {
    out->show_options = true;
    return true;
  }
  attr_name = arg;
  if ((len(this->names) and !list_contains(this->names, attr_name))) {
    e_usage(fmt95(arg));
  }
  changes = this->shopt ? out->shopt_changes : out->opt_changes;
  changes->append((Alloc<Tuple2<Str*, bool>>(attr_name, b)));
  return false;
}

SetAction::SetAction(Str* name)  {
  field_mask_ |= maskof_SetAction();
  this->name = name;
}

bool SetAction::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  StackRoots _roots({&attached_arg, &arg_r, &out});

  out->actions->append(this->name);
  return false;
}

SetNamedAction::SetNamedAction()  {
  field_mask_ |= maskof_SetNamedAction();
  this->names = Alloc<List<Str*>>();
}

void SetNamedAction::ArgName(Str* name) {
  StackRoots _roots({&name});

  this->names->append(name);
}

bool SetNamedAction::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  Str* arg = nullptr;
  Str* attr_name = nullptr;
  StackRoots _roots({&attached_arg, &arg_r, &out, &arg, &attr_name});

  arg_r->Next();
  arg = arg_r->Peek();
  if (arg == nullptr) {
    e_usage(str374);
  }
  attr_name = arg;
  if ((len(this->names) and !list_contains(this->names, attr_name))) {
    e_usage(fmt96(arg));
  }
  out->actions->append(attr_name);
  return false;
}

args::_Attributes* Parse(flag_spec::_FlagSpec* spec, args::Reader* arg_r) {
  args::_Attributes* out = nullptr;
  Str* arg = nullptr;
  int pos;
  Str* suffix = nullptr;
  Str* flag_name = nullptr;
  args::_Action* action = nullptr;
  int n;
  Str* ch = nullptr;
  Str* attached_arg = nullptr;
  StackRoots _roots({&spec, &arg_r, &out, &arg, &suffix, &flag_name, &action, &ch, &attached_arg});

  out = Alloc<_Attributes>(spec->defaults);
  while (!arg_r->AtEnd()) {
    arg = arg_r->Peek();
    if (maybe_str_equals(arg, str376)) {
      out->saw_double_dash = true;
      arg_r->Next();
      break;
    }
    if ((len(spec->actions_long) and arg->startswith(str377))) {
      pos = arg->find(str378, 2);
      if (pos == -1) {
        suffix = nullptr;
        flag_name = arg->slice(2);
      }
      else {
        suffix = arg->slice((pos + 1));
        flag_name = arg->slice(2, pos);
      }
      action = spec->actions_long->get(flag_name);
      if (action == nullptr) {
        e_usage(dynamic_fmt_dummy(), arg_r->SpanId());
      }
      action->OnMatch(suffix, arg_r, out);
      arg_r->Next();
      continue;
    }
    else {
      if ((arg->startswith(str380) and len(arg) > 1)) {
        n = len(arg);
        for (int i = 1; i < n; ++i) {
          ch = arg->index_(i);
          if (str_equals(ch, str381)) {
            ch = str382;
          }
          if (list_contains(spec->plus_flags, ch)) {
            out->Set(ch, Alloc<value::Str>(str383));
            continue;
          }
          if (list_contains(spec->arity0, ch)) {
            out->SetTrue(ch);
            continue;
          }
          if (dict_contains(spec->arity1, ch)) {
            action = spec->arity1->index_(ch);
            attached_arg = i < (n - 1) ? arg->slice((i + 1)) : nullptr;
            action->OnMatch(attached_arg, arg_r, out);
            break;
          }
          e_usage(dynamic_fmt_dummy(), arg_r->SpanId());
        }
        arg_r->Next();
      }
      else {
        if ((len(spec->plus_flags) and (arg->startswith(str386) and len(arg) > 1))) {
          n = len(arg);
          for (int i = 1; i < n; ++i) {
            ch = arg->index_(i);
            if (list_contains(spec->plus_flags, ch)) {
              out->Set(ch, Alloc<value::Str>(str387));
              continue;
            }
            e_usage(dynamic_fmt_dummy(), arg_r->SpanId());
          }
          arg_r->Next();
        }
        else {
          break;
        }
      }
    }
  }
  return out;
}

args::_Attributes* ParseLikeEcho(flag_spec::_FlagSpec* spec, args::Reader* arg_r) {
  args::_Attributes* out = nullptr;
  Str* arg = nullptr;
  Str* chars = nullptr;
  bool done;
  StackRoots _roots({&spec, &arg_r, &out, &arg, &chars});

  out = Alloc<_Attributes>(spec->defaults);
  while (!arg_r->AtEnd()) {
    arg = arg_r->Peek();
    chars = arg->slice(1);
    if ((arg->startswith(str390) and len(chars))) {
      done = false;
      for (StrIter it(chars); !it.Done(); it.Next()) {
        Str* c = it.Value();
        StackRoots _for({&c      });
        if (!list_contains(spec->arity0, c)) {
          done = true;
          break;
        }
      }
      if (done) {
        break;
      }
      for (StrIter it(chars); !it.Done(); it.Next()) {
        Str* ch = it.Value();
        StackRoots _for({&ch      });
        out->SetTrue(ch);
      }
    }
    else {
      break;
    }
    arg_r->Next();
  }
  return out;
}

args::_Attributes* ParseMore(flag_spec::_FlagSpecAndMore* spec, args::Reader* arg_r) {
  args::_Attributes* out = nullptr;
  bool quit;
  Str* arg = nullptr;
  args::_Action* action = nullptr;
  Str* char0 = nullptr;
  Str* attached_arg = nullptr;
  StackRoots _roots({&spec, &arg_r, &out, &arg, &action, &char0, &attached_arg});

  out = Alloc<_Attributes>(spec->defaults);
  quit = false;
  while (!arg_r->AtEnd()) {
    arg = arg_r->Peek();
    if (maybe_str_equals(arg, str391)) {
      out->saw_double_dash = true;
      arg_r->Next();
      break;
    }
    if (arg->startswith(str392)) {
      action = spec->actions_long->get(arg->slice(2));
      if (action == nullptr) {
        e_usage(dynamic_fmt_dummy(), arg_r->SpanId());
      }
      action->OnMatch(nullptr, arg_r, out);
      arg_r->Next();
      continue;
    }
    if (((arg->startswith(str394) or arg->startswith(str395)) and len(arg) > 1)) {
      char0 = arg->index_(0);
      for (StrIter it(arg->slice(1)); !it.Done(); it.Next()) {
        Str* ch = it.Value();
        StackRoots _for({&ch      });
        action = spec->actions_short->get(ch);
        if (action == nullptr) {
          e_usage(dynamic_fmt_dummy(), arg_r->SpanId());
        }
        attached_arg = list_contains(spec->plus_flags, ch) ? char0 : nullptr;
        quit = action->OnMatch(attached_arg, arg_r, out);
      }
      arg_r->Next();
      if (quit) {
        break;
      }
      else {
        continue;
      }
    }
    break;
  }
  return out;
}

}  // define namespace args

namespace lexer {  // define

using syntax_asdl::Token;
using syntax_asdl::line_span;
using types_asdl::lex_mode_t;
using types_asdl::lex_mode_e;
using id_kind_asdl::Id_t;
namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Kind;

Token gobj0(Id::Eol_Tok, runtime::NO_SPID, nullptr);
syntax_asdl::Token* _EOL_TOK = &gobj0;

LineLexer::LineLexer(Str* line, alloc::Arena* arena) 
    : Obj(Tag::FixedSize, maskof_LineLexer(), sizeof(LineLexer))  {
  this->arena = arena;
  this->arena_skip = false;
  this->last_span_id = runtime::NO_SPID;
  this->Reset(line, -1, 0);
}

void LineLexer::Reset(Str* line, int line_id, int line_pos) {
  StackRoots _roots({&line});

  this->line = line;
  this->line_id = line_id;
  this->line_pos = line_pos;
}

bool LineLexer::MaybeUnreadOne() {
  if (this->line_pos == 0) {
    return false;
  }
  else {
    this->line_pos -= 1;
    this->arena_skip = true;
    return true;
  }
}

int LineLexer::GetSpanIdForEof() {
  int line_id;
  if (this->line_id == -1) {
    line_id = this->arena->AddLine(str399, 0);
  }
  else {
    line_id = this->line_id;
  }
  return this->arena->AddLineSpan(line_id, this->line_pos, 0);
}

int LineLexer::LookAheadOne(types_asdl::lex_mode_t lex_mode) {
  int pos;
  int n;
  int tok_type;
  pos = this->line_pos;
  n = len(this->line);
  if (pos == n) {
    return Id::Unknown_Tok;
  }
  else {
    Tuple2<int, int> tup1 = match::OneToken(lex_mode, this->line, pos);
    tok_type = tup1.at0();
    return tok_type;
  }
}

int LineLexer::LookPastSpace(types_asdl::lex_mode_t lex_mode) {
  int pos;
  int n;
  int tok_type;
  int end_pos;
  pos = this->line_pos;
  n = len(this->line);
  while (true) {
    if (pos == n) {
      return Id::Unknown_Tok;
    }
    Tuple2<int, int> tup2 = match::OneToken(lex_mode, this->line, pos);
    tok_type = tup2.at0();
    end_pos = tup2.at1();
    if (tok_type != Id::WS_Space) {
      break;
    }
    pos = end_pos;
  }
  return tok_type;
}

bool LineLexer::LookAheadFuncParens(int unread) {
  int pos;
  int tok_type;
  int end_pos;
  pos = (this->line_pos - unread);
  Tuple2<int, int> tup3 = match::OneToken(lex_mode_e::FuncParens, this->line, pos);
  tok_type = tup3.at0();
  end_pos = tup3.at1();
  return tok_type == Id::LookAhead_FuncParens;
}

Str* LineLexer::ByteLookAhead() {
  int pos;
  pos = this->line_pos;
  if (pos == len(this->line)) {
    return str400;
  }
  else {
    return this->line->index_(pos);
  }
}

int LineLexer::ByteLookBack() {
  int pos;
  pos = (this->line_pos - 2);
  if (pos < 0) {
    return -1;
  }
  else {
    return ord(this->line->index_(pos));
  }
}

syntax_asdl::Token* LineLexer::Read(types_asdl::lex_mode_t lex_mode) {
  Str* line = nullptr;
  int line_pos;
  int tok_type;
  int end_pos;
  id_kind_asdl::Kind_t kind;
  Str* tok_val = nullptr;
  int span_id;
  int tok_len;
  syntax_asdl::Token* t = nullptr;
  StackRoots _roots({&line, &tok_val, &t});

  line = this->line;
  line_pos = this->line_pos;
  Tuple2<int, int> tup4 = match::OneToken(lex_mode, line, line_pos);
  tok_type = tup4.at0();
  end_pos = tup4.at1();
  if (tok_type == Id::Eol_Tok) {
    return _EOL_TOK;
  }
  kind = consts::GetKind(tok_type);
  if ((kind == Kind::Arith || kind == Kind::Op || kind == Kind::WS || kind == Kind::Ignored || kind == Kind::Eof)) {
    tok_val = nullptr;
  }
  else {
    tok_val = line->slice(line_pos, end_pos);
  }
  if (this->arena_skip) {
    span_id = this->last_span_id;
    this->arena_skip = false;
  }
  else {
    tok_len = (end_pos - line_pos);
    span_id = this->arena->AddLineSpan(this->line_id, line_pos, tok_len);
    this->last_span_id = span_id;
  }
  t = Alloc<Token>(tok_type, span_id, tok_val);
  this->line_pos = end_pos;
  return t;
}

Lexer::Lexer(lexer::LineLexer* line_lexer, reader::_Reader* line_reader) 
    : Obj(Tag::FixedSize, maskof_Lexer(), sizeof(Lexer))  {
  this->line_lexer = line_lexer;
  this->line_reader = line_reader;
  this->line_id = -1;
  this->translation_stack = Alloc<List<Tuple2<int, int>*>>();
  this->emit_comp_dummy = false;
}

void Lexer::ResetInputObjects() {
  this->line_lexer->Reset(str401, -1, 0);
}

bool Lexer::MaybeUnreadOne() {
  return this->line_lexer->MaybeUnreadOne();
}

int Lexer::LookAheadOne(types_asdl::lex_mode_t lex_mode) {
  return this->line_lexer->LookAheadOne(lex_mode);
}

int Lexer::LookPastSpace(types_asdl::lex_mode_t lex_mode) {
  return this->line_lexer->LookPastSpace(lex_mode);
}

bool Lexer::LookAheadFuncParens(int unread) {
  return this->line_lexer->LookAheadFuncParens(unread);
}

Str* Lexer::ByteLookAhead() {
  return this->line_lexer->ByteLookAhead();
}

int Lexer::ByteLookBack() {
  return this->line_lexer->ByteLookBack();
}

void Lexer::EmitCompDummy() {
  this->emit_comp_dummy = true;
}

void Lexer::PushHint(int old_id, int new_id) {
  this->translation_stack->append((Alloc<Tuple2<int, int>>(old_id, new_id)));
}

syntax_asdl::Token* Lexer::_Read(types_asdl::lex_mode_t lex_mode) {
  syntax_asdl::Token* t = nullptr;
  int line_id;
  Str* line = nullptr;
  int line_pos;
  int span_id;
  int id_;
  int old_id;
  int new_id;
  StackRoots _roots({&t, &line});

  t = this->line_lexer->Read(lex_mode);
  if (t->id == Id::Eol_Tok) {
    Tuple3<int, Str*, int> tup5 = this->line_reader->GetLine();
    line_id = tup5.at0();
    line = tup5.at1();
    line_pos = tup5.at2();
    if (line == nullptr) {
      span_id = this->line_lexer->GetSpanIdForEof();
      if (this->emit_comp_dummy) {
        id_ = Id::Lit_CompDummy;
        this->emit_comp_dummy = false;
      }
      else {
        id_ = Id::Eof_Real;
      }
      t = Alloc<Token>(id_, span_id, str402);
      return t;
    }
    this->line_lexer->Reset(line, line_id, line_pos);
    t = this->line_lexer->Read(lex_mode);
  }
  if (len(this->translation_stack)) {
    Tuple2<int, int>* tup6 = this->translation_stack->index_(-1);
    old_id = tup6->at0();
    new_id = tup6->at1();
    if (t->id == old_id) {
      this->translation_stack->pop();
      t->id = new_id;
    }
  }
  return t;
}

syntax_asdl::Token* Lexer::Read(types_asdl::lex_mode_t lex_mode) {
  syntax_asdl::Token* t = nullptr;
  StackRoots _roots({&t});

  while (true) {
    t = this->_Read(lex_mode);
    if (t->id != Id::Ignored_LineCont) {
      break;
    }
  }
  return t;
}

}  // define namespace lexer

namespace location {  // define

namespace command_e = syntax_asdl::command_e;
using syntax_asdl::command_t;
using syntax_asdl::command__Simple;
using syntax_asdl::command__ShAssignment;
using syntax_asdl::command__Pipeline;
using syntax_asdl::command__AndOr;
using syntax_asdl::command__DoGroup;
using syntax_asdl::command__Sentence;
using syntax_asdl::command__Subshell;
using syntax_asdl::command__WhileUntil;
using syntax_asdl::command__If;
using syntax_asdl::command__Case;
using syntax_asdl::command__TimeBlock;
using syntax_asdl::BraceGroup;
namespace arith_expr_e = syntax_asdl::arith_expr_e;
using syntax_asdl::arith_expr_t;
using syntax_asdl::compound_word;
using syntax_asdl::Token;

int SpanForCommand(syntax_asdl::command_t* node) {
  syntax_asdl::command_t* UP_node = nullptr;
  int tag;
  StackRoots _roots({&node, &UP_node});

  UP_node = node;
  tag = node->tag_();
  if (tag == command_e::Sentence) {
    command__Sentence* node = static_cast<command__Sentence*>(UP_node);
    return node->terminator->span_id;
  }
  if (tag == command_e::Simple) {
    command__Simple* node = static_cast<command__Simple*>(UP_node);
    if (len(node->words)) {
      return word_::LeftMostSpanForWord(node->words->index_(0));
    }
    else {
      if (len(node->redirects)) {
        return node->redirects->index_(0)->op->span_id;
      }
    }
  }
  if (tag == command_e::ShAssignment) {
    command__ShAssignment* node = static_cast<command__ShAssignment*>(UP_node);
    return node->spids->index_(0);
  }
  if (tag == command_e::Pipeline) {
    command__Pipeline* node = static_cast<command__Pipeline*>(UP_node);
    return node->spids->index_(0);
  }
  if (tag == command_e::AndOr) {
    command__AndOr* node = static_cast<command__AndOr*>(UP_node);
    return node->spids->index_(0);
  }
  if (tag == command_e::DoGroup) {
    command__DoGroup* node = static_cast<command__DoGroup*>(UP_node);
    return node->spids->index_(0);
  }
  if (tag == command_e::BraceGroup) {
    BraceGroup* node = static_cast<BraceGroup*>(UP_node);
    return node->spids->index_(0);
  }
  if (tag == command_e::Subshell) {
    command__Subshell* node = static_cast<command__Subshell*>(UP_node);
    return node->spids->index_(0);
  }
  if (tag == command_e::WhileUntil) {
    command__WhileUntil* node = static_cast<command__WhileUntil*>(UP_node);
    return node->spids->index_(0);
  }
  if (tag == command_e::If) {
    command__If* node = static_cast<command__If*>(UP_node);
    return node->arms->index_(0)->spids->index_(0);
  }
  if (tag == command_e::Case) {
    command__Case* node = static_cast<command__Case*>(UP_node);
    return node->spids->index_(0);
  }
  if (tag == command_e::TimeBlock) {
    command__TimeBlock* node = static_cast<command__TimeBlock*>(UP_node);
    return node->spids->index_(0);
  }
  return runtime::NO_SPID;
}

int SpanForArithExpr(syntax_asdl::arith_expr_t* node) {
  syntax_asdl::arith_expr_t* UP_node = nullptr;
  StackRoots _roots({&node, &UP_node});

  UP_node = node;
  switch (node->tag_()) {
    case arith_expr_e::VarRef: {
      Token* token = static_cast<Token*>(UP_node);
      return token->span_id;
    }
      break;
    case arith_expr_e::Word: {
      compound_word* w = static_cast<compound_word*>(UP_node);
      return word_::LeftMostSpanForWord(w);
    }
      break;
  }
  return runtime::NO_SPID;
}

}  // define namespace location

namespace parse_lib {  // define

using id_kind_asdl::Id_t;
using syntax_asdl::Token;
using syntax_asdl::compound_word;
using syntax_asdl::expr_t;
using syntax_asdl::word_t;
using syntax_asdl::redir;
using syntax_asdl::ArgList;
using syntax_asdl::name_type;
using types_asdl::lex_mode_e;

_BaseTrail::_BaseTrail() 
    : Obj(Tag::FixedSize, maskof__BaseTrail(), sizeof(_BaseTrail))  {
  this->words = Alloc<List<syntax_asdl::compound_word*>>();
  this->redirects = Alloc<List<syntax_asdl::redir*>>();
  this->tokens = Alloc<List<syntax_asdl::Token*>>();
  this->alias_words = Alloc<List<syntax_asdl::compound_word*>>();
  this->_expanding_alias = false;
}

void _BaseTrail::Clear() {
  ;  // pass
}

void _BaseTrail::SetLatestWords(List<syntax_asdl::compound_word*>* words, List<syntax_asdl::redir*>* redirects) {
  StackRoots _roots({&words, &redirects});

  ;  // pass
}

void _BaseTrail::AppendToken(syntax_asdl::Token* token) {
  StackRoots _roots({&token});

  ;  // pass
}

void _BaseTrail::BeginAliasExpansion() {
  ;  // pass
}

void _BaseTrail::EndAliasExpansion() {
  ;  // pass
}

ctx_Alias::ctx_Alias(parse_lib::_BaseTrail* trail) 
    : Obj(Tag::FixedSize, maskof_ctx_Alias(), sizeof(ctx_Alias))  {
  trail->_expanding_alias = true;
  this->trail = trail;
}

ctx_Alias::~ctx_Alias(){
  this->trail->_expanding_alias = false;
}

Trail::Trail() : _BaseTrail() {
}

void Trail::Clear() {
  this->words->clear();
  this->redirects->clear();
  this->tokens->clear();
  this->alias_words->clear();
}

void Trail::SetLatestWords(List<syntax_asdl::compound_word*>* words, List<syntax_asdl::redir*>* redirects) {
  StackRoots _roots({&words, &redirects});

  if (this->_expanding_alias) {
    this->alias_words = words;
    return ;
  }
  this->words = words;
  this->redirects = redirects;
}

void Trail::AppendToken(syntax_asdl::Token* token) {
  StackRoots _roots({&token});

  if (this->_expanding_alias) {
    return ;
  }
  this->tokens->append(token);
}

ParseContext::ParseContext(alloc::Arena* arena, optview::Parse* parse_opts, Dict<Str*, Str*>* aliases, grammar::Grammar* oil_grammar) 
    : Obj(Tag::FixedSize, maskof_ParseContext(), sizeof(ParseContext))  {
  this->arena = arena;
  this->parse_opts = parse_opts;
  this->aliases = aliases;
  this->oil_grammar = oil_grammar;
  if (oil_grammar) {
    this->tr = Alloc<expr_to_ast::Transformer>(oil_grammar);
  }
  else {
    this->tr = nullptr;
  }
  this->trail = Alloc<_BaseTrail>();
  this->one_pass_parse = false;
}

void ParseContext::Init_Trail(parse_lib::_BaseTrail* trail) {
  StackRoots _roots({&trail});

  this->trail = trail;
}

void ParseContext::Init_OnePassParse(bool b) {
  this->one_pass_parse = b;
}

lexer::Lexer* ParseContext::MakeLexer(reader::_Reader* line_reader) {
  lexer::LineLexer* line_lexer = nullptr;
  StackRoots _roots({&line_reader, &line_lexer});

  line_lexer = Alloc<lexer::LineLexer>(str404, this->arena);
  return Alloc<lexer::Lexer>(line_lexer, line_reader);
}

cmd_parse::CommandParser* ParseContext::MakeOshParser(reader::_Reader* line_reader) {
  return MakeOshParser(line_reader, false);
}

cmd_parse::CommandParser* ParseContext::MakeOshParser(reader::_Reader* line_reader, bool emit_comp_dummy) {
  lexer::Lexer* lx = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  StackRoots _roots({&line_reader, &lx, &w_parser, &c_parser});

  lx = this->MakeLexer(line_reader);
  if (emit_comp_dummy) {
    lx->EmitCompDummy();
  }
  w_parser = Alloc<word_parse::WordParser>(this, lx, line_reader);
  c_parser = Alloc<cmd_parse::CommandParser>(this, this->parse_opts, w_parser, lx, line_reader);
  return c_parser;
}

cmd_parse::CommandParser* ParseContext::MakeConfigParser(reader::_Reader* line_reader) {
  lexer::Lexer* lx = nullptr;
  optview::Parse* parse_opts = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  StackRoots _roots({&line_reader, &lx, &parse_opts, &w_parser, &c_parser});

  lx = this->MakeLexer(line_reader);
  parse_opts = state::MakeOilOpts();
  w_parser = Alloc<word_parse::WordParser>(this, lx, line_reader);
  c_parser = Alloc<cmd_parse::CommandParser>(this, parse_opts, w_parser, lx, line_reader);
  return c_parser;
}

word_parse::WordParser* ParseContext::MakeWordParserForHereDoc(reader::_Reader* line_reader) {
  lexer::Lexer* lx = nullptr;
  StackRoots _roots({&line_reader, &lx});

  lx = this->MakeLexer(line_reader);
  return Alloc<word_parse::WordParser>(this, lx, line_reader);
}

word_parse::WordParser* ParseContext::MakeWordParser(lexer::Lexer* lx, reader::_Reader* line_reader) {
  StackRoots _roots({&lx, &line_reader});

  return Alloc<word_parse::WordParser>(this, lx, line_reader);
}

tdop::TdopParser* ParseContext::MakeArithParser(Str* code_str) {
  reader::FileLineReader* line_reader = nullptr;
  lexer::Lexer* lx = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  tdop::TdopParser* a_parser = nullptr;
  StackRoots _roots({&code_str, &line_reader, &lx, &w_parser, &a_parser});

  line_reader = reader::StringLineReader(code_str, this->arena);
  lx = this->MakeLexer(line_reader);
  w_parser = Alloc<word_parse::WordParser>(this, lx, line_reader);
  w_parser->Init(lex_mode_e::Arith);
  a_parser = Alloc<tdop::TdopParser>(arith_parse::Spec(), w_parser, this->parse_opts);
  return a_parser;
}

cmd_parse::CommandParser* ParseContext::MakeParserForCommandSub(reader::_Reader* line_reader, lexer::Lexer* lexer, int eof_id) {
  word_parse::WordParser* w_parser = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  StackRoots _roots({&line_reader, &lexer, &w_parser, &c_parser});

  w_parser = Alloc<word_parse::WordParser>(this, lexer, line_reader);
  c_parser = Alloc<cmd_parse::CommandParser>(this, this->parse_opts, w_parser, lexer, line_reader);
  c_parser->Init_EofId(eof_id);
  return c_parser;
}

word_parse::WordParser* ParseContext::MakeWordParserForPlugin(Str* code_str) {
  reader::FileLineReader* line_reader = nullptr;
  lexer::Lexer* lx = nullptr;
  StackRoots _roots({&code_str, &line_reader, &lx});

  line_reader = reader::StringLineReader(code_str, this->arena);
  lx = this->MakeLexer(line_reader);
  return Alloc<word_parse::WordParser>(this, lx, line_reader);
}

Tuple2<pnode::PNode*, syntax_asdl::Token*> ParseContext::_ParseOil(lexer::Lexer* lexer, int start_symbol) {
  expr_parse::ExprParser* e_parser = nullptr;
  StackRoots _roots({&lexer, &e_parser});

  e_parser = Alloc<expr_parse::ExprParser>(this, this->oil_grammar, false);
  return e_parser->Parse(lexer, start_symbol);
}

Tuple2<pnode::PNode*, syntax_asdl::Token*> ParseContext::_ParseTea(lexer::Lexer* lexer, int start_symbol) {
  expr_parse::ExprParser* e_parser = nullptr;
  StackRoots _roots({&lexer, &e_parser});

  e_parser = Alloc<expr_parse::ExprParser>(this, this->oil_grammar, true);
  return e_parser->Parse(lexer, start_symbol);
}

Tuple2<syntax_asdl::command__VarDecl*, syntax_asdl::Token*> ParseContext::ParseVarDecl(syntax_asdl::Token* kw_token, lexer::Lexer* lexer) {
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  syntax_asdl::command__VarDecl* ast_node = nullptr;
  StackRoots _roots({&kw_token, &lexer, &pnode, &last_token, &ast_node});

  Tuple2<pnode::PNode*, syntax_asdl::Token*> tup0 = this->_ParseOil(lexer, grammar_nt::oil_var_decl);
  pnode = tup0.at0();
  last_token = tup0.at1();
  ast_node = this->tr->MakeVarDecl(pnode);
  ast_node->keyword = kw_token;
  return (Tuple2<syntax_asdl::command__VarDecl*, syntax_asdl::Token*>(ast_node, last_token));
}

Tuple2<syntax_asdl::command__PlaceMutation*, syntax_asdl::Token*> ParseContext::ParsePlaceMutation(syntax_asdl::Token* kw_token, lexer::Lexer* lexer) {
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  syntax_asdl::command__PlaceMutation* ast_node = nullptr;
  StackRoots _roots({&kw_token, &lexer, &pnode, &last_token, &ast_node});

  Tuple2<pnode::PNode*, syntax_asdl::Token*> tup1 = this->_ParseOil(lexer, grammar_nt::oil_place_mutation);
  pnode = tup1.at0();
  last_token = tup1.at1();
  ast_node = this->tr->MakePlaceMutation(pnode);
  ast_node->keyword = kw_token;
  return (Tuple2<syntax_asdl::command__PlaceMutation*, syntax_asdl::Token*>(ast_node, last_token));
}

syntax_asdl::Token* ParseContext::ParseOilArgList(lexer::Lexer* lexer, syntax_asdl::ArgList* out) {
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&lexer, &out, &pnode, &last_token});

  Tuple2<pnode::PNode*, syntax_asdl::Token*> tup2 = this->_ParseOil(lexer, grammar_nt::oil_arglist);
  pnode = tup2.at0();
  last_token = tup2.at1();
  this->tr->ToArgList(pnode, out);
  return last_token;
}

Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> ParseContext::ParseOilExpr(lexer::Lexer* lexer, int start_symbol) {
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  syntax_asdl::expr_t* ast_node = nullptr;
  StackRoots _roots({&lexer, &pnode, &last_token, &ast_node});

  Tuple2<pnode::PNode*, syntax_asdl::Token*> tup3 = this->_ParseOil(lexer, start_symbol);
  pnode = tup3.at0();
  last_token = tup3.at1();
  ast_node = this->tr->Expr(pnode);
  return (Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*>(ast_node, last_token));
}

Tuple3<List<syntax_asdl::name_type*>*, syntax_asdl::expr_t*, syntax_asdl::Token*> ParseContext::ParseOilForExpr(lexer::Lexer* lexer, int start_symbol) {
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  List<syntax_asdl::name_type*>* lvalue = nullptr;
  syntax_asdl::expr_t* iterable = nullptr;
  StackRoots _roots({&lexer, &pnode, &last_token, &lvalue, &iterable});

  Tuple2<pnode::PNode*, syntax_asdl::Token*> tup4 = this->_ParseOil(lexer, start_symbol);
  pnode = tup4.at0();
  last_token = tup4.at1();
  Tuple2<List<syntax_asdl::name_type*>*, syntax_asdl::expr_t*> tup5 = this->tr->OilForExpr(pnode);
  lvalue = tup5.at0();
  iterable = tup5.at1();
  return (Tuple3<List<syntax_asdl::name_type*>*, syntax_asdl::expr_t*, syntax_asdl::Token*>(lvalue, iterable, last_token));
}

syntax_asdl::Token* ParseContext::ParseProc(lexer::Lexer* lexer, syntax_asdl::command__Proc* out) {
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&lexer, &out, &pnode, &last_token});

  Tuple2<pnode::PNode*, syntax_asdl::Token*> tup6 = this->_ParseOil(lexer, grammar_nt::oil_proc);
  pnode = tup6.at0();
  last_token = tup6.at1();
  out->sig = this->tr->Proc(pnode);
  return last_token;
}

syntax_asdl::Token* ParseContext::ParseFunc(lexer::Lexer* lexer, syntax_asdl::command__Func* out) {
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&lexer, &out, &pnode, &last_token});

  Tuple2<pnode::PNode*, syntax_asdl::Token*> tup7 = this->_ParseTea(lexer, grammar_nt::named_func);
  pnode = tup7.at0();
  last_token = tup7.at1();
  this->tr->NamedFunc(pnode, out);
  return last_token;
}

syntax_asdl::Token* ParseContext::ParseDataType(lexer::Lexer* lexer, syntax_asdl::command__Data* out) {
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&lexer, &out, &pnode, &last_token});

  Tuple2<pnode::PNode*, syntax_asdl::Token*> tup8 = this->_ParseTea(lexer, grammar_nt::tea_data);
  pnode = tup8.at0();
  last_token = tup8.at1();
  this->tr->Data(pnode, out);
  return last_token;
}

syntax_asdl::Token* ParseContext::ParseEnum(lexer::Lexer* lexer, syntax_asdl::command__Enum* out) {
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&lexer, &out, &pnode, &last_token});

  Tuple2<pnode::PNode*, syntax_asdl::Token*> tup9 = this->_ParseTea(lexer, grammar_nt::tea_enum);
  pnode = tup9.at0();
  last_token = tup9.at1();
  this->tr->Enum(pnode, out);
  return last_token;
}

syntax_asdl::Token* ParseContext::ParseClass(lexer::Lexer* lexer, syntax_asdl::command__Class* out) {
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&lexer, &out, &pnode, &last_token});

  Tuple2<pnode::PNode*, syntax_asdl::Token*> tup10 = this->_ParseTea(lexer, grammar_nt::tea_class);
  pnode = tup10.at0();
  last_token = tup10.at1();
  this->tr->Class(pnode, out);
  return last_token;
}

syntax_asdl::Token* ParseContext::ParseImport(lexer::Lexer* lexer, syntax_asdl::command__Import* out) {
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&lexer, &out, &pnode, &last_token});

  Tuple2<pnode::PNode*, syntax_asdl::Token*> tup11 = this->_ParseTea(lexer, grammar_nt::tea_import);
  pnode = tup11.at0();
  last_token = tup11.at1();
  this->tr->Import(pnode, out);
  return last_token;
}

}  // define namespace parse_lib

namespace reader {  // define


_Reader::_Reader(alloc::Arena* arena) 
    : Obj(Tag::FixedSize, maskof__Reader(), sizeof(_Reader))  {
  this->arena = arena;
  this->line_num = 1;
}

void _Reader::SetLineOffset(int n) {
  this->line_num = n;
}

Str* _Reader::_GetLine() {
  throw Alloc<NotImplementedError>();
}

Tuple3<int, Str*, int> _Reader::GetLine() {
  Str* line = nullptr;
  Str* eof_line = nullptr;
  int line_id;
  StackRoots _roots({&line, &eof_line});

  line = this->_GetLine();
  if (line == nullptr) {
    eof_line = nullptr;
    return (Tuple3<int, Str*, int>(-1, eof_line, 0));
  }
  line_id = this->arena->AddLine(line, this->line_num);
  this->line_num += 1;
  return (Tuple3<int, Str*, int>(line_id, line, 0));
}

void _Reader::Reset() {
  ;  // pass
}

bool _Reader::LastLineHint() {
  return false;
}

DisallowedLineReader::DisallowedLineReader(alloc::Arena* arena, syntax_asdl::Token* blame_token) : _Reader(arena) {
  field_mask_ |= maskof_DisallowedLineReader();
  this->blame_token = blame_token;
}

Str* DisallowedLineReader::_GetLine() {
  p_die(fmt97(), this->blame_token);
}

FileLineReader::FileLineReader(mylib::LineReader* f, alloc::Arena* arena) : _Reader(arena) {
  field_mask_ |= maskof_FileLineReader();
  this->f = f;
  this->last_line_hint = false;
}

Str* FileLineReader::_GetLine() {
  Str* line = nullptr;
  StackRoots _roots({&line});

  line = this->f->readline();
  if (len(line) == 0) {
    return nullptr;
  }
  if (!line->endswith(str406)) {
    this->last_line_hint = true;
  }
  return line;
}

bool FileLineReader::LastLineHint() {
  return this->last_line_hint;
}

reader::FileLineReader* StringLineReader(Str* s, alloc::Arena* arena) {
  StackRoots _roots({&s, &arena});

  return Alloc<FileLineReader>(Alloc<mylib::BufLineReader>(s), arena);
}

VirtualLineReader::VirtualLineReader(List<Tuple3<int, Str*, int>*>* lines, alloc::Arena* arena) : _Reader(arena) {
  field_mask_ |= maskof_VirtualLineReader();
  this->lines = lines;
  this->num_lines = len(lines);
  this->pos = 0;
}

Tuple3<int, Str*, int> VirtualLineReader::GetLine() {
  Str* eof_line = nullptr;
  int line_id;
  Str* line = nullptr;
  int start_offset;
  StackRoots _roots({&eof_line, &line});

  if (this->pos == this->num_lines) {
    eof_line = nullptr;
    return (Tuple3<int, Str*, int>(-1, eof_line, 0));
  }
  Tuple3<int, Str*, int>* tup0 = this->lines->index_(this->pos);
  line_id = tup0->at0();
  line = tup0->at1();
  start_offset = tup0->at2();
  this->pos += 1;
  return (Tuple3<int, Str*, int>(line_id, line, start_offset));
}

}  // define namespace reader

namespace typed_args {  // define

using syntax_asdl::ArgList;
using syntax_asdl::command_t;
namespace expr_e = syntax_asdl::expr_e;
using syntax_asdl::expr_t;
using syntax_asdl::expr__BlockArg;
using syntax_asdl::command_sub;

void DoesNotAccept(syntax_asdl::ArgList* arg_list) {
  int span_id;
  StackRoots _roots({&arg_list});

  if (arg_list != nullptr) {
    span_id = arg_list->spids->index_(0);
    e_usage(fmt98(), span_id);
  }
}

syntax_asdl::expr_t* RequiredExpr(syntax_asdl::ArgList* arg_list) {
  int span_id;
  int n;
  StackRoots _roots({&arg_list});

  if (arg_list == nullptr) {
    e_usage(str408);
  }
  span_id = arg_list->spids->index_(0);
  n = len(arg_list->positional);
  if (n == 0) {
    e_usage(fmt99(), span_id);
  }
  else {
    if (n == 1) {
      return arg_list->positional->index_(0);
    }
    else {
      e_usage(fmt100(), span_id);
    }
  }
}

syntax_asdl::command_t* GetOneBlock(syntax_asdl::ArgList* arg_list) {
  int n;
  syntax_asdl::expr_t* arg = nullptr;
  syntax_asdl::expr_t* UP_arg = nullptr;
  StackRoots _roots({&arg_list, &arg, &UP_arg});

  if (arg_list == nullptr) {
    return nullptr;
  }
  n = len(arg_list->positional);
  if (n == 0) {
    return nullptr;
  }
  else {
    if (n == 1) {
      arg = arg_list->positional->index_(0);
      UP_arg = arg;
      switch (arg->tag_()) {
        case expr_e::BlockArg: {
          expr__BlockArg* arg = static_cast<expr__BlockArg*>(UP_arg);
          return arg->block;
        }
          break;
        case expr_e::CommandSub: {
          command_sub* arg = static_cast<command_sub*>(UP_arg);
          return arg->child;
        }
          break;
        default: {
          e_usage(fmt101(), arg_list->spids->index_(0));
        }
      }
    }
    else {
      e_usage(fmt102(), arg_list->spids->index_(0));
    }
  }
}

}  // define namespace typed_args

namespace expr_parse {  // define

using syntax_asdl::Token;
using syntax_asdl::double_quoted;
using syntax_asdl::single_quoted;
using syntax_asdl::command_sub;
using syntax_asdl::sh_array_literal;
using syntax_asdl::compound_word;
using syntax_asdl::word_part_t;
namespace word_e = syntax_asdl::word_e;
namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Kind;
using id_kind_asdl::Id_str;
using types_asdl::lex_mode_e;

int _Classify(grammar::Grammar* gr, syntax_asdl::Token* tok, bool tea_keywords) {
  Str* type_str = nullptr;
  StackRoots _roots({&gr, &tok, &type_str});

  if ((tea_keywords and tok->id == Id::Expr_Name)) {
    if (dict_contains(gr->keywords, tok->val)) {
      return gr->keywords->index_(tok->val);
    }
  }
  if (dict_contains(gr->tokens, tok->id)) {
    return gr->tokens->index_(tok->id);
  }
  if (tok->id == Id::Unknown_DEqual) {
    p_die(fmt103(), tok);
  }
  if (tok->id == Id::Unknown_Tok) {
    type_str = str414;
  }
  else {
    type_str = fmt104(ui::PrettyId(tok->id));
  }
  p_die(fmt105(type_str), tok);
}
Dict<int, int> gdict0(std::initializer_list<int>{}, std::initializer_list<int>{});
Dict<int, int>* _OTHER_BALANCE = &gdict0;

syntax_asdl::Token* _PushOilTokens(parse_lib::ParseContext* parse_ctx, grammar::Grammar* gr, parse::Parser* p, lexer::Lexer* lex, bool tea_keywords) {
  syntax_asdl::Token* last_token = nullptr;
  bool prev_was_newline;
  int balance;
  syntax_asdl::Token* tok = nullptr;
  int ilabel;
  StackRoots _roots({&parse_ctx, &gr, &p, &lex, &last_token, &tok});

  last_token = nullptr;
  prev_was_newline = false;
  balance = 0;
  while (true) {
    if (last_token) {
      tok = last_token;
      last_token = nullptr;
    }
    else {
      tok = lex->Read(lex_mode_e::Expr);
    }
    if (consts::GetKind(tok->id) == Kind::Ignored) {
      continue;
    }
    if (tok->id == Id::Op_Newline) {
      if (balance > 0) {
        continue;
      }
      if (prev_was_newline) {
        continue;
      }
      prev_was_newline = true;
    }
    else {
      prev_was_newline = false;
    }
    balance += _OTHER_BALANCE->get(tok->id, 0);
    ilabel = _Classify(gr, tok, tea_keywords);
    if (p->addtoken(tok->id, tok, ilabel)) {
      return tok;
    }
  }
}

ExprParser::ExprParser(parse_lib::ParseContext* parse_ctx, grammar::Grammar* gr, bool tea_keywords) 
    : Obj(Tag::FixedSize, maskof_ExprParser(), sizeof(ExprParser))  {
  this->parse_ctx = parse_ctx;
  this->gr = gr;
  this->tea_keywords = tea_keywords;
  this->push_parser = Alloc<parse::Parser>(gr);
}

Tuple2<pnode::PNode*, syntax_asdl::Token*> ExprParser::Parse(lexer::Lexer* lexer, int start_symbol) {
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&lexer, &last_token});

  this->push_parser->setup(start_symbol);
  try {
    last_token = _PushOilTokens(this->parse_ctx, this->gr, this->push_parser, lexer, this->tea_keywords);
  }
  catch (parse::ParseError* e) {
    p_die(fmt106(ui::PrettyId(e->tok->id)), e->tok);
  }
  return (Tuple2<pnode::PNode*, syntax_asdl::Token*>(this->push_parser->rootnode, last_token));
}

}  // define namespace expr_parse

namespace expr_to_ast {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using id_kind_asdl::Id_str;
using syntax_asdl::Token;
using syntax_asdl::speck;
using syntax_asdl::double_quoted;
using syntax_asdl::single_quoted;
using syntax_asdl::simple_var_sub;
using syntax_asdl::braced_var_sub;
using syntax_asdl::command_sub;
using syntax_asdl::sh_array_literal;
namespace command = syntax_asdl::command;
using syntax_asdl::command_t;
namespace expr = syntax_asdl::expr;
namespace expr_e = syntax_asdl::expr_e;
using syntax_asdl::expr_t;
using syntax_asdl::expr__Var;
using syntax_asdl::expr__Dict;
using syntax_asdl::expr_context_e;
namespace re = syntax_asdl::re;
using syntax_asdl::re_t;
namespace re_repeat = syntax_asdl::re_repeat;
using syntax_asdl::re_repeat_t;
namespace class_literal_term = syntax_asdl::class_literal_term;
using syntax_asdl::class_literal_term_t;
using syntax_asdl::posix_class;
using syntax_asdl::perl_class;
using syntax_asdl::name_type;
namespace place_expr = syntax_asdl::place_expr;
namespace place_expr_e = syntax_asdl::place_expr_e;
using syntax_asdl::place_expr_t;
using syntax_asdl::type_expr_t;
using syntax_asdl::comprehension;
using syntax_asdl::subscript;
using syntax_asdl::attribute;
namespace proc_sig = syntax_asdl::proc_sig;
using syntax_asdl::proc_sig_t;
using syntax_asdl::param;
using syntax_asdl::named_arg;
using syntax_asdl::ArgList;
using syntax_asdl::TypedParam;
using syntax_asdl::UntypedParam;
using syntax_asdl::variant;
namespace variant_type = syntax_asdl::variant_type;
using syntax_asdl::variant_type_t;
Dict<Str*, Str*> gdict0(std::initializer_list<Str*>{}, std::initializer_list<Str*>{});
Dict<Str*, Str*>* PERL_CLASSES = &gdict0;
GLOBAL_LIST(Str*, 12, POSIX_CLASSES, {str418 COMMA str419 COMMA str420 COMMA str421 COMMA str422 COMMA str423 COMMA str424 COMMA str425 COMMA str426 COMMA str427 COMMA str428 COMMA str429});
Str* RANGE_POINT_TOO_LONG = str430;
int NT_OFFSET = 256;

bool ISNONTERMINAL(int x) {
  return x >= NT_OFFSET;
}

Transformer::Transformer(grammar::Grammar* gr) 
    : Obj(Tag::FixedSize, maskof_Transformer(), sizeof(Transformer))  {
  this->number2symbol = gr->number2symbol;
}

syntax_asdl::expr_t* Transformer::_AssocBinary(List<pnode::PNode*>* children) {
  int n;
  syntax_asdl::expr_t* left = nullptr;
  pnode::PNode* op = nullptr;
  syntax_asdl::expr_t* right = nullptr;
  StackRoots _roots({&children, &left, &op, &right});

  n = len(children);
  if (n == 1) {
    return this->Expr(children->index_(0));
  }
  left = this->Expr(children->index_(0));
  op = children->index_(1);
  if (n == 3) {
    right = this->Expr(children->index_(2));
  }
  else {
    right = this->_AssocBinary(children->slice(2));
  }
  return Alloc<expr::Binary>(op->tok, left, right);
}

syntax_asdl::expr_t* Transformer::_Trailer(syntax_asdl::expr_t* base, pnode::PNode* p_trailer) {
  List<pnode::PNode*>* children = nullptr;
  syntax_asdl::Token* op_tok = nullptr;
  syntax_asdl::ArgList* arglist = nullptr;
  pnode::PNode* p = nullptr;
  pnode::PNode* p_args = nullptr;
  List<syntax_asdl::expr_t*>* indices = nullptr;
  int n;
  pnode::PNode* a = nullptr;
  syntax_asdl::Token* attr = nullptr;
  StackRoots _roots({&base, &p_trailer, &children, &op_tok, &arglist, &p, &p_args, &indices, &a, &attr});

  children = p_trailer->children;
  op_tok = children->index_(0)->tok;
  if (op_tok->id == Id::Op_LParen) {
    arglist = Alloc<ArgList>();
    if (len(children) == 2) {
      return Alloc<expr::FuncCall>(base, arglist);
    }
    p = children->index_(1);
    this->_Arglist(p->children, arglist);
    return Alloc<expr::FuncCall>(base, arglist);
  }
  if (op_tok->id == Id::Op_LBracket) {
    p_args = children->index_(1);
    indices = Alloc<List<syntax_asdl::expr_t*>>();
    n = len(p_args->children);
    for (int i = 0; i < n; i += 2) {
      a = p_args->children->index_(i);
      indices->append(this->_Subscript(a->children));
    }
    return Alloc<subscript>(base, indices);
  }
  if ((op_tok->id == Id::Expr_Dot || op_tok->id == Id::Expr_RArrow || op_tok->id == Id::Expr_DColon)) {
    attr = children->index_(1)->tok;
    return Alloc<attribute>(base, op_tok, attr, expr_context_e::Store);
  }
  assert(0);  // AssertionError
}

Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*> Transformer::_DictPair(pnode::PNode* p_node) {
  List<pnode::PNode*>* children = nullptr;
  int typ;
  syntax_asdl::expr_t* key = nullptr;
  syntax_asdl::expr_t* value = nullptr;
  syntax_asdl::Token* tok0 = nullptr;
  int id_;
  StackRoots _roots({&p_node, &children, &key, &value, &tok0});

  children = p_node->children;
  typ = children->index_(0)->typ;
  if (ISNONTERMINAL(typ)) {
    if (typ == grammar_nt::sq_string) {
      key = this->Expr(children->index_(0));
    }
    else {
      if (typ == grammar_nt::dq_string) {
        key = this->Expr(children->index_(0));
      }
    }
    value = this->Expr(children->index_(2));
    return (Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*>(key, value));
  }
  tok0 = children->index_(0)->tok;
  id_ = tok0->id;
  if (id_ == Id::Expr_Name) {
    key = Alloc<expr::Const>(tok0);
    if (len(children) >= 3) {
      value = this->Expr(children->index_(2));
    }
    else {
      value = Alloc<expr::Implicit>();
    }
  }
  if (id_ == Id::Op_LBracket) {
    key = this->Expr(children->index_(1));
    value = this->Expr(children->index_(4));
    return (Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*>(key, value));
  }
  return (Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*>(key, value));
}

syntax_asdl::expr__Dict* Transformer::_Dict(pnode::PNode* p_node) {
  List<syntax_asdl::expr_t*>* keys = nullptr;
  List<syntax_asdl::expr_t*>* values = nullptr;
  int n;
  syntax_asdl::expr_t* key = nullptr;
  syntax_asdl::expr_t* value = nullptr;
  StackRoots _roots({&p_node, &keys, &values, &key, &value});

  if (!ISNONTERMINAL(p_node->typ)) {
    return Alloc<expr::Dict>(Alloc<List<syntax_asdl::expr_t*>>(), Alloc<List<syntax_asdl::expr_t*>>());
  }
  keys = Alloc<List<syntax_asdl::expr_t*>>();
  values = Alloc<List<syntax_asdl::expr_t*>>();
  n = len(p_node->children);
  for (int i = 0; i < n; i += 2) {
    Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*> tup1 = this->_DictPair(p_node->children->index_(i));
    key = tup1.at0();
    value = tup1.at1();
    keys->append(key);
    values->append(value);
  }
  return Alloc<expr::Dict>(keys, values);
}

syntax_asdl::expr_t* Transformer::_Tuple(List<pnode::PNode*>* children) {
  int n;
  List<syntax_asdl::expr_t*>* elts = nullptr;
  pnode::PNode* p_node = nullptr;
  StackRoots _roots({&children, &elts, &p_node});

  n = len(children);
  if (n == 1) {
    return this->Expr(children->index_(0));
  }
  if (n == 2) {
    p_die(fmt107(), children->index_(1)->tok);
  }
  elts = Alloc<List<syntax_asdl::expr_t*>>();
  for (int i = 0; i < n; i += 2) {
    p_node = children->index_(i);
    elts->append(this->Expr(p_node));
  }
  return Alloc<expr::Tuple>(elts, expr_context_e::Store);
}

syntax_asdl::expr_t* Transformer::_TestlistComp(pnode::PNode* p_node, int id0) {
  List<pnode::PNode*>* children = nullptr;
  int n;
  syntax_asdl::expr_t* elt = nullptr;
  syntax_asdl::comprehension* comp = nullptr;
  List<syntax_asdl::expr_t*>* elts = nullptr;
  StackRoots _roots({&p_node, &children, &elt, &comp, &elts});

  children = p_node->children;
  n = len(children);
  if ((n > 1 and children->index_(1)->typ == grammar_nt::comp_for)) {
    elt = this->Expr(children->index_(0));
    comp = this->_CompFor(children->index_(1));
    if (id0 == Id::Op_LParen) {
      return Alloc<expr::GeneratorExp>(elt, NewList<syntax_asdl::comprehension*>(std::initializer_list<syntax_asdl::comprehension*>{comp}));
    }
    if (id0 == Id::Op_LBracket) {
      return Alloc<expr::ListComp>(elt, NewList<syntax_asdl::comprehension*>(std::initializer_list<syntax_asdl::comprehension*>{comp}));
    }
    assert(0);  // AssertionError
  }
  if (id0 == Id::Op_LParen) {
    if (len(children) == 1) {
      return this->Expr(children->index_(0));
    }
    if (children->index_(1)->tok->id == Id::Arith_Comma) {
      return this->_Tuple(children);
    }
    throw Alloc<NotImplementedError>(str432);
  }
  if (id0 == Id::Op_LBracket) {
    elts = Alloc<List<syntax_asdl::expr_t*>>();
    for (int i = 0; i < n; i += 2) {
      elts->append(this->Expr(children->index_(i)));
    }
    return Alloc<expr::List>(elts, expr_context_e::Store);
  }
  assert(0);  // AssertionError
}

syntax_asdl::expr_t* Transformer::_Atom(List<pnode::PNode*>* children) {
  syntax_asdl::Token* tok = nullptr;
  int id_;
  int n;
  int i;
  syntax_asdl::re_t* r = nullptr;
  List<syntax_asdl::Token*>* flags = nullptr;
  syntax_asdl::Token* trans_pref = nullptr;
  StackRoots _roots({&children, &tok, &r, &flags, &trans_pref});

  tok = children->index_(0)->tok;
  id_ = tok->id;
  n = len(children);
  if (id_ == Id::Op_LParen) {
    if (n == 2) {
      return Alloc<expr::Tuple>(Alloc<List<syntax_asdl::expr_t*>>(), expr_context_e::Store);
    }
    return this->_TestlistComp(children->index_(1), id_);
  }
  if (id_ == Id::Op_LBracket) {
    if (n == 2) {
      return Alloc<expr::List>(Alloc<List<syntax_asdl::expr_t*>>(), expr_context_e::Store);
    }
    return this->_TestlistComp(children->index_(1), id_);
  }
  if (id_ == Id::Op_LBrace) {
    i = 1;
    if (children->index_(i)->tok->id == Id::Op_Newline) {
      i += 1;
    }
    return this->_Dict(children->index_(i));
  }
  if (id_ == Id::Arith_Slash) {
    r = this->_Regex(children->index_(1));
    flags = Alloc<List<syntax_asdl::Token*>>();
    trans_pref = nullptr;
    return Alloc<expr::RegexLiteral>(children->index_(0)->tok, r, flags, trans_pref);
  }
  if (id_ == Id::Expr_Func) {
    return Alloc<expr::Lambda>(Alloc<List<syntax_asdl::name_type*>>(), Alloc<expr::Implicit>());
  }
  throw Alloc<NotImplementedError>(Id_str(id_));
}

List<syntax_asdl::name_type*>* Transformer::_NameTypeList(pnode::PNode* p_node) {
  List<syntax_asdl::name_type*>* results = nullptr;
  int n;
  pnode::PNode* p = nullptr;
  List<pnode::PNode*>* children = nullptr;
  syntax_asdl::type_expr_t* typ = nullptr;
  syntax_asdl::name_type* node = nullptr;
  StackRoots _roots({&p_node, &results, &p, &children, &typ, &node});

  results = Alloc<List<syntax_asdl::name_type*>>();
  n = len(p_node->children);
  for (int i = 0; i < n; i += 2) {
    p = p_node->children->index_(i);
    children = p->children;
    if (len(children) == 2) {
      typ = this->_TypeExpr(children->index_(1));
    }
    else {
      typ = nullptr;
    }
    node = Alloc<name_type>(children->index_(0)->tok, typ);
    results->append(node);
  }
  return results;
}

syntax_asdl::comprehension* Transformer::_CompFor(pnode::PNode* p_node) {
  List<pnode::PNode*>* children = nullptr;
  List<syntax_asdl::name_type*>* lhs = nullptr;
  syntax_asdl::expr_t* iterable = nullptr;
  syntax_asdl::expr_t* cond = nullptr;
  StackRoots _roots({&p_node, &children, &lhs, &iterable, &cond});

  children = p_node->children;
  lhs = this->_NameTypeList(children->index_(1));
  iterable = this->Expr(children->index_(3));
  if (len(children) >= 6) {
    cond = this->Expr(children->index_(5));
  }
  else {
    cond = nullptr;
  }
  return Alloc<comprehension>(lhs, iterable, cond);
}

syntax_asdl::expr_t* Transformer::_CompareChain(List<pnode::PNode*>* children) {
  List<syntax_asdl::speck*>* cmp_ops = nullptr;
  List<syntax_asdl::expr_t*>* comparators = nullptr;
  syntax_asdl::expr_t* left = nullptr;
  int i;
  int n;
  List<pnode::PNode*>* op_children = nullptr;
  syntax_asdl::Token* tok1 = nullptr;
  syntax_asdl::speck* op = nullptr;
  StackRoots _roots({&children, &cmp_ops, &comparators, &left, &op_children, &tok1, &op});

  cmp_ops = Alloc<List<syntax_asdl::speck*>>();
  comparators = Alloc<List<syntax_asdl::expr_t*>>();
  left = this->Expr(children->index_(0));
  i = 1;
  n = len(children);
  while (i < n) {
    op_children = children->index_(i)->children;
    tok1 = op_children->index_(0)->tok;
    if (len(op_children) == 2) {
      if (tok1->id == Id::Expr_Not) {
        op = Alloc<speck>(Id::Node_NotIn, tok1->span_id);
      }
      else {
        if (tok1->id == Id::Expr_Is) {
          op = Alloc<speck>(Id::Node_IsNot, tok1->span_id);
        }
        else {
          assert(0);  // AssertionError
        }
      }
    }
    else {
      op = Alloc<speck>(tok1->id, tok1->span_id);
    }
    cmp_ops->append(op);
    i += 1;
    comparators->append(this->Expr(children->index_(i)));
    i += 1;
  }
  return Alloc<expr::Compare>(left, cmp_ops, comparators);
}

syntax_asdl::expr_t* Transformer::_Subscript(List<pnode::PNode*>* children) {
  int typ0;
  int n;
  syntax_asdl::expr_t* lower = nullptr;
  syntax_asdl::expr_t* upper = nullptr;
  StackRoots _roots({&children, &lower, &upper});

  typ0 = children->index_(0)->typ;
  n = len(children);
  if (ISNONTERMINAL(typ0)) {
    if (n == 3) {
      lower = this->Expr(children->index_(0));
      upper = this->Expr(children->index_(2));
    }
    else {
      if (n == 2) {
        lower = this->Expr(children->index_(0));
        upper = nullptr;
      }
      else {
        return this->Expr(children->index_(0));
      }
    }
  }
  else {
    lower = nullptr;
    if (n == 1) {
      upper = nullptr;
    }
    else {
      upper = this->Expr(children->index_(1));
    }
  }
  return Alloc<expr::Slice>(lower, upper);
}

syntax_asdl::expr_t* Transformer::Expr(pnode::PNode* pnode) {
  int typ;
  syntax_asdl::Token* tok = nullptr;
  List<pnode::PNode*>* children = nullptr;
  syntax_asdl::expr_t* test = nullptr;
  syntax_asdl::expr_t* body = nullptr;
  syntax_asdl::expr_t* orelse = nullptr;
  int n;
  List<syntax_asdl::name_type*>* params = nullptr;
  syntax_asdl::Token* op_tok = nullptr;
  pnode::PNode* op = nullptr;
  pnode::PNode* e = nullptr;
  syntax_asdl::expr_t* node = nullptr;
  int i;
  syntax_asdl::expr_t* factor = nullptr;
  Str* bare = nullptr;
  Str* nt_name = nullptr;
  int id_;
  StackRoots _roots({&pnode, &tok, &children, &test, &body, &orelse, &params, &op_tok, &op, &e, &node, &factor, &bare, &nt_name});

  typ = pnode->typ;
  tok = pnode->tok;
  children = pnode->children;
  if (ISNONTERMINAL(typ)) {
    if (typ == grammar_nt::oil_expr) {
      return this->Expr(children->index_(1));
    }
    if (typ == grammar_nt::command_expr) {
      return this->Expr(children->index_(0));
    }
    if (typ == grammar_nt::atom) {
      if (len(children) == 1) {
        return this->Expr(children->index_(0));
      }
      return this->_Atom(children);
    }
    if (typ == grammar_nt::testlist) {
      return this->_Tuple(children);
    }
    if (typ == grammar_nt::test) {
      if (len(children) == 1) {
        return this->Expr(children->index_(0));
      }
      test = this->Expr(children->index_(2));
      body = this->Expr(children->index_(0));
      orelse = this->Expr(children->index_(4));
      return Alloc<expr::IfExp>(test, body, orelse);
    }
    if (typ == grammar_nt::lambdef) {
      n = len(children);
      if (n == 4) {
        params = this->_NameTypeList(children->index_(1));
      }
      else {
        params = Alloc<List<syntax_asdl::name_type*>>();
      }
      body = this->Expr(children->index_((n - 1)));
      return Alloc<expr::Lambda>(params, body);
    }
    if (typ == grammar_nt::or_test) {
      return this->_AssocBinary(children);
    }
    if (typ == grammar_nt::and_test) {
      return this->_AssocBinary(children);
    }
    if (typ == grammar_nt::not_test) {
      if (len(children) == 1) {
        return this->Expr(children->index_(0));
      }
      op_tok = children->index_(0)->tok;
      return Alloc<expr::Unary>(op_tok, this->Expr(children->index_(1)));
    }
    else {
      if (typ == grammar_nt::comparison) {
        if (len(children) == 1) {
          return this->Expr(children->index_(0));
        }
        return this->_CompareChain(children);
      }
      else {
        if (typ == grammar_nt::range_expr) {
          n = len(children);
          if (n == 1) {
            return this->Expr(children->index_(0));
          }
          if (n == 3) {
            return Alloc<expr::Range>(this->Expr(children->index_(0)), this->Expr(children->index_(2)));
          }
          assert(0);  // AssertionError
        }
        else {
          if (typ == grammar_nt::expr) {
            return this->_AssocBinary(children);
          }
        }
      }
    }
    if (typ == grammar_nt::xor_expr) {
      return this->_AssocBinary(children);
    }
    if (typ == grammar_nt::and_expr) {
      return this->_AssocBinary(children);
    }
    else {
      if (typ == grammar_nt::shift_expr) {
        return this->_AssocBinary(children);
      }
      else {
        if (typ == grammar_nt::arith_expr) {
          return this->_AssocBinary(children);
        }
        else {
          if (typ == grammar_nt::term) {
            return this->_AssocBinary(children);
          }
          else {
            if (typ == grammar_nt::factor) {
              if (len(children) == 1) {
                return this->Expr(children->index_(0));
              }
              op = children->index_(0);
              e = children->index_(1);
              return Alloc<expr::Unary>(op->tok, this->Expr(e));
            }
            else {
              if (typ == grammar_nt::power) {
                node = this->Expr(children->index_(0));
                if (len(children) == 1) {
                  return node;
                }
                n = len(children);
                i = 1;
                while ((i < n and ISNONTERMINAL(children->index_(i)->typ))) {
                  node = this->_Trailer(node, children->index_(i));
                  i += 1;
                }
                if (node->tag_() == expr_e::Attribute) {
                  attribute* attr_node = static_cast<attribute*>(node);
                  if (attr_node->op->id == Id::Expr_Dot) {
                    p_die(fmt108(), attr_node->op);
                  }
                }
                if (i != n) {
                  op_tok = children->index_(i)->tok;
                  factor = this->Expr(children->index_((i + 1)));
                  node = Alloc<expr::Binary>(op_tok, node, factor);
                }
                return node;
              }
              else {
                if (typ == grammar_nt::oil_expr_sub) {
                  return this->Expr(children->index_(0));
                }
                else {
                  if (typ == grammar_nt::sh_array_literal) {
                    return reinterpret_cast<sh_array_literal*>(children->index_(1)->tok);
                  }
                  else {
                    if (typ == grammar_nt::sh_command_sub) {
                      return reinterpret_cast<command_sub*>(children->index_(1)->tok);
                    }
                    else {
                      if (typ == grammar_nt::braced_var_sub) {
                        return reinterpret_cast<braced_var_sub*>(children->index_(1)->tok);
                      }
                      else {
                        if (typ == grammar_nt::dq_string) {
                          return reinterpret_cast<double_quoted*>(children->index_(1)->tok);
                        }
                        else {
                          if (typ == grammar_nt::sq_string) {
                            return reinterpret_cast<single_quoted*>(children->index_(1)->tok);
                          }
                          else {
                            if (typ == grammar_nt::simple_var_sub) {
                              tok = children->index_(0)->tok;
                              if (tok->id == Id::VSub_DollarName) {
                                bare = tok->val->slice(1);
                                p_die(fmt109(bare, bare), tok);
                              }
                              return Alloc<simple_var_sub>(tok);
                            }
                            else {
                              nt_name = this->number2symbol->index_(typ);
                              assert(0);  // AssertionError
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else {
    id_ = tok->id;
    if (id_ == Id::Expr_Name) {
      return Alloc<expr::Var>(tok);
    }
    if ((id_ == Id::Expr_DecInt || id_ == Id::Expr_BinInt || id_ == Id::Expr_OctInt || id_ == Id::Expr_HexInt || id_ == Id::Expr_Float)) {
      return Alloc<expr::Const>(tok);
    }
    if ((id_ == Id::Expr_Null || id_ == Id::Expr_True || id_ == Id::Expr_False || id_ == Id::Char_OneChar || id_ == Id::Char_UBraced || id_ == Id::Char_Pound)) {
      return Alloc<expr::Const>(tok);
    }
    throw Alloc<NotImplementedError>(Id_str(id_));
  }
}

syntax_asdl::expr_t* Transformer::_ArrayItem(pnode::PNode* p_node) {
  pnode::PNode* child0 = nullptr;
  int typ0;
  StackRoots _roots({&p_node, &child0});

  child0 = p_node->children->index_(0);
  typ0 = child0->typ;
  if (ISNONTERMINAL(typ0)) {
    return this->Expr(child0);
  }
  else {
    if (child0->tok->id == Id::Op_LParen) {
      return this->Expr(p_node->children->index_(1));
    }
    return this->Expr(child0);
  }
}

List<syntax_asdl::place_expr_t*>* Transformer::_PlaceList(pnode::PNode* p_node) {
  List<syntax_asdl::place_expr_t*>* places = nullptr;
  int n;
  pnode::PNode* p = nullptr;
  syntax_asdl::expr_t* e = nullptr;
  syntax_asdl::expr_t* UP_e = nullptr;
  int tag;
  StackRoots _roots({&p_node, &places, &p, &e, &UP_e});

  places = Alloc<List<syntax_asdl::place_expr_t*>>();
  n = len(p_node->children);
  for (int i = 0; i < n; i += 2) {
    p = p_node->children->index_(i);
    e = this->Expr(p);
    UP_e = e;
    tag = e->tag_();
    if (tag == expr_e::Var) {
      expr__Var* e = static_cast<expr__Var*>(UP_e);
      places->append(Alloc<place_expr::Var>(e->name));
    }
    else {
      if ((tag == place_expr_e::Var || tag == place_expr_e::Subscript || tag == place_expr_e::Attribute)) {
        places->append(reinterpret_cast<place_expr_t*>(UP_e));
      }
      else {
        p_die(fmt110(), p->tok ? p->tok : nullptr);
      }
    }
  }
  return places;
}

syntax_asdl::command__VarDecl* Transformer::MakeVarDecl(pnode::PNode* p_node) {
  int typ;
  List<pnode::PNode*>* children = nullptr;
  List<syntax_asdl::name_type*>* lhs = nullptr;
  syntax_asdl::expr_t* rhs = nullptr;
  StackRoots _roots({&p_node, &children, &lhs, &rhs});

  typ = p_node->typ;
  children = p_node->children;
  lhs = this->_NameTypeList(children->index_(0));
  rhs = this->Expr(children->index_(2));
  return Alloc<command::VarDecl>(nullptr, lhs, rhs);
}

syntax_asdl::command__PlaceMutation* Transformer::MakePlaceMutation(pnode::PNode* p_node) {
  int typ;
  List<pnode::PNode*>* children = nullptr;
  List<syntax_asdl::place_expr_t*>* place_list = nullptr;
  syntax_asdl::Token* op_tok = nullptr;
  syntax_asdl::expr_t* rhs = nullptr;
  StackRoots _roots({&p_node, &children, &place_list, &op_tok, &rhs});

  typ = p_node->typ;
  children = p_node->children;
  place_list = this->_PlaceList(children->index_(0));
  op_tok = children->index_(1)->tok;
  rhs = this->Expr(children->index_(2));
  return Alloc<command::PlaceMutation>(nullptr, place_list, op_tok, rhs);
}

Tuple2<List<syntax_asdl::name_type*>*, syntax_asdl::expr_t*> Transformer::OilForExpr(pnode::PNode* pnode) {
  int typ;
  List<pnode::PNode*>* children = nullptr;
  List<syntax_asdl::name_type*>* lhs = nullptr;
  syntax_asdl::expr_t* iterable = nullptr;
  Str* nt_name = nullptr;
  StackRoots _roots({&pnode, &children, &lhs, &iterable, &nt_name});

  typ = pnode->typ;
  children = pnode->children;
  if (typ == grammar_nt::oil_for) {
    lhs = this->_NameTypeList(children->index_(1));
    iterable = this->Expr(children->index_(3));
    return (Tuple2<List<syntax_asdl::name_type*>*, syntax_asdl::expr_t*>(lhs, iterable));
  }
  nt_name = this->number2symbol->index_(typ);
  assert(0);  // AssertionError
}

void Transformer::_Argument(pnode::PNode* p_node, bool do_named, syntax_asdl::ArgList* arglist) {
  List<syntax_asdl::expr_t*>* positional = nullptr;
  List<syntax_asdl::named_arg*>* named = nullptr;
  List<pnode::PNode*>* children = nullptr;
  int n;
  syntax_asdl::expr_t* arg = nullptr;
  syntax_asdl::expr_t* spread_expr = nullptr;
  syntax_asdl::expr_t* elt = nullptr;
  syntax_asdl::comprehension* comp = nullptr;
  syntax_asdl::named_arg* n1 = nullptr;
  StackRoots _roots({&p_node, &arglist, &positional, &named, &children, &arg, &spread_expr, &elt, &comp, &n1});

  positional = arglist->positional;
  named = arglist->named;
  children = p_node->children;
  n = len(children);
  if (n == 1) {
    arg = this->Expr(children->index_(0));
    positional->append(arg);
    return ;
  }
  if (n == 2) {
    if (children->index_(0)->tok->id == Id::Expr_Ellipsis) {
      spread_expr = this->Expr(children->index_(1));
      if (do_named) {
        named->append(Alloc<named_arg>(nullptr, spread_expr));
      }
      else {
        positional->append(Alloc<expr::Spread>(spread_expr, expr_context_e::Store));
      }
      return ;
    }
    if (children->index_(1)->typ == grammar_nt::comp_for) {
      elt = this->Expr(children->index_(0));
      comp = this->_CompFor(children->index_(1));
      arg = Alloc<expr::GeneratorExp>(elt, NewList<syntax_asdl::comprehension*>(std::initializer_list<syntax_asdl::comprehension*>{comp}));
      positional->append(arg);
      return ;
    }
    assert(0);  // AssertionError
  }
  if (n == 3) {
    n1 = Alloc<named_arg>(children->index_(0)->tok, this->Expr(children->index_(2)));
    named->append(n1);
    return ;
  }
  throw Alloc<NotImplementedError>();
}

void Transformer::_Arglist(List<pnode::PNode*>* children, syntax_asdl::ArgList* arglist) {
  bool do_named;
  StackRoots _roots({&children, &arglist});

  do_named = false;
  for (ListIter<pnode::PNode*> it(children); !it.Done(); it.Next()) {
    pnode::PNode* p_child = it.Value();
    StackRoots _for({&p_child  });
    if (ISNONTERMINAL(p_child->typ)) {
      this->_Argument(p_child, do_named, arglist);
    }
    else {
      if (p_child->tok->id == Id::Op_Semi) {
        do_named = true;
      }
    }
  }
}

void Transformer::ToArgList(pnode::PNode* pnode, syntax_asdl::ArgList* arglist) {
  pnode::PNode* p = nullptr;
  StackRoots _roots({&pnode, &arglist, &p});

  if (len(pnode->children) == 2) {
    return ;
  }
  p = pnode->children->index_(1);
  this->_Arglist(p->children, arglist);
}

syntax_asdl::type_expr_t* Transformer::_TypeExpr(pnode::PNode* pnode) {
  StackRoots _roots({&pnode});

  return nullptr;
}

List<syntax_asdl::type_expr_t*>* Transformer::_TypeExprList(pnode::PNode* pnode) {
  StackRoots _roots({&pnode});

  return nullptr;
}

Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::expr_t*> Transformer::_ProcParam(pnode::PNode* pnode) {
  List<pnode::PNode*>* children = nullptr;
  syntax_asdl::Token* tok0 = nullptr;
  int n;
  syntax_asdl::Token* prefix = nullptr;
  syntax_asdl::Token* name = nullptr;
  syntax_asdl::Token* typ = nullptr;
  syntax_asdl::expr_t* default_val = nullptr;
  int i;
  syntax_asdl::Token* tok1 = nullptr;
  StackRoots _roots({&pnode, &children, &tok0, &prefix, &name, &typ, &default_val, &tok1});

  children = pnode->children;
  tok0 = children->index_(0)->tok;
  n = len(children);
  prefix = nullptr;
  name = nullptr;
  typ = nullptr;
  default_val = nullptr;
  if ((tok0->id == Id::Arith_Colon || tok0->id == Id::Expr_At)) {
    prefix = tok0;
    name = children->index_(1)->tok;
    return (Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::expr_t*>(prefix, name, typ, default_val));
  }
  name = children->index_(0)->tok;
  if (n == 1) {
    return (Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::expr_t*>(prefix, name, typ, default_val));
  }
  i = 1;
  tok1 = children->index_(1)->tok;
  if (tok1->id == Id::Expr_Name) {
    typ = tok1;
    i += 1;
  }
  if ((i + 1) == (n - 1)) {
    default_val = this->Expr(children->index_((i + 1)));
  }
  return (Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::expr_t*>(prefix, name, typ, default_val));
}

syntax_asdl::proc_sig_t* Transformer::_ProcParams(pnode::PNode* p_node) {
  List<pnode::PNode*>* children = nullptr;
  int n;
  List<syntax_asdl::UntypedParam*>* untyped = nullptr;
  syntax_asdl::Token* rest = nullptr;
  List<syntax_asdl::TypedParam*>* typed = nullptr;
  int state;
  int i;
  syntax_asdl::Token* prefix = nullptr;
  syntax_asdl::Token* name = nullptr;
  syntax_asdl::Token* typ = nullptr;
  syntax_asdl::expr_t* default_val = nullptr;
  StackRoots _roots({&p_node, &children, &untyped, &rest, &typed, &prefix, &name, &typ, &default_val});

  children = p_node->children;
  n = len(children);
  untyped = Alloc<List<syntax_asdl::UntypedParam*>>();
  rest = nullptr;
  typed = Alloc<List<syntax_asdl::TypedParam*>>();
  state = 0;
  i = 0;
  while (i < n) {
    Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::Token*, syntax_asdl::expr_t*> tup2 = this->_ProcParam(children->index_(i));
    prefix = tup2.at0();
    name = tup2.at1();
    typ = tup2.at2();
    default_val = tup2.at3();
    if ((prefix and prefix->id == Id::Expr_At)) {
      rest = name;
    }
    else {
      if (typ == nullptr) {
        untyped->append(Alloc<UntypedParam>(prefix, name, default_val));
      }
      else {
        if ((typ->val != str438 && typ->val != str439)) {
          p_die(fmt111(), typ);
        }
        typed->append(Alloc<TypedParam>(name, typ, default_val));
      }
    }
    i += 2;
  }
  return Alloc<proc_sig::Closed>(untyped, rest, typed);
}

syntax_asdl::param* Transformer::_FuncParam(pnode::PNode* pnode) {
  List<pnode::PNode*>* children = nullptr;
  syntax_asdl::Token* tok0 = nullptr;
  int n;
  syntax_asdl::expr_t* default_val = nullptr;
  syntax_asdl::type_expr_t* type_ = nullptr;
  syntax_asdl::Token* prefix_tok = nullptr;
  StackRoots _roots({&pnode, &children, &tok0, &default_val, &type_, &prefix_tok});

  children = pnode->children;
  tok0 = children->index_(0)->tok;
  n = len(children);
  if (tok0->id == Id::Expr_Name) {
    default_val = nullptr;
    type_ = nullptr;
    if ((n > 1 and children->index_(1)->tok->id == Id::Arith_Equal)) {
      default_val = this->Expr(children->index_(2));
    }
    else {
      if ((n > 2 and children->index_(2)->tok->id == Id::Arith_Equal)) {
        default_val = this->Expr(children->index_(3));
      }
    }
    prefix_tok = nullptr;
    return Alloc<param>(prefix_tok, tok0, type_, default_val);
  }
  assert(0);  // AssertionError
}

Tuple2<List<syntax_asdl::param*>*, syntax_asdl::Token*> Transformer::_FuncParams(pnode::PNode* p_node) {
  List<syntax_asdl::param*>* params = nullptr;
  syntax_asdl::Token* splat = nullptr;
  List<pnode::PNode*>* children = nullptr;
  int n;
  pnode::PNode* p = nullptr;
  StackRoots _roots({&p_node, &params, &splat, &children, &p});

  params = Alloc<List<syntax_asdl::param*>>();
  splat = nullptr;
  children = p_node->children;
  n = len(children);
  for (int i = 0; i < n; ++i) {
    p = children->index_(i);
    if (ISNONTERMINAL(p->typ)) {
      params->append(this->_FuncParam(p));
    }
    else {
      if (p->tok->id == Id::Expr_Ellipsis) {
        splat = children->index_((i + 1))->tok;
      }
    }
  }
  return (Tuple2<List<syntax_asdl::param*>*, syntax_asdl::Token*>(params, splat));
}

syntax_asdl::proc_sig_t* Transformer::Proc(pnode::PNode* pnode) {
  int typ;
  List<pnode::PNode*>* children = nullptr;
  int n;
  syntax_asdl::proc_sig_t* sig = nullptr;
  StackRoots _roots({&pnode, &children, &sig});

  typ = pnode->typ;
  children = pnode->children;
  n = len(children);
  if (n == 1) {
    sig = Alloc<proc_sig::Open>();
  }
  else {
    if (n == 3) {
      sig = Alloc<proc_sig::Closed>();
    }
    else {
      if (n == 4) {
        sig = this->_ProcParams(children->index_(1));
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  return sig;
}

syntax_asdl::command_t* Transformer::func_item(pnode::PNode* node) {
  StackRoots _roots({&node});

  if (node->tok->id == Id::Expr_While) {
    return Alloc<command::While>(this->Expr(node->children->index_(1)), this->_Suite(node->children->index_(2)));
  }
  else {
    if (node->tok->id == Id::Expr_For) {
      return Alloc<command::For>(this->_NameTypeList(node->children->index_(1)), this->Expr(node->children->index_(3)), this->_Suite(node->children->index_(4)));
    }
    else {
      if (node->tok->id == Id::Expr_Break) {
        return Alloc<command::Break>();
      }
      else {
        if (node->tok->id == Id::Expr_Continue) {
          return Alloc<command::Continue>();
        }
        else {
          if (node->tok->id == Id::Expr_Return) {
            if (len(node->children) == 1) {
              return Alloc<command::Return>();
            }
            else {
              return Alloc<command::Return>(this->Expr(node->children->index_(1)));
            }
          }
          else {
            if (node->tok->id == Id::Expr_Name) {
              return Alloc<command::NoOp>();
            }
            else {
              throw Alloc<NotImplementedError>(Id_str(node->tok->id));
            }
          }
        }
      }
    }
  }
}

List<syntax_asdl::command_t*>* Transformer::func_items(pnode::PNode* pnode) {
  List<syntax_asdl::command_t*>* result = nullptr;
  int n;
  StackRoots _roots({&pnode, &result});

  result = Alloc<List<syntax_asdl::command_t*>>();
  n = len(pnode->children);
  for (int i = 0; i < n; i += 2) {
    result->append(this->func_item(pnode->children->index_(i)));
  }
  return result;
}

syntax_asdl::command__CommandList* Transformer::_Suite(pnode::PNode* pnode) {
  int n;
  int items_index;
  StackRoots _roots({&pnode});

  n = len(pnode->children);
  if (n == 2) {
    return Alloc<command::CommandList>(Alloc<List<syntax_asdl::command_t*>>());
  }
  if (n == 3) {
    if (pnode->children->index_(1)->typ == grammar_nt::func_items) {
      items_index = 1;
    }
    else {
      return Alloc<command::CommandList>(Alloc<List<syntax_asdl::command_t*>>());
    }
  }
  if (n == 4) {
    items_index = 2;
  }
  return Alloc<command::CommandList>(this->func_items(pnode->children->index_(items_index)));
}

void Transformer::TeaFunc(pnode::PNode* pnode, syntax_asdl::command__Func* out) {
  List<pnode::PNode*>* children = nullptr;
  int pos;
  int typ2;
  int id_;
  StackRoots _roots({&pnode, &out, &children});

  children = pnode->children;
  pos = 1;
  typ2 = children->index_(pos)->typ;
  if (ISNONTERMINAL(typ2)) {
    Tuple2<List<syntax_asdl::param*>*, syntax_asdl::Token*> tup3 = this->_FuncParams(children->index_(pos));
    out->pos_params = tup3.at0();
    out->pos_splat = tup3.at1();
    pos += 1;
  }
  id_ = children->index_(pos)->tok->id;
  if (id_ == Id::Op_RParen) {
    pos += 1;
  }
  else {
    if (id_ == Id::Op_Semi) {
      Tuple2<List<syntax_asdl::param*>*, syntax_asdl::Token*> tup4 = this->_FuncParams(children->index_((pos + 1)));
      out->named_params = tup4.at0();
      out->named_splat = tup4.at1();
      pos += 3;
    }
  }
  if (children->index_(pos)->typ == grammar_nt::type_expr_list) {
    out->return_types = this->_TypeExprList(children->index_(pos));
    pos += 1;
  }
  out->body = this->_Suite(children->index_(pos));
}

void Transformer::NamedFunc(pnode::PNode* pnode, syntax_asdl::command__Func* out) {
  List<pnode::PNode*>* children = nullptr;
  StackRoots _roots({&pnode, &out, &children});

  children = pnode->children;
  out->name = children->index_(0)->tok;
  this->TeaFunc(children->index_(1), out);
}

List<syntax_asdl::param*>* Transformer::_DataParams(pnode::PNode* p_node) {
  List<syntax_asdl::param*>* params = nullptr;
  List<pnode::PNode*>* children = nullptr;
  int n;
  StackRoots _roots({&p_node, &params, &children});

  params = Alloc<List<syntax_asdl::param*>>();
  children = p_node->children;
  n = len(children);
  for (int i = 0; i < n; i += 2) {
    params->append(this->_FuncParam(children->index_(i)));
  }
  return params;
}

void Transformer::Data(pnode::PNode* pnode, syntax_asdl::command__Data* out) {
  List<pnode::PNode*>* children = nullptr;
  StackRoots _roots({&pnode, &out, &children});

  children = pnode->children;
  out->name = children->index_(0)->tok;
  if (ISNONTERMINAL(children->index_(2)->typ)) {
    out->params = this->_DataParams(children->index_(2));
  }
}

syntax_asdl::variant_type_t* Transformer::_VariantType(pnode::PNode* pnode) {
  int n;
  StackRoots _roots({&pnode});

  n = len(pnode->children);
  if (n == 1) {
    return Alloc<variant_type::Ref>(pnode->children->index_(0)->tok);
  }
  else {
    return Alloc<variant_type::Anon>(this->_DataParams(pnode->children->index_(1)));
  }
}

syntax_asdl::variant* Transformer::_Variant(pnode::PNode* pnode) {
  syntax_asdl::variant_type_t* t = nullptr;
  StackRoots _roots({&pnode, &t});

  t = nullptr;
  if (len(pnode->children) == 2) {
    t = this->_VariantType(pnode->children->index_(1));
  }
  return Alloc<variant>(pnode->children->index_(0)->tok, t);
}

void Transformer::Enum(pnode::PNode* pnode, syntax_asdl::command__Enum* out) {
  List<pnode::PNode*>* children = nullptr;
  int start;
  int n;
  pnode::PNode* p_node = nullptr;
  StackRoots _roots({&pnode, &out, &children, &p_node});

  children = pnode->children;
  out->name = children->index_(0)->tok;
  start = 2;
  if (children->index_(start)->tok->id == Id::Op_Newline) {
    start = 3;
  }
  n = len(children);
  for (int i = start; i < (n - 1); i += 2) {
    p_node = children->index_(i);
    out->variants->append(this->_Variant(p_node));
  }
}

void Transformer::Class(pnode::PNode* pnode, syntax_asdl::command__Class* out) {
  List<pnode::PNode*>* children = nullptr;
  StackRoots _roots({&pnode, &out, &children});

  children = pnode->children;
  out->name = children->index_(0)->tok;
  return ;
}

void Transformer::Import(pnode::PNode* pnode, syntax_asdl::command__Import* out) {
  List<pnode::PNode*>* children = nullptr;
  int typ;
  StackRoots _roots({&pnode, &out, &children});

  children = pnode->children;
  typ = children->index_(0)->typ;
  if (ISNONTERMINAL(typ)) {
    if (typ == grammar_nt::sq_string) {
      single_quoted* sq_part = reinterpret_cast<single_quoted*>(children->index_(0)->children->index_(1)->tok);
      out->path = sq_part;
    }
  }
}

syntax_asdl::Token* Transformer::_RangeChar(pnode::PNode* p_node) {
  List<pnode::PNode*>* children = nullptr;
  int typ;
  List<syntax_asdl::Token*>* tokens = nullptr;
  syntax_asdl::Token* tok = nullptr;
  StackRoots _roots({&p_node, &children, &tokens, &tok});

  children = p_node->children;
  typ = children->index_(0)->typ;
  if (ISNONTERMINAL(typ)) {
    if (typ == grammar_nt::sq_string) {
      single_quoted* sq_part = reinterpret_cast<single_quoted*>(children->index_(0)->children->index_(1)->tok);
      tokens = sq_part->tokens;
      if (len(tokens) > 1) {
        p_die(dynamic_fmt_dummy(), sq_part);
      }
      if (len(tokens->index_(0)->val) > 1) {
        p_die(dynamic_fmt_dummy(), sq_part);
      }
      return tokens->index_(0);
    }
    if (typ == grammar_nt::char_literal) {
      tok = children->index_(0)->children->index_(0)->tok;
      return tok;
    }
    throw Alloc<NotImplementedError>();
  }
  else {
    tok = p_node->tok;
    if ((tok->id == Id::Expr_Name || tok->id == Id::Expr_DecInt)) {
      if (len(tok->val) != 1) {
        p_die(dynamic_fmt_dummy(), tok);
      }
      return tok;
    }
    throw Alloc<NotImplementedError>();
  }
}

syntax_asdl::class_literal_term_t* Transformer::_NonRangeChars(pnode::PNode* p_node) {
  List<pnode::PNode*>* children = nullptr;
  int typ;
  pnode::PNode* p_child = nullptr;
  StackRoots _roots({&p_node, &children, &p_child});

  children = p_node->children;
  typ = children->index_(0)->typ;
  if (ISNONTERMINAL(typ)) {
    p_child = children->index_(0);
    if (typ == grammar_nt::braced_var_sub) {
      return reinterpret_cast<braced_var_sub*>(p_child->children->index_(1)->tok);
    }
    if (typ == grammar_nt::dq_string) {
      return reinterpret_cast<double_quoted*>(p_child->children->index_(1)->tok);
    }
    if (typ == grammar_nt::sq_string) {
      return reinterpret_cast<single_quoted*>(p_child->children->index_(1)->tok);
    }
    if (typ == grammar_nt::simple_var_sub) {
      return Alloc<simple_var_sub>(children->index_(0)->tok);
    }
    if (typ == grammar_nt::char_literal) {
      return Alloc<class_literal_term::CharLiteral>(children->index_(0)->tok);
    }
    throw Alloc<NotImplementedError>();
  }
  else {
    return this->_NameInClass(nullptr, children->index_(0)->tok);
  }
}

syntax_asdl::class_literal_term_t* Transformer::_ClassLiteralTerm(pnode::PNode* p_node) {
  List<pnode::PNode*>* children = nullptr;
  int typ;
  pnode::PNode* p_child = nullptr;
  int n;
  syntax_asdl::Token* start = nullptr;
  syntax_asdl::Token* end = nullptr;
  Str* nt_name = nullptr;
  StackRoots _roots({&p_node, &children, &p_child, &start, &end, &nt_name});

  children = p_node->children;
  typ = children->index_(0)->typ;
  if (ISNONTERMINAL(typ)) {
    p_child = children->index_(0);
    if (typ == grammar_nt::simple_var_sub) {
      return Alloc<simple_var_sub>(p_child->children->index_(0)->tok);
    }
    if (typ == grammar_nt::braced_var_sub) {
      return reinterpret_cast<braced_var_sub*>(p_child->children->index_(1)->tok);
    }
    if (typ == grammar_nt::dq_string) {
      return reinterpret_cast<double_quoted*>(p_child->children->index_(1)->tok);
    }
    n = len(children);
    if ((n == 1 and typ == grammar_nt::range_char)) {
      return this->_NonRangeChars(children->index_(0));
    }
    if ((n == 3 and children->index_(1)->tok->id == Id::Arith_Minus)) {
      start = this->_RangeChar(children->index_(0));
      end = this->_RangeChar(children->index_(2));
      return Alloc<class_literal_term::Range>(start, end);
    }
  }
  else {
    if (children->index_(0)->tok->id == Id::Expr_Bang) {
      return this->_NameInClass(children->index_(0)->tok, children->index_(1)->tok);
    }
    assert(0);  // AssertionError
  }
  nt_name = this->number2symbol->index_(typ);
  throw Alloc<NotImplementedError>(nt_name);
}

List<syntax_asdl::class_literal_term_t*>* Transformer::_ClassLiteral(pnode::PNode* p_node) {
  List<syntax_asdl::class_literal_term_t*>* terms = nullptr;
  StackRoots _roots({&p_node, &terms});

  terms = Alloc<List<syntax_asdl::class_literal_term_t*>>();
  for (ListIter<pnode::PNode*> it(p_node->children->slice(1, -1)); !it.Done(); it.Next()) {
    pnode::PNode* c = it.Value();
    terms->append(this->_ClassLiteralTerm(c));
  }
  return terms;
}

syntax_asdl::re_t* Transformer::_NameInRegex(syntax_asdl::Token* negated_tok, syntax_asdl::Token* tok) {
  syntax_asdl::speck* negated_speck = nullptr;
  Str* val = nullptr;
  Str* perl = nullptr;
  StackRoots _roots({&negated_tok, &tok, &negated_speck, &val, &perl});

  if (negated_tok) {
    negated_speck = Alloc<speck>(negated_tok->id, negated_tok->span_id);
  }
  else {
    negated_speck = nullptr;
  }
  val = tok->val;
  if (maybe_str_equals(val, str441)) {
    if (negated_tok) {
      p_die(fmt112(), tok);
    }
    return tok;
  }
  if (list_contains(POSIX_CLASSES, val)) {
    return Alloc<posix_class>(negated_speck, val);
  }
  perl = PERL_CLASSES->get(val);
  if (perl != nullptr) {
    return Alloc<perl_class>(negated_speck, perl);
  }
  if (val->index_(0)->isupper()) {
    return Alloc<re::Splice>(tok);
  }
  p_die(fmt113(val), tok);
}

syntax_asdl::class_literal_term_t* Transformer::_NameInClass(syntax_asdl::Token* negated_tok, syntax_asdl::Token* tok) {
  syntax_asdl::speck* negated_speck = nullptr;
  Str* val = nullptr;
  Str* perl = nullptr;
  StackRoots _roots({&negated_tok, &tok, &negated_speck, &val, &perl});

  if (negated_tok) {
    negated_speck = Alloc<speck>(negated_tok->id, negated_tok->span_id);
  }
  else {
    negated_speck = nullptr;
  }
  val = tok->val;
  if (len(val) == 1) {
    if (negated_tok) {
      p_die(fmt114(), tok);
    }
    return Alloc<class_literal_term::CharLiteral>(tok);
  }
  if (list_contains(POSIX_CLASSES, val)) {
    return Alloc<posix_class>(negated_speck, val);
  }
  perl = PERL_CLASSES->get(val);
  if (perl != nullptr) {
    return Alloc<perl_class>(negated_speck, perl);
  }
  p_die(fmt115(val), tok);
}

syntax_asdl::re_t* Transformer::_ReAtom(pnode::PNode* p_atom) {
  List<pnode::PNode*>* children = nullptr;
  int typ;
  pnode::PNode* p_child = nullptr;
  syntax_asdl::Token* tok = nullptr;
  int n;
  syntax_asdl::re_t* regex = nullptr;
  syntax_asdl::Token* name_tok = nullptr;
  StackRoots _roots({&p_atom, &children, &p_child, &tok, &regex, &name_tok});

  children = p_atom->children;
  typ = children->index_(0)->typ;
  if (ISNONTERMINAL(typ)) {
    p_child = p_atom->children->index_(0);
    if (typ == grammar_nt::class_literal) {
      return Alloc<re::CharClassLiteral>(false, this->_ClassLiteral(p_child));
    }
    if (typ == grammar_nt::braced_var_sub) {
      return reinterpret_cast<braced_var_sub*>(p_child->children->index_(1)->tok);
    }
    if (typ == grammar_nt::dq_string) {
      return reinterpret_cast<double_quoted*>(p_child->children->index_(1)->tok);
    }
    if (typ == grammar_nt::sq_string) {
      return reinterpret_cast<single_quoted*>(p_child->children->index_(1)->tok);
    }
    if (typ == grammar_nt::simple_var_sub) {
      return Alloc<simple_var_sub>(children->index_(0)->tok);
    }
    if (typ == grammar_nt::char_literal) {
      return children->index_(0)->tok;
    }
    throw Alloc<NotImplementedError>(typ);
  }
  else {
    tok = children->index_(0)->tok;
    if ((tok->id == Id::Expr_Dot || tok->id == Id::Arith_Caret || tok->id == Id::Expr_Dollar)) {
      return Alloc<speck>(tok->id, tok->span_id);
    }
    if (tok->id == Id::Expr_Name) {
      return this->_NameInRegex(nullptr, tok);
    }
    if (tok->id == Id::Expr_Symbol) {
      if ((str_equals(tok->val, str446) || str_equals(tok->val, str447) || str_equals(tok->val, str448))) {
        return tok;
      }
      p_die(fmt116(tok->val), tok);
    }
    if (tok->id == Id::Expr_At) {
      return Alloc<re::Splice>(children->index_(1)->tok);
    }
    if (tok->id == Id::Expr_Bang) {
      n = len(children);
      if (n == 2) {
        typ = children->index_(1)->typ;
        if (ISNONTERMINAL(typ)) {
          return Alloc<re::CharClassLiteral>(true, this->_ClassLiteral(children->index_(1)));
        }
        else {
          return this->_NameInRegex(tok, children->index_(1)->tok);
        }
      }
      else {
        p_die(fmt117(), children->index_(1)->tok);
      }
    }
    if (tok->id == Id::Op_LParen) {
      return Alloc<re::Group>(this->_Regex(children->index_(1)));
    }
    if (tok->id == Id::Arith_Less) {
      regex = this->_Regex(children->index_(1));
      n = len(children);
      if (n == 5) {
        name_tok = children->index_(3)->children->index_(0)->tok;
      }
      else {
        name_tok = nullptr;
      }
      return Alloc<re::Capture>(regex, name_tok);
    }
    if (tok->id == Id::Arith_Colon) {
      throw Alloc<NotImplementedError>(Id_str(tok->id));
    }
    throw Alloc<NotImplementedError>(Id_str(tok->id));
  }
}

syntax_asdl::re_repeat_t* Transformer::_RepeatOp(pnode::PNode* p_repeat) {
  syntax_asdl::Token* tok = nullptr;
  int id_;
  pnode::PNode* p_range = nullptr;
  List<pnode::PNode*>* children = nullptr;
  int n;
  StackRoots _roots({&p_repeat, &tok, &p_range, &children});

  tok = p_repeat->children->index_(0)->tok;
  id_ = tok->id;
  if ((id_ == Id::Arith_Plus || id_ == Id::Arith_Star || id_ == Id::Arith_QMark)) {
    return Alloc<re_repeat::Op>(tok);
  }
  if (id_ == Id::Op_LBrace) {
    p_range = p_repeat->children->index_(1);
    children = p_range->children;
    n = len(children);
    if (n == 1) {
      return Alloc<re_repeat::Num>(children->index_(0)->tok);
    }
    if (n == 2) {
      if (children->index_(0)->tok->id == Id::Expr_DecInt) {
        return Alloc<re_repeat::Range>(children->index_(0)->tok, nullptr);
      }
      else {
        return Alloc<re_repeat::Range>(nullptr, children->index_(1)->tok);
      }
    }
    if (n == 3) {
      return Alloc<re_repeat::Range>(children->index_(0)->tok, children->index_(2)->tok);
    }
    assert(0);  // AssertionError
  }
  assert(0);  // AssertionError
}

syntax_asdl::re_t* Transformer::_Regex(pnode::PNode* p_node) {
  int typ;
  List<pnode::PNode*>* children = nullptr;
  List<syntax_asdl::re_t*>* alts = nullptr;
  int n;
  pnode::PNode* c = nullptr;
  int i;
  List<syntax_asdl::re_t*>* seq = nullptr;
  syntax_asdl::re_t* r = nullptr;
  syntax_asdl::re_repeat_t* repeat_op = nullptr;
  Str* nt_name = nullptr;
  StackRoots _roots({&p_node, &children, &alts, &c, &seq, &r, &repeat_op, &nt_name});

  typ = p_node->typ;
  children = p_node->children;
  if (typ == grammar_nt::regex) {
    if (len(children) == 1) {
      return this->_Regex(children->index_(0));
    }
    alts = Alloc<List<syntax_asdl::re_t*>>();
    n = len(p_node->children);
    for (int i = 0; i < n; i += 2) {
      c = p_node->children->index_(i);
      alts->append(this->_Regex(c));
    }
    return Alloc<re::Alt>(alts);
  }
  if (typ == grammar_nt::re_alt) {
    i = 0;
    n = len(children);
    seq = Alloc<List<syntax_asdl::re_t*>>();
    while (i < n) {
      r = this->_ReAtom(children->index_(i));
      i += 1;
      if ((i < n and children->index_(i)->typ == grammar_nt::repeat_op)) {
        repeat_op = this->_RepeatOp(children->index_(i));
        r = Alloc<re::Repeat>(r, repeat_op);
        i += 1;
      }
      seq->append(r);
    }
    if (len(seq) == 1) {
      return seq->index_(0);
    }
    else {
      return Alloc<re::Seq>(seq);
    }
  }
  nt_name = this->number2symbol->index_(typ);
  throw Alloc<NotImplementedError>(nt_name);
}

}  // define namespace expr_to_ast

namespace funcs {  // define

namespace value = runtime_asdl::value;
namespace value_e = runtime_asdl::value_e;
using runtime_asdl::value__Block;
namespace source = syntax_asdl::source;

ParseHay::ParseHay(process::FdState* fd_state, parse_lib::ParseContext* parse_ctx, ui::ErrorFormatter* errfmt) 
    : Obj(Tag::FixedSize, maskof_ParseHay(), sizeof(ParseHay))  {
  this->fd_state = fd_state;
  this->parse_ctx = parse_ctx;
  this->errfmt = errfmt;
}

runtime_asdl::value_t* ParseHay::Call(Str* path) {
  int call_spid;
  mylib::LineReader* f = nullptr;
  Str* msg = nullptr;
  alloc::Arena* arena = nullptr;
  reader::FileLineReader* line_reader = nullptr;
  optview::Parse* parse_opts = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  syntax_asdl::source__SourcedFile* src = nullptr;
  syntax_asdl::command_t* node = nullptr;
  StackRoots _roots({&path, &f, &msg, &arena, &line_reader, &parse_opts, &c_parser, &src, &node});

  call_spid = runtime::NO_SPID;
  try {
    f = this->fd_state->Open(path);
  }
  catch (IOError_OSError* e) {
    msg = posix::strerror(e->errno_);
    throw Alloc<error::Expr>(fmt118(path, msg), call_spid);
  }
  arena = this->parse_ctx->arena;
  line_reader = Alloc<reader::FileLineReader>(f, arena);
  parse_opts = state::MakeOilOpts();
  c_parser = this->parse_ctx->MakeConfigParser(line_reader);
  src = Alloc<source::SourcedFile>(path, call_spid);
  try {
    {  // with
      alloc::ctx_Location ctx(arena, src);

      node = main_loop::ParseWholeFile(c_parser);
    }
  }
  catch (error::Parse* e) {
    this->errfmt->PrettyPrintError(e);
    return nullptr;
  }
  return Alloc<value::Block>(node);
}

EvalHay::EvalHay(state::Hay* hay_state, state::MutableOpts* mutable_opts, state::Mem* mem, cmd_eval::CommandEvaluator* cmd_ev) 
    : Obj(Tag::FixedSize, maskof_EvalHay(), sizeof(EvalHay))  {
  this->hay_state = hay_state;
  this->mutable_opts = mutable_opts;
  this->mem = mem;
  this->cmd_ev = cmd_ev;
}

BlockAsStr::BlockAsStr(alloc::Arena* arena) 
    : Obj(Tag::FixedSize, maskof_BlockAsStr(), sizeof(BlockAsStr))  {
  this->arena = arena;
}

runtime_asdl::value_t* BlockAsStr::Call(runtime_asdl::value_t* block) {
  StackRoots _roots({&block});

  return block;
}

HayFunc::HayFunc(state::Hay* hay_state) 
    : Obj(Tag::FixedSize, maskof_HayFunc(), sizeof(HayFunc))  {
  this->hay_state = hay_state;
}

}  // define namespace funcs

namespace regex_translate {  // define

namespace char_class_term_e = syntax_asdl::char_class_term_e;
using syntax_asdl::char_class_term_t;
using syntax_asdl::char_class_term__Range;
using syntax_asdl::posix_class;
using syntax_asdl::perl_class;
using syntax_asdl::CharCode;
namespace re_e = syntax_asdl::re_e;
using syntax_asdl::re__CharClass;
using syntax_asdl::re__Primitive;
using syntax_asdl::re__LiteralChars;
using syntax_asdl::re__Seq;
using syntax_asdl::re__Alt;
using syntax_asdl::re__Repeat;
using syntax_asdl::re__Group;
namespace re_repeat_e = syntax_asdl::re_repeat_e;
using syntax_asdl::re_repeat__Op;
using syntax_asdl::re_repeat__Num;
using syntax_asdl::re_repeat__Range;
namespace Id = id_kind_asdl::Id;
Dict<Str*, Str*> gdict0(std::initializer_list<Str*>{}, std::initializer_list<Str*>{});
Dict<Str*, Str*>* PERL_CLASS = &gdict0;
int CH_RBRACKET = 93;
int CH_BACKSLASH = 92;
int CH_CARET = 94;
int CH_HYPHEN = 45;
int FLAG_RBRACKET = 1;
int FLAG_BACKSLASH = 2;
int FLAG_CARET = 4;
int FLAG_HYPHEN = 8;

void _CharCodeToEre(syntax_asdl::CharCode* term, List<Str*>* parts, List<int>* special_char_flags) {
  int char_int;
  int mask;
  StackRoots _roots({&term, &parts, &special_char_flags});

  char_int = term->i;
  if ((char_int >= 128 and term->u_braced)) {
    e_die(fmt119(char_int), term->spid);
  }
  mask = special_char_flags->index_(0);
  if (char_int == CH_HYPHEN) {
    mask |= FLAG_HYPHEN;
  }
  else {
    if (char_int == CH_CARET) {
      mask |= FLAG_CARET;
    }
    else {
      if (char_int == CH_RBRACKET) {
        mask |= FLAG_RBRACKET;
      }
      else {
        if (char_int == CH_BACKSLASH) {
          mask |= FLAG_BACKSLASH;
        }
        else {
          parts->append(chr(char_int));
        }
      }
    }
  }
  special_char_flags->set(0, mask);
}

void _CharClassTermToEre(syntax_asdl::char_class_term_t* term, List<Str*>* parts, List<int>* special_char_flags) {
  syntax_asdl::char_class_term_t* UP_term = nullptr;
  int tag;
  List<int>* range_no_special = nullptr;
  Str* n = nullptr;
  Str* chars = nullptr;
  Str* pat = nullptr;
  StackRoots _roots({&term, &parts, &special_char_flags, &UP_term, &range_no_special, &n, &chars, &pat});

  UP_term = term;
  tag = term->tag_();
  switch (term->tag_()) {
    case char_class_term_e::Range: {
      char_class_term__Range* term = static_cast<char_class_term__Range*>(UP_term);
      range_no_special = NewList<int>(std::initializer_list<int>{0});
      _CharCodeToEre(term->start, parts, range_no_special);
      if (range_no_special->index_(0) != 0) {
        e_die(fmt120(term->start->i), term->start->spid);
      }
      parts->append(str454);
      _CharCodeToEre(term->end, parts, range_no_special);
      if (range_no_special->index_(0) != 0) {
        e_die(fmt121(term->end->i), term->end->spid);
      }
    }
      break;
    case char_class_term_e::CharCode: {
      CharCode* term = static_cast<CharCode*>(UP_term);
      _CharCodeToEre(term, parts, special_char_flags);
    }
      break;
    case char_class_term_e::PerlClass: {
      perl_class* term = static_cast<perl_class*>(UP_term);
      n = term->name;
      chars = PERL_CLASS->index_(term->name);
      if (term->negated) {
        e_die(fmt122(), term->negated->span_id);
      }
      else {
        pat = fmt123(chars);
      }
      parts->append(pat);
    }
      break;
    case char_class_term_e::PosixClass: {
      posix_class* term = static_cast<posix_class*>(UP_term);
      n = term->name;
      if (term->negated) {
        e_die(fmt124(), term->negated->span_id);
      }
      else {
        pat = fmt125(n);
      }
      parts->append(pat);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

void AsPosixEre(syntax_asdl::re_t* node, List<Str*>* parts) {
  syntax_asdl::re_t* UP_node = nullptr;
  int tag;
  int i;
  syntax_asdl::re_repeat_t* op = nullptr;
  int op_tag;
  syntax_asdl::re_repeat_t* UP_op = nullptr;
  int op_id;
  Str* lower = nullptr;
  Str* upper = nullptr;
  Str* n = nullptr;
  Str* chars = nullptr;
  Str* pat = nullptr;
  List<int>* special_char_flags = nullptr;
  List<Str*>* non_special_parts = nullptr;
  StackRoots _roots({&node, &parts, &UP_node, &op, &UP_op, &lower, &upper, &n, &chars, &pat, &special_char_flags, &non_special_parts});

  UP_node = node;
  tag = node->tag_();
  if (tag == re_e::Primitive) {
    re__Primitive* node = static_cast<re__Primitive*>(UP_node);
    if (node->id == Id::Re_Dot) {
      parts->append(str460);
    }
    else {
      if (node->id == Id::Re_Start) {
        parts->append(str461);
      }
      else {
        if (node->id == Id::Re_End) {
          parts->append(str462);
        }
        else {
          assert(0);  // AssertionError
        }
      }
    }
    return ;
  }
  if (tag == re_e::LiteralChars) {
    re__LiteralChars* node = static_cast<re__LiteralChars*>(UP_node);
    parts->append(glob_::ExtendedRegexEscape(node->s));
    return ;
  }
  if (tag == re_e::Seq) {
    re__Seq* node = static_cast<re__Seq*>(UP_node);
    for (ListIter<syntax_asdl::re_t*> it(node->children); !it.Done(); it.Next()) {
      syntax_asdl::re_t* c = it.Value();
      StackRoots _for({&c    });
      AsPosixEre(c, parts);
    }
    return ;
  }
  if (tag == re_e::Alt) {
    re__Alt* node = static_cast<re__Alt*>(UP_node);
    i = 0;
    for (ListIter<syntax_asdl::re_t*> it(node->children); !it.Done(); it.Next(), ++i) {
      syntax_asdl::re_t* c = it.Value();
      StackRoots _for({&c    });
      if (i != 0) {
        parts->append(str463);
      }
      AsPosixEre(c, parts);
    }
    return ;
  }
  if (tag == re_e::Repeat) {
    re__Repeat* node = static_cast<re__Repeat*>(UP_node);
    if (node->child->tag_() == re_e::LiteralChars) {
      re__LiteralChars* child = static_cast<re__LiteralChars*>(node->child);
      if (len(child->s) > 1) {
        e_die(fmt126(), child->spid);
      }
    }
    AsPosixEre(node->child, parts);
    op = node->op;
    op_tag = op->tag_();
    UP_op = op;
    if (op_tag == re_repeat_e::Op) {
      re_repeat__Op* op = static_cast<re_repeat__Op*>(UP_op);
      op_id = op->op->id;
      if (op_id == Id::Arith_Plus) {
        parts->append(str465);
      }
      else {
        if (op_id == Id::Arith_Star) {
          parts->append(str466);
        }
        else {
          if (op_id == Id::Arith_QMark) {
            parts->append(str467);
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
      return ;
    }
    if (op_tag == re_repeat_e::Num) {
      re_repeat__Num* op = static_cast<re_repeat__Num*>(UP_op);
      parts->append(fmt127(op->times->val));
      return ;
    }
    if (op_tag == re_repeat_e::Range) {
      re_repeat__Range* op = static_cast<re_repeat__Range*>(UP_op);
      lower = op->lower ? op->lower->val : str469;
      upper = op->upper ? op->upper->val : str470;
      parts->append(fmt128(lower, upper));
      return ;
    }
    throw Alloc<NotImplementedError>(op_tag);
  }
  if ((tag == re_e::Group || tag == re_e::Capture)) {
    re__Group* node = static_cast<re__Group*>(UP_node);
    parts->append(str472);
    AsPosixEre(node->child, parts);
    parts->append(str473);
    return ;
  }
  if (tag == re_e::PerlClass) {
    perl_class* node = static_cast<perl_class*>(UP_node);
    n = node->name;
    chars = PERL_CLASS->index_(node->name);
    if (node->negated) {
      pat = fmt129(chars);
    }
    else {
      pat = fmt130(chars);
    }
    parts->append(pat);
    return ;
  }
  if (tag == re_e::PosixClass) {
    posix_class* node = static_cast<posix_class*>(UP_node);
    n = node->name;
    if (node->negated) {
      pat = fmt131(n);
    }
    else {
      pat = fmt132(n);
    }
    parts->append(pat);
    return ;
  }
  if (tag == re_e::CharClass) {
    re__CharClass* node = static_cast<re__CharClass*>(UP_node);
    special_char_flags = NewList<int>(std::initializer_list<int>{0});
    non_special_parts = Alloc<List<Str*>>();
    for (ListIter<syntax_asdl::char_class_term_t*> it(node->terms); !it.Done(); it.Next()) {
      syntax_asdl::char_class_term_t* term = it.Value();
      StackRoots _for({&term    });
      _CharClassTermToEre(term, non_special_parts, special_char_flags);
    }
    parts->append(str478);
    if (node->negated) {
      parts->append(str479);
    }
    if ((special_char_flags->index_(0) & FLAG_RBRACKET)) {
      parts->append(str480);
    }
    parts->extend(non_special_parts);
    if ((special_char_flags->index_(0) & FLAG_BACKSLASH)) {
      parts->append(str481);
    }
    if ((special_char_flags->index_(0) & FLAG_CARET)) {
      parts->append(str482);
    }
    if ((special_char_flags->index_(0) & FLAG_HYPHEN)) {
      parts->append(str483);
    }
    parts->append(str484);
    return ;
  }
  throw Alloc<NotImplementedError>(tag);
}

}  // define namespace regex_translate

namespace arith_parse {  // define

namespace Id = id_kind_asdl::Id;
namespace arith_expr = syntax_asdl::arith_expr;
using syntax_asdl::arith_expr_t;
using syntax_asdl::word_t;

syntax_asdl::arith_expr_t* NullIncDec(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp) {
  syntax_asdl::arith_expr_t* right = nullptr;
  StackRoots _roots({&p, &w, &right});

  right = p->ParseUntil(bp);
  tdop::CheckLhsExpr(right, p->parse_opts->parse_dynamic_arith(), w);
  return Alloc<arith_expr::UnaryAssign>(word_::ArithId(w), right);
}

syntax_asdl::arith_expr_t* NullUnaryPlus(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp) {
  syntax_asdl::arith_expr_t* right = nullptr;
  StackRoots _roots({&p, &t, &right});

  right = p->ParseUntil(bp);
  return Alloc<arith_expr::Unary>(Id::Node_UnaryPlus, right);
}

syntax_asdl::arith_expr_t* NullUnaryMinus(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp) {
  syntax_asdl::arith_expr_t* right = nullptr;
  StackRoots _roots({&p, &t, &right});

  right = p->ParseUntil(bp);
  return Alloc<arith_expr::Unary>(Id::Node_UnaryMinus, right);
}

syntax_asdl::arith_expr_t* LeftIncDec(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp) {
  int arith_id;
  int op_id;
  StackRoots _roots({&p, &w, &left});

  arith_id = word_::ArithId(w);
  if (arith_id == Id::Arith_DPlus) {
    op_id = Id::Node_PostDPlus;
  }
  else {
    if (arith_id == Id::Arith_DMinus) {
      op_id = Id::Node_PostDMinus;
    }
    else {
      assert(0);  // AssertionError
    }
  }
  tdop::CheckLhsExpr(left, p->parse_opts->parse_dynamic_arith(), w);
  return Alloc<arith_expr::UnaryAssign>(op_id, left);
}

syntax_asdl::arith_expr_t* LeftIndex(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int unused_bp) {
  syntax_asdl::arith_expr_t* index = nullptr;
  StackRoots _roots({&p, &w, &left, &index});

  if (!tdop::IsIndexable(left, p->parse_opts->parse_dynamic_arith())) {
    p_die(fmt133(), w);
  }
  index = p->ParseUntil(0);
  p->Eat(Id::Arith_RBracket);
  return Alloc<arith_expr::Binary>(word_::ArithId(w), left, index);
}

syntax_asdl::arith_expr_t* LeftTernary(tdop::TdopParser* p, syntax_asdl::word_t* t, syntax_asdl::arith_expr_t* left, int bp) {
  syntax_asdl::arith_expr_t* true_expr = nullptr;
  syntax_asdl::arith_expr_t* false_expr = nullptr;
  StackRoots _roots({&p, &t, &left, &true_expr, &false_expr});

  true_expr = p->ParseUntil(0);
  p->Eat(Id::Arith_Colon);
  false_expr = p->ParseUntil(bp);
  return Alloc<arith_expr::TernaryOp>(left, true_expr, false_expr);
}

}  // define namespace arith_parse

namespace bool_parse {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Kind;
using types_asdl::lex_mode_t;
using types_asdl::lex_mode_e;
using syntax_asdl::word_t;
namespace word_e = syntax_asdl::word_e;
namespace bool_expr = syntax_asdl::bool_expr;
using syntax_asdl::bool_expr_t;

BoolParser::BoolParser(word_parse::WordEmitter* w_parser) 
    : Obj(Tag::FixedSize, maskof_BoolParser(), sizeof(BoolParser))  {
  this->w_parser = w_parser;
  this->words = Alloc<List<syntax_asdl::word_t*>>();
  this->cur_word = nullptr;
  this->bool_id = Id::Undefined_Tok;
  this->bool_kind = Kind::Undefined;
}

void BoolParser::_NextOne(types_asdl::lex_mode_t lex_mode) {
  int n;
  syntax_asdl::word_t* w = nullptr;
  StackRoots _roots({&w});

  n = len(this->words);
  if (n == 2) {
    this->words->set(0, this->words->index_(1));
    this->cur_word = this->words->index_(0);
    this->words->pop();
  }
  else {
    if ((n == 0 || n == 1)) {
      w = this->w_parser->ReadWord(lex_mode);
      if (n == 0) {
        this->words->append(w);
      }
      else {
        this->words->set(0, w);
      }
      this->cur_word = w;
    }
  }
  this->bool_id = word_::BoolId(this->cur_word);
  this->bool_kind = consts::GetKind(this->bool_id);
}

void BoolParser::_Next() {
  _Next(lex_mode_e::DBracket);
}

void BoolParser::_Next(types_asdl::lex_mode_t lex_mode) {
  while (true) {
    this->_NextOne(lex_mode);
    if (this->bool_id != Id::Op_Newline) {
      break;
    }
  }
}

syntax_asdl::word_t* BoolParser::_LookAhead() {
  int n;
  syntax_asdl::word_t* w = nullptr;
  StackRoots _roots({&w});

  n = len(this->words);
  if (n != 1) {
    assert(0);  // AssertionError
  }
  w = this->w_parser->ReadWord(lex_mode_e::DBracket);
  this->words->append(w);
  return w;
}

syntax_asdl::bool_expr_t* BoolParser::Parse() {
  syntax_asdl::bool_expr_t* node = nullptr;
  StackRoots _roots({&node});

  this->_Next();
  node = this->ParseExpr();
  if (this->bool_id != Id::Lit_DRightBracket) {
    p_die(fmt134(), this->cur_word);
  }
  return node;
}

bool BoolParser::_TestAtEnd() {
  return this->bool_id == Id::Lit_DRightBracket;
}

syntax_asdl::bool_expr_t* BoolParser::ParseForBuiltin() {
  syntax_asdl::bool_expr_t* node = nullptr;
  StackRoots _roots({&node});

  this->_Next();
  node = this->ParseExpr();
  if (this->bool_id != Id::Eof_Real) {
    p_die(fmt135(word_::Pretty(this->cur_word)), this->cur_word);
  }
  return node;
}

syntax_asdl::bool_expr_t* BoolParser::ParseExpr() {
  syntax_asdl::bool_expr_t* left = nullptr;
  syntax_asdl::bool_expr_t* right = nullptr;
  StackRoots _roots({&left, &right});

  left = this->ParseTerm();
  if ((this->bool_id == Id::Op_DPipe || this->bool_id == Id::BoolUnary_o)) {
    this->_Next();
    right = this->ParseExpr();
    return Alloc<bool_expr::LogicalOr>(left, right);
  }
  else {
    return left;
  }
}

syntax_asdl::bool_expr_t* BoolParser::ParseTerm() {
  syntax_asdl::bool_expr_t* left = nullptr;
  syntax_asdl::bool_expr_t* right = nullptr;
  StackRoots _roots({&left, &right});

  left = this->ParseNegatedFactor();
  if ((this->bool_id == Id::Op_DAmp || this->bool_id == Id::BoolUnary_a)) {
    this->_Next();
    right = this->ParseTerm();
    return Alloc<bool_expr::LogicalAnd>(left, right);
  }
  else {
    return left;
  }
}

syntax_asdl::bool_expr_t* BoolParser::ParseNegatedFactor() {
  syntax_asdl::bool_expr_t* child = nullptr;
  StackRoots _roots({&child});

  if (this->bool_id == Id::KW_Bang) {
    this->_Next();
    child = this->ParseFactor();
    return Alloc<bool_expr::LogicalNot>(child);
  }
  else {
    return this->ParseFactor();
  }
}

syntax_asdl::bool_expr_t* BoolParser::ParseFactor() {
  int op;
  syntax_asdl::word_t* w = nullptr;
  int tag;
  syntax_asdl::compound_word* tilde = nullptr;
  syntax_asdl::bool_expr_t* node = nullptr;
  syntax_asdl::word_t* t2 = nullptr;
  int t2_bool_id;
  id_kind_asdl::Kind_t t2_bool_kind;
  syntax_asdl::word_t* left = nullptr;
  bool is_regex;
  syntax_asdl::word_t* right = nullptr;
  StackRoots _roots({&w, &tilde, &node, &t2, &left, &right});

  if (this->bool_kind == Kind::BoolUnary) {
    op = this->bool_id;
    this->_Next();
    w = this->cur_word;
    tag = w->tag_();
    if ((tag != word_e::Compound and tag != word_e::String)) {
      p_die(fmt136(), w);
    }
    this->_Next();
    tilde = word_::TildeDetect(w);
    if (tilde) {
      w = tilde;
    }
    node = Alloc<bool_expr::Unary>(op, w);
    return node;
  }
  if (this->bool_kind == Kind::Word) {
    t2 = this->_LookAhead();
    t2_bool_id = word_::BoolId(t2);
    t2_bool_kind = consts::GetKind(t2_bool_id);
    if ((t2_bool_kind == Kind::BoolBinary or (t2_bool_id == Id::Op_Less || t2_bool_id == Id::Op_Great))) {
      left = this->cur_word;
      this->_Next();
      op = this->bool_id;
      is_regex = t2_bool_id == Id::BoolBinary_EqualTilde;
      if (is_regex) {
        this->_Next(lex_mode_e::BashRegex);
      }
      else {
        this->_Next();
      }
      right = this->cur_word;
      if (is_regex) {
        ;  // pass
      }
      this->_Next();
      tilde = word_::TildeDetect(left);
      if (tilde) {
        left = tilde;
      }
      tilde = word_::TildeDetect(right);
      if (tilde) {
        right = tilde;
      }
      return Alloc<bool_expr::Binary>(op, left, right);
    }
    else {
      w = this->cur_word;
      tilde = word_::TildeDetect(w);
      if (tilde) {
        w = tilde;
      }
      this->_Next();
      return Alloc<bool_expr::WordTest>(w);
    }
  }
  if (this->bool_id == Id::Op_LParen) {
    this->_Next();
    node = this->ParseExpr();
    if (this->bool_id != Id::Op_RParen) {
      p_die(fmt137(word_::Pretty(this->cur_word)), this->cur_word);
    }
    this->_Next();
    return node;
  }
  p_die(fmt138(ui::PrettyId(this->bool_id)), this->cur_word);
}

}  // define namespace bool_parse

namespace braces {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using syntax_asdl::Token;
using syntax_asdl::compound_word;
namespace word = syntax_asdl::word;
namespace word_e = syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::word__BracedTree;
namespace word_part = syntax_asdl::word_part;
namespace word_part_e = syntax_asdl::word_part_e;
using syntax_asdl::word_part_t;
using syntax_asdl::word_part__BracedTuple;
using syntax_asdl::word_part__BracedRange;
int NO_STEP = 0;

_NotARange::_NotARange(Str* s) 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(_NotARange))  {
  ;  // pass
}

_RangeParser::_RangeParser(match::SimpleLexer* lexer, int span_id) 
    : Obj(Tag::FixedSize, maskof__RangeParser(), sizeof(_RangeParser))  {
  this->lexer = lexer;
  this->span_id = span_id;
  this->token_type = Id::Undefined_Tok;
  this->token_val = str491;
}

void _RangeParser::_Next() {
  Tuple2<int, Str*> tup0 = this->lexer->Next();
  this->token_type = tup0.at0();
  this->token_val = tup0.at1();
}

Str* _RangeParser::_Eat(int token_type) {
  Str* val = nullptr;
  StackRoots _roots({&val});

  if (this->token_type != token_type) {
    throw Alloc<_NotARange>(fmt139(token_type, this->token_type));
  }
  val = this->token_val;
  this->_Next();
  return val;
}

int _RangeParser::_ParseStep() {
  int step;
  this->_Next();
  step = to_int(this->_Eat(Id::Range_Int));
  if (step == 0) {
    p_die(fmt140(), this->span_id);
  }
  return step;
}

syntax_asdl::word_part__BracedRange* _RangeParser::_ParseRange(int range_kind) {
  Str* start = nullptr;
  Str* end = nullptr;
  int step;
  syntax_asdl::word_part__BracedRange* part = nullptr;
  StackRoots _roots({&start, &end, &part});

  start = this->token_val;
  this->_Next();
  this->_Eat(Id::Range_Dots);
  end = this->_Eat(range_kind);
  if (this->token_type == Id::Range_Dots) {
    step = this->_ParseStep();
  }
  else {
    step = NO_STEP;
  }
  part = Alloc<word_part::BracedRange>(range_kind, start, end, step);
  return part;
}

syntax_asdl::word_part__BracedRange* _RangeParser::Parse() {
  syntax_asdl::word_part__BracedRange* part = nullptr;
  int start;
  int end;
  int start_num;
  int end_num;
  bool upper1;
  bool upper2;
  StackRoots _roots({&part});

  this->_Next();
  if (this->token_type == Id::Range_Int) {
    part = this->_ParseRange(this->token_type);
    start = to_int(part->start);
    end = to_int(part->end);
    if (start < end) {
      if (part->step == NO_STEP) {
        part->step = 1;
      }
      if (part->step <= 0) {
        p_die(fmt141(part->step), this->span_id);
      }
    }
    else {
      if (start > end) {
        if (part->step == NO_STEP) {
          part->step = -1;
        }
        if (part->step >= 0) {
          p_die(fmt142(part->step), this->span_id);
        }
      }
      else {
        part->step = 1;
      }
    }
  }
  else {
    if (this->token_type == Id::Range_Char) {
      part = this->_ParseRange(this->token_type);
      start_num = ord(part->start->index_(0));
      end_num = ord(part->end->index_(0));
      if (start_num < end_num) {
        if (part->step == NO_STEP) {
          part->step = 1;
        }
        if (part->step <= 0) {
          p_die(fmt143(part->step), this->span_id);
        }
      }
      else {
        if (start_num > end_num) {
          if (part->step == NO_STEP) {
            part->step = -1;
          }
          if (part->step >= 0) {
            p_die(fmt144(part->step), this->span_id);
          }
        }
        else {
          part->step = 1;
        }
      }
      upper1 = part->start->isupper();
      upper2 = part->end->isupper();
      if (upper1 != upper2) {
        p_die(fmt145(), this->span_id);
      }
    }
    else {
      throw Alloc<_NotARange>(str499);
    }
  }
  this->_Eat(Id::Eol_Tok);
  return part;
}

syntax_asdl::word_part_t* _RangePartDetect(syntax_asdl::Token* tok) {
  match::SimpleLexer* lexer = nullptr;
  braces::_RangeParser* p = nullptr;
  syntax_asdl::word_part__BracedRange* part = nullptr;
  StackRoots _roots({&tok, &lexer, &p, &part});

  lexer = match::BraceRangeLexer(tok->val);
  p = Alloc<_RangeParser>(lexer, tok->span_id);
  try {
    part = p->Parse();
  }
  catch (_NotARange* e) {
    return nullptr;
  }
  part->spids->append(tok->span_id);
  return part;
}

_StackFrame::_StackFrame(List<syntax_asdl::word_part_t*>* cur_parts) 
    : Obj(Tag::FixedSize, maskof__StackFrame(), sizeof(_StackFrame))  {
  this->cur_parts = cur_parts;
  this->alt_part = Alloc<word_part::BracedTuple>();
  this->saw_comma = false;
}

syntax_asdl::word__BracedTree* _BraceDetect(syntax_asdl::compound_word* w) {
  List<syntax_asdl::word_part_t*>* cur_parts = nullptr;
  List<braces::_StackFrame*>* stack = nullptr;
  bool found;
  int i;
  bool append;
  syntax_asdl::word_part_t* UP_part = nullptr;
  int id_;
  braces::_StackFrame* new_frame = nullptr;
  syntax_asdl::word_part_t* range_part = nullptr;
  syntax_asdl::word_part_t* part2 = nullptr;
  braces::_StackFrame* frame = nullptr;
  StackRoots _roots({&w, &cur_parts, &stack, &UP_part, &new_frame, &range_part, &part2, &frame});

  cur_parts = Alloc<List<syntax_asdl::word_part_t*>>();
  stack = Alloc<List<braces::_StackFrame*>>();
  found = false;
  i = 0;
  for (ListIter<syntax_asdl::word_part_t*> it(w->parts); !it.Done(); it.Next(), ++i) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoots _for({&part  });
    append = true;
    UP_part = part;
    if (part->tag_() == word_part_e::Literal) {
      Token* part = static_cast<Token*>(UP_part);
      id_ = part->id;
      if (id_ == Id::Lit_LBrace) {
        new_frame = Alloc<_StackFrame>(cur_parts);
        stack->append(new_frame);
        cur_parts = Alloc<List<syntax_asdl::word_part_t*>>();
        append = false;
        found = true;
      }
      else {
        if (id_ == Id::Lit_Comma) {
          if (len(stack)) {
            stack->index_(-1)->saw_comma = true;
            stack->index_(-1)->alt_part->words->append(Alloc<compound_word>(cur_parts));
            cur_parts = Alloc<List<syntax_asdl::word_part_t*>>();
            append = false;
          }
        }
        else {
          if (id_ == Id::Lit_RBrace) {
            if (len(stack) == 0) {
              return nullptr;
            }
            range_part = nullptr;
            if ((!stack->index_(-1)->saw_comma and len(cur_parts) == 1)) {
              part2 = cur_parts->index_(0);
              if (part2->tag_() == word_part_e::Literal) {
                Token* tok = static_cast<Token*>(part2);
                if (tok->id == Id::Lit_Chars) {
                  range_part = _RangePartDetect(tok);
                  if (range_part) {
                    frame = stack->pop();
                    cur_parts = frame->cur_parts;
                    cur_parts->append(range_part);
                    append = false;
                  }
                }
              }
            }
            if (!range_part) {
              if (!stack->index_(-1)->saw_comma) {
                return nullptr;
              }
              stack->index_(-1)->alt_part->words->append(Alloc<compound_word>(cur_parts));
              frame = stack->pop();
              cur_parts = frame->cur_parts;
              cur_parts->append(frame->alt_part);
              append = false;
            }
          }
        }
      }
    }
    if (append) {
      cur_parts->append(part);
    }
  }
  if (len(stack) != 0) {
    return nullptr;
  }
  if (found) {
    return Alloc<word::BracedTree>(cur_parts);
  }
  else {
    return nullptr;
  }
}

List<syntax_asdl::word_t*>* BraceDetectAll(List<syntax_asdl::compound_word*>* words) {
  List<syntax_asdl::word_t*>* out = nullptr;
  syntax_asdl::word__BracedTree* brace_tree = nullptr;
  StackRoots _roots({&words, &out, &brace_tree});

  out = Alloc<List<syntax_asdl::word_t*>>();
  for (ListIter<syntax_asdl::compound_word*> it(words); !it.Done(); it.Next()) {
    syntax_asdl::compound_word* w = it.Value();
    StackRoots _for({&w  });
    if (len(w->parts) >= 3) {
      brace_tree = _BraceDetect(w);
      if (brace_tree) {
        out->append(brace_tree);
        continue;
      }
    }
    out->append(w);
  }
  return out;
}

int _LeadingZeros(Str* s) {
  int n;
  StackRoots _roots({&s});

  n = 0;
  for (StrIter it(s); !it.Done(); it.Next()) {
    Str* c = it.Value();
    StackRoots _for({&c  });
    if (str_equals(c, str500)) {
      n += 1;
    }
    else {
      break;
    }
  }
  return n;
}

Str* _IntToString(int i, int width) {
  Str* s = nullptr;
  int n;
  Str* pad = nullptr;
  StackRoots _roots({&s, &pad});

  s = str(i);
  n = len(s);
  if (n < width) {
    pad = str_repeat(str501, (width - n));
    return str_concat(pad, s);
  }
  else {
    return s;
  }
}

List<Str*>* _RangeStrings(syntax_asdl::word_part__BracedRange* part) {
  List<Str*>* nums = nullptr;
  int z1;
  int z2;
  int width;
  int n;
  int end;
  int step;
  List<Str*>* chars = nullptr;
  int ord_end;
  StackRoots _roots({&part, &nums, &chars});

  if (part->kind == Id::Range_Int) {
    nums = Alloc<List<Str*>>();
    z1 = _LeadingZeros(part->start);
    z2 = _LeadingZeros(part->end);
    if ((z1 == 0 and z2 == 0)) {
      width = 0;
    }
    else {
      if (z1 < z2) {
        width = len(part->end);
      }
      else {
        width = len(part->start);
      }
    }
    n = to_int(part->start);
    end = to_int(part->end);
    step = part->step;
    if (step > 0) {
      while (true) {
        nums->append(_IntToString(n, width));
        n += step;
        if (n > end) {
          break;
        }
      }
    }
    else {
      while (true) {
        nums->append(_IntToString(n, width));
        n += step;
        if (n < end) {
          break;
        }
      }
    }
    return nums;
  }
  else {
    chars = Alloc<List<Str*>>();
    n = ord(part->start);
    ord_end = ord(part->end);
    step = part->step;
    if (step > 0) {
      while (true) {
        chars->append(chr(n));
        n += step;
        if (n > ord_end) {
          break;
        }
      }
    }
    else {
      while (true) {
        chars->append(chr(n));
        n += step;
        if (n < ord_end) {
          break;
        }
      }
    }
    return chars;
  }
}

List<List<syntax_asdl::word_part_t*>*>* _ExpandPart(List<syntax_asdl::word_part_t*>* parts, int first_alt_index, List<List<syntax_asdl::word_part_t*>*>* suffixes) {
  List<List<syntax_asdl::word_part_t*>*>* out = nullptr;
  List<syntax_asdl::word_part_t*>* prefix = nullptr;
  syntax_asdl::word_part_t* expand_part = nullptr;
  syntax_asdl::word_part_t* UP_part = nullptr;
  List<List<syntax_asdl::word_part_t*>*>* expanded_alts = nullptr;
  List<syntax_asdl::word_part_t*>* out_parts = nullptr;
  List<Str*>* strs = nullptr;
  List<syntax_asdl::word_part_t*>* out_parts_ = nullptr;
  syntax_asdl::Token* t = nullptr;
  StackRoots _roots({&parts, &suffixes, &out, &prefix, &expand_part, &UP_part, &expanded_alts, &out_parts, &strs, &out_parts_, &t});

  out = Alloc<List<List<syntax_asdl::word_part_t*>*>>();
  prefix = parts->slice(0, first_alt_index);
  expand_part = parts->index_(first_alt_index);
  UP_part = expand_part;
  switch (expand_part->tag_()) {
    case word_part_e::BracedTuple: {
      word_part__BracedTuple* expand_part = static_cast<word_part__BracedTuple*>(UP_part);
      expanded_alts = Alloc<List<List<syntax_asdl::word_part_t*>*>>();
      for (ListIter<syntax_asdl::compound_word*> it(expand_part->words); !it.Done(); it.Next()) {
        syntax_asdl::compound_word* w = it.Value();
        StackRoots _for({&w      });
        expanded_alts->extend(_BraceExpand(w->parts));
      }
      for (ListIter<List<syntax_asdl::word_part_t*>*> it(expanded_alts); !it.Done(); it.Next()) {
        List<syntax_asdl::word_part_t*>* alt_parts = it.Value();
        StackRoots _for({&alt_parts      });
        for (ListIter<List<syntax_asdl::word_part_t*>*> it(suffixes); !it.Done(); it.Next()) {
          List<syntax_asdl::word_part_t*>* suffix = it.Value();
          StackRoots _for({&suffix        });
          out_parts = Alloc<List<syntax_asdl::word_part_t*>>();
          out_parts->extend(prefix);
          out_parts->extend(alt_parts);
          out_parts->extend(suffix);
          out->append(out_parts);
        }
      }
    }
      break;
    case word_part_e::BracedRange: {
      word_part__BracedRange* expand_part = static_cast<word_part__BracedRange*>(UP_part);
      strs = _RangeStrings(expand_part);
      for (ListIter<Str*> it(strs); !it.Done(); it.Next()) {
        Str* s = it.Value();
        StackRoots _for({&s      });
        for (ListIter<List<syntax_asdl::word_part_t*>*> it(suffixes); !it.Done(); it.Next()) {
          List<syntax_asdl::word_part_t*>* suffix = it.Value();
          StackRoots _for({&suffix        });
          out_parts_ = Alloc<List<syntax_asdl::word_part_t*>>();
          out_parts_->extend(prefix);
          t = Alloc<Token>(Id::Lit_Chars, expand_part->spids->index_(0), s);
          out_parts_->append(t);
          out_parts_->extend(suffix);
          out->append(out_parts_);
        }
      }
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return out;
}

List<List<syntax_asdl::word_part_t*>*>* _BraceExpand(List<syntax_asdl::word_part_t*>* parts) {
  int num_alts;
  int first_alt_index;
  int i;
  int tag;
  List<syntax_asdl::word_part_t*>* suffix = nullptr;
  List<syntax_asdl::word_part_t*>* tail_parts = nullptr;
  List<List<syntax_asdl::word_part_t*>*>* suffixes = nullptr;
  StackRoots _roots({&parts, &suffix, &tail_parts, &suffixes});

  num_alts = 0;
  first_alt_index = -1;
  i = 0;
  for (ListIter<syntax_asdl::word_part_t*> it(parts); !it.Done(); it.Next(), ++i) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoots _for({&part  });
    tag = part->tag_();
    if ((tag == word_part_e::BracedTuple || tag == word_part_e::BracedRange)) {
      num_alts += 1;
      if (num_alts == 1) {
        first_alt_index = i;
      }
      else {
        if (num_alts == 2) {
          break;
        }
      }
    }
  }
  if (num_alts == 0) {
    return NewList<List<syntax_asdl::word_part_t*>*>(std::initializer_list<List<syntax_asdl::word_part_t*>*>{parts});
  }
  else {
    if (num_alts == 1) {
      suffix = parts->slice((first_alt_index + 1));
      return _ExpandPart(parts, first_alt_index, NewList<List<syntax_asdl::word_part_t*>*>(std::initializer_list<List<syntax_asdl::word_part_t*>*>{suffix}));
    }
    else {
      tail_parts = parts->slice((first_alt_index + 1));
      suffixes = _BraceExpand(tail_parts);
      return _ExpandPart(parts, first_alt_index, suffixes);
    }
  }
}

List<syntax_asdl::compound_word*>* BraceExpandWords(List<syntax_asdl::word_t*>* words) {
  List<syntax_asdl::compound_word*>* out = nullptr;
  syntax_asdl::word_t* UP_w = nullptr;
  List<List<syntax_asdl::word_part_t*>*>* parts_list = nullptr;
  List<syntax_asdl::compound_word*>* tmp = nullptr;
  StackRoots _roots({&words, &out, &UP_w, &parts_list, &tmp});

  out = Alloc<List<syntax_asdl::compound_word*>>();
  for (ListIter<syntax_asdl::word_t*> it(words); !it.Done(); it.Next()) {
    syntax_asdl::word_t* w = it.Value();
    StackRoots _for({&w  });
    UP_w = w;
    switch (w->tag_()) {
      case word_e::BracedTree: {
        word__BracedTree* w = static_cast<word__BracedTree*>(UP_w);
        parts_list = _BraceExpand(w->parts);
        tmp = Alloc<List<syntax_asdl::compound_word*>>();
        for (ListIter<List<syntax_asdl::word_part_t*>*> it(parts_list); !it.Done(); it.Next()) {
          List<syntax_asdl::word_part_t*>* p = it.Value();
          tmp->append(Alloc<compound_word>(p));
        }
        out->extend(tmp);
      }
        break;
      case word_e::Compound: {
        compound_word* w = static_cast<compound_word*>(UP_w);
        out->append(w);
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
  return out;
}

}  // define namespace braces

namespace builtin_assign {  // define

namespace builtin_i = option_asdl::builtin_i;
namespace value = runtime_asdl::value;
namespace value_e = runtime_asdl::value_e;
using runtime_asdl::value_t;
using runtime_asdl::value__Bool;
using runtime_asdl::value__Str;
using runtime_asdl::value__MaybeStrArray;
using runtime_asdl::value__AssocArray;
namespace lvalue = runtime_asdl::lvalue;
using runtime_asdl::scope_e;
using runtime_asdl::cmd_value__Argv;
using runtime_asdl::cmd_value__Assign;
using runtime_asdl::assign_arg;
int _OTHER = 0;
int _READONLY = 1;
int _EXPORT = 2;

int _PrintVariables(state::Mem* mem, runtime_asdl::cmd_value__Assign* cmd_val, args::_Attributes* attrs, bool print_flags) {
  return _PrintVariables(mem, cmd_val, attrs, print_flags, _OTHER);
}

int _PrintVariables(state::Mem* mem, runtime_asdl::cmd_value__Assign* cmd_val, args::_Attributes* attrs, bool print_flags, int builtin) {
  Dict<Str*, runtime_asdl::value_t*>* flag = nullptr;
  runtime_asdl::value_t* tmp_g = nullptr;
  runtime_asdl::value_t* tmp_a = nullptr;
  runtime_asdl::value_t* tmp_A = nullptr;
  bool flag_g;
  bool flag_a;
  bool flag_A;
  runtime_asdl::value_t* tmp_n = nullptr;
  runtime_asdl::value_t* tmp_r = nullptr;
  runtime_asdl::value_t* tmp_x = nullptr;
  Str* flag_n = nullptr;
  Str* flag_r = nullptr;
  Str* flag_x = nullptr;
  runtime_asdl::scope_t which_scopes;
  bool print_all;
  Dict<Str*, runtime_asdl::cell*>* cells = nullptr;
  List<Str*>* names = nullptr;
  Str* name = nullptr;
  Str* s = nullptr;
  Str* invalid = nullptr;
  int count;
  runtime_asdl::cell* cell = nullptr;
  runtime_asdl::value_t* val = nullptr;
  List<Str*>* decl = nullptr;
  List<Str*>* flags = nullptr;
  bool has_holes;
  bool first;
  int i;
  List<Str*>* body = nullptr;
  Str* key_quoted = nullptr;
  Str* value_quoted = nullptr;
  StackRoots _roots({&mem, &cmd_val, &attrs, &flag, &tmp_g, &tmp_a, &tmp_A, &tmp_n, &tmp_r, &tmp_x, &flag_n, &flag_r, &flag_x, &cells, &names, &name, &s, &invalid, &cell, &val, &decl, &flags, &body, &key_quoted, &value_quoted});

  flag = attrs->attrs;
  tmp_g = flag->get(str502);
  tmp_a = flag->get(str503);
  tmp_A = flag->get(str504);
  flag_g = (tmp_g and tmp_g->tag_() == value_e::Bool) ? static_cast<value__Bool*>(tmp_g)->b : false;
  flag_a = (tmp_a and tmp_a->tag_() == value_e::Bool) ? static_cast<value__Bool*>(tmp_a)->b : false;
  flag_A = (tmp_A and tmp_A->tag_() == value_e::Bool) ? static_cast<value__Bool*>(tmp_A)->b : false;
  tmp_n = flag->get(str505);
  tmp_r = flag->get(str506);
  tmp_x = flag->get(str507);
  flag_n = (tmp_n and tmp_n->tag_() == value_e::Str) ? static_cast<value__Str*>(tmp_n)->s : nullptr;
  flag_r = (tmp_r and tmp_r->tag_() == value_e::Str) ? static_cast<value__Str*>(tmp_r)->s : nullptr;
  flag_x = (tmp_x and tmp_x->tag_() == value_e::Str) ? static_cast<value__Str*>(tmp_x)->s : nullptr;
  if (cmd_val->builtin_id == builtin_i::local) {
    if ((flag_g and !mem->IsGlobalScope())) {
      return 1;
    }
    which_scopes = scope_e::LocalOnly;
  }
  else {
    if (flag_g) {
      which_scopes = scope_e::GlobalOnly;
    }
    else {
      which_scopes = mem->ScopesForReading();
    }
  }
  if (len(cmd_val->pairs) == 0) {
    print_all = true;
    cells = mem->GetAllCells(which_scopes);
    names = sorted(cells);
  }
  else {
    print_all = false;
    names = Alloc<List<Str*>>();
    cells = Alloc<Dict<Str*, runtime_asdl::cell*>>();
    for (ListIter<runtime_asdl::assign_arg*> it(cmd_val->pairs); !it.Done(); it.Next()) {
      runtime_asdl::assign_arg* pair = it.Value();
      StackRoots _for({&pair    });
      name = pair->var_name;
      if ((pair->rval and pair->rval->tag_() == value_e::Str)) {
        s = static_cast<value__Str*>(pair->rval)->s;
        invalid = fmt146(name, s);
        names->append(invalid);
        cells->set(invalid, nullptr);
      }
      else {
        names->append(name);
        cells->set(name, mem->GetCell(name, which_scopes));
      }
    }
  }
  count = 0;
  for (ListIter<Str*> it(names); !it.Done(); it.Next()) {
    Str* name = it.Value();
    StackRoots _for({&name  });
    cell = cells->index_(name);
    if (cell == nullptr) {
      continue;
    }
    val = cell->val;
    if (val->tag_() == value_e::Undef) {
      continue;
    }
    if ((builtin == _READONLY and !cell->readonly)) {
      continue;
    }
    if ((builtin == _EXPORT and !cell->exported)) {
      continue;
    }
    if ((maybe_str_equals(flag_n, str509) and !cell->nameref)) {
      continue;
    }
    if ((maybe_str_equals(flag_n, str510) and cell->nameref)) {
      continue;
    }
    if ((maybe_str_equals(flag_r, str511) and !cell->readonly)) {
      continue;
    }
    if ((maybe_str_equals(flag_r, str512) and cell->readonly)) {
      continue;
    }
    if ((maybe_str_equals(flag_x, str513) and !cell->exported)) {
      continue;
    }
    if ((maybe_str_equals(flag_x, str514) and cell->exported)) {
      continue;
    }
    if ((flag_a and val->tag_() != value_e::MaybeStrArray)) {
      continue;
    }
    if ((flag_A and val->tag_() != value_e::AssocArray)) {
      continue;
    }
    decl = Alloc<List<Str*>>();
    if (print_flags) {
      flags = Alloc<List<Str*>>();
      if (cell->nameref) {
        flags->append(str515);
      }
      if (cell->readonly) {
        flags->append(str516);
      }
      if (cell->exported) {
        flags->append(str517);
      }
      if (val->tag_() == value_e::MaybeStrArray) {
        flags->append(str518);
      }
      else {
        if (val->tag_() == value_e::AssocArray) {
          flags->append(str519);
        }
      }
      if (len(flags) == 0) {
        flags->append(str520);
      }
      decl->extend(NewList<Str*>(std::initializer_list<Str*>{str521, str522->join(flags), str523, name}));
    }
    else {
      decl->append(name);
    }
    if (val->tag_() == value_e::Str) {
      value__Str* str_val = static_cast<value__Str*>(val);
      decl->extend(NewList<Str*>(std::initializer_list<Str*>{str524, qsn::maybe_shell_encode(str_val->s)}));
    }
    else {
      if (val->tag_() == value_e::MaybeStrArray) {
        value__MaybeStrArray* array_val = static_cast<value__MaybeStrArray*>(val);
        has_holes = false;
        for (ListIter<Str*> it(array_val->strs); !it.Done(); it.Next()) {
          Str* s = it.Value();
          StackRoots _for({&s        });
          if (s == nullptr) {
            has_holes = true;
            break;
          }
        }
        if (has_holes) {
          decl->append(str525);
          first = true;
          i = 0;
          for (ListIter<Str*> it(array_val->strs); !it.Done(); it.Next(), ++i) {
            Str* element = it.Value();
            StackRoots _for({&element          });
            if (element != nullptr) {
              if (first) {
                decl->append(str526);
                first = false;
              }
              decl->extend(NewList<Str*>(std::initializer_list<Str*>{str527, name, str528, str(i), str529, qsn::maybe_shell_encode(element)}));
            }
          }
        }
        else {
          body = Alloc<List<Str*>>();
          for (ListIter<Str*> it(array_val->strs); !it.Done(); it.Next()) {
            Str* element = it.Value();
            StackRoots _for({&element          });
            if (len(body) > 0) {
              body->append(str530);
            }
            body->append(qsn::maybe_shell_encode(element));
          }
          decl->extend(NewList<Str*>(std::initializer_list<Str*>{str531, str532->join(body), str533}));
        }
      }
      else {
        if (val->tag_() == value_e::AssocArray) {
          value__AssocArray* assoc_val = static_cast<value__AssocArray*>(val);
          body = Alloc<List<Str*>>();
          for (ListIter<Str*> it(sorted(assoc_val->d)); !it.Done(); it.Next()) {
            Str* key = it.Value();
            StackRoots _for({&key          });
            if (len(body) > 0) {
              body->append(str534);
            }
            key_quoted = qsn::maybe_shell_encode(key, qsn::MUST_QUOTE);
            value_quoted = qsn::maybe_shell_encode(assoc_val->d->index_(key));
            body->extend(NewList<Str*>(std::initializer_list<Str*>{str535, key_quoted, str536, value_quoted}));
          }
          if (len(body) > 0) {
            decl->extend(NewList<Str*>(std::initializer_list<Str*>{str537, str538->join(body), str539}));
          }
        }
        else {
          ;  // pass
        }
      }
    }
    print(str540->join(decl));
    count += 1;
  }
  if ((print_all or count == len(names))) {
    return 0;
  }
  else {
    return 1;
  }
}

void _ExportReadonly(state::Mem* mem, runtime_asdl::assign_arg* pair, int flags) {
  runtime_asdl::scope_t which_scopes;
  runtime_asdl::lvalue__Named* lval = nullptr;
  runtime_asdl::value_t* old_val = nullptr;
  runtime_asdl::value_t* val = nullptr;
  StackRoots _roots({&mem, &pair, &lval, &old_val, &val});

  which_scopes = mem->ScopesForWriting();
  lval = Alloc<lvalue::Named>(pair->var_name);
  if (pair->plus_eq) {
    old_val = sh_expr_eval::OldValue(lval, mem, nullptr);
    val = cmd_eval::PlusEquals(old_val, pair->rval);
  }
  else {
    val = pair->rval;
  }
  mem->SetValue(lval, val, which_scopes, flags);
}

Export::Export(state::Mem* mem, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Export();
  this->mem = mem;
  this->errfmt = errfmt;
}

int Export::Run(runtime_asdl::cmd_value__Assign* cmd_val) {
  args::Reader* arg_r = nullptr;
  args::_Attributes* attrs = nullptr;
  arg_types::export_* arg = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &attrs, &arg});

  arg_r = Alloc<args::Reader>(cmd_val->argv, cmd_val->arg_spids);
  arg_r->Next();
  attrs = flag_spec::Parse(str541, arg_r);
  arg = Alloc<arg_types::export_>(attrs->attrs);
  if (arg->f) {
    e_usage(str542);
  }
  if ((arg->p or len(cmd_val->pairs) == 0)) {
    return _PrintVariables(this->mem, cmd_val, attrs, true, _EXPORT);
  }
  if (arg->n) {
    for (ListIter<runtime_asdl::assign_arg*> it(cmd_val->pairs); !it.Done(); it.Next()) {
      runtime_asdl::assign_arg* pair = it.Value();
      StackRoots _for({&pair    });
      if (pair->rval != nullptr) {
        e_usage(fmt147(), pair->spid);
      }
      this->mem->ClearFlag(pair->var_name, state::ClearExport);
    }
  }
  else {
    for (ListIter<runtime_asdl::assign_arg*> it(cmd_val->pairs); !it.Done(); it.Next()) {
      runtime_asdl::assign_arg* pair = it.Value();
      StackRoots _for({&pair    });
      _ExportReadonly(this->mem, pair, state::SetExport);
    }
  }
  return 0;
}

runtime_asdl::value_t* _ReconcileTypes(runtime_asdl::value_t* rval, bool flag_a, bool flag_A, int span_id) {
  StackRoots _roots({&rval});

  if ((flag_a and (rval != nullptr and rval->tag_() != value_e::MaybeStrArray))) {
    e_usage(fmt148(), span_id);
  }
  if ((flag_A and rval)) {
    if (rval->tag_() == value_e::MaybeStrArray) {
      value__MaybeStrArray* array_val = static_cast<value__MaybeStrArray*>(rval);
      if (len(array_val->strs) == 0) {
        return Alloc<value::AssocArray>(Alloc<Dict<Str*, Str*>>());
      }
    }
    if (rval->tag_() != value_e::AssocArray) {
      e_usage(fmt149(), span_id);
    }
  }
  return rval;
}

Readonly::Readonly(state::Mem* mem, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Readonly();
  this->mem = mem;
  this->errfmt = errfmt;
}

int Readonly::Run(runtime_asdl::cmd_value__Assign* cmd_val) {
  args::Reader* arg_r = nullptr;
  args::_Attributes* attrs = nullptr;
  arg_types::readonly* arg = nullptr;
  runtime_asdl::value_t* rval = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &attrs, &arg, &rval});

  arg_r = Alloc<args::Reader>(cmd_val->argv, cmd_val->arg_spids);
  arg_r->Next();
  attrs = flag_spec::Parse(str546, arg_r);
  arg = Alloc<arg_types::readonly>(attrs->attrs);
  if ((arg->p or len(cmd_val->pairs) == 0)) {
    return _PrintVariables(this->mem, cmd_val, attrs, true, _READONLY);
  }
  for (ListIter<runtime_asdl::assign_arg*> it(cmd_val->pairs); !it.Done(); it.Next()) {
    runtime_asdl::assign_arg* pair = it.Value();
    StackRoots _for({&pair  });
    if (pair->rval == nullptr) {
      if (arg->a) {
        rval = Alloc<value::MaybeStrArray>(Alloc<List<Str*>>());
      }
      else {
        if (arg->A) {
          rval = Alloc<value::AssocArray>(Alloc<Dict<Str*, Str*>>());
        }
        else {
          rval = nullptr;
        }
      }
    }
    else {
      rval = pair->rval;
    }
    rval = _ReconcileTypes(rval, arg->a, arg->A, pair->spid);
    _ExportReadonly(this->mem, pair, state::SetReadOnly);
  }
  return 0;
}

NewVar::NewVar(state::Mem* mem, Dict<Str*, runtime_asdl::Proc*>* procs, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_NewVar();
  this->mem = mem;
  this->procs = procs;
  this->errfmt = errfmt;
}

int NewVar::_PrintFuncs(List<Str*>* names) {
  int status;
  StackRoots _roots({&names});

  status = 0;
  for (ListIter<Str*> it(names); !it.Done(); it.Next()) {
    Str* name = it.Value();
    StackRoots _for({&name  });
    if (dict_contains(this->procs, name)) {
      print(name);
    }
    else {
      status = 1;
    }
  }
  return status;
}

int NewVar::Run(runtime_asdl::cmd_value__Assign* cmd_val) {
  args::Reader* arg_r = nullptr;
  args::_Attributes* attrs = nullptr;
  arg_types::new_var* arg = nullptr;
  int status;
  List<Str*>* names = nullptr;
  runtime_asdl::scope_t which_scopes;
  int flags;
  int flags_to_clear;
  runtime_asdl::value_t* rval = nullptr;
  runtime_asdl::value_t* old_val = nullptr;
  runtime_asdl::lvalue__Named* lval = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &attrs, &arg, &names, &rval, &old_val, &lval});

  arg_r = Alloc<args::Reader>(cmd_val->argv, cmd_val->arg_spids);
  arg_r->Next();
  attrs = flag_spec::Parse(str547, arg_r);
  arg = Alloc<arg_types::new_var>(attrs->attrs);
  status = 0;
  if (arg->f) {
    names = arg_r->Rest();
    if (len(names)) {
      status = this->_PrintFuncs(names);
    }
    else {
      e_usage(str548);
    }
    return status;
  }
  if (arg->F) {
    names = arg_r->Rest();
    if (len(names)) {
      status = this->_PrintFuncs(names);
    }
    else {
      for (ListIter<Str*> it(sorted(this->procs)); !it.Done(); it.Next()) {
        Str* func_name = it.Value();
        StackRoots _for({&func_name      });
        print(fmt150(func_name));
      }
    }
    return status;
  }
  if (arg->p) {
    return _PrintVariables(this->mem, cmd_val, attrs, true);
  }
  else {
    if (len(cmd_val->pairs) == 0) {
      return _PrintVariables(this->mem, cmd_val, attrs, false);
    }
  }
  if (cmd_val->builtin_id == builtin_i::local) {
    which_scopes = scope_e::LocalOnly;
  }
  else {
    if (arg->g) {
      which_scopes = scope_e::GlobalOnly;
    }
    else {
      which_scopes = scope_e::LocalOnly;
    }
  }
  flags = 0;
  if (maybe_str_equals(arg->x, str550)) {
    flags |= state::SetExport;
  }
  if (maybe_str_equals(arg->r, str551)) {
    flags |= state::SetReadOnly;
  }
  if (maybe_str_equals(arg->n, str552)) {
    flags |= state::SetNameref;
  }
  flags_to_clear = 0;
  if (maybe_str_equals(arg->x, str553)) {
    flags |= state::ClearExport;
  }
  if (maybe_str_equals(arg->r, str554)) {
    flags |= state::ClearReadOnly;
  }
  if (maybe_str_equals(arg->n, str555)) {
    flags |= state::ClearNameref;
  }
  for (ListIter<runtime_asdl::assign_arg*> it(cmd_val->pairs); !it.Done(); it.Next()) {
    runtime_asdl::assign_arg* pair = it.Value();
    StackRoots _for({&pair  });
    rval = pair->rval;
    if ((rval == nullptr and (arg->a or arg->A))) {
      old_val = this->mem->GetValue(pair->var_name);
      if (arg->a) {
        if (old_val->tag_() != value_e::MaybeStrArray) {
          rval = Alloc<value::MaybeStrArray>(Alloc<List<Str*>>());
        }
      }
      else {
        if (arg->A) {
          if (old_val->tag_() != value_e::AssocArray) {
            rval = Alloc<value::AssocArray>(Alloc<Dict<Str*, Str*>>());
          }
        }
      }
    }
    lval = Alloc<lvalue::Named>(pair->var_name);
    if (pair->plus_eq) {
      old_val = sh_expr_eval::OldValue(lval, this->mem, nullptr);
      rval = cmd_eval::PlusEquals(old_val, pair->rval);
    }
    else {
      rval = _ReconcileTypes(rval, arg->a, arg->A, pair->spid);
    }
    this->mem->SetValue(lval, rval, which_scopes, flags);
  }
  return status;
}

Unset::Unset(state::Mem* mem, Dict<Str*, runtime_asdl::Proc*>* procs, sh_expr_eval::UnsafeArith* unsafe_arith, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Unset();
  this->mem = mem;
  this->procs = procs;
  this->unsafe_arith = unsafe_arith;
  this->errfmt = errfmt;
}

bool Unset::_UnsetVar(Str* arg, int spid, bool proc_fallback) {
  runtime_asdl::lvalue_t* lval = nullptr;
  bool found;
  StackRoots _roots({&arg, &lval});

  lval = this->unsafe_arith->ParseLValue(arg, spid);
  found = false;
  try {
    found = this->mem->Unset(lval, scope_e::Shopt);
  }
  catch (error::Runtime* e) {
    e->span_id = spid;
    this->errfmt->PrettyPrintError(e);
    return false;
  }
  if ((proc_fallback and !found)) {
    if (dict_contains(this->procs, arg)) {
      this->procs->remove(arg);
    }
  }
  return true;
}

int Unset::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::unset* arg = nullptr;
  List<Str*>* argv = nullptr;
  List<int>* arg_spids = nullptr;
  int i;
  int spid;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &argv, &arg_spids});

  Tuple2<args::_Attributes*, args::Reader*> tup0 = flag_spec::ParseCmdVal(str556, cmd_val);
  attrs = tup0.at0();
  arg_r = tup0.at1();
  arg = Alloc<arg_types::unset>(attrs->attrs);
  Tuple2<List<Str*>*, List<int>*> tup1 = arg_r->Rest2();
  argv = tup1.at0();
  arg_spids = tup1.at1();
  i = 0;
  for (ListIter<Str*> it(argv); !it.Done(); it.Next(), ++i) {
    Str* name = it.Value();
    StackRoots _for({&name  });
    spid = arg_spids->index_(i);
    if (arg->f) {
      if (dict_contains(this->procs, name)) {
        this->procs->remove(name);
      }
    }
    else {
      if (arg->v) {
        if (!this->_UnsetVar(name, spid, false)) {
          return 1;
        }
      }
      else {
        if (!this->_UnsetVar(name, spid, true)) {
          return 1;
        }
      }
    }
  }
  return 0;
}

Shift::Shift(state::Mem* mem)  {
  field_mask_ |= maskof_Shift();
  this->mem = mem;
}

int Shift::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  int num_args;
  int n;
  Str* arg = nullptr;
  StackRoots _roots({&cmd_val, &arg});

  num_args = (len(cmd_val->argv) - 1);
  if (num_args == 0) {
    n = 1;
  }
  else {
    if (num_args == 1) {
      arg = cmd_val->argv->index_(1);
      try {
        n = to_int(arg);
      }
      catch (ValueError*) {
        e_usage(fmt151(arg));
      }
    }
    else {
      e_usage(str558);
    }
  }
  return this->mem->Shift(n);
}

}  // define namespace builtin_assign

namespace builtin_meta {  // define

namespace cmd_value = runtime_asdl::cmd_value;
using runtime_asdl::CommandStatus;
namespace source = syntax_asdl::source;

Eval::Eval(parse_lib::ParseContext* parse_ctx, optview::Exec* exec_opts, cmd_eval::CommandEvaluator* cmd_ev, dev::Tracer* tracer, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Eval();
  this->parse_ctx = parse_ctx;
  this->arena = parse_ctx->arena;
  this->exec_opts = exec_opts;
  this->cmd_ev = cmd_ev;
  this->tracer = tracer;
  this->errfmt = errfmt;
}

int Eval::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  Str* code_str = nullptr;
  int eval_spid;
  reader::FileLineReader* line_reader = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  syntax_asdl::source__ArgvWord* src = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &code_str, &line_reader, &c_parser, &src});

  Tuple2<args::_Attributes*, args::Reader*> tup0 = flag_spec::ParseCmdVal(str559, cmd_val);
  arg_r = tup0.at1();
  if (this->exec_opts->simple_eval_builtin()) {
    Tuple2<Str*, int> tup1 = arg_r->ReadRequired2(str560);
    code_str = tup1.at0();
    eval_spid = tup1.at1();
    if (!arg_r->AtEnd()) {
      e_usage(str561);
    }
  }
  else {
    code_str = str562->join(arg_r->Rest());
    eval_spid = cmd_val->arg_spids->index_(0);
  }
  line_reader = reader::StringLineReader(code_str, this->arena);
  c_parser = this->parse_ctx->MakeOshParser(line_reader);
  src = Alloc<source::ArgvWord>(str563, eval_spid);
  {  // with
    dev::ctx_Tracer ctx(this->tracer, str564, nullptr);

    {  // with
      alloc::ctx_Location ctx(this->arena, src);

      return main_loop::Batch(this->cmd_ev, c_parser, this->errfmt, cmd_eval::RaiseControlFlow);
    }
  }
}

Source::Source(parse_lib::ParseContext* parse_ctx, state::SearchPath* search_path, cmd_eval::CommandEvaluator* cmd_ev, process::FdState* fd_state, dev::Tracer* tracer, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Source();
  this->parse_ctx = parse_ctx;
  this->arena = parse_ctx->arena;
  this->search_path = search_path;
  this->cmd_ev = cmd_ev;
  this->fd_state = fd_state;
  this->tracer = tracer;
  this->errfmt = errfmt;
  this->mem = cmd_ev->mem;
}

int Source::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  int call_spid;
  args::Reader* arg_r = nullptr;
  Str* path = nullptr;
  Str* resolved = nullptr;
  mylib::LineReader* f = nullptr;
  reader::FileLineReader* line_reader = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  List<Str*>* source_argv = nullptr;
  syntax_asdl::source__SourcedFile* src = nullptr;
  int status;
  StackRoots _roots({&cmd_val, &arg_r, &path, &resolved, &f, &line_reader, &c_parser, &source_argv, &src});

  call_spid = cmd_val->arg_spids->index_(0);
  Tuple2<args::_Attributes*, args::Reader*> tup2 = flag_spec::ParseCmdVal(str565, cmd_val);
  arg_r = tup2.at1();
  path = arg_r->Peek();
  if (path == nullptr) {
    e_usage(str566);
  }
  arg_r->Next();
  resolved = this->search_path->Lookup(path, false);
  if (resolved == nullptr) {
    resolved = path;
  }
  try {
    f = this->fd_state->Open(resolved);
  }
  catch (IOError_OSError* e) {
    this->errfmt->Print_(fmt152(path, pyutil::strerror(e)), cmd_val->arg_spids->index_(1));
    return 1;
  }
  line_reader = Alloc<reader::FileLineReader>(f, this->arena);
  c_parser = this->parse_ctx->MakeOshParser(line_reader);
  {  // with
    dev::ctx_Tracer ctx(this->tracer, str568, cmd_val->argv);

    source_argv = arg_r->Rest();
    {  // with
      state::ctx_Source ctx(this->mem, path, source_argv);

      {  // with
        state::ctx_ThisDir ctx(this->mem, path);

        src = Alloc<source::SourcedFile>(path, call_spid);
        {  // with
          alloc::ctx_Location ctx(this->arena, src);

          try {
            try {
              status = main_loop::Batch(this->cmd_ev, c_parser, this->errfmt, cmd_eval::RaiseControlFlow);
            }
            catch (error::_ControlFlow* e) {
              if (e->IsReturn()) {
                status = e->StatusCode();
              }
              else {
                throw ;
              }
            }
          }
          catch (std::exception) { }
        }
      }
    }
  }
  return status;
}

Command::Command(vm::_Executor* shell_ex, Dict<Str*, runtime_asdl::Proc*>* funcs, Dict<Str*, Str*>* aliases, state::SearchPath* search_path)  {
  field_mask_ |= maskof_Command();
  this->shell_ex = shell_ex;
  this->funcs = funcs;
  this->aliases = aliases;
  this->search_path = search_path;
}

int Command::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::command* arg = nullptr;
  int status;
  List<Str*>* names = nullptr;
  Str* kind = nullptr;
  Str* argument = nullptr;
  runtime_asdl::CommandStatus* cmd_st = nullptr;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &names, &kind, &argument, &cmd_st});

  Tuple2<args::_Attributes*, args::Reader*> tup3 = flag_spec::ParseCmdVal(str569, cmd_val, true);
  attrs = tup3.at0();
  arg_r = tup3.at1();
  arg = Alloc<arg_types::command>(attrs->attrs);
  if (arg->v) {
    status = 0;
    names = arg_r->Rest();
    for (ListIter<Tuple2<Str*, Str*>*> it(_ResolveNames(names, this->funcs, this->aliases, this->search_path)); !it.Done(); it.Next()) {
      Tuple2<Str*, Str*>* tup4 = it.Value();
      kind = tup4->at0();
      argument = tup4->at1();
      if (kind == nullptr) {
        status = 1;
      }
      else {
        print(argument);
      }
    }
    return status;
  }
  cmd_val = Alloc<cmd_value::Argv>(cmd_val->argv->slice(1), cmd_val->arg_spids->slice(1), cmd_val->typed_args);
  cmd_st = Alloc<CommandStatus>();
  return this->shell_ex->RunSimpleCommand(cmd_val, cmd_st, true, false);
}

Builtin::Builtin(vm::_Executor* shell_ex, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Builtin();
  this->shell_ex = shell_ex;
  this->errfmt = errfmt;
}

int Builtin::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  Str* name = nullptr;
  int to_run;
  int span_id;
  runtime_asdl::cmd_value__Argv* cmd_val2 = nullptr;
  StackRoots _roots({&cmd_val, &name, &cmd_val2});

  if (len(cmd_val->argv) == 1) {
    return 0;
  }
  name = cmd_val->argv->index_(1);
  to_run = consts::LookupNormalBuiltin(name);
  if (to_run == consts::NO_INDEX) {
    to_run = consts::LookupSpecialBuiltin(name);
  }
  if (to_run == consts::NO_INDEX) {
    span_id = cmd_val->arg_spids->index_(1);
    if (consts::LookupAssignBuiltin(name) != consts::NO_INDEX) {
      this->errfmt->Print_(str570, span_id);
    }
    else {
      this->errfmt->Print_(fmt153(name), span_id);
    }
    return 1;
  }
  cmd_val2 = Alloc<cmd_value::Argv>(cmd_val->argv->slice(1), cmd_val->arg_spids->slice(1), cmd_val->typed_args);
  return this->shell_ex->RunBuiltin(to_run, cmd_val2);
}

RunProc::RunProc(vm::_Executor* shell_ex, Dict<Str*, runtime_asdl::Proc*>* procs, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_RunProc();
  this->shell_ex = shell_ex;
  this->procs = procs;
  this->errfmt = errfmt;
}

int RunProc::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  List<Str*>* argv = nullptr;
  List<int>* spids = nullptr;
  Str* name = nullptr;
  runtime_asdl::cmd_value__Argv* cmd_val2 = nullptr;
  runtime_asdl::CommandStatus* cmd_st = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &argv, &spids, &name, &cmd_val2, &cmd_st});

  Tuple2<args::_Attributes*, args::Reader*> tup5 = flag_spec::ParseCmdVal(str572, cmd_val, true);
  arg_r = tup5.at1();
  Tuple2<List<Str*>*, List<int>*> tup6 = arg_r->Rest2();
  argv = tup6.at0();
  spids = tup6.at1();
  if (len(argv) == 0) {
    throw Alloc<error::Usage>(str573, runtime::NO_SPID);
  }
  name = argv->index_(0);
  if (!dict_contains(this->procs, name)) {
    this->errfmt->PrintMessage(fmt154(name));
    return 1;
  }
  cmd_val2 = Alloc<cmd_value::Argv>(argv, spids, cmd_val->typed_args);
  cmd_st = Alloc<CommandStatus>();
  return this->shell_ex->RunSimpleCommand(cmd_val2, cmd_st, true);
}

Try::Try(state::MutableOpts* mutable_opts, state::Mem* mem, cmd_eval::CommandEvaluator* cmd_ev, vm::_Executor* shell_ex, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Try();
  this->mutable_opts = mutable_opts;
  this->mem = mem;
  this->shell_ex = shell_ex;
  this->cmd_ev = cmd_ev;
  this->errfmt = errfmt;
}

int Try::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  syntax_asdl::command_t* block = nullptr;
  int status;
  List<Str*>* argv = nullptr;
  List<int>* spids = nullptr;
  runtime_asdl::cmd_value__Argv* cmd_val2 = nullptr;
  runtime_asdl::CommandStatus* cmd_st = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &block, &argv, &spids, &cmd_val2, &cmd_st});

  Tuple2<args::_Attributes*, args::Reader*> tup7 = flag_spec::ParseCmdVal(str575, cmd_val, true);
  arg_r = tup7.at1();
  block = typed_args::GetOneBlock(cmd_val->typed_args);
  if (block) {
    status = 0;
    try {
      {  // with
        state::ctx_ErrExit ctx(this->mutable_opts, true, runtime::NO_SPID);

      }
    }
    catch (error::Expr* e) {
      status = e->ExitStatus();
    }
    catch (error::ErrExit* e) {
      status = e->ExitStatus();
    }
    this->mem->SetTryStatus(status);
    return 0;
  }
  if (arg_r->Peek() == nullptr) {
    e_usage(str576);
  }
  Tuple2<List<Str*>*, List<int>*> tup8 = arg_r->Rest2();
  argv = tup8.at0();
  spids = tup8.at1();
  cmd_val2 = Alloc<cmd_value::Argv>(argv, spids, cmd_val->typed_args);
  try {
    {  // with
      state::ctx_ErrExit ctx(this->mutable_opts, true, runtime::NO_SPID);

      cmd_st = Alloc<CommandStatus>();
      status = this->shell_ex->RunSimpleCommand(cmd_val2, cmd_st, true);
    }
  }
  catch (error::Expr* e) {
    status = e->ExitStatus();
  }
  catch (error::ErrExit* e) {
    status = e->ExitStatus();
  }
  this->mem->SetTryStatus(status);
  return 0;
}

BoolStatus::BoolStatus(vm::_Executor* shell_ex, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_BoolStatus();
  this->shell_ex = shell_ex;
  this->errfmt = errfmt;
}

int BoolStatus::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  List<Str*>* argv = nullptr;
  List<int>* spids = nullptr;
  runtime_asdl::cmd_value__Argv* cmd_val2 = nullptr;
  runtime_asdl::CommandStatus* cmd_st = nullptr;
  int status;
  StackRoots _roots({&cmd_val, &arg_r, &argv, &spids, &cmd_val2, &cmd_st});

  Tuple2<args::_Attributes*, args::Reader*> tup9 = flag_spec::ParseCmdVal(str577, cmd_val);
  arg_r = tup9.at1();
  if (arg_r->Peek() == nullptr) {
    e_usage(str578);
  }
  Tuple2<List<Str*>*, List<int>*> tup10 = arg_r->Rest2();
  argv = tup10.at0();
  spids = tup10.at1();
  cmd_val2 = Alloc<cmd_value::Argv>(argv, spids, cmd_val->typed_args);
  cmd_st = Alloc<CommandStatus>();
  status = this->shell_ex->RunSimpleCommand(cmd_val2, cmd_st, true);
  if ((status != 0 && status != 1)) {
    e_die_status(status, fmt155(status), spids->index_(0));
  }
  return status;
}

List<Tuple2<Str*, Str*>*>* _ResolveNames(List<Str*>* names, Dict<Str*, runtime_asdl::Proc*>* funcs, Dict<Str*, Str*>* aliases, state::SearchPath* search_path) {
  List<Tuple2<Str*, Str*>*>* results = nullptr;
  Tuple2<Str*, Str*>* kind = nullptr;
  Str* resolved = nullptr;
  Str* no_str = nullptr;
  StackRoots _roots({&names, &funcs, &aliases, &search_path, &results, &kind, &resolved, &no_str});

  results = Alloc<List<Tuple2<Str*, Str*>*>>();
  for (ListIter<Str*> it(names); !it.Done(); it.Next()) {
    Str* name = it.Value();
    StackRoots _for({&name  });
    if (dict_contains(funcs, name)) {
      kind = (Alloc<Tuple2<Str*, Str*>>(str580, name));
    }
    else {
      if (dict_contains(aliases, name)) {
        kind = (Alloc<Tuple2<Str*, Str*>>(str581, name));
      }
      else {
        if (consts::LookupNormalBuiltin(name) != 0) {
          kind = (Alloc<Tuple2<Str*, Str*>>(str582, name));
        }
        else {
          if (consts::LookupSpecialBuiltin(name) != 0) {
            kind = (Alloc<Tuple2<Str*, Str*>>(str583, name));
          }
          else {
            if (consts::LookupAssignBuiltin(name) != 0) {
              kind = (Alloc<Tuple2<Str*, Str*>>(str584, name));
            }
            else {
              if (consts::IsControlFlow(name)) {
                kind = (Alloc<Tuple2<Str*, Str*>>(str585, name));
              }
              else {
                if (consts::IsKeyword(name)) {
                  kind = (Alloc<Tuple2<Str*, Str*>>(str586, name));
                }
                else {
                  resolved = search_path->Lookup(name);
                  if (resolved == nullptr) {
                    no_str = nullptr;
                    kind = (Alloc<Tuple2<Str*, Str*>>(no_str, name));
                  }
                  else {
                    kind = (Alloc<Tuple2<Str*, Str*>>(str587, resolved));
                  }
                }
              }
            }
          }
        }
      }
    }
    results->append(kind);
  }
  return results;
}

Type::Type(Dict<Str*, runtime_asdl::Proc*>* funcs, Dict<Str*, Str*>* aliases, state::SearchPath* search_path, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Type();
  this->funcs = funcs;
  this->aliases = aliases;
  this->search_path = search_path;
  this->errfmt = errfmt;
}

int Type::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::type* arg = nullptr;
  Dict<Str*, runtime_asdl::Proc*>* funcs = nullptr;
  int status;
  List<Tuple2<Str*, Str*>*>* r = nullptr;
  Str* kind = nullptr;
  Str* name = nullptr;
  Str* resolved = nullptr;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &funcs, &r, &kind, &name, &resolved});

  Tuple2<args::_Attributes*, args::Reader*> tup11 = flag_spec::ParseCmdVal(str588, cmd_val);
  attrs = tup11.at0();
  arg_r = tup11.at1();
  arg = Alloc<arg_types::type>(attrs->attrs);
  if (arg->f) {
    funcs = Alloc<Dict<Str*, runtime_asdl::Proc*>>();
  }
  else {
    funcs = this->funcs;
  }
  status = 0;
  r = _ResolveNames(arg_r->Rest(), funcs, this->aliases, this->search_path);
  for (ListIter<Tuple2<Str*, Str*>*> it(r); !it.Done(); it.Next()) {
    Tuple2<Str*, Str*>* tup12 = it.Value();
    kind = tup12->at0();
    name = tup12->at1();
    if (kind == nullptr) {
      if (!arg->t) {
        this->errfmt->PrintMessage(fmt156(name));
      }
      status = 1;
    }
    else {
      if (arg->t) {
        print(kind);
      }
      else {
        if (arg->p) {
          if (str_equals(kind, str590)) {
            print(name);
          }
        }
        else {
          if (arg->P) {
            if (str_equals(kind, str591)) {
              print(name);
            }
            else {
              resolved = this->search_path->Lookup(name);
              if (resolved == nullptr) {
                status = 1;
              }
              else {
                print(resolved);
              }
            }
          }
          else {
            print(fmt157(name, kind));
            if (str_equals(kind, str593)) {
              ;  // pass
            }
          }
        }
      }
    }
  }
  return status;
}

}  // define namespace builtin_meta

namespace builtin_misc {  // define

using runtime_asdl::span_e;
using runtime_asdl::cmd_value__Argv;
namespace lvalue = runtime_asdl::lvalue;
namespace value = runtime_asdl::value;
using runtime_asdl::scope_e;
namespace source = syntax_asdl::source;

Times::Times() : vm::_Builtin() {
}

int Times::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  StackRoots _roots({&cmd_val});

  pyos::PrintTimes();
  return 0;
}

Tuple2<bool, bool> _AppendParts(Str* s, List<Tuple2<runtime_asdl::span_t, int>*>* spans, int max_results, bool join_next, List<mylib::BufWriter*>* parts) {
  int start_index;
  bool last_span_was_black;
  runtime_asdl::span_t span_type;
  int end_index;
  mylib::BufWriter* buf = nullptr;
  bool done;
  runtime_asdl::span_t last_span_type;
  StackRoots _roots({&s, &spans, &parts, &buf});

  start_index = 0;
  last_span_was_black = false;
  for (ListIter<Tuple2<runtime_asdl::span_t, int>*> it(spans); !it.Done(); it.Next()) {
    Tuple2<runtime_asdl::span_t, int>* tup0 = it.Value();
    span_type = tup0->at0();
    end_index = tup0->at1();
    if (span_type == span_e::Black) {
      if ((join_next and parts)) {
        parts->index_(-1)->write(s->slice(start_index, end_index));
        join_next = false;
      }
      else {
        buf = Alloc<mylib::BufWriter>();
        buf->write(s->slice(start_index, end_index));
        parts->append(buf);
      }
      last_span_was_black = true;
    }
    else {
      if (span_type == span_e::Delim) {
        if (join_next) {
          parts->index_(-1)->write(s->slice(start_index, end_index));
          join_next = false;
        }
        last_span_was_black = false;
      }
      else {
        if (span_type == span_e::Backslash) {
          if (last_span_was_black) {
            join_next = true;
          }
          last_span_was_black = false;
        }
      }
    }
    if ((max_results and len(parts) >= max_results)) {
      join_next = true;
    }
    start_index = end_index;
  }
  done = true;
  if (len(spans)) {
    Tuple2<runtime_asdl::span_t, int>* tup1 = spans->index_(-1);
    last_span_type = tup1->at0();
    if (last_span_type == span_e::Backslash) {
      done = false;
    }
  }
  return (Tuple2<bool, bool>(done, join_next));
}

Str* _ReadN(int stdin_fd, int num_bytes, cmd_eval::CommandEvaluator* cmd_ev) {
  List<Str*>* chunks = nullptr;
  int bytes_left;
  int n;
  int err_num;
  StackRoots _roots({&cmd_ev, &chunks});

  chunks = Alloc<List<Str*>>();
  bytes_left = num_bytes;
  while (bytes_left > 0) {
    Tuple2<int, int> tup2 = pyos::Read(stdin_fd, bytes_left, chunks);
    n = tup2.at0();
    err_num = tup2.at1();
    if (n < 0) {
      if (err_num == EINTR) {
        cmd_ev->RunPendingTraps();
      }
      else {
        throw Alloc<pyos::ReadError>(err_num);
      }
    }
    else {
      if (n == 0) {
        break;
      }
      else {
        bytes_left -= n;
      }
    }
  }
  return str594->join(chunks);
}

Tuple2<Str*, bool> _ReadUntilDelim(int delim_byte, cmd_eval::CommandEvaluator* cmd_ev) {
  bool eof;
  List<int>* ch_array = nullptr;
  int ch;
  int err_num;
  StackRoots _roots({&cmd_ev, &ch_array});

  eof = false;
  ch_array = Alloc<List<int>>();
  while (true) {
    Tuple2<int, int> tup3 = pyos::ReadByte(0);
    ch = tup3.at0();
    err_num = tup3.at1();
    if (ch < 0) {
      if (err_num == EINTR) {
        cmd_ev->RunPendingTraps();
      }
      else {
        throw Alloc<pyos::ReadError>(err_num);
      }
    }
    else {
      if (ch == pyos::EOF_SENTINEL) {
        eof = true;
        break;
      }
      else {
        if (ch == delim_byte) {
          break;
        }
        else {
          ch_array->append(ch);
        }
      }
    }
  }
  return (Tuple2<Str*, bool>(pyutil::ChArrayToString(ch_array), eof));
}

Str* _ReadLineSlowly(cmd_eval::CommandEvaluator* cmd_ev) {
  List<int>* ch_array = nullptr;
  int ch;
  int err_num;
  StackRoots _roots({&cmd_ev, &ch_array});

  ch_array = Alloc<List<int>>();
  while (true) {
    Tuple2<int, int> tup4 = pyos::ReadByte(0);
    ch = tup4.at0();
    err_num = tup4.at1();
    if (ch < 0) {
      if (err_num == EINTR) {
        cmd_ev->RunPendingTraps();
      }
      else {
        throw Alloc<pyos::ReadError>(err_num);
      }
    }
    else {
      if (ch == pyos::EOF_SENTINEL) {
        break;
      }
      else {
        ch_array->append(ch);
      }
    }
    if (ch == pyos::NEWLINE_CH) {
      break;
    }
  }
  return pyutil::ChArrayToString(ch_array);
}

Str* _ReadAll() {
  List<Str*>* chunks = nullptr;
  int n;
  int err_num;
  StackRoots _roots({&chunks});

  chunks = Alloc<List<Str*>>();
  while (true) {
    Tuple2<int, int> tup5 = pyos::Read(0, 4096, chunks);
    n = tup5.at0();
    err_num = tup5.at1();
    if (n < 0) {
      if (err_num == EINTR) {
        ;  // pass
      }
      else {
        throw Alloc<pyos::ReadError>(err_num);
      }
    }
    else {
      if (n == 0) {
        break;
      }
    }
  }
  return str595->join(chunks);
}

Read::Read(split::SplitContext* splitter, state::Mem* mem, parse_lib::ParseContext* parse_ctx, cmd_eval::CommandEvaluator* cmd_ev, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Read();
  this->splitter = splitter;
  this->mem = mem;
  this->parse_ctx = parse_ctx;
  this->cmd_ev = cmd_ev;
  this->errfmt = errfmt;
  this->stdin = mylib::Stdin();
}

int Read::_Line(arg_types::read* arg, Str* var_name) {
  Str* line = nullptr;
  alloc::Arena* arena = nullptr;
  reader::FileLineReader* line_reader = nullptr;
  lexer::Lexer* lexer = nullptr;
  List<syntax_asdl::Token*>* tokens = nullptr;
  List<Str*>* tmp = nullptr;
  runtime_asdl::lvalue__Named* lhs = nullptr;
  StackRoots _roots({&arg, &var_name, &line, &arena, &line_reader, &lexer, &tokens, &tmp, &lhs});

  line = pyos::ReadLine();
  if (len(line) == 0) {
    return 1;
  }
  if (!arg->with_eol) {
    if (line->endswith(str596)) {
      line = line->slice(0, -2);
    }
    else {
      if (line->endswith(str597)) {
        line = line->slice(0, -1);
      }
    }
  }
  if ((arg->q and line->startswith(str598))) {
    arena = this->parse_ctx->arena;
    line_reader = reader::StringLineReader(line, arena);
    lexer = this->parse_ctx->MakeLexer(line_reader);
    try {
      {  // with
        alloc::ctx_Location ctx(arena, Alloc<source::Stdin>(str599));

        tokens = qsn_native::Parse(lexer);
      }
    }
    catch (error::Parse* e) {
      this->errfmt->PrettyPrintError(e);
      return 1;
    }
    tmp = Alloc<List<Str*>>();
    for (ListIter<syntax_asdl::Token*> it(tokens); !it.Done(); it.Next()) {
      syntax_asdl::Token* t = it.Value();
      tmp->append(word_compile::EvalCStringToken(t));
    }
    line = str600->join(tmp);
  }
  lhs = Alloc<lvalue::Named>(var_name);
  this->mem->SetValue(lhs, Alloc<value::Str>(line), scope_e::LocalOnly);
  return 0;
}

int Read::_All(Str* var_name) {
  Str* contents = nullptr;
  runtime_asdl::lvalue__Named* lhs = nullptr;
  StackRoots _roots({&var_name, &contents, &lhs});

  contents = _ReadAll();
  lhs = Alloc<lvalue::Named>(var_name);
  this->mem->SetValue(lhs, Alloc<value::Str>(contents), scope_e::LocalOnly);
  return 0;
}

int Read::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  int status;
  StackRoots _roots({&cmd_val});

  try {
    status = this->_Run(cmd_val);
  }
  catch (pyos::ReadError* e) {
    this->errfmt->PrintMessage(fmt158(posix::strerror(e->err_num)));
    status = 1;
  }
  return status;
}

int Read::_Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::read* arg = nullptr;
  List<Str*>* names = nullptr;
  Str* var_name = nullptr;
  int var_spid;
  Str* next_arg = nullptr;
  int next_spid;
  int fd;
  int bits;
  int status;
  pyos::TermState* term = nullptr;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &names, &var_name, &next_arg, &term});

  Tuple2<args::_Attributes*, args::Reader*> tup6 = flag_spec::ParseCmdVal(str602, cmd_val);
  attrs = tup6.at0();
  arg_r = tup6.at1();
  arg = Alloc<arg_types::read>(attrs->attrs);
  names = arg_r->Rest();
  if (arg->line) {
    Tuple2<Str*, int> tup7 = arg_r->Peek2();
    var_name = tup7.at0();
    var_spid = tup7.at1();
    if (var_name == nullptr) {
      var_name = str603;
    }
    else {
      if (var_name->startswith(str604)) {
        var_name = var_name->slice(1);
      }
      arg_r->Next();
    }
    Tuple2<Str*, int> tup8 = arg_r->Peek2();
    next_arg = tup8.at0();
    next_spid = tup8.at1();
    if (next_arg != nullptr) {
      throw Alloc<error::Usage>(str605, next_spid);
    }
    return this->_Line(arg, var_name);
  }
  if (arg->q) {
    e_usage(str606);
  }
  if (arg->all) {
    Tuple2<Str*, int> tup9 = arg_r->Peek2();
    var_name = tup9.at0();
    var_spid = tup9.at1();
    if (var_name == nullptr) {
      var_name = str607;
    }
    else {
      if (var_name->startswith(str608)) {
        var_name = var_name->slice(1);
      }
      arg_r->Next();
    }
    Tuple2<Str*, int> tup10 = arg_r->Peek2();
    next_arg = tup10.at0();
    next_spid = tup10.at1();
    if (next_arg != nullptr) {
      throw Alloc<error::Usage>(str609, next_spid);
    }
    return this->_All(var_name);
  }
  if (arg->q) {
    e_usage(str610);
  }
  fd = this->stdin->fileno();
  if (arg->t >= 0.0) {
    if (arg->t != 0.0) {
      e_die(str611);
    }
    else {
      return pyos::InputAvailable(fd) ? 0 : 1;
    }
  }
  bits = 0;
  if (this->stdin->isatty()) {
    if ((arg->d != nullptr or arg->n >= 0)) {
      bits |= pyos::TERM_ICANON;
    }
    if (arg->s) {
      bits |= pyos::TERM_ECHO;
    }
    if (arg->p != nullptr) {
      mylib::Stderr()->write(arg->p);
    }
  }
  if (bits == 0) {
    status = this->_Read(arg, names);
  }
  else {
    term = Alloc<pyos::TermState>(fd, ~bits);
    try {
      status = this->_Read(arg, names);
    }
    catch (std::exception) { }
  }
  return status;
}

int Read::_Read(arg_types::read* arg, List<Str*>* names) {
  Str* name = nullptr;
  int stdin_fd;
  Str* s = nullptr;
  int max_results;
  bool raw;
  int delim_byte;
  List<mylib::BufWriter*>* parts = nullptr;
  bool join_next;
  int status;
  Str* line = nullptr;
  bool eof;
  List<Tuple2<runtime_asdl::span_t, int>*>* spans = nullptr;
  bool done;
  List<Str*>* entries = nullptr;
  int num_parts;
  Str* var_name = nullptr;
  StackRoots _roots({&arg, &names, &name, &s, &parts, &line, &spans, &entries, &var_name});

  if (arg->n >= 0) {
    if (len(names)) {
      name = names->index_(0);
    }
    else {
      name = str612;
    }
    stdin_fd = this->stdin->fileno();
    s = _ReadN(stdin_fd, arg->n, this->cmd_ev);
    state::BuiltinSetString(this->mem, name, s);
    return len(s) == arg->n ? 0 : 1;
  }
  if (len(names) == 0) {
    names->append(str613);
  }
  if (arg->a != nullptr) {
    max_results = 0;
  }
  else {
    max_results = len(names);
  }
  if (arg->Z) {
    raw = true;
    delim_byte = 0;
  }
  else {
    raw = arg->r;
    if (arg->d != nullptr) {
      if (len(arg->d)) {
        delim_byte = ord(arg->d->index_(0));
      }
      else {
        delim_byte = 0;
      }
    }
    else {
      delim_byte = pyos::NEWLINE_CH;
    }
  }
  parts = Alloc<List<mylib::BufWriter*>>();
  join_next = false;
  status = 0;
  while (true) {
    Tuple2<Str*, bool> tup11 = _ReadUntilDelim(delim_byte, this->cmd_ev);
    line = tup11.at0();
    eof = tup11.at1();
    if (eof) {
      status = 1;
    }
    if (len(line) == 0) {
      break;
    }
    spans = this->splitter->SplitForRead(line, !raw);
    Tuple2<bool, bool> tup12 = _AppendParts(line, spans, max_results, join_next, parts);
    done = tup12.at0();
    join_next = tup12.at1();
    if (done) {
      break;
    }
  }
  entries = Alloc<List<Str*>>();
  for (ListIter<mylib::BufWriter*> it(parts); !it.Done(); it.Next()) {
    mylib::BufWriter* buf = it.Value();
    entries->append(buf->getvalue());
  }
  num_parts = len(entries);
  if (arg->a != nullptr) {
    state::BuiltinSetArray(this->mem, arg->a, entries);
  }
  else {
    for (int i = 0; i < max_results; ++i) {
      if (i < num_parts) {
        s = entries->index_(i);
      }
      else {
        s = str614;
      }
      var_name = names->index_(i);
      if (var_name->startswith(str615)) {
        var_name = var_name->slice(1);
      }
      state::BuiltinSetString(this->mem, var_name, s);
    }
  }
  return status;
}

MapFile::MapFile(state::Mem* mem, ui::ErrorFormatter* errfmt, cmd_eval::CommandEvaluator* cmd_ev)  {
  field_mask_ |= maskof_MapFile();
  this->mem = mem;
  this->errfmt = errfmt;
  this->cmd_ev = cmd_ev;
}

int MapFile::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::mapfile* arg = nullptr;
  Str* var_name = nullptr;
  List<Str*>* lines = nullptr;
  Str* line = nullptr;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &var_name, &lines, &line});

  Tuple2<args::_Attributes*, args::Reader*> tup13 = flag_spec::ParseCmdVal(str616, cmd_val);
  attrs = tup13.at0();
  arg_r = tup13.at1();
  arg = Alloc<arg_types::mapfile>(attrs->attrs);
  Tuple2<Str*, int> tup14 = arg_r->Peek2();
  var_name = tup14.at0();
  if (var_name == nullptr) {
    var_name = str617;
  }
  else {
    if (var_name->startswith(str618)) {
      var_name = var_name->slice(1);
    }
  }
  lines = Alloc<List<Str*>>();
  while (true) {
    try {
      line = _ReadLineSlowly(this->cmd_ev);
    }
    catch (pyos::ReadError* e) {
      this->errfmt->PrintMessage(fmt159(posix::strerror(e->err_num)));
      return 1;
    }
    if (len(line) == 0) {
      break;
    }
    if ((arg->t and line->endswith(str620))) {
      line = line->slice(0, -1);
    }
    lines->append(line);
  }
  state::BuiltinSetArray(this->mem, var_name, lines);
  return 0;
}

ctx_CdBlock::ctx_CdBlock(state::DirStack* dir_stack, Str* dest_dir, state::Mem* mem, ui::ErrorFormatter* errfmt, List<bool>* out_errs) 
    : Obj(Tag::FixedSize, maskof_ctx_CdBlock(), sizeof(ctx_CdBlock))  {
  dir_stack->Push(dest_dir);
  this->dir_stack = dir_stack;
  this->mem = mem;
  this->errfmt = errfmt;
  this->out_errs = out_errs;
}

ctx_CdBlock::~ctx_CdBlock(){
  _PopDirStack(str621, this->mem, this->dir_stack, this->errfmt, this->out_errs);
}

Cd::Cd(state::Mem* mem, state::DirStack* dir_stack, cmd_eval::CommandEvaluator* cmd_ev, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Cd();
  this->mem = mem;
  this->dir_stack = dir_stack;
  this->cmd_ev = cmd_ev;
  this->errfmt = errfmt;
}

int Cd::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::cd* arg = nullptr;
  Str* dest_dir = nullptr;
  int arg_spid;
  runtime_asdl::value_t* val = nullptr;
  Str* pwd = nullptr;
  Str* abspath = nullptr;
  Str* real_dest_dir = nullptr;
  int err_num;
  syntax_asdl::command_t* block = nullptr;
  List<bool>* out_errs = nullptr;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &dest_dir, &val, &pwd, &abspath, &real_dest_dir, &block, &out_errs});

  Tuple2<args::_Attributes*, args::Reader*> tup15 = flag_spec::ParseCmdVal(str622, cmd_val, true);
  attrs = tup15.at0();
  arg_r = tup15.at1();
  arg = Alloc<arg_types::cd>(attrs->attrs);
  Tuple2<Str*, int> tup16 = arg_r->Peek2();
  dest_dir = tup16.at0();
  arg_spid = tup16.at1();
  if (dest_dir == nullptr) {
    val = this->mem->GetValue(str623);
    try {
      dest_dir = state::GetString(this->mem, str624);
    }
    catch (error::Runtime* e) {
      this->errfmt->Print_(e->UserErrorString());
      return 1;
    }
  }
  if (str_equals(dest_dir, str625)) {
    try {
      dest_dir = state::GetString(this->mem, str626);
      print(dest_dir);
    }
    catch (error::Runtime* e) {
      this->errfmt->Print_(e->UserErrorString());
      return 1;
    }
  }
  try {
    pwd = state::GetString(this->mem, str627);
  }
  catch (error::Runtime* e) {
    this->errfmt->Print_(e->UserErrorString());
    return 1;
  }
  abspath = os_path::join(pwd, dest_dir);
  if (arg->P) {
    real_dest_dir = libc::realpath(abspath);
  }
  else {
    real_dest_dir = os_path::normpath(abspath);
  }
  err_num = pyos::Chdir(real_dest_dir);
  if (err_num != 0) {
    this->errfmt->Print_(fmt160(real_dest_dir, posix::strerror(err_num)), arg_spid);
    return 1;
  }
  state::ExportGlobalString(this->mem, str629, real_dest_dir);
  this->mem->SetPwd(real_dest_dir);
  block = typed_args::GetOneBlock(cmd_val->typed_args);
  if (block) {
    out_errs = Alloc<List<bool>>();
    {  // with
      ctx_CdBlock ctx(this->dir_stack, real_dest_dir, this->mem, this->errfmt, out_errs);

    }
    if (len(out_errs)) {
      return 1;
    }
  }
  else {
    state::ExportGlobalString(this->mem, str630, pwd);
    this->dir_stack->Reset();
  }
  return 0;
}
int WITH_LINE_NUMBERS = 1;
int WITHOUT_LINE_NUMBERS = 2;
int SINGLE_LINE = 3;

void _PrintDirStack(state::DirStack* dir_stack, int style, Str* home_dir) {
  int i;
  List<Str*>* parts = nullptr;
  Str* s = nullptr;
  StackRoots _roots({&dir_stack, &home_dir, &parts, &s});

  if (style == WITH_LINE_NUMBERS) {
    i = 0;
    for (ListIter<Str*> it(dir_stack->Iter()); !it.Done(); it.Next(), ++i) {
      Str* entry = it.Value();
      StackRoots _for({&entry    });
      print(fmt161(i, ui::PrettyDir(entry, home_dir)));
    }
  }
  else {
    if (style == WITHOUT_LINE_NUMBERS) {
      for (ListIter<Str*> it(dir_stack->Iter()); !it.Done(); it.Next()) {
        Str* entry = it.Value();
        StackRoots _for({&entry      });
        print(ui::PrettyDir(entry, home_dir));
      }
    }
    else {
      if (style == SINGLE_LINE) {
        parts = Alloc<List<Str*>>();
        for (ListIter<Str*> it(dir_stack->Iter()); !it.Done(); it.Next()) {
          Str* entry = it.Value();
          parts->append(ui::PrettyDir(entry, home_dir));
        }
        s = str632->join(parts);
        print(s);
      }
    }
  }
}

Pushd::Pushd(state::Mem* mem, state::DirStack* dir_stack, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Pushd();
  this->mem = mem;
  this->dir_stack = dir_stack;
  this->errfmt = errfmt;
}

int Pushd::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  Str* dir_arg = nullptr;
  int dir_arg_spid;
  Str* extra = nullptr;
  int extra_spid;
  Str* dest_dir = nullptr;
  int err_num;
  StackRoots _roots({&cmd_val, &arg_r, &dir_arg, &extra, &dest_dir});

  Tuple2<args::_Attributes*, args::Reader*> tup17 = flag_spec::ParseCmdVal(str633, cmd_val);
  arg_r = tup17.at1();
  Tuple2<Str*, int> tup18 = arg_r->Peek2();
  dir_arg = tup18.at0();
  dir_arg_spid = tup18.at1();
  if (dir_arg == nullptr) {
    this->errfmt->Print_(str634);
    return 1;
  }
  arg_r->Next();
  Tuple2<Str*, int> tup19 = arg_r->Peek2();
  extra = tup19.at0();
  extra_spid = tup19.at1();
  if (extra != nullptr) {
    e_usage(fmt162(), extra_spid);
  }
  dest_dir = os_path::abspath(dir_arg);
  err_num = pyos::Chdir(dest_dir);
  if (err_num != 0) {
    this->errfmt->Print_(fmt163(dest_dir, posix::strerror(err_num)), dir_arg_spid);
    return 1;
  }
  this->dir_stack->Push(dest_dir);
  _PrintDirStack(this->dir_stack, SINGLE_LINE, state::MaybeString(this->mem, str637));
  state::ExportGlobalString(this->mem, str638, dest_dir);
  this->mem->SetPwd(dest_dir);
  return 0;
}

bool _PopDirStack(Str* label, state::Mem* mem, state::DirStack* dir_stack, ui::ErrorFormatter* errfmt, List<bool>* out_errs) {
  Str* dest_dir = nullptr;
  int err_num;
  StackRoots _roots({&label, &mem, &dir_stack, &errfmt, &out_errs, &dest_dir});

  dest_dir = dir_stack->Pop();
  if (dest_dir == nullptr) {
    errfmt->Print_(fmt164(label));
    out_errs->append(true);
    return false;
  }
  err_num = pyos::Chdir(dest_dir);
  if (err_num != 0) {
    errfmt->Print_(fmt165(label, dest_dir, posix::strerror(err_num)));
    out_errs->append(true);
    return false;
  }
  state::SetGlobalString(mem, str641, dest_dir);
  mem->SetPwd(dest_dir);
  return true;
}

Popd::Popd(state::Mem* mem, state::DirStack* dir_stack, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Popd();
  this->mem = mem;
  this->dir_stack = dir_stack;
  this->errfmt = errfmt;
}

int Popd::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  Str* extra = nullptr;
  int extra_spid;
  List<bool>* out_errs = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &extra, &out_errs});

  Tuple2<args::_Attributes*, args::Reader*> tup20 = flag_spec::ParseCmdVal(str642, cmd_val);
  arg_r = tup20.at1();
  Tuple2<Str*, int> tup21 = arg_r->Peek2();
  extra = tup21.at0();
  extra_spid = tup21.at1();
  if (extra != nullptr) {
    e_usage(fmt166(), extra_spid);
  }
  out_errs = Alloc<List<bool>>();
  _PopDirStack(str644, this->mem, this->dir_stack, this->errfmt, out_errs);
  if (len(out_errs)) {
    return 1;
  }
  _PrintDirStack(this->dir_stack, SINGLE_LINE, state::MaybeString(this->mem, str645));
  return 0;
}

Dirs::Dirs(state::Mem* mem, state::DirStack* dir_stack, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Dirs();
  this->mem = mem;
  this->dir_stack = dir_stack;
  this->errfmt = errfmt;
}

int Dirs::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::dirs* arg = nullptr;
  Str* home_dir = nullptr;
  int style;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &home_dir});

  Tuple2<args::_Attributes*, args::Reader*> tup22 = flag_spec::ParseCmdVal(str646, cmd_val);
  attrs = tup22.at0();
  arg_r = tup22.at1();
  arg = Alloc<arg_types::dirs>(attrs->attrs);
  home_dir = state::MaybeString(this->mem, str647);
  style = SINGLE_LINE;
  if (arg->l) {
    home_dir = nullptr;
  }
  if (arg->c) {
    this->dir_stack->Reset();
    return 0;
  }
  else {
    if (arg->v) {
      style = WITH_LINE_NUMBERS;
    }
    else {
      if (arg->p) {
        style = WITHOUT_LINE_NUMBERS;
      }
    }
  }
  _PrintDirStack(this->dir_stack, style, home_dir);
  return 0;
}

Pwd::Pwd(state::Mem* mem, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Pwd();
  this->mem = mem;
  this->errfmt = errfmt;
}

int Pwd::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::pwd* arg = nullptr;
  Str* pwd = nullptr;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &pwd});

  Tuple2<args::_Attributes*, args::Reader*> tup23 = flag_spec::ParseCmdVal(str648, cmd_val);
  attrs = tup23.at0();
  arg_r = tup23.at1();
  arg = Alloc<arg_types::pwd>(attrs->attrs);
  pwd = this->mem->pwd;
  if (arg->P) {
    pwd = libc::realpath(pwd);
  }
  print(pwd);
  return 0;
}

Help::Help(pyutil::_ResourceLoader* loader, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Help();
  this->loader = loader;
  this->errfmt = errfmt;
}

List<Str*>* Help::_Groups() {
  Str* contents = nullptr;
  List<Str*>* groups = nullptr;
  StackRoots _roots({&contents, &groups});

  contents = this->loader->Get(str649);
  groups = contents->splitlines(false);
  return groups;
}

int Help::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  Str* topic = nullptr;
  int blame_spid;
  Str* contents = nullptr;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &topic, &contents});

  Tuple2<args::_Attributes*, args::Reader*> tup24 = flag_spec::ParseCmdVal(str650, cmd_val);
  attrs = tup24.at0();
  arg_r = tup24.at1();
  Tuple2<Str*, int> tup25 = arg_r->Peek2();
  topic = tup25.at0();
  blame_spid = tup25.at1();
  if (topic == nullptr) {
    topic = str651;
    blame_spid = runtime::NO_SPID;
  }
  else {
    arg_r->Next();
  }
  try {
    contents = this->loader->Get(fmt167(topic));
  }
  catch (IOError*) {
    this->errfmt->Print_(fmt168(topic), blame_spid);
    return 1;
  }
  print(contents);
  return 0;
}

Cat::Cat() : vm::_Builtin() {
}

int Cat::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  List<Str*>* chunks = nullptr;
  int n;
  int err_num;
  StackRoots _roots({&cmd_val, &chunks});

  chunks = Alloc<List<Str*>>();
  while (true) {
    Tuple2<int, int> tup26 = pyos::Read(0, 4096, chunks);
    n = tup26.at0();
    err_num = tup26.at1();
    if (n < 0) {
      if (err_num == EINTR) {
        ;  // pass
      }
      else {
        e_die_status(2, fmt169(posix::strerror(err_num)));
      }
    }
    else {
      if (n == 0) {
        break;
      }
      else {
        mylib::Stdout()->write(chunks->index_(0));
        chunks->pop();
      }
    }
  }
  return 0;
}

}  // define namespace builtin_misc

namespace builtin_printf {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Kind;
using id_kind_asdl::Id_t;
using id_kind_asdl::Kind_t;
using runtime_asdl::cmd_value__Argv;
namespace value_e = runtime_asdl::value_e;
using runtime_asdl::value__Str;
namespace value = runtime_asdl::value;
namespace printf_part = syntax_asdl::printf_part;
namespace printf_part_e = syntax_asdl::printf_part_e;
using syntax_asdl::printf_part_t;
using syntax_asdl::printf_part__Literal;
using syntax_asdl::printf_part__Percent;
namespace source = syntax_asdl::source;
using syntax_asdl::Token;
using types_asdl::lex_mode_e;
using types_asdl::lex_mode_t;

_FormatStringParser::_FormatStringParser(lexer::Lexer* lexer) 
    : Obj(Tag::FixedSize, maskof__FormatStringParser(), sizeof(_FormatStringParser))  {
  this->lexer = lexer;
  this->cur_token = nullptr;
  this->token_type = Id::Undefined_Tok;
  this->token_kind = Kind::Undefined;
}

void _FormatStringParser::_Next(types_asdl::lex_mode_t lex_mode) {
  this->cur_token = this->lexer->Read(lex_mode);
  this->token_type = this->cur_token->id;
  this->token_kind = consts::GetKind(this->token_type);
}

syntax_asdl::printf_part_t* _FormatStringParser::_ParseFormatStr() {
  syntax_asdl::printf_part__Percent* part = nullptr;
  Str* flag = nullptr;
  StackRoots _roots({&part, &flag});

  this->_Next(lex_mode_e::PrintfPercent);
  part = Alloc<printf_part::Percent>();
  while ((this->token_type == Id::Format_Flag || this->token_type == Id::Format_Zero)) {
    flag = this->cur_token->val;
    if (str_contains(str655, flag)) {
      p_die(fmt170(flag), this->cur_token);
    }
    part->flags->append(this->cur_token);
    this->_Next(lex_mode_e::PrintfPercent);
  }
  if ((this->token_type == Id::Format_Num || this->token_type == Id::Format_Star)) {
    part->width = this->cur_token;
    this->_Next(lex_mode_e::PrintfPercent);
  }
  if (this->token_type == Id::Format_Dot) {
    part->precision = this->cur_token;
    this->_Next(lex_mode_e::PrintfPercent);
    if ((this->token_type == Id::Format_Num || this->token_type == Id::Format_Star || this->token_type == Id::Format_Zero)) {
      part->precision = this->cur_token;
      this->_Next(lex_mode_e::PrintfPercent);
    }
  }
  if ((this->token_type == Id::Format_Type || this->token_type == Id::Format_Time)) {
    part->type = this->cur_token;
    if (str_contains(str657, part->type->val)) {
      p_die(fmt171(), part->type);
    }
    if (maybe_str_equals(part->type->val, str659)) {
      p_die(fmt172(), part->type);
    }
  }
  else {
    if (this->token_type == Id::Unknown_Tok) {
      p_die(fmt173(), this->cur_token);
    }
    else {
      p_die(fmt174(), this->cur_token);
    }
  }
  return part;
}

List<syntax_asdl::printf_part_t*>* _FormatStringParser::Parse() {
  List<syntax_asdl::printf_part_t*>* parts = nullptr;
  StackRoots _roots({&parts});

  this->_Next(lex_mode_e::PrintfOuter);
  parts = Alloc<List<syntax_asdl::printf_part_t*>>();
  while (true) {
    if ((this->token_kind == Kind::Char or (this->token_type == Id::Format_EscapedPercent or this->token_type == Id::Unknown_Backslash))) {
      parts->append(Alloc<printf_part::Literal>(this->cur_token));
    }
    else {
      if (this->token_type == Id::Format_Percent) {
        parts->append(this->_ParseFormatStr());
      }
      else {
        if ((this->token_type == Id::Eof_Real || this->token_type == Id::Eol_Tok)) {
          break;
        }
        else {
          assert(0);  // AssertionError
        }
      }
    }
    this->_Next(lex_mode_e::PrintfOuter);
  }
  return parts;
}

Printf::Printf(state::Mem* mem, parse_lib::ParseContext* parse_ctx, sh_expr_eval::UnsafeArith* unsafe_arith, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Printf();
  this->mem = mem;
  this->parse_ctx = parse_ctx;
  this->unsafe_arith = unsafe_arith;
  this->errfmt = errfmt;
  this->parse_cache = Alloc<Dict<Str*, List<syntax_asdl::printf_part_t*>*>>();
  this->shell_start_time = time_::time();
}

int Printf::_Format(List<syntax_asdl::printf_part_t*>* parts, List<Str*>* varargs, List<int>* spids, List<Str*>* out) {
  int arg_index;
  int num_args;
  bool backslash_c;
  syntax_asdl::printf_part_t* UP_part = nullptr;
  syntax_asdl::Token* token = nullptr;
  Str* s = nullptr;
  List<Str*>* flags = nullptr;
  int width;
  Str* width_str = nullptr;
  int width_spid;
  int precision;
  Str* precision_str = nullptr;
  int precision_spid;
  int word_spid;
  bool has_arg;
  Str* typ = nullptr;
  List<Str*>* c_parts = nullptr;
  match::SimpleLexer* lex = nullptr;
  int id_;
  Str* tok_val = nullptr;
  syntax_asdl::Token* tok = nullptr;
  Str* p = nullptr;
  int d;
  int blame_spid;
  runtime_asdl::cell* tzcell = nullptr;
  double ts;
  int zero_pad;
  bool negative;
  Str* digits = nullptr;
  Str* sign = nullptr;
  int n;
  StackRoots _roots({&parts, &varargs, &spids, &out, &UP_part, &token, &s, &flags, &width_str, &precision_str, &typ, &c_parts, &lex, &tok_val, &tok, &p, &tzcell, &digits, &sign});

  arg_index = 0;
  num_args = len(varargs);
  backslash_c = false;
  while (true) {
    for (ListIter<syntax_asdl::printf_part_t*> it(parts); !it.Done(); it.Next()) {
      syntax_asdl::printf_part_t* part = it.Value();
      StackRoots _for({&part    });
      UP_part = part;
      if (part->tag_() == printf_part_e::Literal) {
        printf_part__Literal* part = static_cast<printf_part__Literal*>(UP_part);
        token = part->token;
        if (token->id == Id::Format_EscapedPercent) {
          s = str663;
        }
        else {
          s = word_compile::EvalCStringToken(token);
        }
        out->append(s);
      }
      else {
        if (part->tag_() == printf_part_e::Percent) {
          printf_part__Percent* part = static_cast<printf_part__Percent*>(UP_part);
          flags = Alloc<List<Str*>>();
          if (len(part->flags) > 0) {
            for (ListIter<syntax_asdl::Token*> it(part->flags); !it.Done(); it.Next()) {
              syntax_asdl::Token* flag_token = it.Value();
              StackRoots _for({&flag_token            });
              flags->append(flag_token->val);
            }
          }
          width = -1;
          if (part->width) {
            if ((part->width->id == Id::Format_Num || part->width->id == Id::Format_Zero)) {
              width_str = part->width->val;
              width_spid = part->width->span_id;
            }
            else {
              if (part->width->id == Id::Format_Star) {
                if (arg_index < num_args) {
                  width_str = varargs->index_(arg_index);
                  width_spid = spids->index_(arg_index);
                  arg_index += 1;
                }
                else {
                  width_str = str664;
                  width_spid = runtime::NO_SPID;
                }
              }
              else {
                assert(0);  // AssertionError
              }
            }
            try {
              width = to_int(width_str);
            }
            catch (ValueError*) {
              if (width_spid == runtime::NO_SPID) {
                width_spid = part->width->span_id;
              }
              this->errfmt->Print_(fmt175(width_str), width_spid);
              return 1;
            }
          }
          precision = -1;
          if (part->precision) {
            if (part->precision->id == Id::Format_Dot) {
              precision_str = str666;
              precision_spid = part->precision->span_id;
            }
            else {
              if ((part->precision->id == Id::Format_Num || part->precision->id == Id::Format_Zero)) {
                precision_str = part->precision->val;
                precision_spid = part->precision->span_id;
              }
              else {
                if (part->precision->id == Id::Format_Star) {
                  if (arg_index < num_args) {
                    precision_str = varargs->index_(arg_index);
                    precision_spid = spids->index_(arg_index);
                    arg_index += 1;
                  }
                  else {
                    precision_str = str667;
                    precision_spid = runtime::NO_SPID;
                  }
                }
                else {
                  assert(0);  // AssertionError
                }
              }
            }
            try {
              precision = to_int(precision_str);
            }
            catch (ValueError*) {
              if (precision_spid == runtime::NO_SPID) {
                precision_spid = part->precision->span_id;
              }
              this->errfmt->Print_(fmt176(precision_str), precision_spid);
              return 1;
            }
          }
          if (arg_index < num_args) {
            s = varargs->index_(arg_index);
            word_spid = spids->index_(arg_index);
            arg_index += 1;
            has_arg = true;
          }
          else {
            s = str669;
            word_spid = runtime::NO_SPID;
            has_arg = false;
          }
          typ = part->type->val;
          if (str_equals(typ, str670)) {
            if (precision >= 0) {
              s = s->slice(0, precision);
            }
          }
          else {
            if (str_equals(typ, str671)) {
              s = qsn::maybe_shell_encode(s);
            }
            else {
              if (str_equals(typ, str672)) {
                c_parts = Alloc<List<Str*>>();
                lex = match::EchoLexer(s);
                while (true) {
                  Tuple2<int, Str*> tup0 = lex->Next();
                  id_ = tup0.at0();
                  tok_val = tup0.at1();
                  if (id_ == Id::Eol_Tok) {
                    break;
                  }
                  tok = Alloc<Token>(id_, runtime::NO_SPID, tok_val);
                  p = word_compile::EvalCStringToken(tok);
                  if (p == nullptr) {
                    backslash_c = true;
                    break;
                  }
                  c_parts->append(p);
                }
                s = str673->join(c_parts);
              }
              else {
                if ((part->type->id == Id::Format_Time or str_contains(str674, typ))) {
                  try {
                    d = to_int(s);
                  }
                  catch (ValueError*) {
                    if ((len(s) >= 1 and str_contains(str675, s->index_(0)))) {
                      d = len(s) >= 2 ? ord(s->index_(1)) : 0;
                    }
                    else {
                      if ((!has_arg and part->type->id == Id::Format_Time)) {
                        d = -1;
                      }
                      else {
                        blame_spid = has_arg ? word_spid : part->type->span_id;
                        this->errfmt->Print_(fmt177(s), blame_spid);
                        return 1;
                      }
                    }
                  }
                  if (part->type->id == Id::Format_Time) {
                    tzcell = this->mem->GetCell(str677);
                    if ((tzcell and (tzcell->exported and tzcell->val->tag_() == value_e::Str))) {
                      value__Str* tzval = static_cast<value__Str*>(tzcell->val);
                      posix::putenv(str678, tzval->s);
                    }
                    time_::tzset();
                    if (d == -1) {
                      ts = time_::time();
                    }
                    else {
                      if (d == -2) {
                        ts = this->shell_start_time;
                      }
                      else {
                        ts = d;
                      }
                    }
                    s = time_::strftime(typ->slice(1, -2), time_::localtime(ts));
                    if (precision >= 0) {
                      s = s->slice(0, precision);
                    }
                  }
                  else {
                    if ((d < 0 and str_contains(str679, typ))) {
                      e_die(fmt178(d, typ), part->type->span_id);
                    }
                    if (str_equals(typ, str681)) {
                      s = mylib::octal(d);
                    }
                    else {
                      if (str_equals(typ, str682)) {
                        s = mylib::hex_lower(d);
                      }
                      else {
                        if (str_equals(typ, str683)) {
                          s = mylib::hex_upper(d);
                        }
                        else {
                          s = str(d);
                        }
                      }
                    }
                    zero_pad = 0;
                    if ((width >= 0 and list_contains(flags, str684))) {
                      zero_pad = 1;
                    }
                    else {
                      if ((precision > 0 and len(s) < precision)) {
                        zero_pad = 2;
                      }
                    }
                    if (zero_pad) {
                      negative = str_equals(s->index_(0), str685);
                      if (negative) {
                        digits = s->slice(1);
                        sign = str686;
                        if (zero_pad == 1) {
                          n = (width - 1);
                        }
                        else {
                          n = precision;
                        }
                      }
                      else {
                        digits = s;
                        sign = str687;
                        if (zero_pad == 1) {
                          n = width;
                        }
                        else {
                          n = precision;
                        }
                      }
                      s = str_concat(sign, digits->rjust(n, str688));
                    }
                  }
                }
                else {
                  assert(0);  // AssertionError
                }
              }
            }
          }
          if (width >= 0) {
            if (list_contains(flags, str689)) {
              s = s->ljust(width, str690);
            }
            else {
              s = s->rjust(width, str691);
            }
          }
          out->append(s);
        }
        else {
          assert(0);  // AssertionError
        }
      }
      if (backslash_c) {
        break;
      }
    }
    if (arg_index == 0) {
      break;
    }
    if (arg_index >= num_args) {
      break;
    }
  }
  return 0;
}

int Printf::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::printf* arg = nullptr;
  Str* fmt = nullptr;
  int fmt_spid;
  List<Str*>* varargs = nullptr;
  List<int>* spids = nullptr;
  alloc::Arena* arena = nullptr;
  List<syntax_asdl::printf_part_t*>* parts = nullptr;
  reader::FileLineReader* line_reader = nullptr;
  lexer::Lexer* lexer = nullptr;
  builtin_printf::_FormatStringParser* parser = nullptr;
  List<Str*>* out = nullptr;
  int status;
  Str* result = nullptr;
  int v_spid;
  runtime_asdl::lvalue_t* lval = nullptr;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &fmt, &varargs, &spids, &arena, &parts, &line_reader, &lexer, &parser, &out, &result, &lval});

  Tuple2<args::_Attributes*, args::Reader*> tup1 = flag_spec::ParseCmdVal(str692, cmd_val);
  attrs = tup1.at0();
  arg_r = tup1.at1();
  arg = Alloc<arg_types::printf>(attrs->attrs);
  Tuple2<Str*, int> tup2 = arg_r->ReadRequired2(str693);
  fmt = tup2.at0();
  fmt_spid = tup2.at1();
  Tuple2<List<Str*>*, List<int>*> tup3 = arg_r->Rest2();
  varargs = tup3.at0();
  spids = tup3.at1();
  arena = this->errfmt->arena;
  if (dict_contains(this->parse_cache, fmt)) {
    parts = this->parse_cache->index_(fmt);
  }
  else {
    line_reader = reader::StringLineReader(fmt, arena);
    lexer = this->parse_ctx->MakeLexer(line_reader);
    parser = Alloc<_FormatStringParser>(lexer);
    {  // with
      alloc::ctx_Location ctx(arena, Alloc<source::ArgvWord>(str694, fmt_spid));

      try {
        parts = parser->Parse();
      }
      catch (error::Parse* e) {
        this->errfmt->PrettyPrintError(e);
        return 2;
      }
    }
    this->parse_cache->set(fmt, parts);
  }
  out = Alloc<List<Str*>>();
  status = this->_Format(parts, varargs, spids, out);
  if (status != 0) {
    return status;
  }
  result = str695->join(out);
  if (arg->v != nullptr) {
    v_spid = runtime::NO_SPID;
    lval = this->unsafe_arith->ParseLValue(arg->v, v_spid);
    state::BuiltinSetValue(this->mem, lval, Alloc<value::Str>(result));
  }
  else {
    mylib::Stdout()->write(result);
  }
  return 0;
}

}  // define namespace builtin_printf

namespace builtin_process2 {  // define

namespace cmd_value = runtime_asdl::cmd_value;
using runtime_asdl::cmd_value__Argv;
using runtime_asdl::wait_status__Cancelled;
using runtime_asdl::wait_status__Pipeline;
using runtime_asdl::wait_status__Proc;
namespace wait_status_e = runtime_asdl::wait_status_e;

Exec::Exec(state::Mem* mem, process::ExternalProgram* ext_prog, process::FdState* fd_state, state::SearchPath* search_path, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Exec();
  this->mem = mem;
  this->ext_prog = ext_prog;
  this->fd_state = fd_state;
  this->search_path = search_path;
  this->errfmt = errfmt;
}

int Exec::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  Dict<Str*, Str*>* environ = nullptr;
  int i;
  Str* cmd = nullptr;
  Str* argv0_path = nullptr;
  runtime_asdl::cmd_value__Argv* c2 = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &environ, &cmd, &argv0_path, &c2});

  Tuple2<args::_Attributes*, args::Reader*> tup0 = flag_spec::ParseCmdVal(str696, cmd_val);
  arg_r = tup0.at1();
  if (arg_r->AtEnd()) {
    this->fd_state->MakePermanent();
    return 0;
  }
  environ = this->mem->GetExported();
  i = arg_r->i;
  cmd = cmd_val->argv->index_(i);
  argv0_path = this->search_path->CachedLookup(cmd);
  if (argv0_path == nullptr) {
    e_die_status(127, fmt179(cmd), cmd_val->arg_spids->index_(1));
  }
  c2 = Alloc<cmd_value::Argv>(cmd_val->argv->slice(i), cmd_val->arg_spids->slice(i), cmd_val->typed_args);
  this->ext_prog->Exec(argv0_path, c2, environ);
  assert(0);  // AssertionError
}

Wait::Wait(process::Waiter* waiter, process::JobState* job_state, state::Mem* mem, dev::Tracer* tracer, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Wait();
  this->waiter = waiter;
  this->job_state = job_state;
  this->mem = mem;
  this->tracer = tracer;
  this->errfmt = errfmt;
}

int Wait::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  StackRoots _roots({&cmd_val});

  {  // with
    dev::ctx_Tracer ctx(this->tracer, str699, cmd_val->argv);

    return this->_Run(cmd_val);
  }
}

int Wait::_Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::wait* arg = nullptr;
  List<Str*>* job_ids = nullptr;
  List<int>* arg_spids = nullptr;
  int n;
  int status;
  int target;
  int result;
  int i;
  int span_id;
  int pid;
  process::Process* job = nullptr;
  runtime_asdl::wait_status_t* wait_status = nullptr;
  runtime_asdl::wait_status_t* UP_wait_status = nullptr;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &job_ids, &arg_spids, &job, &wait_status, &UP_wait_status});

  Tuple2<args::_Attributes*, args::Reader*> tup1 = flag_spec::ParseCmdVal(str700, cmd_val);
  attrs = tup1.at0();
  arg_r = tup1.at1();
  arg = Alloc<arg_types::wait>(attrs->attrs);
  Tuple2<List<Str*>*, List<int>*> tup2 = arg_r->Rest2();
  job_ids = tup2.at0();
  arg_spids = tup2.at1();
  if (arg->n) {
    n = this->job_state->NumRunning();
    if (n == 0) {
      status = 127;
    }
    else {
      target = (n - 1);
      status = 0;
      while (this->job_state->NumRunning() > target) {
        result = this->waiter->WaitForOne();
        if (result == process::W1_OK) {
          status = this->waiter->last_status;
        }
        else {
          if (result == process::W1_ECHILD) {
            status = 127;
            break;
          }
          else {
            if (result >= 0) {
              status = (128 + result);
              break;
            }
          }
        }
      }
    }
    return status;
  }
  if (len(job_ids) == 0) {
    status = 0;
    while (this->job_state->NumRunning() != 0) {
      result = this->waiter->WaitForOne();
      if (result == process::W1_ECHILD) {
        break;
      }
      else {
        if (result >= 0) {
          status = (128 + result);
          break;
        }
      }
    }
    return status;
  }
  status = 1;
  i = 0;
  for (ListIter<Str*> it(job_ids); !it.Done(); it.Next(), ++i) {
    Str* job_id = it.Value();
    StackRoots _for({&job_id  });
    span_id = arg_spids->index_(i);
    if (job_id->startswith(str701)) {
      throw Alloc<error::Usage>(fmt180(job_id), span_id);
    }
    try {
      pid = to_int(job_id);
    }
    catch (ValueError*) {
      throw Alloc<error::Usage>(fmt181(job_id), span_id);
    }
    job = this->job_state->JobFromPid(pid);
    if (job == nullptr) {
      this->errfmt->Print_(fmt182(pid), span_id);
      return 127;
    }
    wait_status = job->JobWait(this->waiter);
    UP_wait_status = wait_status;
    switch (wait_status->tag_()) {
      case wait_status_e::Proc: {
        wait_status__Proc* wait_status = static_cast<wait_status__Proc*>(UP_wait_status);
        status = wait_status->code;
      }
        break;
      case wait_status_e::Pipeline: {
        wait_status__Pipeline* wait_status = static_cast<wait_status__Pipeline*>(UP_wait_status);
        status = wait_status->codes->index_(-1);
      }
        break;
      case wait_status_e::Cancelled: {
        wait_status__Cancelled* wait_status = static_cast<wait_status__Cancelled*>(UP_wait_status);
        status = (128 + wait_status->sig_num);
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
  return status;
}

Umask::Umask()  {
  ;  // pass
}

int Umask::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  List<Str*>* argv = nullptr;
  int mask;
  Str* a = nullptr;
  int new_mask;
  StackRoots _roots({&cmd_val, &argv, &a});

  argv = cmd_val->argv->slice(1);
  if (len(argv) == 0) {
    mask = posix::umask(0);
    posix::umask(mask);
    print(fmt183(mask));
    return 0;
  }
  if (len(argv) == 1) {
    a = argv->index_(0);
    try {
      new_mask = to_int(a, 8);
    }
    catch (ValueError*) {
      println_stderr(str706);
      return 1;
    }
    posix::umask(new_mask);
    return 0;
  }
  e_usage(str707);
}

}  // define namespace builtin_process2

namespace builtin_pure {  // define

namespace Id = id_kind_asdl::Id;
using runtime_asdl::scope_e;
namespace lvalue = runtime_asdl::lvalue;
namespace value = runtime_asdl::value;
namespace value_e = runtime_asdl::value_e;
using runtime_asdl::value__Str;
using runtime_asdl::value__MaybeStrArray;
using runtime_asdl::value__AssocArray;
using runtime_asdl::value__Obj;
using syntax_asdl::Token;
namespace command_e = syntax_asdl::command_e;
using syntax_asdl::BraceGroup;
namespace opt_group_i = types_asdl::opt_group_i;
namespace fmt = format;

Boolean::Boolean(int status)  {
  this->status = status;
}

int Boolean::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  StackRoots _roots({&cmd_val});

  typed_args::DoesNotAccept(cmd_val->typed_args);
  return this->status;
}

Alias::Alias(Dict<Str*, Str*>* aliases, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Alias();
  this->aliases = aliases;
  this->errfmt = errfmt;
}

int Alias::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  List<Str*>* argv = nullptr;
  Str* alias_exp = nullptr;
  int status;
  int i;
  Str* name = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &argv, &alias_exp, &name});

  Tuple2<args::_Attributes*, args::Reader*> tup0 = flag_spec::ParseCmdVal(str708, cmd_val);
  arg_r = tup0.at1();
  argv = arg_r->Rest();
  if (len(argv) == 0) {
    for (ListIter<Str*> it(sorted(this->aliases)); !it.Done(); it.Next()) {
      Str* name = it.Value();
      StackRoots _for({&name    });
      alias_exp = this->aliases->index_(name);
      print(fmt184(name, alias_exp));
    }
    return 0;
  }
  status = 0;
  i = 0;
  for (ListIter<Str*> it(argv); !it.Done(); it.Next(), ++i) {
    Str* arg = it.Value();
    StackRoots _for({&arg  });
    Tuple2<Str*, Str*> tup1 = mylib::split_once(arg, str710);
    name = tup1.at0();
    alias_exp = tup1.at1();
    if (alias_exp == nullptr) {
      alias_exp = this->aliases->get(name);
      if (alias_exp == nullptr) {
        this->errfmt->Print_(fmt185(name), cmd_val->arg_spids->index_(i));
        status = 1;
      }
      else {
        print(fmt186(name, alias_exp));
      }
    }
    else {
      this->aliases->set(name, alias_exp);
    }
  }
  return status;
}

UnAlias::UnAlias(Dict<Str*, Str*>* aliases, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_UnAlias();
  this->aliases = aliases;
  this->errfmt = errfmt;
}

int UnAlias::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  List<Str*>* argv = nullptr;
  int status;
  int i;
  StackRoots _roots({&cmd_val, &arg_r, &argv});

  Tuple2<args::_Attributes*, args::Reader*> tup2 = flag_spec::ParseCmdVal(str713, cmd_val);
  arg_r = tup2.at1();
  argv = arg_r->Rest();
  if (len(argv) == 0) {
    e_usage(str714);
  }
  status = 0;
  i = 0;
  for (ListIter<Str*> it(argv); !it.Done(); it.Next(), ++i) {
    Str* name = it.Value();
    StackRoots _for({&name  });
    if (dict_contains(this->aliases, name)) {
      this->aliases->remove(name);
    }
    else {
      this->errfmt->Print_(fmt187(name), cmd_val->arg_spids->index_(i));
      status = 1;
    }
  }
  return status;
}

void SetOptionsFromFlags(state::MutableOpts* exec_opts, List<Tuple2<Str*, bool>*>* opt_changes, List<Tuple2<Str*, bool>*>* shopt_changes) {
  Str* opt_name = nullptr;
  bool b;
  StackRoots _roots({&exec_opts, &opt_changes, &shopt_changes, &opt_name});

  for (ListIter<Tuple2<Str*, bool>*> it(opt_changes); !it.Done(); it.Next()) {
    Tuple2<Str*, bool>* tup3 = it.Value();
    opt_name = tup3->at0();
    b = tup3->at1();
    exec_opts->SetAnyOption(opt_name, b);
  }
  for (ListIter<Tuple2<Str*, bool>*> it(shopt_changes); !it.Done(); it.Next()) {
    Tuple2<Str*, bool>* tup4 = it.Value();
    opt_name = tup4->at0();
    b = tup4->at1();
    exec_opts->SetAnyOption(opt_name, b);
  }
}

Set::Set(state::MutableOpts* exec_opts, state::Mem* mem)  {
  field_mask_ |= maskof_Set();
  this->exec_opts = exec_opts;
  this->mem = mem;
}

int Set::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  Dict<Str*, Str*>* mapping = nullptr;
  Str* str_val = nullptr;
  Str* code_str = nullptr;
  args::Reader* arg_r = nullptr;
  args::_Attributes* arg = nullptr;
  Str* opt_name = nullptr;
  bool b;
  StackRoots _roots({&cmd_val, &mapping, &str_val, &code_str, &arg_r, &arg, &opt_name});

  if (len(cmd_val->argv) == 1) {
    mapping = this->mem->GetAllVars();
    for (ListIter<Str*> it(sorted(mapping)); !it.Done(); it.Next()) {
      Str* name = it.Value();
      StackRoots _for({&name    });
      str_val = mapping->index_(name);
      code_str = fmt188(name, qsn::maybe_shell_encode(str_val));
      print(code_str);
    }
    return 0;
  }
  arg_r = Alloc<args::Reader>(cmd_val->argv, cmd_val->arg_spids);
  arg_r->Next();
  arg = flag_spec::ParseMore(str717, arg_r);
  if (arg->show_options) {
    this->exec_opts->ShowOptions(Alloc<List<Str*>>());
    return 0;
  }
  for (ListIter<Tuple2<Str*, bool>*> it(arg->opt_changes); !it.Done(); it.Next()) {
    Tuple2<Str*, bool>* tup5 = it.Value();
    opt_name = tup5->at0();
    b = tup5->at1();
    this->exec_opts->SetOldOption(opt_name, b);
  }
  for (ListIter<Tuple2<Str*, bool>*> it(arg->shopt_changes); !it.Done(); it.Next()) {
    Tuple2<Str*, bool>* tup6 = it.Value();
    opt_name = tup6->at0();
    b = tup6->at1();
    this->exec_opts->SetAnyOption(opt_name, b);
  }
  if ((arg->saw_double_dash or !arg_r->AtEnd())) {
    this->mem->SetArgv(arg_r->Rest());
  }
  return 0;
}

Shopt::Shopt(state::MutableOpts* mutable_opts, cmd_eval::CommandEvaluator* cmd_ev)  {
  field_mask_ |= maskof_Shopt();
  this->mutable_opts = mutable_opts;
  this->cmd_ev = cmd_ev;
}

int Shopt::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::shopt* arg = nullptr;
  List<Str*>* opt_names = nullptr;
  int index;
  bool b;
  syntax_asdl::command_t* block = nullptr;
  List<int>* opt_nums = nullptr;
  int opt_group;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &opt_names, &block, &opt_nums});

  Tuple2<args::_Attributes*, args::Reader*> tup7 = flag_spec::ParseCmdVal(str718, cmd_val, true);
  attrs = tup7.at0();
  arg_r = tup7.at1();
  arg = Alloc<arg_types::shopt>(attrs->attrs);
  opt_names = arg_r->Rest();
  if (arg->p) {
    if (arg->o) {
      this->mutable_opts->ShowOptions(opt_names);
    }
    else {
      this->mutable_opts->ShowShoptOptions(opt_names);
    }
    return 0;
  }
  if (arg->q) {
    for (ListIter<Str*> it(opt_names); !it.Done(); it.Next()) {
      Str* name = it.Value();
      StackRoots _for({&name    });
      index = consts::OptionNum(name);
      if (index == 0) {
        return 2;
      }
      if (!this->mutable_opts->opt0_array->index_(index)) {
        return 1;
      }
    }
    return 0;
  }
  if (arg->s) {
    b = true;
  }
  else {
    if (arg->u) {
      b = false;
    }
    else {
      this->mutable_opts->ShowShoptOptions(opt_names);
      return 0;
    }
  }
  block = typed_args::GetOneBlock(cmd_val->typed_args);
  if (block) {
    opt_nums = Alloc<List<int>>();
    for (ListIter<Str*> it(opt_names); !it.Done(); it.Next()) {
      Str* opt_name = it.Value();
      StackRoots _for({&opt_name    });
      opt_group = consts::OptionGroupNum(opt_name);
      if (opt_group == opt_group_i::OilUpgrade) {
        opt_nums->extend(consts::OIL_UPGRADE);
        continue;
      }
      if (opt_group == opt_group_i::OilAll) {
        opt_nums->extend(consts::OIL_ALL);
        continue;
      }
      if (opt_group == opt_group_i::StrictAll) {
        opt_nums->extend(consts::STRICT_ALL);
        continue;
      }
      index = consts::OptionNum(opt_name);
      if (index == 0) {
        e_usage(fmt189(opt_name));
      }
      opt_nums->append(index);
    }
    {  // with
      state::ctx_Option ctx(this->mutable_opts, opt_nums, b);

    }
    return 0;
  }
  for (ListIter<Str*> it(opt_names); !it.Done(); it.Next()) {
    Str* opt_name = it.Value();
    StackRoots _for({&opt_name  });
    this->mutable_opts->SetAnyOption(opt_name, b);
  }
  return 0;
}

Hash::Hash(state::SearchPath* search_path)  {
  field_mask_ |= maskof_Hash();
  this->search_path = search_path;
}

int Hash::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::hash* arg = nullptr;
  List<Str*>* rest = nullptr;
  int status;
  Str* full_path = nullptr;
  List<Str*>* commands = nullptr;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &rest, &full_path, &commands});

  Tuple2<args::_Attributes*, args::Reader*> tup8 = flag_spec::ParseCmdVal(str720, cmd_val);
  attrs = tup8.at0();
  arg_r = tup8.at1();
  arg = Alloc<arg_types::hash>(attrs->attrs);
  rest = arg_r->Rest();
  if (arg->r) {
    if (len(rest)) {
      e_usage(str721);
    }
    this->search_path->ClearCache();
    return 0;
  }
  status = 0;
  if (len(rest)) {
    for (ListIter<Str*> it(rest); !it.Done(); it.Next()) {
      Str* cmd = it.Value();
      StackRoots _for({&cmd    });
      full_path = this->search_path->CachedLookup(cmd);
      if (full_path == nullptr) {
        println_stderr(fmt190(cmd));
        status = 1;
      }
    }
  }
  else {
    commands = this->search_path->CachedCommands();
    commands->sort();
    for (ListIter<Str*> it(commands); !it.Done(); it.Next()) {
      Str* cmd = it.Value();
      StackRoots _for({&cmd    });
      print(cmd);
    }
  }
  return status;
}

Dict<Str*, bool>* _ParseOptSpec(Str* spec_str) {
  Dict<Str*, bool>* spec = nullptr;
  int i;
  int n;
  Str* ch = nullptr;
  StackRoots _roots({&spec_str, &spec, &ch});

  spec = Alloc<Dict<Str*, bool>>();
  i = 0;
  n = len(spec_str);
  while (true) {
    if (i >= n) {
      break;
    }
    ch = spec_str->index_(i);
    spec->set(ch, false);
    i += 1;
    if (i >= n) {
      break;
    }
    if (str_equals(spec_str->index_(i), str723)) {
      spec->set(ch, true);
      i += 1;
    }
  }
  return spec;
}

GetOptsState::GetOptsState(state::Mem* mem, ui::ErrorFormatter* errfmt) 
    : Obj(Tag::FixedSize, maskof_GetOptsState(), sizeof(GetOptsState))  {
  this->mem = mem;
  this->errfmt = errfmt;
  this->_optind = -1;
  this->flag_pos = 1;
}

int GetOptsState::_OptInd() {
  int result;
  try {
    result = state::GetInteger(this->mem, str724);
  }
  catch (error::Runtime* e) {
    this->errfmt->Print_(e->UserErrorString());
    result = -1;
  }
  return result;
}

Str* GetOptsState::GetArg(List<Str*>* argv) {
  int optind;
  int i;
  StackRoots _roots({&argv});

  optind = this->_OptInd();
  if (optind == -1) {
    return nullptr;
  }
  this->_optind = optind;
  i = (optind - 1);
  if ((0 <= i and i < len(argv))) {
    return argv->index_(i);
  }
  else {
    return nullptr;
  }
}

void GetOptsState::IncIndex() {
  state::BuiltinSetString(this->mem, str725, str((this->_optind + 1)));
}

void GetOptsState::SetArg(Str* optarg) {
  StackRoots _roots({&optarg});

  state::BuiltinSetString(this->mem, str726, optarg);
}

void GetOptsState::Fail() {
  state::BuiltinSetString(this->mem, str727, str728);
}

Tuple2<int, Str*> _GetOpts(Dict<Str*, bool>* spec, List<Str*>* argv, builtin_pure::GetOptsState* my_state, ui::ErrorFormatter* errfmt) {
  Str* current = nullptr;
  Str* flag_char = nullptr;
  bool more_chars;
  Str* optarg = nullptr;
  List<Str*>* tmp = nullptr;
  StackRoots _roots({&spec, &argv, &my_state, &errfmt, &current, &flag_char, &optarg, &tmp});

  current = my_state->GetArg(argv);
  if (current == nullptr) {
    my_state->Fail();
    return (Tuple2<int, Str*>(1, str729));
  }
  if ((!current->startswith(str730) or str_equals(current, str731))) {
    my_state->Fail();
    return (Tuple2<int, Str*>(1, str732));
  }
  flag_char = current->index_(my_state->flag_pos);
  if (my_state->flag_pos < (len(current) - 1)) {
    my_state->flag_pos += 1;
    more_chars = true;
  }
  else {
    my_state->IncIndex();
    my_state->flag_pos = 1;
    more_chars = false;
  }
  if (!dict_contains(spec, flag_char)) {
    return (Tuple2<int, Str*>(0, str733));
  }
  if (spec->index_(flag_char)) {
    if (more_chars) {
      optarg = current->slice(my_state->flag_pos);
    }
    else {
      optarg = my_state->GetArg(argv);
      if (optarg == nullptr) {
        my_state->Fail();
        errfmt->Print_(fmt191(current));
        tmp = Alloc<List<Str*>>();
        for (ListIter<Str*> it(argv); !it.Done(); it.Next()) {
          Str* a = it.Value();
          tmp->append(qsn::maybe_shell_encode(a));
        }
        println_stderr(fmt192(str736->join(tmp)));
        return (Tuple2<int, Str*>(0, str737));
      }
    }
    my_state->IncIndex();
    my_state->SetArg(optarg);
  }
  else {
    my_state->SetArg(str738);
  }
  return (Tuple2<int, Str*>(0, flag_char));
}

GetOpts::GetOpts(state::Mem* mem, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_GetOpts();
  this->mem = mem;
  this->errfmt = errfmt;
  this->my_state = Alloc<GetOptsState>(mem, errfmt);
  this->spec_cache = Alloc<Dict<Str*, Dict<Str*, bool>*>>();
}

int GetOpts::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  Str* spec_str = nullptr;
  Str* var_name = nullptr;
  int var_spid;
  Dict<Str*, bool>* spec = nullptr;
  List<Str*>* user_argv = nullptr;
  int status;
  Str* flag_char = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &spec_str, &var_name, &spec, &user_argv, &flag_char});

  arg_r = Alloc<args::Reader>(cmd_val->argv, cmd_val->arg_spids);
  arg_r->Next();
  spec_str = arg_r->ReadRequired(str739);
  Tuple2<Str*, int> tup9 = arg_r->ReadRequired2(str740);
  var_name = tup9.at0();
  var_spid = tup9.at1();
  spec = this->spec_cache->get(spec_str);
  if (spec == nullptr) {
    spec = _ParseOptSpec(spec_str);
    this->spec_cache->set(spec_str, spec);
  }
  user_argv = arg_r->AtEnd() ? this->mem->GetArgv() : arg_r->Rest();
  Tuple2<int, Str*> tup10 = _GetOpts(spec, user_argv, this->my_state, this->errfmt);
  status = tup10.at0();
  flag_char = tup10.at1();
  if (match::IsValidVarName(var_name)) {
    state::BuiltinSetString(this->mem, var_name, flag_char);
  }
  else {
    throw Alloc<error::Usage>(fmt193(var_name), var_spid);
  }
  return status;
}

Echo::Echo(optview::Exec* exec_opts)  {
  field_mask_ |= maskof_Echo();
  this->exec_opts = exec_opts;
  this->f = mylib::Stdout();
}

int Echo::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  List<Str*>* argv = nullptr;
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::echo* arg = nullptr;
  bool backslash_c;
  int arg0_spid;
  List<Str*>* new_argv = nullptr;
  List<Str*>* parts = nullptr;
  match::SimpleLexer* lex = nullptr;
  int id_;
  Str* value = nullptr;
  syntax_asdl::Token* tok = nullptr;
  Str* p = nullptr;
  int n;
  int i;
  StackRoots _roots({&cmd_val, &argv, &attrs, &arg_r, &arg, &new_argv, &parts, &lex, &value, &tok, &p});

  argv = cmd_val->argv->slice(1);
  Tuple2<args::_Attributes*, args::Reader*> tup11 = flag_spec::ParseLikeEcho(str742, cmd_val);
  attrs = tup11.at0();
  arg_r = tup11.at1();
  arg = Alloc<arg_types::echo>(attrs->attrs);
  argv = arg_r->Rest();
  backslash_c = false;
  arg0_spid = cmd_val->arg_spids->index_(0);
  if (arg->e) {
    new_argv = Alloc<List<Str*>>();
    for (ListIter<Str*> it(argv); !it.Done(); it.Next()) {
      Str* a = it.Value();
      StackRoots _for({&a    });
      parts = Alloc<List<Str*>>();
      lex = match::EchoLexer(a);
      while (!backslash_c) {
        Tuple2<int, Str*> tup12 = lex->Next();
        id_ = tup12.at0();
        value = tup12.at1();
        if (id_ == Id::Eol_Tok) {
          break;
        }
        tok = Alloc<Token>(id_, arg0_spid, value);
        p = word_compile::EvalCStringToken(tok);
        if (p == nullptr) {
          backslash_c = true;
          break;
        }
        parts->append(p);
      }
      new_argv->append(str743->join(parts));
      if (backslash_c) {
        break;
      }
    }
    argv = new_argv;
  }
  if (this->exec_opts->simple_echo()) {
    n = len(argv);
    if (n == 0) {
      ;  // pass
    }
    else {
      if (n == 1) {
        this->f->write(argv->index_(0));
      }
      else {
        e_usage(str744);
      }
    }
  }
  else {
    i = 0;
    for (ListIter<Str*> it(argv); !it.Done(); it.Next(), ++i) {
      Str* a = it.Value();
      StackRoots _for({&a    });
      if (i != 0) {
        this->f->write(str745);
      }
      this->f->write(a);
    }
  }
  if ((!arg->n and !backslash_c)) {
    this->f->write(str746);
  }
  return 0;
}

Module::Module(Dict<Str*, bool>* modules, optview::Exec* exec_opts, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Module();
  this->modules = modules;
  this->exec_opts = exec_opts;
  this->errfmt = errfmt;
}

int Module::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  Str* name = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &name});

  Tuple2<args::_Attributes*, args::Reader*> tup13 = flag_spec::ParseCmdVal(str747, cmd_val);
  arg_r = tup13.at1();
  Tuple2<Str*, int> tup14 = arg_r->ReadRequired2(str748);
  name = tup14.at0();
  if (dict_contains(this->modules, name)) {
    if (this->exec_opts->redefine_module()) {
      this->errfmt->PrintMessage(fmt194(name));
      return 0;
    }
    else {
      return 1;
    }
  }
  this->modules->set(name, true);
  return 0;
}

Use::Use(state::Mem* mem, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Use();
  this->mem = mem;
  this->errfmt = errfmt;
}

int Use::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  Str* arg = nullptr;
  int arg_spid;
  Str* expected = nullptr;
  int e_spid;
  runtime_asdl::value_t* UP_actual = nullptr;
  Str* actual = nullptr;
  List<Str*>* rest = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &arg, &expected, &UP_actual, &actual, &rest});

  arg_r = Alloc<args::Reader>(cmd_val->argv, cmd_val->arg_spids);
  arg_r->Next();
  Tuple2<Str*, int> tup15 = arg_r->Peek2();
  arg = tup15.at0();
  arg_spid = tup15.at1();
  if (arg == nullptr) {
    throw Alloc<error::Usage>(str750, runtime::NO_SPID);
  }
  arg_r->Next();
  if (str_equals(arg, str751)) {
    Tuple2<Str*, int> tup16 = arg_r->Peek2();
    expected = tup16.at0();
    e_spid = tup16.at1();
    if (expected == nullptr) {
      throw Alloc<error::Usage>(str752, runtime::NO_SPID);
    }
    UP_actual = this->mem->GetValue(str753, scope_e::Dynamic);
    if (UP_actual->tag_() == value_e::Str) {
      actual = static_cast<value__Str*>(UP_actual)->s;
      if (maybe_str_equals(actual, expected)) {
        return 0;
      }
      else {
        this->errfmt->Print_(fmt195(expected, actual), e_spid);
        return 1;
      }
    }
    else {
      this->errfmt->Print_(fmt196(expected), e_spid);
      return 1;
    }
  }
  if (str_equals(arg, str756)) {
    rest = arg_r->Rest();
    for (ListIter<Str*> it(rest); !it.Done(); it.Next()) {
      Str* name = it.Value();
      StackRoots _for({&name    });
      println_stderr(fmt197(name));
    }
    return 0;
  }
  throw Alloc<error::Usage>(str758, arg_spid);
}

Shvar::Shvar(state::Mem* mem, state::SearchPath* search_path, cmd_eval::CommandEvaluator* cmd_ev)  {
  field_mask_ |= maskof_Shvar();
  this->mem = mem;
  this->search_path = search_path;
  this->cmd_ev = cmd_ev;
}

int Shvar::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  syntax_asdl::command_t* block = nullptr;
  List<Tuple2<Str*, Str*>*>* pairs = nullptr;
  List<Str*>* args = nullptr;
  List<int>* arg_spids = nullptr;
  int i;
  Str* name = nullptr;
  Str* s = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &block, &pairs, &args, &arg_spids, &name, &s});

  Tuple2<args::_Attributes*, args::Reader*> tup17 = flag_spec::ParseCmdVal(str759, cmd_val, true);
  arg_r = tup17.at1();
  block = typed_args::GetOneBlock(cmd_val->typed_args);
  if (!block) {
    throw Alloc<error::Usage>(str760, runtime::NO_SPID);
  }
  pairs = Alloc<List<Tuple2<Str*, Str*>*>>();
  Tuple2<List<Str*>*, List<int>*> tup18 = arg_r->Rest2();
  args = tup18.at0();
  arg_spids = tup18.at1();
  if (len(args) == 0) {
    throw Alloc<error::Usage>(str761, runtime::NO_SPID);
  }
  i = 0;
  for (ListIter<Str*> it(args); !it.Done(); it.Next(), ++i) {
    Str* arg = it.Value();
    StackRoots _for({&arg  });
    Tuple2<Str*, Str*> tup19 = mylib::split_once(arg, str762);
    name = tup19.at0();
    s = tup19.at1();
    if (s == nullptr) {
      throw Alloc<error::Usage>(str763, arg_spids->index_(i));
    }
    pairs->append((Alloc<Tuple2<Str*, Str*>>(name, s)));
    if (str_equals(name, str764)) {
      this->search_path->ClearCache();
    }
  }
  {  // with
    state::ctx_Shvar ctx(this->mem, pairs);

  }
  return 0;
}

PushRegisters::PushRegisters(state::Mem* mem, cmd_eval::CommandEvaluator* cmd_ev)  {
  field_mask_ |= maskof_PushRegisters();
  this->mem = mem;
  this->cmd_ev = cmd_ev;
}

int PushRegisters::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  syntax_asdl::command_t* block = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &block});

  Tuple2<args::_Attributes*, args::Reader*> tup20 = flag_spec::ParseCmdVal(str765, cmd_val, true);
  arg_r = tup20.at1();
  block = typed_args::GetOneBlock(cmd_val->typed_args);
  if (!block) {
    throw Alloc<error::Usage>(str766, runtime::NO_SPID);
  }
  {  // with
    state::ctx_Registers ctx(this->mem);

  }
  return this->mem->last_status->index_(-1);
}

Fopen::Fopen(state::Mem* mem, cmd_eval::CommandEvaluator* cmd_ev)  {
  field_mask_ |= maskof_Fopen();
  this->mem = mem;
  this->cmd_ev = cmd_ev;
}

int Fopen::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::Reader* arg_r = nullptr;
  syntax_asdl::command_t* block = nullptr;
  StackRoots _roots({&cmd_val, &arg_r, &block});

  Tuple2<args::_Attributes*, args::Reader*> tup21 = flag_spec::ParseCmdVal(str767, cmd_val, true);
  arg_r = tup21.at1();
  block = typed_args::GetOneBlock(cmd_val->typed_args);
  if (!block) {
    throw Alloc<error::Usage>(str768, runtime::NO_SPID);
  }
  return 0;
}

}  // define namespace builtin_pure

namespace builtin_trap {  // define

using runtime_asdl::cmd_value__Argv;
namespace source = syntax_asdl::source;

TrapState::TrapState() 
    : Obj(Tag::FixedSize, maskof_TrapState(), sizeof(TrapState))  {
  this->hooks = Alloc<Dict<Str*, syntax_asdl::command_t*>>();
  this->traps = Alloc<Dict<int, syntax_asdl::command_t*>>();
  this->display = nullptr;
}

syntax_asdl::command_t* TrapState::GetHook(Str* hook_name) {
  StackRoots _roots({&hook_name});

  return this->hooks->get(hook_name, nullptr);
}

void TrapState::AddUserHook(Str* hook_name, syntax_asdl::command_t* handler) {
  StackRoots _roots({&hook_name, &handler});

  this->hooks->set(hook_name, handler);
}

void TrapState::RemoveUserHook(Str* hook_name) {
  StackRoots _roots({&hook_name});

  mylib::dict_remove(this->hooks, hook_name);
}

void TrapState::AddUserTrap(int sig_num, syntax_asdl::command_t* handler) {
  StackRoots _roots({&handler});

  this->traps->set(sig_num, handler);
  if (sig_num == SIGWINCH) {
    pyos::SetSigwinchCode(SIGWINCH);
  }
  else {
    pyos::RegisterSignalInterest(sig_num);
  }
}

void TrapState::RemoveUserTrap(int sig_num) {
  mylib::dict_remove(this->traps, sig_num);
  if (sig_num == SIGWINCH) {
    pyos::SetSigwinchCode(pyos::UNTRAPPED_SIGWINCH);
  }
  else {
    pyos::Sigaction(sig_num, SIG_DFL);
  }
}

void TrapState::InitShell() {
  pyos::InitShell();
}

void TrapState::InitInteractiveShell(comp_ui::_IDisplay* display, int my_pid) {
  StackRoots _roots({&display});

  pyos::Sigaction(SIGQUIT, SIG_IGN);
  pyos::Sigaction(SIGTSTP, SIG_IGN);
  pyos::Sigaction(SIGTTOU, SIG_IGN);
  pyos::Sigaction(SIGTTIN, SIG_IGN);
  this->display = display;
  pyos::RegisterSignalInterest(SIGWINCH);
  pyos::SetSigwinchCode(pyos::UNTRAPPED_SIGWINCH);
}

int TrapState::GetLastSignal() {
  return pyos::LastSignal();
}

List<syntax_asdl::command_t*>* TrapState::TakeRunList() {
  List<int>* sig_queue = nullptr;
  List<syntax_asdl::command_t*>* run_list = nullptr;
  syntax_asdl::command_t* node = nullptr;
  StackRoots _roots({&sig_queue, &run_list, &node});

  sig_queue = pyos::TakeSignalQueue();
  run_list = Alloc<List<syntax_asdl::command_t*>>();
  for (ListIter<int> it(sig_queue); !it.Done(); it.Next()) {
    int sig_num = it.Value();
    node = this->traps->get(sig_num, nullptr);
    if (sig_num == SIGWINCH) {
      if (node == nullptr) {
        continue;
      }
    }
    run_list->append(node);
  }
  return run_list;
}

int _GetSignalNumber(Str* sig_spec) {
  StackRoots _roots({&sig_spec});

  if ((str_equals(sig_spec->strip(), str769) || str_equals(sig_spec->strip(), str770) || str_equals(sig_spec->strip(), str771) || str_equals(sig_spec->strip(), str772) || str_equals(sig_spec->strip(), str773) || str_equals(sig_spec->strip(), str774) || str_equals(sig_spec->strip(), str775) || str_equals(sig_spec->strip(), str776))) {
    return to_int(sig_spec);
  }
  if (sig_spec->startswith(str777)) {
    sig_spec = sig_spec->slice(3);
  }
  return signal_def::GetNumber(sig_spec);
}
GLOBAL_LIST(Str*, 4, _HOOK_NAMES, {str778 COMMA str779 COMMA str780 COMMA str781});

Trap::Trap(builtin_trap::TrapState* trap_state, parse_lib::ParseContext* parse_ctx, dev::Tracer* tracer, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Trap();
  this->trap_state = trap_state;
  this->parse_ctx = parse_ctx;
  this->arena = parse_ctx->arena;
  this->tracer = tracer;
  this->errfmt = errfmt;
}

syntax_asdl::command_t* Trap::_ParseTrapCode(Str* code_str) {
  reader::FileLineReader* line_reader = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  syntax_asdl::source__ArgvWord* src = nullptr;
  syntax_asdl::command_t* node = nullptr;
  StackRoots _roots({&code_str, &line_reader, &c_parser, &src, &node});

  line_reader = reader::StringLineReader(code_str, this->arena);
  c_parser = this->parse_ctx->MakeOshParser(line_reader);
  src = Alloc<source::ArgvWord>(str782, runtime::NO_SPID);
  {  // with
    alloc::ctx_Location ctx(this->arena, src);

    try {
      node = main_loop::ParseWholeFile(c_parser);
    }
    catch (error::Parse* e) {
      this->errfmt->PrettyPrintError(e);
      return nullptr;
    }
  }
  return node;
}

int Trap::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  args::_Attributes* attrs = nullptr;
  args::Reader* arg_r = nullptr;
  arg_types::trap* arg = nullptr;
  Str* code_str = nullptr;
  Str* sig_spec = nullptr;
  int sig_spid;
  Str* sig_key = nullptr;
  int sig_num;
  syntax_asdl::command_t* node = nullptr;
  StackRoots _roots({&cmd_val, &attrs, &arg_r, &arg, &code_str, &sig_spec, &sig_key, &node});

  Tuple2<args::_Attributes*, args::Reader*> tup0 = flag_spec::ParseCmdVal(str783, cmd_val);
  attrs = tup0.at0();
  arg_r = tup0.at1();
  arg = Alloc<arg_types::trap>(attrs->attrs);
  if (arg->p) {
    for (DictIter<Str*, syntax_asdl::command_t*> it(this->trap_state->hooks); !it.Done(); it.Next()) {
      Str* name = it.Key();
      syntax_asdl::command_t* _ = it.Value();
      print(fmt198(name));
    }
    for (DictIter<int, syntax_asdl::command_t*> it(this->trap_state->traps); !it.Done(); it.Next()) {
      int sig_num = it.Key();
      syntax_asdl::command_t* _ = it.Value();
      print(fmt199(sig_num));
    }
    return 0;
  }
  if (arg->l) {
    for (ListIter<Str*> it(_HOOK_NAMES); !it.Done(); it.Next()) {
      Str* name = it.Value();
      StackRoots _for({&name    });
      print(fmt200(name));
    }
    signal_def::PrintSignals();
    return 0;
  }
  code_str = arg_r->ReadRequired(str787);
  Tuple2<Str*, int> tup1 = arg_r->ReadRequired2(str788);
  sig_spec = tup1.at0();
  sig_spid = tup1.at1();
  sig_key = nullptr;
  sig_num = signal_def::NO_SIGNAL;
  if (list_contains(_HOOK_NAMES, sig_spec)) {
    sig_key = sig_spec;
  }
  else {
    if (str_equals(sig_spec, str789)) {
      sig_key = str790;
    }
    else {
      sig_num = _GetSignalNumber(sig_spec);
      if (sig_num != signal_def::NO_SIGNAL) {
        sig_key = str(sig_num);
      }
    }
  }
  if (sig_key == nullptr) {
    this->errfmt->Print_(fmt201(sig_spec), cmd_val->arg_spids->index_(2));
    return 1;
  }
  if (str_equals(code_str, str792)) {
    if (list_contains(_HOOK_NAMES, sig_key)) {
      this->trap_state->RemoveUserHook(sig_key);
      return 0;
    }
    if (sig_num != signal_def::NO_SIGNAL) {
      this->trap_state->RemoveUserTrap(sig_num);
      return 0;
    }
    assert(0);  // AssertionError
  }
  node = this->_ParseTrapCode(code_str);
  if (node == nullptr) {
    return 1;
  }
  if (list_contains(_HOOK_NAMES, sig_key)) {
    if ((str_equals(sig_key, str794) || str_equals(sig_key, str795) || str_equals(sig_key, str796))) {
      println_stderr(fmt202(sig_spec));
    }
    this->trap_state->AddUserHook(sig_key, node);
    return 0;
  }
  if (sig_num != signal_def::NO_SIGNAL) {
    if ((sig_num == SIGKILL || sig_num == SIGSTOP)) {
      this->errfmt->Print_(fmt203(sig_spec), sig_spid);
      return 1;
    }
    this->trap_state->AddUserTrap(sig_num, node);
    return 0;
  }
  assert(0);  // AssertionError
}

}  // define namespace builtin_trap

namespace cmd_eval {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Id_str;
namespace option_i = option_asdl::option_i;
using syntax_asdl::compound_word;
namespace command_e = syntax_asdl::command_e;
using syntax_asdl::command_t;
using syntax_asdl::command__AndOr;
using syntax_asdl::command__Case;
using syntax_asdl::command__CommandList;
using syntax_asdl::command__ControlFlow;
using syntax_asdl::command__DBracket;
using syntax_asdl::command__DoGroup;
using syntax_asdl::command__DParen;
using syntax_asdl::command__ExpandedAlias;
using syntax_asdl::command__Expr;
using syntax_asdl::command__ForEach;
using syntax_asdl::command__ForExpr;
using syntax_asdl::command__If;
using syntax_asdl::command__NoOp;
using syntax_asdl::command__Pipeline;
using syntax_asdl::command__PlaceMutation;
using syntax_asdl::command__Proc;
using syntax_asdl::command__Sentence;
using syntax_asdl::command__ShAssignment;
using syntax_asdl::command__ShFunction;
using syntax_asdl::command__Simple;
using syntax_asdl::command__Subshell;
using syntax_asdl::command__TimeBlock;
using syntax_asdl::command__VarDecl;
using syntax_asdl::command__WhileUntil;
namespace condition_e = syntax_asdl::condition_e;
using syntax_asdl::condition_t;
using syntax_asdl::condition__Shell;
using syntax_asdl::condition__Oil;
using syntax_asdl::BraceGroup;
using syntax_asdl::expr__BlockArg;
using syntax_asdl::ArgList;
using syntax_asdl::assign_op_e;
using syntax_asdl::place_expr__Var;
namespace proc_sig_e = syntax_asdl::proc_sig_e;
using syntax_asdl::proc_sig__Closed;
namespace redir_param_e = syntax_asdl::redir_param_e;
using syntax_asdl::redir_param__HereDoc;
namespace proc_sig = syntax_asdl::proc_sig;
namespace for_iter_e = syntax_asdl::for_iter_e;
using syntax_asdl::for_iter__Words;
using syntax_asdl::for_iter__Oil;
using syntax_asdl::Token;
using syntax_asdl::expr_t;
namespace lvalue = runtime_asdl::lvalue;
namespace lvalue_e = runtime_asdl::lvalue_e;
using runtime_asdl::lvalue__ObjIndex;
using runtime_asdl::lvalue__ObjAttr;
namespace value = runtime_asdl::value;
namespace value_e = runtime_asdl::value_e;
using runtime_asdl::value_t;
using runtime_asdl::value__Str;
using runtime_asdl::value__MaybeStrArray;
using runtime_asdl::redirect;
namespace redirect_arg = runtime_asdl::redirect_arg;
using runtime_asdl::scope_e;
namespace cmd_value_e = runtime_asdl::cmd_value_e;
using runtime_asdl::cmd_value__Argv;
using runtime_asdl::cmd_value__Assign;
using runtime_asdl::CommandStatus;
using runtime_asdl::StatusArray;
using runtime_asdl::Proc;
using types_asdl::redir_arg_type_e;
using error::_ControlFlow;
int IsMainProgram = (1 << 0);
int RaiseControlFlow = (1 << 1);
int Optimize = (1 << 2);
Dict<Str*, Str*> gdict0(std::initializer_list<Str*>{}, std::initializer_list<Str*>{});
Dict<Str*, Str*>* OIL_TYPE_NAMES = &gdict0;

Deps::Deps() 
    : Obj(Tag::FixedSize, maskof_Deps(), sizeof(Deps))  {
  this->mutable_opts = nullptr;
  this->dumper = nullptr;
  this->debug_f = nullptr;
}

int _PackFlags(int keyword_id) {
  return _PackFlags(keyword_id, 0);
}

int _PackFlags(int keyword_id, int flags) {
  return ((keyword_id << 8) | flags);
}

bool _HasManyStatuses(syntax_asdl::command_t* node) {
  syntax_asdl::command_t* UP_node = nullptr;
  StackRoots _roots({&node, &UP_node});

  if (node->tag_() == command_e::Sentence) {
    command__Sentence* node1 = static_cast<command__Sentence*>(node);
    return _HasManyStatuses(node1->child);
  }
  UP_node = node;
  switch (node->tag_()) {
    case command_e::Simple: 
    case command_e::DBracket: 
    case command_e::DParen: {
      return false;
    }
      break;
    case command_e::Pipeline: {
      command__Pipeline* node = static_cast<command__Pipeline*>(UP_node);
      if (len(node->children) == 1) {
        return _HasManyStatuses(node->children->index_(0));
      }
      else {
        return true;
      }
    }
      break;
  }
  return true;
}

runtime_asdl::value_t* PlusEquals(runtime_asdl::value_t* old_val, runtime_asdl::value_t* val) {
  runtime_asdl::value_t* UP_old_val = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  int old_tag;
  int tag;
  List<Str*>* strs = nullptr;
  StackRoots _roots({&old_val, &val, &UP_old_val, &UP_val, &strs});

  UP_old_val = old_val;
  UP_val = val;
  old_tag = old_val->tag_();
  tag = val->tag_();
  if ((old_tag == value_e::Undef and tag == value_e::Str)) {
    ;  // pass
  }
  else {
    if ((old_tag == value_e::Undef and tag == value_e::MaybeStrArray)) {
      ;  // pass
    }
    else {
      if ((old_tag == value_e::Str and tag == value_e::Str)) {
        value__Str* old_val = static_cast<value__Str*>(UP_old_val);
        value__Str* str_to_append = static_cast<value__Str*>(UP_val);
        val = Alloc<value::Str>(str_concat(old_val->s, str_to_append->s));
      }
      else {
        if ((old_tag == value_e::Str and tag == value_e::MaybeStrArray)) {
          e_die(str800);
        }
        else {
          if ((old_tag == value_e::MaybeStrArray and tag == value_e::Str)) {
            e_die(str801);
          }
          else {
            if ((old_tag == value_e::MaybeStrArray and tag == value_e::MaybeStrArray)) {
              value__MaybeStrArray* old_val = static_cast<value__MaybeStrArray*>(UP_old_val);
              value__MaybeStrArray* to_append = static_cast<value__MaybeStrArray*>(UP_val);
              strs = Alloc<List<Str*>>();
              strs->extend(old_val->strs);
              strs->extend(to_append->strs);
              val = Alloc<value::MaybeStrArray>(strs);
            }
          }
        }
      }
    }
  }
  return val;
}

ctx_LoopLevel::ctx_LoopLevel(cmd_eval::CommandEvaluator* cmd_ev) 
    : Obj(Tag::FixedSize, maskof_ctx_LoopLevel(), sizeof(ctx_LoopLevel))  {
  cmd_ev->loop_level += 1;
  this->cmd_ev = cmd_ev;
}

ctx_LoopLevel::~ctx_LoopLevel(){
  this->cmd_ev->loop_level -= 1;
}

CommandEvaluator::CommandEvaluator(state::Mem* mem, optview::Exec* exec_opts, ui::ErrorFormatter* errfmt, Dict<Str*, runtime_asdl::Proc*>* procs, Dict<int, vm::_AssignBuiltin*>* assign_builtins, alloc::Arena* arena, cmd_eval::Deps* cmd_deps, builtin_trap::TrapState* trap_state) 
    : Obj(Tag::FixedSize, maskof_CommandEvaluator(), sizeof(CommandEvaluator))  {
  this->shell_ex = nullptr;
  this->arith_ev = nullptr;
  this->bool_ev = nullptr;
  this->expr_ev = nullptr;
  this->word_ev = nullptr;
  this->tracer = nullptr;
  this->mem = mem;
  this->exec_opts = exec_opts;
  this->errfmt = errfmt;
  this->procs = procs;
  this->assign_builtins = assign_builtins;
  this->arena = arena;
  this->mutable_opts = cmd_deps->mutable_opts;
  this->dumper = cmd_deps->dumper;
  this->debug_f = cmd_deps->debug_f;
  this->trap_state = trap_state;
  this->loop_level = 0;
  this->check_command_sub_status = false;
}

void CommandEvaluator::CheckCircularDeps() {
}

int CommandEvaluator::_RunAssignBuiltin(runtime_asdl::cmd_value__Assign* cmd_val) {
  vm::_AssignBuiltin* builtin_func = nullptr;
  int status;
  Str* arg0 = nullptr;
  StackRoots _roots({&cmd_val, &builtin_func, &arg0});

  builtin_func = this->assign_builtins->get(cmd_val->builtin_id);
  if (builtin_func == nullptr) {
    e_die(fmt204(cmd_val->argv->index_(0)), cmd_val->arg_spids->index_(0));
  }
  {  // with
    ui::ctx_Location ctx(this->errfmt, cmd_val->arg_spids->index_(0));

    try {
      try {
        status = builtin_func->Run(cmd_val);
      }
      catch (error::Usage* e) {
        arg0 = cmd_val->argv->index_(0);
        if (e->span_id == runtime::NO_SPID) {
          e->span_id = this->errfmt->CurrentLocation();
        }
        this->errfmt->PrefixPrint(e->msg, fmt205(arg0), e->span_id);
        status = 2;
      }
    }
    catch (std::exception) { }
  }
  return status;
}

int CommandEvaluator::_SpanIdForShAssignment(syntax_asdl::command__ShAssignment* node) {
  StackRoots _roots({&node});

  return node->spids->index_(0);
}

void CommandEvaluator::_CheckStatus(int status, runtime_asdl::CommandStatus* cmd_st, syntax_asdl::command_t* node, int blame_spid) {
  syntax_asdl::command_t* UP_node = nullptr;
  Str* desc = nullptr;
  int span_id;
  Str* msg = nullptr;
  StackRoots _roots({&cmd_st, &node, &UP_node, &desc, &msg});

  if ((this->exec_opts->errexit() and status != 0)) {
    UP_node = node;
    switch (node->tag_()) {
      case command_e::Simple: {
        command__Simple* node = static_cast<command__Simple*>(UP_node);
        desc = str804;
        span_id = location::SpanForCommand(node);
      }
        break;
      case command_e::ShAssignment: {
        command__ShAssignment* node = static_cast<command__ShAssignment*>(UP_node);
        cmd_st->show_code = true;
        desc = str805;
        span_id = this->_SpanIdForShAssignment(node);
      }
        break;
      case command_e::Subshell: {
        command__Subshell* node = static_cast<command__Subshell*>(UP_node);
        cmd_st->show_code = true;
        desc = str806;
        span_id = node->spids->index_(0);
      }
        break;
      case command_e::Pipeline: {
        command__Pipeline* node = static_cast<command__Pipeline*>(UP_node);
        cmd_st->show_code = true;
        desc = str807;
        span_id = node->spids->index_(0);
      }
        break;
      default: {
        desc = ui::CommandType(node);
        span_id = runtime::NO_SPID;
      }
    }
    if (blame_spid != runtime::NO_SPID) {
      span_id = blame_spid;
    }
    msg = fmt206(desc, status);
    throw Alloc<error::ErrExit>(msg, span_id, status, cmd_st->show_code);
  }
}

runtime_asdl::redirect* CommandEvaluator::_EvalRedirect(syntax_asdl::redir* r) {
  runtime_asdl::redirect* result = nullptr;
  syntax_asdl::redir_param_t* arg = nullptr;
  syntax_asdl::redir_param_t* UP_arg = nullptr;
  types_asdl::redir_arg_type_t redir_type;
  runtime_asdl::value__Str* val = nullptr;
  Str* filename = nullptr;
  Str* t = nullptr;
  int target_fd;
  syntax_asdl::compound_word* w = nullptr;
  StackRoots _roots({&r, &result, &arg, &UP_arg, &val, &filename, &t, &w});

  result = Alloc<redirect>(r->op->id, r->op->span_id, r->loc, nullptr);
  arg = r->arg;
  UP_arg = arg;
  switch (arg->tag_()) {
    case redir_param_e::Word: {
      compound_word* arg_word = static_cast<compound_word*>(UP_arg);
      this->mem->SetCurrentSpanId(r->op->span_id);
      redir_type = consts::RedirArgType(r->op->id);
      if (redir_type == redir_arg_type_e::Path) {
        val = this->word_ev->EvalWordToString(arg_word);
        filename = val->s;
        if (len(filename) == 0) {
          throw Alloc<error::RedirectEval>(str809, arg_word);
        }
        result->arg = Alloc<redirect_arg::Path>(filename);
        return result;
      }
      else {
        if (redir_type == redir_arg_type_e::Desc) {
          val = this->word_ev->EvalWordToString(arg_word);
          t = val->s;
          if (len(t) == 0) {
            throw Alloc<error::RedirectEval>(str810, arg_word);
            return nullptr;
          }
          try {
            if (maybe_str_equals(t, str811)) {
              result->arg = Alloc<redirect_arg::CloseFd>();
            }
            else {
              if (str_equals(t->index_(-1), str812)) {
                target_fd = to_int(t->slice(0, -1));
                result->arg = Alloc<redirect_arg::MoveFd>(target_fd);
              }
              else {
                result->arg = Alloc<redirect_arg::CopyFd>(to_int(t));
              }
            }
          }
          catch (ValueError*) {
            throw Alloc<error::RedirectEval>(fmt207(t), arg_word);
            return nullptr;
          }
          return result;
        }
        else {
          if (redir_type == redir_arg_type_e::Here) {
            val = this->word_ev->EvalWordToString(arg_word);
            result->arg = Alloc<redirect_arg::HereDoc>(str_concat(val->s, str814));
            return result;
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
      break;
    case redir_param_e::HereDoc: {
      redir_param__HereDoc* arg = static_cast<redir_param__HereDoc*>(UP_arg);
      w = Alloc<compound_word>(arg->stdin_parts);
      val = this->word_ev->EvalWordToString(w);
      result->arg = Alloc<redirect_arg::HereDoc>(val->s);
      return result;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  assert(0);  // AssertionError
}

List<runtime_asdl::redirect*>* CommandEvaluator::_EvalRedirects(syntax_asdl::command_t* node) {
  syntax_asdl::command_t* UP_node = nullptr;
  List<syntax_asdl::redir*>* redirects = nullptr;
  List<runtime_asdl::redirect*>* result = nullptr;
  StackRoots _roots({&node, &UP_node, &redirects, &result});

  UP_node = node;
  switch (node->tag_()) {
    case command_e::Simple: {
      command__Simple* node = static_cast<command__Simple*>(UP_node);
      redirects = node->redirects;
    }
      break;
    case command_e::ExpandedAlias: {
      command__ExpandedAlias* node = static_cast<command__ExpandedAlias*>(UP_node);
      redirects = node->redirects;
    }
      break;
    case command_e::ShAssignment: {
      command__ShAssignment* node = static_cast<command__ShAssignment*>(UP_node);
      redirects = node->redirects;
    }
      break;
    case command_e::BraceGroup: {
      BraceGroup* node = static_cast<BraceGroup*>(UP_node);
      redirects = node->redirects;
    }
      break;
    case command_e::Subshell: {
      command__Subshell* node = static_cast<command__Subshell*>(UP_node);
      redirects = node->redirects;
    }
      break;
    case command_e::DParen: {
      command__DParen* node = static_cast<command__DParen*>(UP_node);
      redirects = node->redirects;
    }
      break;
    case command_e::DBracket: {
      command__DBracket* node = static_cast<command__DBracket*>(UP_node);
      redirects = node->redirects;
    }
      break;
    case command_e::ForEach: {
      command__ForEach* node = static_cast<command__ForEach*>(UP_node);
      redirects = node->redirects;
    }
      break;
    case command_e::ForExpr: {
      command__ForExpr* node = static_cast<command__ForExpr*>(UP_node);
      redirects = node->redirects;
    }
      break;
    case command_e::WhileUntil: {
      command__WhileUntil* node = static_cast<command__WhileUntil*>(UP_node);
      redirects = node->redirects;
    }
      break;
    case command_e::If: {
      command__If* node = static_cast<command__If*>(UP_node);
      redirects = node->redirects;
    }
      break;
    case command_e::Case: {
      command__Case* node = static_cast<command__Case*>(UP_node);
      redirects = node->redirects;
    }
      break;
    default: {
      redirects = Alloc<List<syntax_asdl::redir*>>();
    }
  }
  result = Alloc<List<runtime_asdl::redirect*>>();
  for (ListIter<syntax_asdl::redir*> it(redirects); !it.Done(); it.Next()) {
    syntax_asdl::redir* redir = it.Value();
    StackRoots _for({&redir  });
    result->append(this->_EvalRedirect(redir));
  }
  return result;
}

int CommandEvaluator::_RunSimpleCommand(runtime_asdl::cmd_value_t* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork) {
  runtime_asdl::cmd_value_t* UP_cmd_val = nullptr;
  StackRoots _roots({&cmd_val, &cmd_st, &UP_cmd_val});

  UP_cmd_val = cmd_val;
  switch (UP_cmd_val->tag_()) {
    case cmd_value_e::Argv: {
      cmd_value__Argv* cmd_val = static_cast<cmd_value__Argv*>(UP_cmd_val);
      this->tracer->OnSimpleCommand(cmd_val->argv);
      return this->shell_ex->RunSimpleCommand(cmd_val, cmd_st, do_fork);
    }
      break;
    case cmd_value_e::Assign: {
      cmd_value__Assign* cmd_val = static_cast<cmd_value__Assign*>(UP_cmd_val);
      this->tracer->OnAssignBuiltin(cmd_val);
      return this->_RunAssignBuiltin(cmd_val);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

void CommandEvaluator::_EvalTempEnv(List<syntax_asdl::env_pair*>* more_env, int flags) {
  runtime_asdl::value__Str* val = nullptr;
  StackRoots _roots({&more_env, &val});

  for (ListIter<syntax_asdl::env_pair*> it(more_env); !it.Done(); it.Next()) {
    syntax_asdl::env_pair* e_pair = it.Value();
    StackRoots _for({&e_pair  });
    val = this->word_ev->EvalWordToString(e_pair->val);
    this->mem->SetValue(Alloc<lvalue::Named>(e_pair->name), val, scope_e::LocalOnly, flags);
  }
}

void CommandEvaluator::_StrictErrExit(syntax_asdl::command_t* node) {
  Str* node_str = nullptr;
  StackRoots _roots({&node, &node_str});

  if (!(this->exec_opts->errexit() and this->exec_opts->strict_errexit())) {
    return ;
  }
  if (_HasManyStatuses(node)) {
    node_str = ui::CommandType(node);
    e_die(fmt208(node_str), location::SpanForCommand(node));
  }
}

void CommandEvaluator::_StrictErrExitList(List<syntax_asdl::command_t*>* node_list) {
  syntax_asdl::command_t* node = nullptr;
  Str* node_str = nullptr;
  StackRoots _roots({&node_list, &node, &node_str});

  if (!(this->exec_opts->errexit() and this->exec_opts->strict_errexit())) {
    return ;
  }
  if (len(node_list) > 1) {
    e_die(fmt209(), location::SpanForCommand(node_list->index_(0)));
  }
  node = node_list->index_(0);
  if (_HasManyStatuses(node)) {
    node_str = ui::CommandType(node);
    e_die(fmt210(node_str), location::SpanForCommand(node));
  }
}

bool CommandEvaluator::_EvalCondition(syntax_asdl::condition_t* cond, int spid) {
  bool b;
  syntax_asdl::condition_t* UP_cond = nullptr;
  int cond_status;
  StackRoots _roots({&cond, &UP_cond});

  b = false;
  UP_cond = cond;
  switch (cond->tag_()) {
    case condition_e::Shell: {
      condition__Shell* cond = static_cast<condition__Shell*>(UP_cond);
      this->_StrictErrExitList(cond->commands);
      {  // with
        state::ctx_ErrExit ctx(this->mutable_opts, false, spid);

        cond_status = this->_ExecuteList(cond->commands);
      }
      b = cond_status == 0;
    }
      break;
    case condition_e::Oil: {
    }
      break;
  }
  return b;
}

int CommandEvaluator::_Dispatch(syntax_asdl::command_t* node, runtime_asdl::CommandStatus* cmd_st) {
  syntax_asdl::command_t* UP_node = nullptr;
  int span_id;
  List<syntax_asdl::compound_word*>* words = nullptr;
  runtime_asdl::cmd_value_t* cmd_val = nullptr;
  runtime_asdl::cmd_value_t* UP_cmd_val = nullptr;
  syntax_asdl::ArgList* typed_args = nullptr;
  syntax_asdl::expr__BlockArg* block_expr = nullptr;
  bool is_other_special;
  int status;
  int left_spid;
  bool result;
  int i;
  runtime_asdl::scope_t which_scopes;
  int spid;
  runtime_asdl::value_t* rhs = nullptr;
  runtime_asdl::lvalue_t* lval = nullptr;
  runtime_asdl::value_t* old_val = nullptr;
  runtime_asdl::value_t* val = nullptr;
  int flags;
  int last_status;
  syntax_asdl::Token* tok = nullptr;
  runtime_asdl::value__Str* str_val = nullptr;
  int arg;
  bool ok;
  Str* msg = nullptr;
  syntax_asdl::command_t* left = nullptr;
  int n;
  syntax_asdl::command_t* child = nullptr;
  int op_id;
  bool b;
  List<Str*>* iter_list = nullptr;
  syntax_asdl::expr_t* iter_expr = nullptr;
  syntax_asdl::Token* iter_blame = nullptr;
  syntax_asdl::for_iter_t* iterable = nullptr;
  syntax_asdl::for_iter_t* UP_iterable = nullptr;
  syntax_asdl::Token* iter_expr_blame = nullptr;
  runtime_asdl::lvalue__Named* i_name = nullptr;
  runtime_asdl::lvalue__Named* val_name = nullptr;
  int index;
  syntax_asdl::arith_expr_t* init = nullptr;
  syntax_asdl::arith_expr_t* for_cond = nullptr;
  syntax_asdl::command_t* body = nullptr;
  syntax_asdl::arith_expr_t* update = nullptr;
  int cond_int;
  List<runtime_asdl::value_t*>* defaults = nullptr;
  bool done;
  Str* to_match = nullptr;
  runtime_asdl::value__Str* pat_val = nullptr;
  double s_real;
  double s_user;
  double s_sys;
  double e_real;
  double e_user;
  double e_sys;
  StackRoots _roots({&node, &cmd_st, &UP_node, &words, &cmd_val, &UP_cmd_val, &typed_args, &block_expr, &rhs, &lval, &old_val, &val, &tok, &str_val, &msg, &left, &child, &iter_list, &iter_expr, &iter_blame, &iterable, &UP_iterable, &iter_expr_blame, &i_name, &val_name, &init, &for_cond, &body, &update, &defaults, &to_match, &pat_val});

  this->check_command_sub_status = false;
  UP_node = node;
  switch (node->tag_()) {
    case command_e::Simple: {
      command__Simple* node = static_cast<command__Simple*>(UP_node);
      cmd_st->check_errexit = true;
      if (len(node->words)) {
        span_id = word_::LeftMostSpanForWord(node->words->index_(0));
        if (span_id != runtime::NO_SPID) {
          this->mem->SetCurrentSpanId(span_id);
        }
      }
      words = braces::BraceExpandWords(node->words);
      cmd_val = this->word_ev->EvalWordSequence2(words, true);
      UP_cmd_val = cmd_val;
      if (UP_cmd_val->tag_() == cmd_value_e::Argv) {
        cmd_value__Argv* cmd_val = static_cast<cmd_value__Argv*>(UP_cmd_val);
        typed_args = nullptr;
        if (node->typed_args) {
          typed_args = Alloc<ArgList>(list(node->typed_args->positional), node->typed_args->named);
          typed_args->spids = node->typed_args->spids;
          if (node->block) {
            block_expr = Alloc<expr__BlockArg>(node->block);
            typed_args->positional->append(block_expr);
          }
        }
        else {
          if (node->block) {
            typed_args = Alloc<ArgList>();
            block_expr = Alloc<expr__BlockArg>(node->block);
            typed_args->positional->append(block_expr);
            typed_args->spids->append(node->block->spids->index_(0));
          }
        }
        cmd_val->typed_args = typed_args;
      }
      else {
        if (node->block) {
          e_die(fmt211(), node->block->spids->index_(0));
        }
        cmd_value__Assign* cmd_val = static_cast<cmd_value__Assign*>(UP_cmd_val);
      }
      if (len(node->more_env)) {
        is_other_special = false;
        if ((cmd_val->tag_() == cmd_value_e::Assign or is_other_special)) {
          this->_EvalTempEnv(node->more_env, 0);
          status = this->_RunSimpleCommand(cmd_val, cmd_st, node->do_fork);
        }
        else {
          {  // with
            state::ctx_Temp ctx(this->mem);

            this->_EvalTempEnv(node->more_env, state::SetExport);
            status = this->_RunSimpleCommand(cmd_val, cmd_st, node->do_fork);
          }
        }
      }
      else {
        status = this->_RunSimpleCommand(cmd_val, cmd_st, node->do_fork);
      }
    }
      break;
    case command_e::ExpandedAlias: {
      command__ExpandedAlias* node = static_cast<command__ExpandedAlias*>(UP_node);
      if (len(node->more_env)) {
        {  // with
          state::ctx_Temp ctx(this->mem);

          this->_EvalTempEnv(node->more_env, state::SetExport);
          status = this->_Execute(node->child);
        }
      }
      else {
        status = this->_Execute(node->child);
      }
    }
      break;
    case command_e::Sentence: {
      command__Sentence* node = static_cast<command__Sentence*>(UP_node);
      if (node->terminator->id == Id::Op_Semi) {
        status = this->_Execute(node->child);
      }
      else {
        status = this->shell_ex->RunBackgroundJob(node->child);
      }
    }
      break;
    case command_e::Pipeline: {
      command__Pipeline* node = static_cast<command__Pipeline*>(UP_node);
      cmd_st->check_errexit = true;
      if (len(node->stderr_indices)) {
        e_die(fmt212(), node->spids->index_(0));
      }
      if (node->negated) {
        this->_StrictErrExit(node);
        cmd_st->pipe_negated = true;
        {  // with
          state::ctx_ErrExit ctx(this->mutable_opts, false, node->spids->index_(0));

          this->shell_ex->RunPipeline(node, cmd_st);
        }
        cmd_st->check_errexit = false;
      }
      else {
        this->shell_ex->RunPipeline(node, cmd_st);
      }
      status = -1;
    }
      break;
    case command_e::Subshell: {
      command__Subshell* node = static_cast<command__Subshell*>(UP_node);
      cmd_st->check_errexit = true;
      status = this->shell_ex->RunSubshell(node->child);
    }
      break;
    case command_e::DBracket: {
      command__DBracket* node = static_cast<command__DBracket*>(UP_node);
      left_spid = node->spids->index_(0);
      this->mem->SetCurrentSpanId(left_spid);
      this->tracer->PrintSourceCode(left_spid, node->spids->index_(1), this->arena);
      cmd_st->check_errexit = true;
      cmd_st->show_code = true;
      result = this->bool_ev->EvalB(node->expr);
      status = result ? 0 : 1;
    }
      break;
    case command_e::DParen: {
      command__DParen* node = static_cast<command__DParen*>(UP_node);
      left_spid = node->spids->index_(0);
      this->mem->SetCurrentSpanId(left_spid);
      this->tracer->PrintSourceCode(left_spid, node->spids->index_(1), this->arena);
      cmd_st->check_errexit = true;
      cmd_st->show_code = true;
      i = this->arith_ev->EvalToInt(node->child);
      status = i == 0 ? 1 : 0;
    }
      break;
    case command_e::VarDecl: {
      command__VarDecl* node = static_cast<command__VarDecl*>(UP_node);
      status = 0;
    }
      break;
    case command_e::PlaceMutation: {
      status = 0;
    }
      break;
    case command_e::ShAssignment: {
      command__ShAssignment* node = static_cast<command__ShAssignment*>(UP_node);
      which_scopes = this->mem->ScopesForWriting();
      for (ListIter<syntax_asdl::assign_pair*> it(node->pairs); !it.Done(); it.Next()) {
        syntax_asdl::assign_pair* pair = it.Value();
        StackRoots _for({&pair      });
        spid = pair->spids->index_(0);
        this->mem->SetCurrentSpanId(spid);
        if (pair->op == assign_op_e::PlusEqual) {
          rhs = this->word_ev->EvalRhsWord(pair->rhs);
          lval = this->arith_ev->EvalShellLhs(pair->lhs, spid, which_scopes);
          old_val = sh_expr_eval::OldValue(lval, this->mem, nullptr);
          val = PlusEquals(old_val, rhs);
        }
        else {
          lval = this->arith_ev->EvalShellLhs(pair->lhs, spid, which_scopes);
          if (pair->rhs) {
            val = this->word_ev->EvalRhsWord(pair->rhs);
          }
          else {
            val = nullptr;
          }
        }
        flags = 0;
        this->mem->SetValue(lval, val, which_scopes, flags);
        this->tracer->OnShAssignment(lval, pair->op, val, flags, which_scopes);
      }
      if (this->check_command_sub_status) {
        last_status = this->mem->LastStatus();
        this->_CheckStatus(last_status, cmd_st, node, runtime::NO_SPID);
        status = last_status;
      }
      else {
        status = 0;
      }
    }
      break;
    case command_e::Expr: {
      command__Expr* node = static_cast<command__Expr*>(UP_node);
      status = 0;
    }
      break;
    case command_e::ControlFlow: {
      command__ControlFlow* node = static_cast<command__ControlFlow*>(UP_node);
      tok = node->token;
      if (node->arg_word) {
        str_val = this->word_ev->EvalWordToString(node->arg_word);
        if ((len(str_val->s) == 0 and !this->exec_opts->strict_control_flow())) {
          arg = 0;
        }
        else {
          try {
            arg = to_int(str_val->s);
          }
          catch (ValueError*) {
            e_die(fmt213(node->token->val, str_val->s), node->arg_word);
          }
        }
      }
      else {
        if ((tok->id == Id::ControlFlow_Exit || tok->id == Id::ControlFlow_Return)) {
          arg = this->mem->LastStatus();
        }
        else {
          arg = 0;
        }
      }
      this->tracer->OnControlFlow(tok->val, arg);
      ok = true;
      if (((tok->id == Id::ControlFlow_Break || tok->id == Id::ControlFlow_Continue) and this->loop_level == 0)) {
        ok = false;
      }
      if (ok) {
        if (tok->id == Id::ControlFlow_Exit) {
          throw Alloc<util::UserExit>(arg);
        }
        else {
          throw Alloc<_ControlFlow>(tok, arg);
        }
      }
      else {
        msg = str824;
        if (this->exec_opts->strict_control_flow()) {
          e_die(dynamic_fmt_dummy(), tok);
        }
        else {
          this->errfmt->PrefixPrint(msg, str825, tok->span_id);
          status = 0;
        }
      }
    }
      break;
    case command_e::CommandList: {
      command__CommandList* node = static_cast<command__CommandList*>(UP_node);
      status = this->_ExecuteList(node->children);
      cmd_st->check_errexit = false;
    }
      break;
    case command_e::DoGroup: {
      command__DoGroup* node = static_cast<command__DoGroup*>(UP_node);
      status = this->_ExecuteList(node->children);
      cmd_st->check_errexit = false;
    }
      break;
    case command_e::BraceGroup: {
      BraceGroup* node = static_cast<BraceGroup*>(UP_node);
      status = this->_ExecuteList(node->children);
      cmd_st->check_errexit = false;
    }
      break;
    case command_e::AndOr: {
      command__AndOr* node = static_cast<command__AndOr*>(UP_node);
      left = node->children->index_(0);
      this->_StrictErrExit(left);
      {  // with
        state::ctx_ErrExit ctx(this->mutable_opts, false, node->spids->index_(0));

        status = this->_Execute(left);
      }
      i = 1;
      n = len(node->children);
      while (i < n) {
        child = node->children->index_(i);
        op_id = node->ops->index_((i - 1));
        if ((op_id == Id::Op_DPipe and status == 0)) {
          i += 1;
          continue;
        }
        else {
          if ((op_id == Id::Op_DAmp and status != 0)) {
            i += 1;
            continue;
          }
        }
        if (i == (n - 1)) {
          status = this->_Execute(child);
          cmd_st->check_errexit = true;
        }
        else {
          this->_StrictErrExit(child);
          {  // with
            state::ctx_ErrExit ctx(this->mutable_opts, false, node->spids->index_(i));

            status = this->_Execute(child);
          }
        }
        i += 1;
      }
    }
      break;
    case command_e::WhileUntil: {
      command__WhileUntil* node = static_cast<command__WhileUntil*>(UP_node);
      status = 0;
      {  // with
        ctx_LoopLevel ctx(this);

        while (true) {
          try {
            b = this->_EvalCondition(node->cond, node->spids->index_(0));
            if (node->keyword->id == Id::KW_Until) {
              b = !b;
            }
            if (!b) {
              break;
            }
            status = this->_Execute(node->body);
          }
          catch (_ControlFlow* e) {
            if (e->IsBreak()) {
              status = 0;
              break;
            }
            else {
              if (e->IsContinue()) {
                status = 0;
                continue;
              }
              else {
                throw ;
              }
            }
          }
        }
      }
    }
      break;
    case command_e::ForEach: {
      command__ForEach* node = static_cast<command__ForEach*>(UP_node);
      this->mem->SetCurrentSpanId(node->spids->index_(0));
      iter_list = nullptr;
      iter_expr = nullptr;
      iter_blame = nullptr;
      iterable = node->iterable;
      UP_iterable = iterable;
      switch (node->iterable->tag_()) {
        case for_iter_e::Args: {
          iter_list = this->mem->GetArgv();
        }
          break;
        case for_iter_e::Words: {
          for_iter__Words* iterable = static_cast<for_iter__Words*>(UP_iterable);
          words = braces::BraceExpandWords(iterable->words);
          iter_list = this->word_ev->EvalWordSequence(words);
        }
          break;
        case for_iter_e::Oil: {
          for_iter__Oil* iterable = static_cast<for_iter__Oil*>(UP_iterable);
          iter_expr = iterable->e;
          iter_expr_blame = iterable->blame;
        }
          break;
      }
      status = 0;
      if (iter_list == nullptr) {
      }
      else {
        {  // with
          ctx_LoopLevel ctx(this);

          n = len(node->iter_names);
          if (n == 1) {
            i_name = nullptr;
            val_name = Alloc<lvalue::Named>(node->iter_names->index_(0));
          }
          else {
            if (n == 2) {
              i_name = Alloc<lvalue::Named>(node->iter_names->index_(0));
              val_name = Alloc<lvalue::Named>(node->iter_names->index_(1));
            }
            else {
              e_die_status(2, str826, node->spids->index_(0));
            }
          }
          index = 0;
          for (ListIter<Str*> it(iter_list); !it.Done(); it.Next()) {
            Str* x = it.Value();
            StackRoots _for({&x          });
            this->mem->SetValue(val_name, Alloc<value::Str>(x), scope_e::LocalOnly);
            try {
              status = this->_Execute(node->body);
            }
            catch (_ControlFlow* e) {
              if (e->IsBreak()) {
                status = 0;
                break;
              }
              else {
                if (e->IsContinue()) {
                  status = 0;
                }
                else {
                  throw ;
                }
              }
            }
            index += 1;
          }
        }
      }
    }
      break;
    case command_e::ForExpr: {
      command__ForExpr* node = static_cast<command__ForExpr*>(UP_node);
      status = 0;
      init = node->init;
      for_cond = node->cond;
      body = node->body;
      update = node->update;
      if (init) {
        this->arith_ev->Eval(init);
      }
      {  // with
        ctx_LoopLevel ctx(this);

        while (true) {
          if (for_cond) {
            cond_int = this->arith_ev->EvalToInt(for_cond);
            if (cond_int == 0) {
              break;
            }
          }
          try {
            status = this->_Execute(body);
          }
          catch (_ControlFlow* e) {
            if (e->IsBreak()) {
              status = 0;
              break;
            }
            else {
              if (e->IsContinue()) {
                status = 0;
              }
              else {
                throw ;
              }
            }
          }
          if (update) {
            this->arith_ev->Eval(update);
          }
        }
      }
    }
      break;
    case command_e::ShFunction: {
      command__ShFunction* node = static_cast<command__ShFunction*>(UP_node);
      if ((dict_contains(this->procs, node->name) and !this->exec_opts->redefine_proc())) {
        e_die(fmt214(node->name), node->spids->index_(1));
      }
      this->procs->set(node->name, Alloc<Proc>(node->name, node->spids->index_(1), Alloc<proc_sig::Open>(), node->body, Alloc<List<runtime_asdl::value_t*>>(), true));
      status = 0;
    }
      break;
    case command_e::Proc: {
      command__Proc* node = static_cast<command__Proc*>(UP_node);
      if ((dict_contains(this->procs, node->name->val) and !this->exec_opts->redefine_proc())) {
        e_die(fmt215(node->name->val), node->name->span_id);
      }
      defaults = nullptr;
      this->procs->set(node->name->val, Alloc<Proc>(node->name->val, node->name->span_id, node->sig, node->body, defaults, false));
      status = 0;
    }
      break;
    case command_e::If: {
      command__If* node = static_cast<command__If*>(UP_node);
      done = false;
      for (ListIter<syntax_asdl::if_arm*> it(node->arms); !it.Done(); it.Next()) {
        syntax_asdl::if_arm* if_arm = it.Value();
        StackRoots _for({&if_arm      });
        b = this->_EvalCondition(if_arm->cond, if_arm->spids->index_(0));
        if (b) {
          status = this->_ExecuteList(if_arm->action);
          done = true;
          break;
        }
      }
      if ((!done and node->else_action != nullptr)) {
        status = this->_ExecuteList(node->else_action);
      }
    }
      break;
    case command_e::NoOp: {
      command__NoOp* node = static_cast<command__NoOp*>(UP_node);
      status = 0;
    }
      break;
    case command_e::Case: {
      command__Case* node = static_cast<command__Case*>(UP_node);
      str_val = this->word_ev->EvalWordToString(node->to_match);
      to_match = str_val->s;
      status = 0;
      done = false;
      for (ListIter<syntax_asdl::case_arm*> it(node->arms); !it.Done(); it.Next()) {
        syntax_asdl::case_arm* case_arm = it.Value();
        StackRoots _for({&case_arm      });
        for (ListIter<syntax_asdl::word_t*> it(case_arm->pat_list); !it.Done(); it.Next()) {
          syntax_asdl::word_t* pat_word = it.Value();
          StackRoots _for({&pat_word        });
          pat_val = this->word_ev->EvalWordToString(pat_word, word_eval::QUOTE_FNMATCH);
          if (libc::fnmatch(pat_val->s, to_match)) {
            status = this->_ExecuteList(case_arm->action);
            done = true;
            break;
          }
        }
        if (done) {
          break;
        }
      }
    }
      break;
    case command_e::TimeBlock: {
      command__TimeBlock* node = static_cast<command__TimeBlock*>(UP_node);
      Tuple3<double, double, double> tup1 = pyos::Time();
      s_real = tup1.at0();
      s_user = tup1.at1();
      s_sys = tup1.at2();
      status = this->_Execute(node->pipeline);
      Tuple3<double, double, double> tup2 = pyos::Time();
      e_real = tup2.at0();
      e_user = tup2.at1();
      e_sys = tup2.at2();
      libc::print_time((e_real - s_real), (e_user - s_user), (e_sys - s_sys));
    }
      break;
    default: {
      throw Alloc<NotImplementedError>(node->tag_());
    }
  }
  return status;
}

void CommandEvaluator::RunPendingTraps() {
  List<syntax_asdl::command_t*>* trap_nodes = nullptr;
  StackRoots _roots({&trap_nodes});

  trap_nodes = this->trap_state->TakeRunList();
  if (len(trap_nodes)) {
    {  // with
      state::ctx_Option ctx(this->mutable_opts, NewList<int>(std::initializer_list<int>{option_i::_running_trap}), true);

      for (ListIter<syntax_asdl::command_t*> it(trap_nodes); !it.Done(); it.Next()) {
        syntax_asdl::command_t* trap_node = it.Value();
        StackRoots _for({&trap_node      });
        {  // with
          state::ctx_Registers ctx(this->mem);

          {  // with
            dev::ctx_Tracer ctx(this->tracer, str829, nullptr);

            this->_Execute(trap_node);
          }
        }
      }
    }
  }
}

int CommandEvaluator::_Execute(syntax_asdl::command_t* node) {
  runtime_asdl::CommandStatus* cmd_st = nullptr;
  runtime_asdl::StatusArray* process_sub_st = nullptr;
  int errexit_spid;
  bool check_errexit;
  List<runtime_asdl::redirect*>* redirects = nullptr;
  int status;
  List<int>* codes = nullptr;
  int i;
  StackRoots _roots({&node, &cmd_st, &process_sub_st, &redirects, &codes});

  this->RunPendingTraps();
  cmd_st = Alloc<CommandStatus>();
  process_sub_st = Alloc<StatusArray>();
  errexit_spid = runtime::NO_SPID;
  check_errexit = true;
  {  // with
    vm::ctx_ProcessSub ctx(this->shell_ex, process_sub_st);

    try {
      redirects = this->_EvalRedirects(node);
    }
    catch (error::RedirectEval* e) {
      this->errfmt->PrettyPrintError(e);
      redirects = nullptr;
    }
    if (redirects == nullptr) {
      status = 1;
    }
    else {
      if (this->shell_ex->PushRedirects(redirects)) {
        {  // with
          vm::ctx_Redirect ctx(this->shell_ex);

          try {
            status = this->_Dispatch(node, cmd_st);
            check_errexit = cmd_st->check_errexit;
          }
          catch (error::FailGlob* e) {
            if (!e->HasLocation()) {
              e->span_id = this->mem->CurrentSpanId();
            }
            this->errfmt->PrettyPrintError(e, str830);
            status = 1;
            check_errexit = true;
          }
        }
        codes = cmd_st->pipe_status;
        if (len(codes)) {
          this->mem->SetPipeStatus(codes);
          if (this->exec_opts->pipefail()) {
            status = 0;
            i = 0;
            for (ListIter<int> it(codes); !it.Done(); it.Next(), ++i) {
              int st = it.Value();
              if (st != 0) {
                status = st;
                errexit_spid = cmd_st->pipe_spids->index_(i);
              }
            }
          }
          else {
            status = codes->index_(-1);
          }
          if (cmd_st->pipe_negated) {
            status = status == 0 ? 1 : 0;
          }
        }
      }
      else {
        status = 1;
      }
    }
  }
  if (len(process_sub_st->codes)) {
    codes = process_sub_st->codes;
    this->mem->SetProcessSubStatus(codes);
    if ((status == 0 and this->exec_opts->process_sub_fail())) {
      i = 0;
      for (ListIter<int> it(codes); !it.Done(); it.Next(), ++i) {
        int st = it.Value();
        if (st != 0) {
          status = st;
          errexit_spid = process_sub_st->spids->index_(i);
        }
      }
    }
  }
  this->mem->SetLastStatus(status);
  if (check_errexit) {
    this->_CheckStatus(status, cmd_st, node, errexit_spid);
  }
  return status;
}

int CommandEvaluator::_ExecuteList(List<syntax_asdl::command_t*>* children) {
  int status;
  StackRoots _roots({&children});

  status = 0;
  for (ListIter<syntax_asdl::command_t*> it(children); !it.Done(); it.Next()) {
    syntax_asdl::command_t* child = it.Value();
    StackRoots _for({&child  });
    status = this->_Execute(child);
  }
  return status;
}

int CommandEvaluator::LastStatus() {
  return this->mem->LastStatus();
}

void CommandEvaluator::_NoForkLast(syntax_asdl::command_t* node) {
  syntax_asdl::command_t* UP_node = nullptr;
  StackRoots _roots({&node, &UP_node});

  UP_node = node;
  switch (node->tag_()) {
    case command_e::Simple: {
      command__Simple* node = static_cast<command__Simple*>(UP_node);
      node->do_fork = false;
    }
      break;
    case command_e::Pipeline: {
      command__Pipeline* node = static_cast<command__Pipeline*>(UP_node);
      if (!node->negated) {
        this->_NoForkLast(node->children->index_(-1));
      }
    }
      break;
    case command_e::Sentence: {
      command__Sentence* node = static_cast<command__Sentence*>(UP_node);
      this->_NoForkLast(node->child);
    }
      break;
    case command_e::CommandList: {
      command__CommandList* node = static_cast<command__CommandList*>(UP_node);
      this->_NoForkLast(node->children->index_(-1));
    }
      break;
    case command_e::BraceGroup: {
      BraceGroup* node = static_cast<BraceGroup*>(UP_node);
      this->_NoForkLast(node->children->index_(-1));
    }
      break;
  }
}

syntax_asdl::command_t* CommandEvaluator::_RemoveSubshells(syntax_asdl::command_t* node) {
  syntax_asdl::command_t* UP_node = nullptr;
  StackRoots _roots({&node, &UP_node});

  UP_node = node;
  switch (node->tag_()) {
    case command_e::Subshell: {
      command__Subshell* node = static_cast<command__Subshell*>(UP_node);
      if (len(node->redirects) == 0) {
        return this->_RemoveSubshells(node->child);
      }
    }
      break;
  }
  return node;
}

Tuple2<bool, bool> CommandEvaluator::ExecuteAndCatch(syntax_asdl::command_t* node) {
  return ExecuteAndCatch(node, 0);
}

Tuple2<bool, bool> CommandEvaluator::ExecuteAndCatch(syntax_asdl::command_t* node, int cmd_flags) {
  bool is_return;
  bool is_fatal;
  bool is_errexit;
  error::_ErrorWithLocation* err = nullptr;
  int status;
  StackRoots _roots({&node, &err});

  if ((cmd_flags & Optimize)) {
    node = this->_RemoveSubshells(node);
    this->_NoForkLast(node);
  }
  is_return = false;
  is_fatal = false;
  is_errexit = false;
  err = nullptr;
  try {
    status = this->_Execute(node);
  }
  catch (_ControlFlow* e) {
    if ((cmd_flags & RaiseControlFlow)) {
      throw ;
    }
    else {
      if (e->IsReturn()) {
        is_return = true;
        status = e->StatusCode();
      }
      else {
        this->errfmt->Print_(str831, e->token->span_id);
        is_fatal = true;
        status = 1;
      }
    }
  }
  catch (error::Parse* e) {
    this->dumper->MaybeCollect(this, e);
    throw ;
  }
  catch (error::ErrExit* e) {
    err = e;
    is_errexit = true;
  }
  catch (error::FatalRuntime* e) {
    err = e;
  }
  if (err) {
    status = err->ExitStatus();
    is_fatal = true;
    this->dumper->MaybeCollect(this, err);
    if (!err->HasLocation()) {
      err->span_id = this->mem->CurrentSpanId();
    }
    if (is_errexit) {
      if (this->exec_opts->verbose_errexit()) {
        this->errfmt->PrintErrExit(err, posix::getpid());
      }
    }
    else {
      this->errfmt->PrettyPrintError(err, str832);
    }
  }
  this->dumper->MaybeDump(status);
  this->mem->SetLastStatus(status);
  return (Tuple2<bool, bool>(is_return, is_fatal));
}

void CommandEvaluator::MaybeRunExitTrap(List<int>* mut_status) {
  syntax_asdl::command_t* node = nullptr;
  bool is_return;
  bool is_fatal;
  StackRoots _roots({&mut_status, &node});

  node = this->trap_state->GetHook(str833);
  if (node) {
    {  // with
      dev::ctx_Tracer ctx(this->tracer, str834, nullptr);

      try {
        Tuple2<bool, bool> tup3 = this->ExecuteAndCatch(node);
        is_return = tup3.at0();
        is_fatal = tup3.at1();
      }
      catch (util::UserExit* e) {
        mut_status->set(0, e->status);
        return ;
      }
      if (is_return) {
        mut_status->set(0, this->LastStatus());
      }
    }
  }
}

int CommandEvaluator::RunProc(runtime_asdl::Proc* proc, List<Str*>* argv, int arg0_spid) {
  syntax_asdl::proc_sig_t* sig = nullptr;
  List<Str*>* proc_argv = nullptr;
  int n_args;
  syntax_asdl::proc_sig_t* UP_sig = nullptr;
  int i;
  bool is_out_param;
  Str* param_name = nullptr;
  Str* arg_str = nullptr;
  runtime_asdl::value_t* val = nullptr;
  int flags;
  int n_params;
  runtime_asdl::value__MaybeStrArray* leftover = nullptr;
  int status;
  StackRoots _roots({&proc, &argv, &sig, &proc_argv, &UP_sig, &param_name, &arg_str, &val, &leftover});

  sig = proc->sig;
  if (sig->tag_() == proc_sig_e::Closed) {
    proc_argv = Alloc<List<Str*>>();
  }
  else {
    proc_argv = argv;
  }
  {  // with
    state::ctx_Call ctx(this->mem, this->mutable_opts, proc, proc_argv);

    n_args = len(argv);
    UP_sig = sig;
    if (UP_sig->tag_() == proc_sig_e::Closed) {
      proc_sig__Closed* sig = static_cast<proc_sig__Closed*>(UP_sig);
      i = 0;
      for (ListIter<syntax_asdl::UntypedParam*> it(sig->untyped); !it.Done(); it.Next(), ++i) {
        syntax_asdl::UntypedParam* p = it.Value();
        StackRoots _for({&p      });
        is_out_param = p->ref != nullptr;
        param_name = p->name->val;
        if (i < n_args) {
          arg_str = argv->index_(i);
          if (is_out_param) {
            param_name = str_concat(str835, param_name);
            if (!arg_str->startswith(str836)) {
              e_die(fmt216(arg_str));
            }
            arg_str = arg_str->slice(1);
          }
          val = Alloc<value::Str>(arg_str);
        }
        else {
          val = proc->defaults->index_(i);
          if (val == nullptr) {
            e_die(fmt217(p->name->val));
          }
        }
        if (is_out_param) {
          flags = state::SetNameref;
        }
        else {
          flags = 0;
        }
        this->mem->SetValue(Alloc<lvalue::Named>(param_name), val, scope_e::LocalOnly, flags);
      }
      n_params = len(sig->untyped);
      if (sig->rest) {
        leftover = Alloc<value::MaybeStrArray>(argv->slice(n_params));
        this->mem->SetValue(Alloc<lvalue::Named>(sig->rest->val), leftover, scope_e::LocalOnly);
      }
      else {
        if (n_args > n_params) {
          this->errfmt->Print_(fmt218(proc->name, n_params, n_args), arg0_spid);
          return 2;
        }
      }
    }
    try {
      status = this->_Execute(proc->body);
    }
    catch (_ControlFlow* e) {
      if (e->IsReturn()) {
        status = e->StatusCode();
      }
      else {
        e_die(fmt219(e->token->val), e->token);
      }
    }
    catch (error::FatalRuntime* e) {
      this->dumper->MaybeCollect(this, e);
      throw ;
    }
  }
  return status;
}

Dict<Str*, runtime_asdl::cell*>* CommandEvaluator::EvalBlock(syntax_asdl::command_t* block) {
  int status;
  Dict<Str*, runtime_asdl::cell*>* namespace_ = nullptr;
  StackRoots _roots({&block, &namespace_});

  status = 0;
  namespace_ = nullptr;
  try {
    this->_Execute(block);
  }
  catch (_ControlFlow* e) {
    if (e->IsReturn()) {
      status = e->StatusCode();
    }
    else {
      e_die(fmt220(), e->token);
    }
  }
  namespace_ = this->mem->TopNamespace();
  return namespace_;
}

int CommandEvaluator::RunFuncForCompletion(runtime_asdl::Proc* proc, List<Str*>* argv) {
  int status;
  StackRoots _roots({&proc, &argv});

  try {
    status = this->RunProc(proc, argv, runtime::NO_SPID);
  }
  catch (error::FatalRuntime* e) {
    this->errfmt->PrettyPrintError(e);
    status = e->ExitStatus();
  }
  catch (_ControlFlow* e) {
    this->errfmt->Print_(str842, e->token->span_id);
    status = 1;
  }
  return status;
}

}  // define namespace cmd_eval

namespace cmd_parse {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using id_kind_asdl::Kind;
using types_asdl::lex_mode_e;
namespace condition = syntax_asdl::condition;
using syntax_asdl::condition_t;
namespace for_iter = syntax_asdl::for_iter;
namespace command = syntax_asdl::command;
using syntax_asdl::command_t;
using syntax_asdl::command__Simple;
using syntax_asdl::command__DoGroup;
using syntax_asdl::command__ForExpr;
using syntax_asdl::command__ForEach;
using syntax_asdl::command__WhileUntil;
using syntax_asdl::command__Case;
using syntax_asdl::command__If;
using syntax_asdl::command__ShFunction;
using syntax_asdl::command__Subshell;
using syntax_asdl::command__DBracket;
using syntax_asdl::command__DParen;
using syntax_asdl::command__CommandList;
using syntax_asdl::command__Proc;
using syntax_asdl::ArgList;
using syntax_asdl::BraceGroup;
using syntax_asdl::case_arm;
namespace sh_lhs_expr = syntax_asdl::sh_lhs_expr;
using syntax_asdl::sh_lhs_expr_t;
using syntax_asdl::redir;
namespace redir_param = syntax_asdl::redir_param;
using syntax_asdl::redir_param__HereDoc;
namespace redir_loc = syntax_asdl::redir_loc;
using syntax_asdl::redir_loc_t;
namespace word = syntax_asdl::word;
namespace word_e = syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::compound_word;
using syntax_asdl::Token;
namespace word_part_e = syntax_asdl::word_part_e;
using syntax_asdl::word_part_t;
using syntax_asdl::assign_pair;
using syntax_asdl::env_pair;
using syntax_asdl::assign_op_e;
namespace source = syntax_asdl::source;
namespace parse_result = syntax_asdl::parse_result;
using syntax_asdl::parse_result_t;
using syntax_asdl::speck;
using syntax_asdl::name_type;
namespace proc_sig_e = syntax_asdl::proc_sig_e;
using syntax_asdl::proc_sig__Closed;
int TAB_CH = 9;
int SPACE_CH = 32;

int _KeywordSpid(syntax_asdl::word_t* w) {
  StackRoots _roots({&w});

  return word_::LeftMostSpanForWord(w);
}

syntax_asdl::Token* _KeywordToken(syntax_asdl::word_t* UP_w) {
  syntax_asdl::word_part_t* part = nullptr;
  StackRoots _roots({&UP_w, &part});

  compound_word* w = static_cast<compound_word*>(UP_w);
  part = w->parts->index_(0);
  return static_cast<Token*>(part);
}

Tuple2<List<Tuple3<int, Str*, int>*>*, Tuple3<int, Str*, int>*> _ReadHereLines(reader::_Reader* line_reader, syntax_asdl::redir* h, Str* delimiter) {
  List<Tuple3<int, Str*, int>*>* here_lines = nullptr;
  Tuple3<int, Str*, int>* last_line = nullptr;
  bool strip_leading_tabs;
  int line_id;
  Str* line = nullptr;
  int start_offset;
  int n;
  int i;
  StackRoots _roots({&line_reader, &h, &delimiter, &here_lines, &last_line, &line});

  here_lines = Alloc<List<Tuple3<int, Str*, int>*>>();
  last_line = nullptr;
  strip_leading_tabs = h->op->id == Id::Redir_DLessDash;
  while (true) {
    Tuple3<int, Str*, int> tup0 = line_reader->GetLine();
    line_id = tup0.at0();
    line = tup0.at1();
    if (line == nullptr) {
      p_die(fmt221(), h->op);
    }
    start_offset = 0;
    if (strip_leading_tabs) {
      n = len(line);
      i = 0;
      while (i < n) {
        if (!(str_equals(line->index_(i), str844))) {
          break;
        }
        i += 1;
      }
      start_offset = i;
    }
    if (str_equals(line->slice(start_offset)->rstrip(), delimiter)) {
      last_line = (Alloc<Tuple3<int, Str*, int>>(line_id, line, start_offset));
      break;
    }
    here_lines->append((Alloc<Tuple3<int, Str*, int>>(line_id, line, start_offset)));
  }
  return (Tuple2<List<Tuple3<int, Str*, int>*>*, Tuple3<int, Str*, int>*>(here_lines, last_line));
}

List<syntax_asdl::word_part_t*>* _MakeLiteralHereLines(List<Tuple3<int, Str*, int>*>* here_lines, alloc::Arena* arena) {
  List<syntax_asdl::Token*>* tokens = nullptr;
  int line_id;
  Str* line = nullptr;
  int start_offset;
  int span_id;
  syntax_asdl::Token* t = nullptr;
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  StackRoots _roots({&here_lines, &arena, &tokens, &line, &t, &parts});

  tokens = Alloc<List<syntax_asdl::Token*>>();
  for (ListIter<Tuple3<int, Str*, int>*> it(here_lines); !it.Done(); it.Next()) {
    Tuple3<int, Str*, int>* tup1 = it.Value();
    line_id = tup1->at0();
    line = tup1->at1();
    start_offset = tup1->at2();
    span_id = arena->AddLineSpan(line_id, start_offset, len(line));
    t = Alloc<Token>(Id::Lit_Chars, span_id, line->slice(start_offset));
    tokens->append(t);
  }
  parts = Alloc<List<syntax_asdl::word_part_t*>>();
  for (ListIter<syntax_asdl::Token*> it(tokens); !it.Done(); it.Next()) {
    syntax_asdl::Token* t = it.Value();
    parts->append(static_cast<word_part_t*>(t));
  }
  return parts;
}

void _ParseHereDocBody(parse_lib::ParseContext* parse_ctx, syntax_asdl::redir* r, reader::_Reader* line_reader, alloc::Arena* arena) {
  bool ok;
  Str* delimiter = nullptr;
  bool delim_quoted;
  List<Tuple3<int, Str*, int>*>* here_lines = nullptr;
  Tuple3<int, Str*, int>* last_line = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  int end_line_id;
  Str* end_line = nullptr;
  int end_pos;
  StackRoots _roots({&parse_ctx, &r, &line_reader, &arena, &delimiter, &here_lines, &last_line, &w_parser, &end_line});

  redir_param__HereDoc* h = static_cast<redir_param__HereDoc*>(r->arg);
  Tuple3<bool, Str*, bool> tup2 = word_::StaticEval(h->here_begin);
  ok = tup2.at0();
  delimiter = tup2.at1();
  delim_quoted = tup2.at2();
  if (!ok) {
    p_die(fmt222(), h->here_begin);
  }
  Tuple2<List<Tuple3<int, Str*, int>*>*, Tuple3<int, Str*, int>*> tup3 = _ReadHereLines(line_reader, r, delimiter);
  here_lines = tup3.at0();
  last_line = tup3.at1();
  if (delim_quoted) {
    h->stdin_parts = _MakeLiteralHereLines(here_lines, arena);
  }
  else {
    line_reader = Alloc<reader::VirtualLineReader>(here_lines, arena);
    w_parser = parse_ctx->MakeWordParserForHereDoc(line_reader);
    w_parser->ReadHereDocBody(h->stdin_parts);
  }
  Tuple3<int, Str*, int>* tup4 = last_line;
  end_line_id = tup4->at0();
  end_line = tup4->at1();
  end_pos = tup4->at2();
  h->here_end_span_id = arena->AddLineSpan(end_line_id, end_pos, len(end_line));
}

syntax_asdl::assign_pair* _MakeAssignPair(parse_lib::ParseContext* parse_ctx, Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>* preparsed, alloc::Arena* arena) {
  syntax_asdl::Token* left_token = nullptr;
  syntax_asdl::Token* close_token = nullptr;
  int part_offset;
  syntax_asdl::compound_word* w = nullptr;
  Str* var_name = nullptr;
  syntax_asdl::assign_op_t op;
  syntax_asdl::sh_lhs_expr__Name* tmp = nullptr;
  sh_lhs_expr_t* lhs = nullptr;
  int left_spid;
  int right_spid;
  syntax_asdl::line_span* left_span = nullptr;
  syntax_asdl::line_span* right_span = nullptr;
  Str* line = nullptr;
  Str* index_str = nullptr;
  int spid1;
  int spid2;
  syntax_asdl::line_span* span1 = nullptr;
  syntax_asdl::line_span* span2 = nullptr;
  Str* code_str = nullptr;
  tdop::TdopParser* a_parser = nullptr;
  syntax_asdl::source__Reparsed* src = nullptr;
  syntax_asdl::arith_expr_t* index_node = nullptr;
  syntax_asdl::sh_lhs_expr__IndexedName* tmp3 = nullptr;
  int n;
  syntax_asdl::word_t* rhs = nullptr;
  syntax_asdl::compound_word* tmp2 = nullptr;
  syntax_asdl::assign_pair* pair = nullptr;
  StackRoots _roots({&parse_ctx, &preparsed, &arena, &left_token, &close_token, &w, &var_name, &tmp, &lhs, &left_span, &right_span, &line, &index_str, &span1, &span2, &code_str, &a_parser, &src, &index_node, &tmp3, &rhs, &tmp2, &pair});

  Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>* tup5 = preparsed;
  left_token = tup5->at0();
  close_token = tup5->at1();
  part_offset = tup5->at2();
  w = tup5->at3();
  if (left_token->id == Id::Lit_VarLike) {
    if (str_equals(left_token->val->index_(-2), str846)) {
      var_name = left_token->val->slice(0, -2);
      op = assign_op_e::PlusEqual;
    }
    else {
      var_name = left_token->val->slice(0, -1);
      op = assign_op_e::Equal;
    }
    tmp = Alloc<sh_lhs_expr::Name>(var_name);
    tmp->spids->append(left_token->span_id);
    lhs = static_cast<sh_lhs_expr_t*>(tmp);
  }
  else {
    if ((left_token->id == Id::Lit_ArrayLhsOpen and parse_ctx->one_pass_parse)) {
      var_name = left_token->val->slice(0, -1);
      if (str_equals(close_token->val->index_(-2), str847)) {
        op = assign_op_e::PlusEqual;
      }
      else {
        op = assign_op_e::Equal;
      }
      left_spid = (left_token->span_id + 1);
      right_spid = close_token->span_id;
      left_span = parse_ctx->arena->GetLineSpan(left_spid);
      right_span = parse_ctx->arena->GetLineSpan(right_spid);
      line = parse_ctx->arena->GetLine(left_span->line_id);
      index_str = line->slice(left_span->col, right_span->col);
      lhs = Alloc<sh_lhs_expr::UnparsedIndex>(var_name, index_str);
    }
    else {
      if (left_token->id == Id::Lit_ArrayLhsOpen) {
        var_name = left_token->val->slice(0, -1);
        if (str_equals(close_token->val->index_(-2), str848)) {
          op = assign_op_e::PlusEqual;
        }
        else {
          op = assign_op_e::Equal;
        }
        spid1 = left_token->span_id;
        spid2 = close_token->span_id;
        span1 = arena->GetLineSpan(spid1);
        span2 = arena->GetLineSpan(spid2);
        if (span1->line_id == span2->line_id) {
          line = arena->GetLine(span1->line_id);
          code_str = line->slice((span1->col + span1->length), span2->col);
        }
        else {
          throw Alloc<NotImplementedError>(fmt223(span1->line_id, span2->line_id));
        }
        a_parser = parse_ctx->MakeArithParser(code_str);
        src = Alloc<source::Reparsed>(str850, left_token->span_id, close_token->span_id);
        {  // with
          alloc::ctx_Location ctx(arena, src);

          index_node = a_parser->Parse();
        }
        tmp3 = Alloc<sh_lhs_expr::IndexedName>(var_name, index_node);
        tmp3->spids->append(left_token->span_id);
        lhs = static_cast<sh_lhs_expr_t*>(tmp3);
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  n = len(w->parts);
  if (part_offset == n) {
    rhs = Alloc<word::Empty>();
  }
  else {
    tmp2 = Alloc<compound_word>(w->parts->slice(part_offset));
    word_::TildeDetectAssign(tmp2);
    rhs = tmp2;
  }
  pair = Alloc<syntax_asdl::assign_pair>(lhs, op, rhs, NewList<int>(std::initializer_list<int>{left_token->span_id}));
  return pair;
}

void _AppendMoreEnv(List<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*>* preparsed_list, List<syntax_asdl::env_pair*>* more_env) {
  syntax_asdl::Token* left_token = nullptr;
  int part_offset;
  syntax_asdl::compound_word* w = nullptr;
  Str* var_name = nullptr;
  int n;
  syntax_asdl::word_t* val = nullptr;
  syntax_asdl::env_pair* pair = nullptr;
  StackRoots _roots({&preparsed_list, &more_env, &left_token, &w, &var_name, &val, &pair});

  for (ListIter<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*> it(preparsed_list); !it.Done(); it.Next()) {
    Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>* tup6 = it.Value();
    left_token = tup6->at0();
    part_offset = tup6->at2();
    w = tup6->at3();
    if (left_token->id != Id::Lit_VarLike) {
      p_die(fmt224(), left_token);
    }
    if (str_equals(left_token->val->index_(-2), str852)) {
      p_die(fmt225(), left_token);
    }
    var_name = left_token->val->slice(0, -1);
    n = len(w->parts);
    if (part_offset == n) {
      val = Alloc<word::Empty>();
    }
    else {
      val = Alloc<compound_word>(w->parts->slice(part_offset));
    }
    pair = Alloc<syntax_asdl::env_pair>(var_name, val, NewList<int>(std::initializer_list<int>{left_token->span_id}));
    more_env->append(pair);
  }
}

Tuple2<List<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*>*, List<syntax_asdl::compound_word*>*> _SplitSimpleCommandPrefix(List<syntax_asdl::compound_word*>* words) {
  List<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*>* preparsed_list = nullptr;
  List<syntax_asdl::compound_word*>* suffix_words = nullptr;
  bool done_prefix;
  syntax_asdl::Token* left_token = nullptr;
  syntax_asdl::Token* close_token = nullptr;
  int part_offset;
  StackRoots _roots({&words, &preparsed_list, &suffix_words, &left_token, &close_token});

  preparsed_list = Alloc<List<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*>>();
  suffix_words = Alloc<List<syntax_asdl::compound_word*>>();
  done_prefix = false;
  for (ListIter<syntax_asdl::compound_word*> it(words); !it.Done(); it.Next()) {
    syntax_asdl::compound_word* w = it.Value();
    StackRoots _for({&w  });
    if (done_prefix) {
      suffix_words->append(w);
      continue;
    }
    Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int> tup7 = word_::DetectShAssignment(w);
    left_token = tup7.at0();
    close_token = tup7.at1();
    part_offset = tup7.at2();
    if (left_token) {
      preparsed_list->append((Alloc<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>>(left_token, close_token, part_offset, w)));
    }
    else {
      done_prefix = true;
      suffix_words->append(w);
    }
  }
  return (Tuple2<List<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*>*, List<syntax_asdl::compound_word*>*>(preparsed_list, suffix_words));
}

syntax_asdl::command__Simple* _MakeSimpleCommand(List<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*>* preparsed_list, List<syntax_asdl::compound_word*>* suffix_words, List<syntax_asdl::redir*>* redirects, syntax_asdl::ArgList* typed_args, syntax_asdl::BraceGroup* block) {
  syntax_asdl::compound_word* w = nullptr;
  List<syntax_asdl::word_t*>* words2 = nullptr;
  List<syntax_asdl::word_t*>* words3 = nullptr;
  List<syntax_asdl::env_pair*>* more_env = nullptr;
  syntax_asdl::command__Simple* node = nullptr;
  StackRoots _roots({&preparsed_list, &suffix_words, &redirects, &typed_args, &block, &w, &words2, &words3, &more_env, &node});

  for (ListIter<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*> it(preparsed_list); !it.Done(); it.Next()) {
    Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>* tup8 = it.Value();
    w = tup8->at3();
    if (word_::HasArrayPart(w)) {
      p_die(fmt226(), w);
    }
  }
  words2 = braces::BraceDetectAll(suffix_words);
  words3 = word_::TildeDetectAll(words2);
  more_env = Alloc<List<syntax_asdl::env_pair*>>();
  _AppendMoreEnv(preparsed_list, more_env);
  node = Alloc<command::Simple>(words3, redirects, more_env, typed_args, block, true);
  return node;
}

VarChecker::VarChecker() 
    : Obj(Tag::FixedSize, maskof_VarChecker(), sizeof(VarChecker))  {
  this->tokens = Alloc<List<syntax_asdl::Token*>>();
  this->names = Alloc<List<Dict<Str*, int>*>>();
}

void VarChecker::Push(syntax_asdl::Token* blame_tok) {
  Dict<Str*, int>* entry = nullptr;
  StackRoots _roots({&blame_tok, &entry});

  if (len(this->tokens) != 0) {
    if ((this->tokens->index_(0)->id == Id::KW_Proc or blame_tok->id == Id::KW_Proc)) {
      p_die(fmt227(), blame_tok);
    }
  }
  this->tokens->append(blame_tok);
  entry = Alloc<Dict<Str*, int>>();
  this->names->append(entry);
}

void VarChecker::Pop() {
  this->names->pop();
  this->tokens->pop();
}

void VarChecker::Check(int keyword_id, syntax_asdl::Token* name_tok) {
  Dict<Str*, int>* top = nullptr;
  Str* name = nullptr;
  StackRoots _roots({&name_tok, &top, &name});

  if (len(this->names) == 0) {
    return ;
  }
  top = this->names->index_(-1);
  name = name_tok->val;
  if ((keyword_id == Id::KW_Const || keyword_id == Id::KW_Var)) {
    if (dict_contains(top, name)) {
      p_die(fmt228(name), name_tok);
    }
    else {
      top->set(name, keyword_id);
    }
  }
  if (keyword_id == Id::KW_SetVar) {
    if (!dict_contains(top, name)) {
      p_die(fmt229(name), name_tok);
    }
    if ((dict_contains(top, name) and top->index_(name) == Id::KW_Const)) {
      p_die(fmt230(name), name_tok);
    }
  }
}

ctx_VarChecker::ctx_VarChecker(cmd_parse::VarChecker* var_checker, syntax_asdl::Token* blame_tok) 
    : Obj(Tag::FixedSize, maskof_ctx_VarChecker(), sizeof(ctx_VarChecker))  {
  var_checker->Push(blame_tok);
  this->var_checker = var_checker;
}

ctx_VarChecker::~ctx_VarChecker(){
  this->var_checker->Pop();
}
GLOBAL_LIST(int, 7, SECONDARY_KEYWORDS, {Id::KW_Do COMMA Id::KW_Done COMMA Id::KW_Then COMMA Id::KW_Fi COMMA Id::KW_Elif COMMA Id::KW_Else COMMA Id::KW_Esac});

CommandParser::CommandParser(parse_lib::ParseContext* parse_ctx, optview::Parse* parse_opts, word_parse::WordParser* w_parser, lexer::Lexer* lexer, reader::_Reader* line_reader) 
    : Obj(Tag::FixedSize, maskof_CommandParser(), sizeof(CommandParser))  {
  this->parse_ctx = parse_ctx;
  this->aliases = parse_ctx->aliases;
  this->parse_opts = parse_opts;
  this->w_parser = w_parser;
  this->lexer = lexer;
  this->line_reader = line_reader;
  this->arena = parse_ctx->arena;
  this->eof_id = Id::Eof_Real;
  this->aliases_in_flight = Alloc<List<Tuple2<Str*, int>*>>();
  this->allow_block = true;
  this->allow_block_attrs = Alloc<List<bool>>();
  this->var_checker = Alloc<VarChecker>();
  this->Reset();
}

void CommandParser::Init_EofId(int eof_id) {
  this->eof_id = eof_id;
}

void CommandParser::Init_AliasesInFlight(List<Tuple2<Str*, int>*>* aliases_in_flight) {
  StackRoots _roots({&aliases_in_flight});

  this->aliases_in_flight = aliases_in_flight;
}

void CommandParser::Reset() {
  this->next_lex_mode = lex_mode_e::ShCommand;
  this->cur_word = nullptr;
  this->c_kind = Kind::Undefined;
  this->c_id = Id::Undefined_Tok;
  this->pending_here_docs = Alloc<List<syntax_asdl::redir*>>();
}

void CommandParser::ResetInputObjects() {
  this->w_parser->Reset();
  this->lexer->ResetInputObjects();
  this->line_reader->Reset();
}

void CommandParser::_Next() {
  this->next_lex_mode = lex_mode_e::ShCommand;
}

void CommandParser::_Peek() {
  syntax_asdl::word_t* w = nullptr;
  StackRoots _roots({&w});

  if (this->next_lex_mode != lex_mode_e::Undefined) {
    w = this->w_parser->ReadWord(this->next_lex_mode);
    if (w->tag_() == word_e::Token) {
      Token* tok = static_cast<Token*>(w);
      if (tok->id == Id::Op_Newline) {
        for (ListIter<syntax_asdl::redir*> it(this->pending_here_docs); !it.Done(); it.Next()) {
          syntax_asdl::redir* h = it.Value();
          StackRoots _for({&h        });
          _ParseHereDocBody(this->parse_ctx, h, this->line_reader, this->arena);
        }
        this->pending_here_docs->clear();
      }
    }
    this->cur_word = w;
    this->c_kind = word_::CommandKind(this->cur_word);
    this->c_id = word_::CommandId(this->cur_word);
    this->next_lex_mode = lex_mode_e::Undefined;
  }
}

void CommandParser::_Eat(int c_id) {
  int actual_id;
  Str* msg = nullptr;
  StackRoots _roots({&msg});

  actual_id = word_::CommandId(this->cur_word);
  msg = fmt231(ui::PrettyId(c_id), ui::PrettyId(actual_id));
  this->_Eat2(c_id, msg);
}

void CommandParser::_Eat2(int c_id, Str* msg) {
  StackRoots _roots({&msg});

  this->_Peek();
  if (this->c_id != c_id) {
    p_die(dynamic_fmt_dummy(), this->cur_word);
  }
  this->_Next();
}

void CommandParser::_NewlineOk() {
  this->_Peek();
  if (this->c_id == Id::Op_Newline) {
    this->_Next();
    this->_Peek();
  }
}

bool CommandParser::_AtSecondaryKeyword() {
  if (list_contains(SECONDARY_KEYWORDS, this->c_id)) {
    return true;
  }
  return false;
}

syntax_asdl::redir* CommandParser::ParseRedirect() {
  Str* op_val = nullptr;
  int pos;
  syntax_asdl::redir_loc_t* loc = nullptr;
  syntax_asdl::redir_param__HereDoc* arg = nullptr;
  syntax_asdl::redir* r = nullptr;
  syntax_asdl::word_t* arg_word = nullptr;
  syntax_asdl::compound_word* tilde = nullptr;
  StackRoots _roots({&op_val, &loc, &arg, &r, &arg_word, &tilde});

  this->_Peek();
  Token* op_tok = static_cast<Token*>(this->cur_word);
  op_val = op_tok->val;
  if (str_equals(op_val->index_(0), str860)) {
    pos = op_val->find(str861);
    loc = Alloc<redir_loc::VarName>(op_val->slice(1, pos));
  }
  else {
    if (op_val->index_(0)->isdigit()) {
      pos = 1;
      if (op_val->index_(1)->isdigit()) {
        pos = 2;
      }
      loc = Alloc<redir_loc::Fd>(to_int(op_val->slice(0, pos)));
    }
    else {
      loc = Alloc<redir_loc::Fd>(consts::RedirDefaultFd(op_tok->id));
    }
  }
  this->_Next();
  this->_Peek();
  if ((op_tok->id == Id::Redir_DLess || op_tok->id == Id::Redir_DLessDash)) {
    arg = Alloc<redir_param::HereDoc>();
    arg->here_begin = this->cur_word;
    r = Alloc<redir>(op_tok, loc, arg);
    this->pending_here_docs->append(r);
    this->_Next();
    return r;
  }
  if (this->c_kind != Kind::Word) {
    p_die(fmt232(), this->cur_word);
  }
  arg_word = this->cur_word;
  tilde = word_::TildeDetect(arg_word);
  if (tilde) {
    arg_word = tilde;
  }
  this->_Next();
  return Alloc<redir>(op_tok, loc, static_cast<compound_word*>(arg_word));
}

List<syntax_asdl::redir*>* CommandParser::_ParseRedirectList() {
  List<syntax_asdl::redir*>* redirects = nullptr;
  syntax_asdl::redir* node = nullptr;
  StackRoots _roots({&redirects, &node});

  redirects = Alloc<List<syntax_asdl::redir*>>();
  while (true) {
    this->_Peek();
    if (this->c_kind != Kind::Redir) {
      break;
    }
    node = this->ParseRedirect();
    redirects->append(node);
    this->_Next();
  }
  return redirects;
}

Tuple4<List<syntax_asdl::redir*>*, List<syntax_asdl::compound_word*>*, syntax_asdl::ArgList*, syntax_asdl::BraceGroup*> CommandParser::_ScanSimpleCommand() {
  List<syntax_asdl::redir*>* redirects = nullptr;
  List<syntax_asdl::compound_word*>* words = nullptr;
  syntax_asdl::ArgList* typed_args = nullptr;
  syntax_asdl::BraceGroup* block = nullptr;
  bool first_word_caps;
  int i;
  syntax_asdl::redir* node = nullptr;
  bool ok;
  Str* word_str = nullptr;
  bool quoted;
  int prev_byte;
  int next_id;
  StackRoots _roots({&redirects, &words, &typed_args, &block, &node, &word_str});

  redirects = Alloc<List<syntax_asdl::redir*>>();
  words = Alloc<List<syntax_asdl::compound_word*>>();
  typed_args = nullptr;
  block = nullptr;
  first_word_caps = false;
  i = 0;
  while (true) {
    this->_Peek();
    if (this->c_kind == Kind::Redir) {
      node = this->ParseRedirect();
      redirects->append(node);
    }
    else {
      if (this->c_kind == Kind::Word) {
        if (this->parse_opts->parse_brace()) {
          if (this->c_id == Id::Lit_LBrace) {
            if (this->allow_block) {
              this->allow_block_attrs->append(first_word_caps);
              block = this->ParseBraceGroup();
              this->allow_block_attrs->pop();
            }
            break;
          }
          else {
            if (this->c_id == Id::Lit_RBrace) {
              break;
            }
          }
        }
        compound_word* w = static_cast<compound_word*>(this->cur_word);
        words->append(w);
        if (i == 0) {
          Tuple3<bool, Str*, bool> tup9 = word_::StaticEval(w);
          ok = tup9.at0();
          word_str = tup9.at1();
          quoted = tup9.at2();
          if ((ok and (len(word_str) and (word_str->index_(0)->isupper() and !word_str->isupper())))) {
            first_word_caps = true;
          }
        }
      }
      else {
        if (this->c_id == Id::Op_LParen) {
          prev_byte = this->lexer->ByteLookBack();
          if ((prev_byte != SPACE_CH && prev_byte != TAB_CH)) {
            if (this->parse_opts->parse_at()) {
              p_die(fmt233(), this->cur_word);
            }
            else {
              p_die(fmt234(), this->cur_word);
            }
          }
          next_id = this->lexer->LookPastSpace(lex_mode_e::ShCommand);
          if (next_id == Id::Op_RParen) {
            p_die(fmt235(), this->cur_word);
          }
          typed_args = this->w_parser->ParseProcCallArgs();
        }
        else {
          break;
        }
      }
    }
    this->_Next();
    i += 1;
  }
  return (Tuple4<List<syntax_asdl::redir*>*, List<syntax_asdl::compound_word*>*, syntax_asdl::ArgList*, syntax_asdl::BraceGroup*>(redirects, words, typed_args, block));
}

syntax_asdl::command_t* CommandParser::_MaybeExpandAliases(List<syntax_asdl::compound_word*>* words) {
  List<Tuple2<Str*, int>*>* aliases_in_flight = nullptr;
  Str* first_word_str = nullptr;
  int argv0_spid;
  List<Str*>* expanded = nullptr;
  int i;
  int n;
  syntax_asdl::compound_word* w = nullptr;
  bool ok;
  Str* word_str = nullptr;
  bool quoted;
  Str* alias_exp = nullptr;
  int spid1;
  int spid2;
  syntax_asdl::line_span* span1 = nullptr;
  syntax_asdl::line_span* span2 = nullptr;
  Str* line = nullptr;
  Str* piece = nullptr;
  Str* code_str = nullptr;
  reader::FileLineReader* line_reader = nullptr;
  cmd_parse::CommandParser* cp = nullptr;
  syntax_asdl::source__Alias* src = nullptr;
  syntax_asdl::command__CommandList* node = nullptr;
  StackRoots _roots({&words, &aliases_in_flight, &first_word_str, &expanded, &w, &word_str, &alias_exp, &span1, &span2, &line, &piece, &code_str, &line_reader, &cp, &src, &node});

  aliases_in_flight = len(this->aliases_in_flight) ? this->aliases_in_flight : Alloc<List<Tuple2<Str*, int>*>>();
  first_word_str = nullptr;
  argv0_spid = word_::LeftMostSpanForWord(words->index_(0));
  expanded = Alloc<List<Str*>>();
  i = 0;
  n = len(words);
  while (i < n) {
    w = words->index_(i);
    Tuple3<bool, Str*, bool> tup10 = word_::StaticEval(w);
    ok = tup10.at0();
    word_str = tup10.at1();
    quoted = tup10.at2();
    if ((!ok or quoted)) {
      break;
    }
    alias_exp = this->aliases->get(word_str);
    if (alias_exp == nullptr) {
      break;
    }
    if (list_contains(aliases_in_flight, (Alloc<Tuple2<Str*, int>>(word_str, i)))) {
      break;
    }
    if (i == 0) {
      first_word_str = word_str;
    }
    aliases_in_flight->append((Alloc<Tuple2<Str*, int>>(word_str, i)));
    expanded->append(alias_exp);
    i += 1;
    if (!alias_exp->endswith(str866)) {
      expanded->append(str867);
      break;
    }
  }
  if (len(expanded) == 0) {
    return nullptr;
  }
  while (i < n) {
    w = words->index_(i);
    spid1 = word_::LeftMostSpanForWord(w);
    spid2 = word_::RightMostSpanForWord(w);
    span1 = this->arena->GetLineSpan(spid1);
    span2 = this->arena->GetLineSpan(spid2);
    if (span1->line_id == span2->line_id) {
      line = this->arena->GetLine(span1->line_id);
      piece = line->slice(span1->col, (span2->col + span2->length));
      expanded->append(piece);
    }
    else {
      throw Alloc<NotImplementedError>(fmt236(span1->line_id, span2->line_id));
    }
    expanded->append(str869);
    i += 1;
  }
  code_str = str870->join(expanded);
  line_reader = reader::StringLineReader(code_str, this->arena);
  cp = this->parse_ctx->MakeOshParser(line_reader);
  cp->Init_AliasesInFlight(aliases_in_flight);
  src = Alloc<source::Alias>(first_word_str, argv0_spid);
  {  // with
    alloc::ctx_Location ctx(this->arena, src);

    {  // with
      parse_lib::ctx_Alias ctx(this->parse_ctx->trail);

      try {
        node = cp->_ParseCommandTerm();
      }
      catch (error::Parse* e) {
        throw ;
      }
    }
  }
  return node;
}

syntax_asdl::command_t* CommandParser::ParseSimpleCommand() {
  List<syntax_asdl::redir*>* redirects = nullptr;
  List<syntax_asdl::compound_word*>* words = nullptr;
  syntax_asdl::ArgList* typed_args = nullptr;
  syntax_asdl::BraceGroup* block = nullptr;
  int typed_spid;
  syntax_asdl::command__Simple* simple = nullptr;
  syntax_asdl::word_part_t* part0 = nullptr;
  List<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*>* preparsed_list = nullptr;
  List<syntax_asdl::compound_word*>* suffix_words = nullptr;
  syntax_asdl::Token* left_token = nullptr;
  List<syntax_asdl::assign_pair*>* pairs = nullptr;
  syntax_asdl::command__ShAssignment* assign = nullptr;
  int left_spid;
  id_kind_asdl::Kind_t kind;
  syntax_asdl::Token* kw_token = nullptr;
  syntax_asdl::word_t* arg_word = nullptr;
  syntax_asdl::command_t* expanded_node = nullptr;
  List<syntax_asdl::env_pair*>* more_env = nullptr;
  syntax_asdl::command__ExpandedAlias* exp = nullptr;
  syntax_asdl::command__Simple* node = nullptr;
  StackRoots _roots({&redirects, &words, &typed_args, &block, &simple, &part0, &preparsed_list, &suffix_words, &left_token, &pairs, &assign, &kw_token, &arg_word, &expanded_node, &more_env, &exp, &node});

  Tuple4<List<syntax_asdl::redir*>*, List<syntax_asdl::compound_word*>*, syntax_asdl::ArgList*, syntax_asdl::BraceGroup*> tup11 = this->_ScanSimpleCommand();
  redirects = tup11.at0();
  words = tup11.at1();
  typed_args = tup11.at2();
  block = tup11.at3();
  typed_spid = runtime::NO_SPID;
  if (block) {
    typed_spid = block->spids->index_(0);
  }
  if (typed_args) {
    typed_spid = typed_args->spids->index_(0);
  }
  if (len(words) == 0) {
    if (typed_spid != runtime::NO_SPID) {
      p_die(fmt237(), typed_spid);
    }
    simple = Alloc<command::Simple>();
    simple->redirects = redirects;
    return simple;
  }
  part0 = words->index_(0)->parts->index_(0);
  if (part0->tag_() == word_part_e::Literal) {
    Token* tok = static_cast<Token*>(part0);
    if (tok->id == Id::Lit_Equals) {
      p_die(fmt238(), tok);
    }
  }
  Tuple2<List<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*>*, List<syntax_asdl::compound_word*>*> tup12 = _SplitSimpleCommandPrefix(words);
  preparsed_list = tup12.at0();
  suffix_words = tup12.at1();
  if (len(preparsed_list)) {
    Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>* tup13 = preparsed_list->index_(0);
    left_token = tup13->at0();
    if ((!this->parse_opts->parse_sh_assign() and len(suffix_words) == 0)) {
      p_die(fmt239(), left_token);
    }
  }
  this->parse_ctx->trail->SetLatestWords(suffix_words, redirects);
  if (len(suffix_words) == 0) {
    if (typed_spid != runtime::NO_SPID) {
      p_die(fmt240(), typed_spid);
    }
    pairs = Alloc<List<syntax_asdl::assign_pair*>>();
    for (ListIter<Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>*> it(preparsed_list); !it.Done(); it.Next()) {
      Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>* preparsed = it.Value();
      pairs->append(_MakeAssignPair(this->parse_ctx, preparsed, this->arena));
    }
    assign = Alloc<command::ShAssignment>(pairs, redirects);
    left_spid = word_::LeftMostSpanForWord(words->index_(0));
    assign->spids->append(left_spid);
    return assign;
  }
  Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*> tup14 = word_::KeywordToken(suffix_words->index_(0));
  kind = tup14.at0();
  kw_token = tup14.at1();
  if (kind == Kind::ControlFlow) {
    if (typed_spid != runtime::NO_SPID) {
      p_die(fmt241(), typed_spid);
    }
    if ((!this->parse_opts->parse_ignored() and len(redirects))) {
      p_die(fmt242(), kw_token);
    }
    if (len(preparsed_list)) {
      Tuple4<syntax_asdl::Token*, syntax_asdl::Token*, int, syntax_asdl::compound_word*>* tup15 = preparsed_list->index_(0);
      left_token = tup15->at0();
      p_die(fmt243(), left_token);
    }
    if (len(suffix_words) == 1) {
      arg_word = nullptr;
    }
    else {
      if (len(suffix_words) == 2) {
        arg_word = suffix_words->index_(1);
      }
      else {
        p_die(fmt244(kw_token->val), suffix_words->index_(2));
      }
    }
    return Alloc<command::ControlFlow>(kw_token, arg_word);
  }
  if ((!block and this->parse_opts->expand_aliases())) {
    expanded_node = this->_MaybeExpandAliases(suffix_words);
    if (expanded_node) {
      more_env = Alloc<List<syntax_asdl::env_pair*>>();
      _AppendMoreEnv(preparsed_list, more_env);
      exp = Alloc<command::ExpandedAlias>(expanded_node, redirects, more_env);
      return exp;
    }
  }
  node = _MakeSimpleCommand(preparsed_list, suffix_words, redirects, typed_args, block);
  return node;
}

syntax_asdl::BraceGroup* CommandParser::ParseBraceGroup() {
  int left_spid;
  syntax_asdl::Token* doc_token = nullptr;
  syntax_asdl::command__CommandList* c_list = nullptr;
  int right_spid;
  syntax_asdl::BraceGroup* node = nullptr;
  StackRoots _roots({&doc_token, &c_list, &node});

  left_spid = _KeywordSpid(this->cur_word);
  this->_Eat(Id::Lit_LBrace);
  doc_token = nullptr;
  this->_Peek();
  if (this->c_id == Id::Op_Newline) {
    this->_Next();
    {  // with
      word_::ctx_EmitDocToken ctx(this->w_parser);

      this->_Peek();
    }
  }
  if (this->c_id == Id::Ignored_Comment) {
    Token* doc_token = static_cast<Token*>(this->cur_word);
    this->_Next();
  }
  c_list = this->_ParseCommandList();
  this->_Eat(Id::Lit_RBrace);
  right_spid = word_::LeftMostSpanForWord(this->cur_word);
  node = Alloc<BraceGroup>(doc_token, c_list->children, Alloc<List<syntax_asdl::redir*>>());
  node->spids->append(left_spid);
  node->spids->append(right_spid);
  return node;
}

syntax_asdl::command__DoGroup* CommandParser::ParseDoGroup() {
  int do_spid;
  syntax_asdl::command__CommandList* c_list = nullptr;
  int done_spid;
  syntax_asdl::command__DoGroup* node = nullptr;
  StackRoots _roots({&c_list, &node});

  this->_Eat(Id::KW_Do);
  do_spid = _KeywordSpid(this->cur_word);
  c_list = this->_ParseCommandList();
  this->_Eat(Id::KW_Done);
  done_spid = _KeywordSpid(this->cur_word);
  node = Alloc<command::DoGroup>(c_list->children);
  node->spids->append(do_spid);
  node->spids->append(done_spid);
  return node;
}

Tuple2<List<syntax_asdl::compound_word*>*, int> CommandParser::ParseForWords() {
  List<syntax_asdl::compound_word*>* words = nullptr;
  int semi_spid;
  StackRoots _roots({&words});

  words = Alloc<List<syntax_asdl::compound_word*>>();
  semi_spid = runtime::NO_SPID;
  while (true) {
    this->_Peek();
    if (this->c_id == Id::Op_Semi) {
      Token* tok = static_cast<Token*>(this->cur_word);
      semi_spid = tok->span_id;
      this->_Next();
      this->_NewlineOk();
      break;
    }
    else {
      if (this->c_id == Id::Op_Newline) {
        this->_Next();
        break;
      }
      else {
        if ((this->parse_opts->parse_brace() and this->c_id == Id::Lit_LBrace)) {
          break;
        }
      }
    }
    if (this->cur_word->tag_() != word_e::Compound) {
      p_die(fmt245(), this->cur_word);
    }
    compound_word* w2 = static_cast<compound_word*>(this->cur_word);
    words->append(w2);
    this->_Next();
  }
  return (Tuple2<List<syntax_asdl::compound_word*>*, int>(words, semi_spid));
}

syntax_asdl::command__ForExpr* CommandParser::_ParseForExprLoop() {
  syntax_asdl::command__ForExpr* node = nullptr;
  StackRoots _roots({&node});

  node = this->w_parser->ReadForExpression();
  this->_Next();
  this->_Peek();
  if (this->c_id == Id::Op_Semi) {
    this->_Next();
    this->_NewlineOk();
  }
  else {
    if (this->c_id == Id::Op_Newline) {
      this->_Next();
    }
    else {
      if (this->c_id == Id::KW_Do) {
        ;  // pass
      }
      else {
        if (this->c_id == Id::Lit_LBrace) {
          ;  // pass
        }
        else {
          p_die(fmt246(), this->cur_word);
        }
      }
    }
  }
  if (this->c_id == Id::Lit_LBrace) {
    node->body = this->ParseBraceGroup();
  }
  else {
    node->body = this->ParseDoGroup();
  }
  return node;
}

syntax_asdl::command__ForEach* CommandParser::_ParseForEachLoop(int for_spid) {
  syntax_asdl::command__ForEach* node = nullptr;
  int num_iter_names;
  syntax_asdl::word_t* w = nullptr;
  syntax_asdl::word_t* UP_w = nullptr;
  bool ok;
  Str* iter_name = nullptr;
  bool quoted;
  int in_spid;
  int semi_spid;
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  List<syntax_asdl::compound_word*>* iter_words = nullptr;
  Str* s = nullptr;
  List<syntax_asdl::word_t*>* words2 = nullptr;
  List<syntax_asdl::word_t*>* words3 = nullptr;
  StackRoots _roots({&node, &w, &UP_w, &iter_name, &enode, &last_token, &iter_words, &s, &words2, &words3});

  node = Alloc<command::ForEach>();
  node->spids->append(for_spid);
  num_iter_names = 0;
  while (true) {
    w = this->cur_word;
    UP_w = w;
    if (w->tag_() == word_e::Compound) {
      compound_word* w = static_cast<compound_word*>(UP_w);
      if (word_::LiteralId(w->parts->index_(-1)) == Id::Lit_Comma) {
        w->parts->pop();
      }
    }
    Tuple3<bool, Str*, bool> tup16 = word_::StaticEval(w);
    ok = tup16.at0();
    iter_name = tup16.at1();
    quoted = tup16.at2();
    if ((!ok or quoted)) {
      p_die(fmt247(), w);
    }
    if (!match::IsValidVarName(iter_name)) {
      if (str_contains(iter_name, str882)) {
        p_die(fmt248(), w);
      }
      p_die(fmt249(iter_name), w);
    }
    node->iter_names->append(iter_name);
    num_iter_names += 1;
    this->_Next();
    this->_Peek();
    if (((this->c_id == Id::KW_In || this->c_id == Id::KW_Do) or this->c_kind == Kind::Op)) {
      break;
    }
    if (num_iter_names == 3) {
      p_die(fmt250(), this->cur_word);
    }
  }
  this->_NewlineOk();
  in_spid = runtime::NO_SPID;
  semi_spid = runtime::NO_SPID;
  this->_Peek();
  if (this->c_id == Id::KW_In) {
    in_spid = word_::LeftMostSpanForWord(this->cur_word);
    this->_Next();
    if (this->w_parser->LookPastSpace() == Id::Op_LParen) {
      Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> tup17 = this->parse_ctx->ParseOilExpr(this->lexer, grammar_nt::oil_expr);
      enode = tup17.at0();
      last_token = tup17.at1();
      node->iterable = Alloc<for_iter::Oil>(enode, last_token);
      this->_Peek();
      if (this->c_id != Id::Lit_LBrace) {
        p_die(fmt251(), this->cur_word);
      }
    }
    else {
      Tuple2<List<syntax_asdl::compound_word*>*, int> tup18 = this->ParseForWords();
      iter_words = tup18.at0();
      semi_spid = tup18.at1();
      if ((!this->parse_opts->parse_bare_word() and len(iter_words) == 1)) {
        Tuple3<bool, Str*, bool> tup19 = word_::StaticEval(iter_words->index_(0));
        ok = tup19.at0();
        s = tup19.at1();
        quoted = tup19.at2();
        if ((ok and (match::IsValidVarName(s) and !quoted))) {
          p_die(fmt252(), iter_words->index_(0));
        }
      }
      words2 = braces::BraceDetectAll(iter_words);
      words3 = word_::TildeDetectAll(words2);
      node->iterable = Alloc<for_iter::Words>(words3);
      if (num_iter_names > 2) {
        p_die(fmt253(), for_spid);
      }
    }
  }
  else {
    if (this->c_id == Id::KW_Do) {
      node->iterable = Alloc<for_iter::Args>();
    }
    else {
      if (this->c_id == Id::Op_Semi) {
        node->iterable = Alloc<for_iter::Args>();
        this->_Next();
      }
      else {
        p_die(fmt254(), this->cur_word);
      }
    }
  }
  this->_Peek();
  if (this->c_id == Id::Lit_LBrace) {
    node->body = this->ParseBraceGroup();
  }
  else {
    node->body = this->ParseDoGroup();
  }
  node->spids->append(in_spid);
  node->spids->append(semi_spid);
  return node;
}

syntax_asdl::command_t* CommandParser::ParseFor() {
  int for_spid;
  syntax_asdl::command__ForExpr* n1 = nullptr;
  syntax_asdl::command__ForEach* n2 = nullptr;
  StackRoots _roots({&n1, &n2});

  for_spid = _KeywordSpid(this->cur_word);
  this->_Eat(Id::KW_For);
  this->_Peek();
  if (this->c_id == Id::Op_DLeftParen) {
    if (!this->parse_opts->parse_dparen()) {
      p_die(fmt255(), this->cur_word);
    }
    n1 = this->_ParseForExprLoop();
    n1->redirects = this->_ParseRedirectList();
    return n1;
  }
  else {
    n2 = this->_ParseForEachLoop(for_spid);
    n2->redirects = this->_ParseRedirectList();
    return n2;
  }
}

syntax_asdl::command__WhileUntil* CommandParser::ParseWhileUntil(syntax_asdl::Token* keyword) {
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::condition_t* cond = nullptr;
  syntax_asdl::command__CommandList* commands = nullptr;
  syntax_asdl::command_t* body_node = nullptr;
  syntax_asdl::command__WhileUntil* node = nullptr;
  StackRoots _roots({&keyword, &enode, &cond, &commands, &body_node, &node});

  this->_Next();
  if ((this->parse_opts->parse_paren() and this->w_parser->LookPastSpace() == Id::Op_LParen)) {
    Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> tup20 = this->parse_ctx->ParseOilExpr(this->lexer, grammar_nt::oil_expr);
    enode = tup20.at0();
    cond = Alloc<condition::Oil>(enode);
  }
  else {
    this->allow_block = false;
    commands = this->_ParseCommandList();
    this->allow_block = true;
    cond = Alloc<condition::Shell>(commands->children);
  }
  this->_Peek();
  if ((this->parse_opts->parse_brace() and this->c_id == Id::Lit_LBrace)) {
    body_node = this->ParseBraceGroup();
  }
  else {
    body_node = this->ParseDoGroup();
  }
  node = Alloc<command::WhileUntil>(keyword, cond, body_node, nullptr);
  node->spids->append(keyword->span_id);
  return node;
}

syntax_asdl::case_arm* CommandParser::ParseCaseItem() {
  int left_spid;
  List<syntax_asdl::word_t*>* pat_words = nullptr;
  bool ok;
  Str* s = nullptr;
  bool quoted;
  int rparen_spid;
  syntax_asdl::command__CommandList* c_list = nullptr;
  List<syntax_asdl::command_t*>* action_children = nullptr;
  int dsemi_spid;
  int last_spid;
  List<int>* spids = nullptr;
  syntax_asdl::case_arm* arm = nullptr;
  StackRoots _roots({&pat_words, &s, &c_list, &action_children, &spids, &arm});

  this->lexer->PushHint(Id::Op_RParen, Id::Right_CasePat);
  left_spid = word_::LeftMostSpanForWord(this->cur_word);
  if (this->c_id == Id::Op_LParen) {
    this->_Next();
  }
  else {
    if (!this->parse_opts->parse_sloppy_case()) {
      p_die(fmt256(), this->cur_word);
    }
  }
  pat_words = Alloc<List<syntax_asdl::word_t*>>();
  while (true) {
    this->_Peek();
    pat_words->append(this->cur_word);
    this->_Next();
    this->_Peek();
    if (this->c_id == Id::Op_Pipe) {
      this->_Next();
    }
    else {
      break;
    }
  }
  if ((!this->parse_opts->parse_bare_word() and len(pat_words) == 1)) {
    Tuple3<bool, Str*, bool> tup21 = word_::StaticEval(pat_words->index_(0));
    ok = tup21.at0();
    s = tup21.at1();
    quoted = tup21.at2();
    if ((ok and (match::IsValidVarName(s) and !quoted))) {
      p_die(fmt257(), pat_words->index_(0));
    }
  }
  rparen_spid = word_::LeftMostSpanForWord(this->cur_word);
  this->_Eat(Id::Right_CasePat);
  this->_NewlineOk();
  if ((this->c_id != Id::Op_DSemi && this->c_id != Id::KW_Esac)) {
    c_list = this->_ParseCommandTerm();
    action_children = c_list->children;
  }
  else {
    action_children = Alloc<List<syntax_asdl::command_t*>>();
  }
  dsemi_spid = runtime::NO_SPID;
  last_spid = runtime::NO_SPID;
  this->_Peek();
  if (this->c_id == Id::KW_Esac) {
    last_spid = word_::LeftMostSpanForWord(this->cur_word);
  }
  else {
    if (this->c_id == Id::Op_DSemi) {
      dsemi_spid = word_::LeftMostSpanForWord(this->cur_word);
      this->_Next();
    }
    else {
      p_die(fmt258(), this->cur_word);
    }
  }
  this->_NewlineOk();
  spids = NewList<int>(std::initializer_list<int>{left_spid, rparen_spid, dsemi_spid, last_spid});
  arm = Alloc<syntax_asdl::case_arm>(pat_words, action_children, spids);
  return arm;
}

void CommandParser::ParseCaseList(List<syntax_asdl::case_arm*>* arms) {
  syntax_asdl::case_arm* arm = nullptr;
  StackRoots _roots({&arms, &arm});

  this->_Peek();
  while (true) {
    if (this->c_id == Id::KW_Esac) {
      break;
    }
    if ((this->parse_opts->parse_brace() and this->c_id == Id::Lit_RBrace)) {
      break;
    }
    if ((this->c_kind != Kind::Word and this->c_id != Id::Op_LParen)) {
      break;
    }
    arm = this->ParseCaseItem();
    arms->append(arm);
    this->_Peek();
  }
}

syntax_asdl::command__Case* CommandParser::ParseCase() {
  syntax_asdl::command__Case* case_node = nullptr;
  int case_spid;
  syntax_asdl::word_t* to_match = nullptr;
  bool ok;
  Str* s = nullptr;
  bool quoted;
  int in_spid;
  int esac_spid;
  StackRoots _roots({&case_node, &to_match, &s});

  case_node = Alloc<command::Case>();
  case_spid = _KeywordSpid(this->cur_word);
  this->_Next();
  this->_Peek();
  to_match = this->cur_word;
  if (!this->parse_opts->parse_bare_word()) {
    Tuple3<bool, Str*, bool> tup22 = word_::StaticEval(to_match);
    ok = tup22.at0();
    s = tup22.at1();
    quoted = tup22.at2();
    if ((ok and !quoted)) {
      p_die(fmt259(), to_match);
    }
  }
  case_node->to_match = to_match;
  this->_Next();
  this->_NewlineOk();
  in_spid = word_::LeftMostSpanForWord(this->cur_word);
  this->_Peek();
  if ((this->parse_opts->parse_brace() and this->c_id == Id::Lit_LBrace)) {
    this->_Next();
  }
  else {
    this->_Eat(Id::KW_In);
  }
  this->_NewlineOk();
  if (this->c_id != Id::KW_Esac) {
    this->ParseCaseList(case_node->arms);
    this->_Peek();
  }
  esac_spid = word_::LeftMostSpanForWord(this->cur_word);
  this->_Peek();
  if ((this->parse_opts->parse_brace() and this->c_id == Id::Lit_RBrace)) {
    this->_Next();
  }
  else {
    this->_Eat(Id::KW_Esac);
  }
  this->_Next();
  case_node->spids->append(case_spid);
  case_node->spids->append(in_spid);
  case_node->spids->append(esac_spid);
  return case_node;
}

void CommandParser::_ParseOilElifElse(syntax_asdl::command__If* if_node) {
  List<syntax_asdl::if_arm*>* arms = nullptr;
  int elif_spid;
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::condition_t* cond = nullptr;
  syntax_asdl::command__CommandList* commands = nullptr;
  syntax_asdl::BraceGroup* body = nullptr;
  syntax_asdl::if_arm* arm = nullptr;
  int else_spid;
  StackRoots _roots({&if_node, &arms, &enode, &cond, &commands, &body, &arm});

  arms = if_node->arms;
  while (this->c_id == Id::KW_Elif) {
    elif_spid = word_::LeftMostSpanForWord(this->cur_word);
    this->_Next();
    if ((this->parse_opts->parse_paren() and this->w_parser->LookPastSpace() == Id::Op_LParen)) {
      Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> tup23 = this->parse_ctx->ParseOilExpr(this->lexer, grammar_nt::oil_expr);
      enode = tup23.at0();
      cond = Alloc<condition::Oil>(enode);
    }
    else {
      this->allow_block = false;
      commands = this->_ParseCommandList();
      this->allow_block = true;
      cond = Alloc<condition::Shell>(commands->children);
    }
    body = this->ParseBraceGroup();
    this->_Peek();
    arm = Alloc<syntax_asdl::if_arm>(cond, body->children, NewList<int>(std::initializer_list<int>{elif_spid}));
    arms->append(arm);
  }
  this->_Peek();
  if (this->c_id == Id::KW_Else) {
    else_spid = word_::LeftMostSpanForWord(this->cur_word);
    this->_Next();
    body = this->ParseBraceGroup();
    if_node->else_action = body->children;
  }
  else {
    else_spid = runtime::NO_SPID;
  }
  if_node->spids->append(else_spid);
}

syntax_asdl::command__If* CommandParser::_ParseOilIf(int if_spid, syntax_asdl::condition_t* cond) {
  syntax_asdl::command__If* if_node = nullptr;
  syntax_asdl::BraceGroup* body1 = nullptr;
  syntax_asdl::if_arm* arm = nullptr;
  StackRoots _roots({&cond, &if_node, &body1, &arm});

  if_node = Alloc<command::If>();
  body1 = this->ParseBraceGroup();
  arm = Alloc<syntax_asdl::if_arm>(cond, body1->children, NewList<int>(std::initializer_list<int>{if_spid}));
  if_node->arms->append(arm);
  this->_Peek();
  if ((this->c_id == Id::KW_Elif || this->c_id == Id::KW_Else)) {
    this->_ParseOilElifElse(if_node);
  }
  else {
    if_node->spids->append(runtime::NO_SPID);
  }
  return if_node;
}

void CommandParser::_ParseElifElse(syntax_asdl::command__If* if_node) {
  List<syntax_asdl::if_arm*>* arms = nullptr;
  int elif_spid;
  syntax_asdl::command__CommandList* commands = nullptr;
  syntax_asdl::condition__Shell* cond = nullptr;
  int then_spid;
  syntax_asdl::command__CommandList* body = nullptr;
  syntax_asdl::if_arm* arm = nullptr;
  int else_spid;
  StackRoots _roots({&if_node, &arms, &commands, &cond, &body, &arm});

  arms = if_node->arms;
  this->_Peek();
  while (this->c_id == Id::KW_Elif) {
    elif_spid = word_::LeftMostSpanForWord(this->cur_word);
    this->_Next();
    commands = this->_ParseCommandList();
    cond = Alloc<condition::Shell>(commands->children);
    then_spid = word_::LeftMostSpanForWord(this->cur_word);
    this->_Eat(Id::KW_Then);
    body = this->_ParseCommandList();
    arm = Alloc<syntax_asdl::if_arm>(cond, body->children, NewList<int>(std::initializer_list<int>{elif_spid, then_spid}));
    arms->append(arm);
  }
  if (this->c_id == Id::KW_Else) {
    else_spid = word_::LeftMostSpanForWord(this->cur_word);
    this->_Next();
    body = this->_ParseCommandList();
    if_node->else_action = body->children;
  }
  else {
    else_spid = runtime::NO_SPID;
  }
  if_node->spids->append(else_spid);
}

syntax_asdl::command__If* CommandParser::ParseIf() {
  int if_spid;
  syntax_asdl::command__If* if_node = nullptr;
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::condition_t* cond = nullptr;
  syntax_asdl::command__CommandList* commands = nullptr;
  int then_spid;
  syntax_asdl::command__CommandList* body = nullptr;
  syntax_asdl::if_arm* arm = nullptr;
  int fi_spid;
  StackRoots _roots({&if_node, &enode, &cond, &commands, &body, &arm});

  if_spid = _KeywordSpid(this->cur_word);
  if_node = Alloc<command::If>();
  this->_Next();
  if ((this->parse_opts->parse_paren() and this->w_parser->LookPastSpace() == Id::Op_LParen)) {
    Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> tup24 = this->parse_ctx->ParseOilExpr(this->lexer, grammar_nt::oil_expr);
    enode = tup24.at0();
    cond = Alloc<condition::Oil>(enode);
  }
  else {
    this->allow_block = false;
    commands = this->_ParseCommandList();
    this->allow_block = true;
    cond = Alloc<condition::Shell>(commands->children);
  }
  this->_Peek();
  if ((this->parse_opts->parse_brace() and this->c_id == Id::Lit_LBrace)) {
    return this->_ParseOilIf(if_spid, cond);
  }
  then_spid = word_::LeftMostSpanForWord(this->cur_word);
  this->_Eat(Id::KW_Then);
  body = this->_ParseCommandList();
  arm = Alloc<syntax_asdl::if_arm>(cond, body->children, NewList<int>(std::initializer_list<int>{if_spid, then_spid}));
  if_node->arms->append(arm);
  if ((this->c_id == Id::KW_Elif || this->c_id == Id::KW_Else)) {
    this->_ParseElifElse(if_node);
  }
  else {
    if_node->spids->append(runtime::NO_SPID);
  }
  fi_spid = word_::LeftMostSpanForWord(this->cur_word);
  this->_Eat(Id::KW_Fi);
  if_node->spids->append(fi_spid);
  return if_node;
}

syntax_asdl::command_t* CommandParser::ParseTime() {
  int time_spid;
  syntax_asdl::command_t* pipeline = nullptr;
  syntax_asdl::command__TimeBlock* node = nullptr;
  StackRoots _roots({&pipeline, &node});

  time_spid = _KeywordSpid(this->cur_word);
  this->_Next();
  pipeline = this->ParsePipeline();
  node = Alloc<command::TimeBlock>(pipeline);
  node->spids->append(time_spid);
  return node;
}

syntax_asdl::command_t* CommandParser::ParseCompoundCommand() {
  syntax_asdl::BraceGroup* n1 = nullptr;
  syntax_asdl::command__Subshell* n2 = nullptr;
  syntax_asdl::Token* keyword = nullptr;
  syntax_asdl::command__WhileUntil* n3 = nullptr;
  syntax_asdl::command__If* n4 = nullptr;
  syntax_asdl::command__Case* n5 = nullptr;
  syntax_asdl::command__DBracket* n6 = nullptr;
  syntax_asdl::command__DParen* n7 = nullptr;
  StackRoots _roots({&n1, &n2, &keyword, &n3, &n4, &n5, &n6, &n7});

  if (this->c_id == Id::Lit_LBrace) {
    n1 = this->ParseBraceGroup();
    n1->redirects = this->_ParseRedirectList();
    return n1;
  }
  if (this->c_id == Id::Op_LParen) {
    n2 = this->ParseSubshell();
    n2->redirects = this->_ParseRedirectList();
    return n2;
  }
  if (this->c_id == Id::KW_For) {
    return this->ParseFor();
  }
  if ((this->c_id == Id::KW_While || this->c_id == Id::KW_Until)) {
    keyword = _KeywordToken(this->cur_word);
    n3 = this->ParseWhileUntil(keyword);
    n3->redirects = this->_ParseRedirectList();
    return n3;
  }
  if (this->c_id == Id::KW_If) {
    n4 = this->ParseIf();
    n4->redirects = this->_ParseRedirectList();
    return n4;
  }
  if (this->c_id == Id::KW_Case) {
    n5 = this->ParseCase();
    n5->redirects = this->_ParseRedirectList();
    return n5;
  }
  if (this->c_id == Id::KW_DLeftBracket) {
    n6 = this->ParseDBracket();
    n6->redirects = this->_ParseRedirectList();
    return n6;
  }
  if (this->c_id == Id::Op_DLeftParen) {
    if (!this->parse_opts->parse_dparen()) {
      p_die(fmt260(), this->cur_word);
    }
    n7 = this->ParseDParen();
    n7->redirects = this->_ParseRedirectList();
    return n7;
  }
  if (this->c_id == Id::KW_Time) {
    return this->ParseTime();
  }
  p_die(fmt261(), this->cur_word);
}

syntax_asdl::command__ShFunction* CommandParser::ParseFunctionDef() {
  int left_spid;
  Str* name = nullptr;
  syntax_asdl::word_part_t* part0 = nullptr;
  int after_name_spid;
  syntax_asdl::command__ShFunction* func = nullptr;
  StackRoots _roots({&name, &part0, &func});

  left_spid = word_::LeftMostSpanForWord(this->cur_word);
  compound_word* word0 = static_cast<compound_word*>(this->cur_word);
  name = word_::ShFunctionName(word0);
  if (len(name) == 0) {
    p_die(fmt262(), word0);
  }
  part0 = word0->parts->index_(0);
  Token* blame_tok = static_cast<Token*>(part0);
  this->_Next();
  this->_Peek();
  this->lexer->PushHint(Id::Op_RParen, Id::Right_ShFunction);
  this->_Next();
  this->_Peek();
  if (this->c_id == Id::Right_ShFunction) {
    this->_Next();
    after_name_spid = (word_::LeftMostSpanForWord(this->cur_word) + 1);
    this->_NewlineOk();
    func = Alloc<command::ShFunction>();
    func->name = name;
    {  // with
      ctx_VarChecker ctx(this->var_checker, blame_tok);

      func->body = this->ParseCompoundCommand();
    }
    func->spids->append(left_spid);
    func->spids->append(left_spid);
    func->spids->append(after_name_spid);
    return func;
  }
  else {
    p_die(fmt263(), this->cur_word);
    return nullptr;
  }
}

syntax_asdl::command__ShFunction* CommandParser::ParseKshFunctionDef() {
  syntax_asdl::Token* keyword_tok = nullptr;
  int left_spid;
  Str* name = nullptr;
  int name_spid;
  int after_name_spid;
  syntax_asdl::command__ShFunction* func = nullptr;
  StackRoots _roots({&keyword_tok, &name, &func});

  keyword_tok = _KeywordToken(this->cur_word);
  left_spid = word_::LeftMostSpanForWord(this->cur_word);
  this->_Next();
  this->_Peek();
  compound_word* cur_word = static_cast<compound_word*>(this->cur_word);
  name = word_::ShFunctionName(cur_word);
  if (len(name) == 0) {
    p_die(fmt264(), cur_word);
  }
  name_spid = word_::LeftMostSpanForWord(this->cur_word);
  after_name_spid = (name_spid + 1);
  this->_Next();
  this->_Peek();
  if (this->c_id == Id::Op_LParen) {
    this->lexer->PushHint(Id::Op_RParen, Id::Right_ShFunction);
    this->_Next();
    this->_Eat(Id::Right_ShFunction);
    after_name_spid = (word_::LeftMostSpanForWord(this->cur_word) + 1);
  }
  this->_NewlineOk();
  func = Alloc<command::ShFunction>();
  func->name = name;
  {  // with
    ctx_VarChecker ctx(this->var_checker, keyword_tok);

    func->body = this->ParseCompoundCommand();
  }
  func->spids->append(left_spid);
  func->spids->append(name_spid);
  func->spids->append(after_name_spid);
  return func;
}

syntax_asdl::command__Proc* CommandParser::ParseOilProc() {
  syntax_asdl::command__Proc* node = nullptr;
  syntax_asdl::Token* keyword_tok = nullptr;
  StackRoots _roots({&node, &keyword_tok});

  node = Alloc<command::Proc>();
  keyword_tok = _KeywordToken(this->cur_word);
  {  // with
    ctx_VarChecker ctx(this->var_checker, keyword_tok);

    this->w_parser->ParseProc(node);
    if (node->sig->tag_() == proc_sig_e::Closed) {
      proc_sig__Closed* sig = static_cast<proc_sig__Closed*>(node->sig);
      for (ListIter<syntax_asdl::UntypedParam*> it(sig->untyped); !it.Done(); it.Next()) {
        syntax_asdl::UntypedParam* param = it.Value();
        StackRoots _for({&param      });
        this->var_checker->Check(Id::KW_Var, param->name);
      }
      if (sig->rest) {
        this->var_checker->Check(Id::KW_Var, sig->rest);
      }
      for (ListIter<syntax_asdl::TypedParam*> it(sig->typed); !it.Done(); it.Next()) {
        syntax_asdl::TypedParam* param2 = it.Value();
        StackRoots _for({&param2      });
        this->var_checker->Check(Id::KW_Var, param2->name);
      }
    }
    this->_Next();
    node->body = this->ParseBraceGroup();
  }
  return node;
}

syntax_asdl::command_t* CommandParser::ParseCoproc() {
  throw Alloc<NotImplementedError>();
}

syntax_asdl::command__Subshell* CommandParser::ParseSubshell() {
  int left_spid;
  syntax_asdl::command__CommandList* c_list = nullptr;
  syntax_asdl::command_t* child = nullptr;
  syntax_asdl::command__Subshell* node = nullptr;
  int right_spid;
  StackRoots _roots({&c_list, &child, &node});

  left_spid = word_::LeftMostSpanForWord(this->cur_word);
  this->_Next();
  this->lexer->PushHint(Id::Op_RParen, Id::Right_Subshell);
  c_list = this->_ParseCommandList();
  if (len(c_list->children) == 1) {
    child = c_list->children->index_(0);
  }
  else {
    child = c_list;
  }
  node = Alloc<command::Subshell>(child, nullptr);
  right_spid = word_::LeftMostSpanForWord(this->cur_word);
  this->_Eat(Id::Right_Subshell);
  node->spids->append(left_spid);
  node->spids->append(right_spid);
  return node;
}

syntax_asdl::command__DBracket* CommandParser::ParseDBracket() {
  int left_spid;
  bool_parse::BoolParser* b_parser = nullptr;
  syntax_asdl::bool_expr_t* bnode = nullptr;
  int right_spid;
  syntax_asdl::command__DBracket* node = nullptr;
  StackRoots _roots({&b_parser, &bnode, &node});

  left_spid = word_::LeftMostSpanForWord(this->cur_word);
  this->_Next();
  b_parser = Alloc<bool_parse::BoolParser>(this->w_parser);
  bnode = b_parser->Parse();
  this->_Peek();
  right_spid = word_::LeftMostSpanForWord(this->cur_word);
  node = Alloc<command::DBracket>(bnode, nullptr);
  node->spids->append(left_spid);
  node->spids->append(right_spid);
  return node;
}

syntax_asdl::command__DParen* CommandParser::ParseDParen() {
  int left_spid;
  syntax_asdl::arith_expr_t* anode = nullptr;
  int right_spid;
  syntax_asdl::command__DParen* node = nullptr;
  StackRoots _roots({&anode, &node});

  left_spid = word_::LeftMostSpanForWord(this->cur_word);
  this->_Next();
  anode = this->w_parser->ReadDParen();
  this->_Peek();
  right_spid = word_::LeftMostSpanForWord(this->cur_word);
  node = Alloc<command::DParen>(anode, nullptr);
  node->spids->append(left_spid);
  node->spids->append(right_spid);
  return node;
}

syntax_asdl::command_t* CommandParser::ParseCommand() {
  int keyword_id;
  syntax_asdl::Token* kw_token = nullptr;
  syntax_asdl::command__VarDecl* n8 = nullptr;
  syntax_asdl::command__PlaceMutation* n9 = nullptr;
  syntax_asdl::Token* keyword = nullptr;
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::command__Func* out0 = nullptr;
  syntax_asdl::command__Data* out1 = nullptr;
  syntax_asdl::command__Enum* out2 = nullptr;
  syntax_asdl::command__Class* out3 = nullptr;
  syntax_asdl::command__Import* out4 = nullptr;
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  syntax_asdl::word_part_t* part0 = nullptr;
  StackRoots _roots({&kw_token, &n8, &n9, &keyword, &enode, &out0, &out1, &out2, &out3, &out4, &parts, &part0});

  this->_Peek();
  if (this->_AtSecondaryKeyword()) {
    p_die(fmt265(), this->cur_word);
  }
  if (this->c_id == Id::KW_Proc) {
    if (this->parse_opts->parse_proc()) {
      return this->ParseOilProc();
    }
    else {
      p_die(fmt266(), this->cur_word);
    }
  }
  if ((this->c_id == Id::KW_Var || this->c_id == Id::KW_Const)) {
    keyword_id = this->c_id;
    kw_token = word_::LiteralToken(this->cur_word);
    this->_Next();
    n8 = this->w_parser->ParseVarDecl(kw_token);
    for (ListIter<syntax_asdl::name_type*> it(n8->lhs); !it.Done(); it.Next()) {
      syntax_asdl::name_type* lhs = it.Value();
      StackRoots _for({&lhs    });
      this->var_checker->Check(keyword_id, lhs->name);
    }
    return n8;
  }
  if ((this->c_id == Id::KW_SetVar || this->c_id == Id::KW_SetRef || this->c_id == Id::KW_SetGlobal)) {
    kw_token = word_::LiteralToken(this->cur_word);
    this->_Next();
    n9 = this->w_parser->ParsePlaceMutation(kw_token, this->var_checker);
    return n9;
  }
  if ((this->c_id == Id::Lit_Underscore || this->c_id == Id::Lit_Equals)) {
    keyword = _KeywordToken(this->cur_word);
    this->_Next();
    enode = this->w_parser->ParseCommandExpr();
    return Alloc<command::Expr>(Alloc<speck>(keyword->id, keyword->span_id), enode);
  }
  if (this->c_id == Id::KW_Function) {
    return this->ParseKshFunctionDef();
  }
  if (this->parse_opts->parse_tea()) {
    if (this->c_id == Id::KW_Func) {
      out0 = Alloc<command::Func>();
      this->parse_ctx->ParseFunc(this->lexer, out0);
      this->_Next();
      return out0;
    }
    if (this->c_id == Id::KW_Data) {
      out1 = Alloc<command::Data>();
      this->parse_ctx->ParseDataType(this->lexer, out1);
      this->_Next();
      return out1;
    }
    if (this->c_id == Id::KW_Enum) {
      out2 = Alloc<command::Enum>();
      this->parse_ctx->ParseEnum(this->lexer, out2);
      this->_Next();
      return out2;
    }
    if (this->c_id == Id::KW_Class) {
      out3 = Alloc<command::Class>();
      this->parse_ctx->ParseClass(this->lexer, out3);
      this->_Next();
      return out3;
    }
    if (this->c_id == Id::KW_Import) {
      out4 = Alloc<command::Import>();
      this->w_parser->ParseImport(out4);
      this->_Next();
      return out4;
    }
  }
  if ((this->c_id == Id::KW_DLeftBracket || this->c_id == Id::Op_DLeftParen || this->c_id == Id::Op_LParen || this->c_id == Id::Lit_LBrace || this->c_id == Id::KW_For || this->c_id == Id::KW_While || this->c_id == Id::KW_Until || this->c_id == Id::KW_If || this->c_id == Id::KW_Case || this->c_id == Id::KW_Time)) {
    return this->ParseCompoundCommand();
  }
  if (this->c_id == Id::Lit_RBrace) {
    p_die(fmt267(), this->cur_word);
  }
  if (this->c_kind == Kind::Redir) {
    return this->ParseSimpleCommand();
  }
  if (this->c_kind == Kind::Word) {
    compound_word* cur_word = static_cast<compound_word*>(this->cur_word);
    if ((this->w_parser->LookAheadFuncParens() and !word_::IsVarLike(cur_word))) {
      return this->ParseFunctionDef();
    }
    parts = cur_word->parts;
    if ((this->parse_opts->parse_equals() and len(parts) == 1)) {
      part0 = parts->index_(0);
      if (part0->tag_() == word_part_e::Literal) {
        Token* tok = static_cast<Token*>(part0);
        if ((match::IsValidVarName(tok->val) and this->w_parser->LookPastSpace() == Id::Lit_Equals)) {
          if ((len(this->allow_block_attrs) and this->allow_block_attrs->index_(-1))) {
            enode = this->w_parser->ParseBareDecl();
            this->_Next();
            return Alloc<command::VarDecl>(nullptr, NewList<syntax_asdl::name_type*>(std::initializer_list<syntax_asdl::name_type*>{Alloc<name_type>(tok, nullptr)}), enode);
          }
          else {
            this->_Next();
            this->_Peek();
            p_die(fmt268(), this->cur_word);
          }
        }
      }
    }
    return this->ParseSimpleCommand();
  }
  if (this->c_kind == Kind::Eof) {
    p_die(fmt269(), this->cur_word);
  }
  p_die(fmt270(), this->cur_word);
}

syntax_asdl::command_t* CommandParser::ParsePipeline() {
  bool negated;
  int pipeline_spid;
  syntax_asdl::command_t* child = nullptr;
  List<syntax_asdl::command_t*>* children = nullptr;
  List<int>* no_stderrs = nullptr;
  syntax_asdl::command__Pipeline* node = nullptr;
  int pipe_index;
  List<int>* stderr_indices = nullptr;
  StackRoots _roots({&child, &children, &no_stderrs, &node, &stderr_indices});

  negated = false;
  pipeline_spid = runtime::NO_SPID;
  this->_Peek();
  if (this->c_id == Id::KW_Bang) {
    pipeline_spid = word_::LeftMostSpanForWord(this->cur_word);
    negated = true;
    this->_Next();
  }
  child = this->ParseCommand();
  children = NewList<syntax_asdl::command_t*>(std::initializer_list<syntax_asdl::command_t*>{child});
  this->_Peek();
  if ((this->c_id != Id::Op_Pipe && this->c_id != Id::Op_PipeAmp)) {
    if (negated) {
      no_stderrs = Alloc<List<int>>();
      node = Alloc<command::Pipeline>(children, negated, no_stderrs);
      node->spids->append(pipeline_spid);
      return node;
    }
    else {
      return child;
    }
  }
  pipe_index = 0;
  stderr_indices = Alloc<List<int>>();
  if (this->c_id == Id::Op_PipeAmp) {
    stderr_indices->append(pipe_index);
  }
  pipe_index += 1;
  while (true) {
    if (pipeline_spid == runtime::NO_SPID) {
      pipeline_spid = word_::LeftMostSpanForWord(this->cur_word);
    }
    this->_Next();
    this->_NewlineOk();
    child = this->ParseCommand();
    children->append(child);
    this->_Peek();
    if ((this->c_id != Id::Op_Pipe && this->c_id != Id::Op_PipeAmp)) {
      break;
    }
    if (this->c_id == Id::Op_PipeAmp) {
      stderr_indices->append(pipe_index);
    }
    pipe_index += 1;
  }
  node = Alloc<command::Pipeline>(children, negated, stderr_indices);
  node->spids->append(pipeline_spid);
  return node;
}

syntax_asdl::command_t* CommandParser::ParseAndOr() {
  syntax_asdl::Token* first_word_tok = nullptr;
  StackRoots _roots({&first_word_tok});

  this->_Peek();
  if (this->c_id == Id::Word_Compound) {
    first_word_tok = word_::LiteralToken(this->cur_word);
    if ((first_word_tok != nullptr and first_word_tok->id == Id::Lit_TDot)) {
      this->_Next();
      {  // with
        word_::ctx_Multiline ctx(this->w_parser);

        return this->_ParseAndOr();
      }
    }
  }
  return this->_ParseAndOr();
}

syntax_asdl::command_t* CommandParser::_ParseAndOr() {
  syntax_asdl::command_t* child = nullptr;
  List<int>* ops = nullptr;
  List<int>* op_spids = nullptr;
  List<syntax_asdl::command_t*>* children = nullptr;
  syntax_asdl::command__AndOr* node = nullptr;
  StackRoots _roots({&child, &ops, &op_spids, &children, &node});

  child = this->ParsePipeline();
  this->_Peek();
  if ((this->c_id != Id::Op_DPipe && this->c_id != Id::Op_DAmp)) {
    return child;
  }
  ops = Alloc<List<int>>();
  op_spids = Alloc<List<int>>();
  children = NewList<syntax_asdl::command_t*>(std::initializer_list<syntax_asdl::command_t*>{child});
  while (true) {
    ops->append(this->c_id);
    op_spids->append(word_::LeftMostSpanForWord(this->cur_word));
    this->_Next();
    this->_NewlineOk();
    child = this->ParsePipeline();
    children->append(child);
    this->_Peek();
    if ((this->c_id != Id::Op_DPipe && this->c_id != Id::Op_DAmp)) {
      break;
    }
  }
  node = Alloc<command::AndOr>(ops, children);
  node->spids = op_spids;
  return node;
}

syntax_asdl::command_t* CommandParser::_ParseCommandLine() {
  List<int>* END_LIST = nullptr;
  List<syntax_asdl::command_t*>* children = nullptr;
  bool done;
  syntax_asdl::command_t* child = nullptr;
  StackRoots _roots({&END_LIST, &children, &child});

  END_LIST = NewList<int>(std::initializer_list<int>{Id::Op_Newline, Id::Eof_Real});
  children = Alloc<List<syntax_asdl::command_t*>>();
  done = false;
  while (!done) {
    child = this->ParseAndOr();
    this->_Peek();
    if ((this->c_id == Id::Op_Semi || this->c_id == Id::Op_Amp)) {
      Token* tok = static_cast<Token*>(this->cur_word);
      child = Alloc<command::Sentence>(child, tok);
      this->_Next();
      this->_Peek();
      if (list_contains(END_LIST, this->c_id)) {
        done = true;
      }
    }
    else {
      if (list_contains(END_LIST, this->c_id)) {
        done = true;
      }
      else {
        p_die(fmt271(), this->cur_word);
      }
    }
    children->append(child);
  }
  if (len(children) > 1) {
    return Alloc<command::CommandList>(children);
  }
  else {
    return children->index_(0);
  }
}

syntax_asdl::command__CommandList* CommandParser::_ParseCommandTerm() {
  List<int>* END_LIST = nullptr;
  List<syntax_asdl::command_t*>* children = nullptr;
  bool done;
  syntax_asdl::command_t* child = nullptr;
  StackRoots _roots({&END_LIST, &children, &child});

  END_LIST = NewList<int>(std::initializer_list<int>{this->eof_id, Id::Right_Subshell, Id::Lit_RBrace, Id::Op_DSemi});
  children = Alloc<List<syntax_asdl::command_t*>>();
  done = false;
  while (!done) {
    this->_Peek();
    if (this->_AtSecondaryKeyword()) {
      break;
    }
    child = this->ParseAndOr();
    this->_Peek();
    if (this->c_id == Id::Op_Newline) {
      this->_Next();
      this->_Peek();
      if (list_contains(END_LIST, this->c_id)) {
        done = true;
      }
    }
    else {
      if ((this->c_id == Id::Op_Semi || this->c_id == Id::Op_Amp)) {
        Token* tok = static_cast<Token*>(this->cur_word);
        child = Alloc<command::Sentence>(child, tok);
        this->_Next();
        this->_Peek();
        if (this->c_id == Id::Op_Newline) {
          this->_Next();
          this->_Peek();
          if (list_contains(END_LIST, this->c_id)) {
            done = true;
          }
        }
        else {
          if (list_contains(END_LIST, this->c_id)) {
            done = true;
          }
        }
      }
      else {
        if (list_contains(END_LIST, this->c_id)) {
          done = true;
        }
        else {
          if ((this->parse_opts->parse_brace() and this->c_id == Id::Lit_LBrace)) {
            done = true;
          }
          else {
            if (this->c_kind != Kind::Word) {
              p_die(fmt272(), this->cur_word);
            }
          }
        }
      }
    }
    children->append(child);
  }
  this->_Peek();
  return Alloc<command::CommandList>(children);
}

syntax_asdl::command__CommandList* CommandParser::_ParseCommandList() {
  syntax_asdl::command__CommandList* node = nullptr;
  StackRoots _roots({&node});

  this->_NewlineOk();
  node = this->_ParseCommandTerm();
  return node;
}

syntax_asdl::command_t* CommandParser::ParseLogicalLine() {
  syntax_asdl::command_t* node = nullptr;
  StackRoots _roots({&node});

  this->_NewlineOk();
  this->_Peek();
  if (this->c_id == Id::Eof_Real) {
    return nullptr;
  }
  node = this->_ParseCommandLine();
  return node;
}

syntax_asdl::parse_result_t* CommandParser::ParseInteractiveLine() {
  syntax_asdl::command_t* node = nullptr;
  StackRoots _roots({&node});

  this->_Peek();
  if (this->c_id == Id::Op_Newline) {
    return Alloc<parse_result::EmptyLine>();
  }
  if (this->c_id == Id::Eof_Real) {
    return Alloc<parse_result::Eof>();
  }
  node = this->_ParseCommandLine();
  return Alloc<parse_result::Node>(node);
}

syntax_asdl::command_t* CommandParser::ParseCommandSub() {
  syntax_asdl::command__CommandList* c_list = nullptr;
  StackRoots _roots({&c_list});

  this->_NewlineOk();
  if (this->c_kind == Kind::Eof) {
    return Alloc<command::NoOp>();
  }
  c_list = this->_ParseCommandTerm();
  if (len(c_list->children) == 1) {
    return c_list->children->index_(0);
  }
  else {
    return c_list;
  }
}

void CommandParser::CheckForPendingHereDocs() {
  syntax_asdl::redir* node = nullptr;
  StackRoots _roots({&node});

  if (len(this->pending_here_docs)) {
    node = this->pending_here_docs->index_(0);
    redir_param__HereDoc* h = static_cast<redir_param__HereDoc*>(node->arg);
    p_die(fmt273(), h->here_begin);
  }
}

}  // define namespace cmd_parse

namespace glob_ {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using syntax_asdl::compound_word;
using syntax_asdl::Token;
namespace word_part_e = syntax_asdl::word_part_e;
namespace glob_part_e = syntax_asdl::glob_part_e;
namespace glob_part = syntax_asdl::glob_part;
using syntax_asdl::glob_part_t;
using syntax_asdl::glob_part__Literal;
using syntax_asdl::glob_part__Operator;
using syntax_asdl::glob_part__CharClass;

bool LooksLikeGlob(Str* s) {
  bool left_bracket;
  int i;
  int n;
  Str* c = nullptr;
  StackRoots _roots({&s, &c});

  left_bracket = false;
  i = 0;
  n = len(s);
  while (i < n) {
    c = s->index_(i);
    if (str_equals(c, str909)) {
      i += 1;
    }
    else {
      if ((str_equals(c, str910) or str_equals(c, str911))) {
        return true;
      }
      else {
        if (str_equals(c, str912)) {
          left_bracket = true;
        }
        else {
          if ((str_equals(c, str913) and left_bracket)) {
            return true;
          }
        }
      }
    }
    i += 1;
  }
  return false;
}

bool LooksLikeStaticGlob(syntax_asdl::compound_word* w) {
  bool left_bracket;
  int id_;
  StackRoots _roots({&w});

  left_bracket = false;
  for (ListIter<syntax_asdl::word_part_t*> it(w->parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoots _for({&part  });
    if (part->tag_() == word_part_e::Literal) {
      id_ = static_cast<Token*>(part)->id;
      if ((id_ == Id::Lit_Star || id_ == Id::Lit_QMark)) {
        return true;
      }
      else {
        if (id_ == Id::Lit_LBracket) {
          left_bracket = true;
        }
        else {
          if ((id_ == Id::Lit_RBracket and left_bracket)) {
            return true;
          }
        }
      }
    }
  }
  return false;
}
Str* GLOB_META_CHARS = str914;

Str* GlobEscape(Str* s) {
  StackRoots _roots({&s});

  return pyutil::BackslashEscape(s, GLOB_META_CHARS);
}
Str* ERE_META_CHARS = str915;

Str* ExtendedRegexEscape(Str* s) {
  StackRoots _roots({&s});

  return pyutil::BackslashEscape(s, ERE_META_CHARS);
}

Str* GlobUnescape(Str* s) {
  List<Str*>* unescaped = nullptr;
  int i;
  int n;
  Str* c = nullptr;
  Str* c2 = nullptr;
  StackRoots _roots({&s, &unescaped, &c, &c2});

  unescaped = Alloc<List<Str*>>();
  i = 0;
  n = len(s);
  while (i < n) {
    c = s->index_(i);
    if ((str_equals(c, str916) and i != (n - 1))) {
      i += 1;
      c2 = s->index_(i);
      if (str_contains(GLOB_META_CHARS, c2)) {
        unescaped->append(c2);
      }
      else {
        assert(0);  // AssertionError
      }
    }
    else {
      unescaped->append(c);
    }
    i += 1;
  }
  return str918->join(unescaped);
}

_GlobParser::_GlobParser(match::SimpleLexer* lexer) 
    : Obj(Tag::FixedSize, maskof__GlobParser(), sizeof(_GlobParser))  {
  this->lexer = lexer;
  this->token_type = Id::Undefined_Tok;
  this->token_val = str919;
  this->warnings = Alloc<List<Str*>>();
}

void _GlobParser::_Next() {
  Tuple2<int, Str*> tup0 = this->lexer->Next();
  this->token_type = tup0.at0();
  this->token_val = tup0.at1();
}

List<syntax_asdl::glob_part_t*>* _GlobParser::_ParseCharClass() {
  syntax_asdl::glob_part__Literal* first_token = nullptr;
  int balance;
  List<Tuple2<int, Str*>*>* tokens = nullptr;
  List<syntax_asdl::glob_part_t*>* parts = nullptr;
  int id_;
  Str* s = nullptr;
  bool negated;
  int id1;
  List<Str*>* strs = nullptr;
  StackRoots _roots({&first_token, &tokens, &parts, &s, &strs});

  first_token = Alloc<glob_part::Literal>(this->token_type, this->token_val);
  balance = 1;
  tokens = Alloc<List<Tuple2<int, Str*>*>>();
  while (true) {
    this->_Next();
    if (this->token_type == Id::Eol_Tok) {
      this->warnings->append(str920);
      parts = NewList<syntax_asdl::glob_part_t*>(std::initializer_list<syntax_asdl::glob_part_t*>{first_token});
      for (ListIter<Tuple2<int, Str*>*> it(tokens); !it.Done(); it.Next()) {
        Tuple2<int, Str*>* tup1 = it.Value();
        id_ = tup1->at0();
        s = tup1->at1();
        parts->append(Alloc<glob_part::Literal>(id_, s));
      }
      return parts;
    }
    if (this->token_type == Id::Glob_LBracket) {
      balance += 1;
    }
    else {
      if (this->token_type == Id::Glob_RBracket) {
        balance -= 1;
      }
    }
    if (balance == 0) {
      break;
    }
    tokens->append((Alloc<Tuple2<int, Str*>>(this->token_type, this->token_val)));
  }
  negated = false;
  if (len(tokens)) {
    Tuple2<int, Str*>* tup2 = tokens->index_(0);
    id1 = tup2->at0();
    if ((id1 == Id::Glob_Bang || id1 == Id::Glob_Caret)) {
      negated = true;
      tokens = tokens->slice(1);
    }
  }
  strs = Alloc<List<Str*>>();
  for (ListIter<Tuple2<int, Str*>*> it(tokens); !it.Done(); it.Next()) {
    Tuple2<int, Str*>* tup3 = it.Value();
    s = tup3->at1();
    strs->append(s);
  }
  return NewList<syntax_asdl::glob_part_t*>(std::initializer_list<syntax_asdl::glob_part_t*>{Alloc<glob_part::CharClass>(negated, strs)});
}

Tuple2<List<syntax_asdl::glob_part_t*>*, List<Str*>*> _GlobParser::Parse() {
  List<syntax_asdl::glob_part_t*>* parts = nullptr;
  int id_;
  Str* s = nullptr;
  StackRoots _roots({&parts, &s});

  parts = Alloc<List<syntax_asdl::glob_part_t*>>();
  while (true) {
    this->_Next();
    id_ = this->token_type;
    s = this->token_val;
    if (id_ == Id::Eol_Tok) {
      break;
    }
    if ((id_ == Id::Glob_Star || id_ == Id::Glob_QMark)) {
      parts->append(Alloc<glob_part::Operator>(id_));
    }
    else {
      if (id_ == Id::Glob_LBracket) {
        parts->extend(this->_ParseCharClass());
      }
      else {
        parts->append(Alloc<glob_part::Literal>(id_, s));
      }
    }
    if (id_ == Id::Glob_RBracket) {
      this->warnings->append(str921);
    }
    if (id_ == Id::Glob_BadBackslash) {
      this->warnings->append(str922);
    }
  }
  return (Tuple2<List<syntax_asdl::glob_part_t*>*, List<Str*>*>(parts, this->warnings));
}
Str* _REGEX_CHARS_TO_ESCAPE = str923;

Str* _GenerateERE(List<syntax_asdl::glob_part_t*>* parts) {
  List<Str*>* out = nullptr;
  int tag;
  syntax_asdl::glob_part_t* UP_part = nullptr;
  Str* c = nullptr;
  List<Str*>* good = nullptr;
  bool literal_hyphen;
  bool literal_rbracket;
  StackRoots _roots({&parts, &out, &UP_part, &c, &good});

  out = Alloc<List<Str*>>();
  for (ListIter<syntax_asdl::glob_part_t*> it(parts); !it.Done(); it.Next()) {
    syntax_asdl::glob_part_t* part = it.Value();
    StackRoots _for({&part  });
    tag = part->tag_();
    UP_part = part;
    if (tag == glob_part_e::Literal) {
      glob_part__Literal* part = static_cast<glob_part__Literal*>(UP_part);
      if (part->id == Id::Glob_EscapedChar) {
        c = part->s->index_(1);
        if (str_contains(_REGEX_CHARS_TO_ESCAPE, c)) {
          out->append(str924);
        }
        out->append(c);
      }
      else {
        if ((part->id == Id::Glob_CleanLiterals || part->id == Id::Glob_Bang)) {
          out->append(part->s);
        }
        else {
          if ((part->id == Id::Glob_OtherLiteral || part->id == Id::Glob_Caret)) {
            c = part->s;
            if (str_contains(_REGEX_CHARS_TO_ESCAPE, c)) {
              out->append(str925);
            }
            out->append(c);
          }
          else {
            if (part->id == Id::Glob_LBracket) {
              out->append(str926);
            }
            else {
              if (part->id == Id::Glob_RBracket) {
                out->append(str927);
              }
              else {
                if (part->id == Id::Glob_BadBackslash) {
                  out->append(str928);
                }
                else {
                  if (part->id == Id::Glob_Caret) {
                    out->append(str929);
                  }
                  else {
                    assert(0);  // AssertionError
                  }
                }
              }
            }
          }
        }
      }
    }
    else {
      if (tag == glob_part_e::Operator) {
        glob_part__Operator* part = static_cast<glob_part__Operator*>(UP_part);
        if (part->op_id == Id::Glob_QMark) {
          out->append(str930);
        }
        else {
          if (part->op_id == Id::Glob_Star) {
            out->append(str931);
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
      else {
        if (tag == glob_part_e::CharClass) {
          glob_part__CharClass* part = static_cast<glob_part__CharClass*>(UP_part);
          out->append(str932);
          if (part->negated) {
            out->append(str933);
          }
          good = Alloc<List<Str*>>();
          literal_hyphen = false;
          literal_rbracket = false;
          for (ListIter<Str*> it(part->strs); !it.Done(); it.Next()) {
            Str* s = it.Value();
            StackRoots _for({&s          });
            if (str_equals(s, str934)) {
              literal_hyphen = true;
              continue;
            }
            if (str_equals(s, str935)) {
              literal_rbracket = true;
              continue;
            }
            good->append(s);
          }
          if (literal_rbracket) {
            out->append(str936);
          }
          out->extend(good);
          if (literal_hyphen) {
            out->append(str937);
          }
          out->append(str938);
        }
      }
    }
  }
  return str939->join(out);
}

Tuple2<Str*, List<Str*>*> GlobToERE(Str* pat) {
  match::SimpleLexer* lexer = nullptr;
  glob_::_GlobParser* p = nullptr;
  List<syntax_asdl::glob_part_t*>* parts = nullptr;
  List<Str*>* warnings = nullptr;
  Str* regex = nullptr;
  StackRoots _roots({&pat, &lexer, &p, &parts, &warnings, &regex});

  lexer = match::GlobLexer(pat);
  p = Alloc<_GlobParser>(lexer);
  Tuple2<List<syntax_asdl::glob_part_t*>*, List<Str*>*> tup4 = p->Parse();
  parts = tup4.at0();
  warnings = tup4.at1();
  regex = _GenerateERE(parts);
  return (Tuple2<Str*, List<Str*>*>(regex, warnings));
}

Globber::Globber(optview::Exec* exec_opts) 
    : Obj(Tag::FixedSize, maskof_Globber(), sizeof(Globber))  {
  this->exec_opts = exec_opts;
}

int Globber::_Glob(Str* arg, List<Str*>* out) {
  List<Str*>* results = nullptr;
  Str* msg = nullptr;
  int n;
  StackRoots _roots({&arg, &out, &results, &msg});

  try {
    results = libc::glob(arg);
  }
  catch (RuntimeError* e) {
    msg = e->message;
    println_stderr(fmt274(arg, msg));
    throw ;
  }
  n = len(results);
  if (n) {
    if (!this->exec_opts->dashglob()) {
      results = Alloc<List<Str*>>();
      for (ListIter<Str*> it(results); !it.Done(); it.Next()) {
        Str* s = it.Value();
        if (!s->startswith(str941)) {
          results->append(s);
        }
      }
      n = len(results);
    }
    out->extend(results);
    return n;
  }
  return 0;
}

int Globber::Expand(Str* arg, List<Str*>* out) {
  int n;
  StackRoots _roots({&arg, &out});

  if (this->exec_opts->noglob()) {
    out->append(arg);
    return 1;
  }
  n = this->_Glob(arg, out);
  if (n) {
    return n;
  }
  if (this->exec_opts->failglob()) {
    return -1;
  }
  if (this->exec_opts->nullglob()) {
    return 0;
  }
  else {
    out->append(GlobUnescape(arg));
    return 1;
  }
}

int Globber::ExpandExtended(Str* glob_pat, Str* fnmatch_pat, List<Str*>* out) {
  List<Str*>* tmp = nullptr;
  List<Str*>* filtered = nullptr;
  int n;
  StackRoots _roots({&glob_pat, &fnmatch_pat, &out, &tmp, &filtered});

  if (this->exec_opts->noglob()) {
    out->append(fnmatch_pat);
    return 1;
  }
  tmp = Alloc<List<Str*>>();
  this->_Glob(glob_pat, tmp);
  filtered = Alloc<List<Str*>>();
  for (ListIter<Str*> it(tmp); !it.Done(); it.Next()) {
    Str* s = it.Value();
    if (libc::fnmatch(fnmatch_pat, s)) {
      filtered->append(s);
    }
  }
  n = len(filtered);
  if (n) {
    out->extend(filtered);
    return n;
  }
  if (this->exec_opts->failglob()) {
    return -1;
  }
  if (this->exec_opts->nullglob()) {
    return 0;
  }
  else {
    out->append(GlobUnescape(fnmatch_pat));
    return 1;
  }
}

List<Str*>* Globber::OilFuncCall(Str* arg) {
  List<Str*>* out = nullptr;
  StackRoots _roots({&arg, &out});

  out = Alloc<List<Str*>>();
  this->_Glob(arg, out);
  return out;
}

}  // define namespace glob_

namespace prompt {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Id_t;
namespace value_e = runtime_asdl::value_e;
using runtime_asdl::value_t;
using runtime_asdl::value__Str;
using syntax_asdl::command_t;
namespace source = syntax_asdl::source;
using syntax_asdl::compound_word;
Str* PROMPT_ERROR = str942;

_PromptEvaluatorCache::_PromptEvaluatorCache() 
    : Obj(Tag::FixedSize, maskof__PromptEvaluatorCache(), sizeof(_PromptEvaluatorCache))  {
  this->cache = Alloc<Dict<Str*, Str*>>();
  this->euid = -1;
}

int _PromptEvaluatorCache::_GetEuid() {
  if (this->euid == -1) {
    this->euid = posix::geteuid();
  }
  return this->euid;
}

Str* _PromptEvaluatorCache::Get(Str* name) {
  Str* value = nullptr;
  StackRoots _roots({&name, &value});

  if (dict_contains(this->cache, name)) {
    return this->cache->index_(name);
  }
  if (str_equals(name, str943)) {
    value = this->_GetEuid() == 0 ? str944 : str945;
  }
  else {
    if (str_equals(name, str946)) {
      value = libc::gethostname();
    }
    else {
      if (str_equals(name, str947)) {
        value = pyos::GetUserName(this->_GetEuid());
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  this->cache->set(name, value);
  return value;
}

Evaluator::Evaluator(Str* lang, Str* version_str, parse_lib::ParseContext* parse_ctx, state::Mem* mem) 
    : Obj(Tag::FixedSize, maskof_Evaluator(), sizeof(Evaluator))  {
  this->word_ev = nullptr;
  this->lang = lang;
  this->version_str = version_str;
  this->parse_ctx = parse_ctx;
  this->mem = mem;
  this->cache = Alloc<_PromptEvaluatorCache>();
  this->tokens_cache = Alloc<Dict<Str*, List<Tuple2<int, Str*>*>*>>();
  this->parse_cache = Alloc<Dict<Str*, syntax_asdl::compound_word*>>();
}

void Evaluator::CheckCircularDeps() {
}

Str* Evaluator::_ReplaceBackslashCodes(List<Tuple2<int, Str*>*>* tokens) {
  List<Str*>* ret = nullptr;
  int non_printing;
  int id_;
  Str* value = nullptr;
  int i;
  Str* ch = nullptr;
  Str* r = nullptr;
  Str* hostname = nullptr;
  double now;
  Str* fmt = nullptr;
  Str* pwd = nullptr;
  Str* home = nullptr;
  runtime_asdl::value_t* val = nullptr;
  StackRoots _roots({&tokens, &ret, &value, &ch, &r, &hostname, &fmt, &pwd, &home, &val});

  ret = Alloc<List<Str*>>();
  non_printing = 0;
  for (ListIter<Tuple2<int, Str*>*> it(tokens); !it.Done(); it.Next()) {
    Tuple2<int, Str*>* tup0 = it.Value();
    id_ = tup0->at0();
    value = tup0->at1();
    if ((id_ == Id::PS_Literals || id_ == Id::PS_BadBackslash)) {
      ret->append(value);
    }
    else {
      if (id_ == Id::PS_Octal3) {
        i = to_int(value->slice(1), 8);
        ret->append(chr((i % 256)));
      }
      else {
        if (id_ == Id::PS_LBrace) {
          non_printing += 1;
          ret->append(str948);
        }
        else {
          if (id_ == Id::PS_RBrace) {
            non_printing -= 1;
            if (non_printing < 0) {
              return PROMPT_ERROR;
            }
            ret->append(str949);
          }
          else {
            if (id_ == Id::PS_Subst) {
              ch = value->index_(1);
              if (str_equals(ch, str950)) {
                r = this->cache->Get(str951);
              }
              else {
                if (str_equals(ch, str952)) {
                  r = this->cache->Get(str953);
                }
                else {
                  if (str_equals(ch, str954)) {
                    hostname = this->cache->Get(str955);
                    Tuple2<Str*, Str*> tup1 = mylib::split_once(hostname, str956);
                    r = tup1.at0();
                  }
                  else {
                    if (str_equals(ch, str957)) {
                      r = this->cache->Get(str958);
                    }
                    else {
                      if (str_equals(ch, str959)) {
                        r = this->lang;
                      }
                      else {
                        if (str_equals(ch, str960)) {
                          r = this->version_str;
                        }
                        else {
                          if (str_equals(ch, str961)) {
                            now = time_::time();
                            r = time_::strftime(str962, time_::localtime(now));
                          }
                          else {
                            if (str_equals(ch, str963)) {
                              now = time_::time();
                              fmt = value->slice(3, -1);
                              if (len(fmt) == 0) {
                                fmt = str964;
                              }
                              r = time_::strftime(fmt, time_::localtime(now));
                            }
                            else {
                              if (str_equals(ch, str965)) {
                                try {
                                  pwd = state::GetString(this->mem, str966);
                                  home = state::MaybeString(this->mem, str967);
                                  r = ui::PrettyDir(pwd, home);
                                }
                                catch (error::Runtime* e) {
                                  r = fmt275(e->UserErrorString());
                                }
                              }
                              else {
                                if (str_equals(ch, str969)) {
                                  val = this->mem->GetValue(str970);
                                  if (val->tag_() == value_e::Str) {
                                    value__Str* str_val = static_cast<value__Str*>(val);
                                    r = os_path::basename(str_val->s);
                                  }
                                  else {
                                    r = str971;
                                  }
                                }
                                else {
                                  r = consts::LookupCharPrompt(ch);
                                  if (r == nullptr) {
                                    r = fmt276(ch);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              ret->append(r->replace(str973, str974));
            }
            else {
              assert(0);  // AssertionError
            }
          }
        }
      }
    }
  }
  if (non_printing != 0) {
    return PROMPT_ERROR;
  }
  return str976->join(ret);
}

Str* Evaluator::EvalPrompt(runtime_asdl::value_t* UP_val) {
  List<Tuple2<int, Str*>*>* tokens = nullptr;
  Str* ps1_str = nullptr;
  syntax_asdl::compound_word* ps1_word = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  runtime_asdl::value__Str* val2 = nullptr;
  StackRoots _roots({&UP_val, &tokens, &ps1_str, &ps1_word, &w_parser, &val2});

  if (UP_val->tag_() != value_e::Str) {
    return str977;
  }
  value__Str* val = static_cast<value__Str*>(UP_val);
  tokens = this->tokens_cache->get(val->s);
  if (tokens == nullptr) {
    tokens = match::Ps1Tokens(val->s);
    this->tokens_cache->set(val->s, tokens);
  }
  ps1_str = this->_ReplaceBackslashCodes(tokens);
  ps1_word = this->parse_cache->get(ps1_str);
  if (ps1_word == nullptr) {
    w_parser = this->parse_ctx->MakeWordParserForPlugin(ps1_str);
    try {
      ps1_word = w_parser->ReadForPlugin();
    }
    catch (error::Parse* e) {
      ps1_word = word_::ErrorWord(fmt277(e->UserErrorString()));
    }
    this->parse_cache->set(ps1_str, ps1_word);
  }
  val2 = this->word_ev->EvalForPlugin(ps1_word);
  return val2->s;
}

Str* Evaluator::EvalFirstPrompt() {
  runtime_asdl::value_t* val = nullptr;
  StackRoots _roots({&val});

  if (str_equals(this->lang, str979)) {
    val = this->mem->GetValue(str980);
    return this->EvalPrompt(val);
  }
  else {
    return str_concat(this->lang, str981);
  }
}
Str* PROMPT_COMMAND = str982;

UserPlugin::UserPlugin(state::Mem* mem, parse_lib::ParseContext* parse_ctx, cmd_eval::CommandEvaluator* cmd_ev, ui::ErrorFormatter* errfmt) 
    : Obj(Tag::FixedSize, maskof_UserPlugin(), sizeof(UserPlugin))  {
  this->mem = mem;
  this->parse_ctx = parse_ctx;
  this->cmd_ev = cmd_ev;
  this->errfmt = errfmt;
  this->arena = parse_ctx->arena;
  this->parse_cache = Alloc<Dict<Str*, syntax_asdl::command_t*>>();
}

void UserPlugin::Run() {
  runtime_asdl::value_t* val = nullptr;
  Str* prompt_cmd = nullptr;
  syntax_asdl::command_t* node = nullptr;
  reader::FileLineReader* line_reader = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  syntax_asdl::source__Variable* src = nullptr;
  StackRoots _roots({&val, &prompt_cmd, &node, &line_reader, &c_parser, &src});

  val = this->mem->GetValue(PROMPT_COMMAND);
  if (val->tag_() != value_e::Str) {
    return ;
  }
  prompt_cmd = static_cast<value__Str*>(val)->s;
  node = this->parse_cache->get(prompt_cmd);
  if (node == nullptr) {
    line_reader = reader::StringLineReader(prompt_cmd, this->arena);
    c_parser = this->parse_ctx->MakeOshParser(line_reader);
    src = Alloc<source::Variable>(PROMPT_COMMAND, runtime::NO_SPID);
    {  // with
      alloc::ctx_Location ctx(this->arena, src);

      try {
        node = main_loop::ParseWholeFile(c_parser);
      }
      catch (error::Parse* e) {
        this->errfmt->PrettyPrintError(e);
        return ;
      }
    }
    this->parse_cache->set(prompt_cmd, node);
  }
  {  // with
    state::ctx_Registers ctx(this->mem);

    this->cmd_ev->ExecuteAndCatch(node);
  }
}

}  // define namespace prompt

namespace sh_expr_eval {  // define

namespace Id = id_kind_asdl::Id;
using runtime_asdl::scope_t;
namespace lvalue = runtime_asdl::lvalue;
namespace lvalue_e = runtime_asdl::lvalue_e;
using runtime_asdl::lvalue_t;
using runtime_asdl::lvalue__Named;
using runtime_asdl::lvalue__Indexed;
using runtime_asdl::lvalue__Keyed;
namespace value = runtime_asdl::value;
namespace value_e = runtime_asdl::value_e;
using runtime_asdl::value_t;
using runtime_asdl::value__Str;
using runtime_asdl::value__Int;
using runtime_asdl::value__MaybeStrArray;
using runtime_asdl::value__AssocArray;
using runtime_asdl::value__Obj;
namespace arith_expr_e = syntax_asdl::arith_expr_e;
using syntax_asdl::arith_expr_t;
using syntax_asdl::arith_expr__Unary;
using syntax_asdl::arith_expr__Binary;
using syntax_asdl::arith_expr__UnaryAssign;
using syntax_asdl::arith_expr__BinaryAssign;
using syntax_asdl::arith_expr__TernaryOp;
namespace bool_expr_e = syntax_asdl::bool_expr_e;
using syntax_asdl::bool_expr_t;
using syntax_asdl::bool_expr__WordTest;
using syntax_asdl::bool_expr__LogicalNot;
using syntax_asdl::bool_expr__LogicalAnd;
using syntax_asdl::bool_expr__LogicalOr;
using syntax_asdl::bool_expr__Unary;
using syntax_asdl::bool_expr__Binary;
using syntax_asdl::compound_word;
using syntax_asdl::Token;
namespace sh_lhs_expr_e = syntax_asdl::sh_lhs_expr_e;
using syntax_asdl::sh_lhs_expr_t;
using syntax_asdl::sh_lhs_expr__Name;
using syntax_asdl::sh_lhs_expr__IndexedName;
namespace source = syntax_asdl::source;
using syntax_asdl::word_t;
using syntax_asdl::braced_var_sub;
using types_asdl::bool_arg_type_e;

runtime_asdl::value_t* OldValue(runtime_asdl::lvalue_t* lval, state::Mem* mem, optview::Exec* exec_opts) {
  runtime_asdl::lvalue_t* UP_lval = nullptr;
  Str* var_name = nullptr;
  runtime_asdl::value_t* val = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  runtime_asdl::value__MaybeStrArray* array_val = nullptr;
  Str* s = nullptr;
  runtime_asdl::value__AssocArray* assoc_val = nullptr;
  StackRoots _roots({&lval, &mem, &exec_opts, &UP_lval, &var_name, &val, &UP_val, &array_val, &s, &assoc_val});

  UP_lval = lval;
  switch (lval->tag_()) {
    case lvalue_e::Named: {
      lvalue__Named* lval = static_cast<lvalue__Named*>(UP_lval);
      var_name = lval->name;
    }
      break;
    case lvalue_e::Indexed: {
      lvalue__Indexed* lval = static_cast<lvalue__Indexed*>(UP_lval);
      var_name = lval->name;
    }
      break;
    case lvalue_e::Keyed: {
      lvalue__Keyed* lval = static_cast<lvalue__Keyed*>(UP_lval);
      var_name = lval->name;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  val = mem->GetValue(var_name);
  if ((exec_opts and (exec_opts->nounset() and val->tag_() == value_e::Undef))) {
    e_die(fmt278(var_name));
  }
  UP_val = val;
  switch (lval->tag_()) {
    case lvalue_e::Named: {
      return val;
    }
      break;
    case lvalue_e::Indexed: {
      lvalue__Indexed* lval = static_cast<lvalue__Indexed*>(UP_lval);
      array_val = nullptr;
      switch (val->tag_()) {
        case value_e::Undef: {
          array_val = Alloc<value::MaybeStrArray>(Alloc<List<Str*>>());
        }
          break;
        case value_e::MaybeStrArray: {
          value__MaybeStrArray* tmp = static_cast<value__MaybeStrArray*>(UP_val);
          array_val = tmp;
        }
          break;
        default: {
          e_die(fmt279(ui::ValType(val)));
        }
      }
      s = word_eval::GetArrayItem(array_val->strs, lval->index);
      if (s == nullptr) {
        val = Alloc<value::Str>(str985);
      }
      else {
        val = Alloc<value::Str>(s);
      }
    }
      break;
    case lvalue_e::Keyed: {
      lvalue__Keyed* lval = static_cast<lvalue__Keyed*>(UP_lval);
      assoc_val = nullptr;
      switch (val->tag_()) {
        case value_e::Undef: {
          assert(0);  // AssertionError
        }
          break;
        case value_e::AssocArray: {
          value__AssocArray* tmp2 = static_cast<value__AssocArray*>(UP_val);
          assoc_val = tmp2;
        }
          break;
        default: {
          e_die(fmt280(ui::ValType(val)));
        }
      }
      s = assoc_val->d->get(lval->key);
      if (s == nullptr) {
        val = Alloc<value::Str>(str987);
      }
      else {
        val = Alloc<value::Str>(s);
      }
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return val;
}

UnsafeArith::UnsafeArith(state::Mem* mem, optview::Exec* exec_opts, parse_lib::ParseContext* parse_ctx, sh_expr_eval::ArithEvaluator* arith_ev, ui::ErrorFormatter* errfmt) 
    : Obj(Tag::FixedSize, maskof_UnsafeArith(), sizeof(UnsafeArith))  {
  this->mem = mem;
  this->exec_opts = exec_opts;
  this->parse_ctx = parse_ctx;
  this->arith_ev = arith_ev;
  this->errfmt = errfmt;
  this->arena = this->parse_ctx->arena;
}

runtime_asdl::lvalue_t* UnsafeArith::ParseLValue(Str* s, int span_id) {
  tdop::TdopParser* a_parser = nullptr;
  syntax_asdl::arith_expr_t* anode = nullptr;
  runtime_asdl::lvalue_t* lval = nullptr;
  StackRoots _roots({&s, &a_parser, &anode, &lval});

  a_parser = this->parse_ctx->MakeArithParser(s);
  {  // with
    alloc::ctx_Location ctx(this->arena, Alloc<source::ArgvWord>(str988, span_id));

    try {
      anode = a_parser->Parse();
    }
    catch (error::Parse* e) {
      this->errfmt->PrettyPrintError(e);
      e_usage(fmt281(), span_id);
    }
  }
  lval = this->arith_ev->EvalArithLhs(anode, span_id);
  if ((!this->exec_opts->eval_unsafe_arith() and lval->tag_() != lvalue_e::Named)) {
    e_usage(fmt282(), span_id);
  }
  return lval;
}

syntax_asdl::braced_var_sub* UnsafeArith::ParseVarRef(Str* ref_str, syntax_asdl::Token* token) {
  int static_ref_spid;
  reader::FileLineReader* line_reader = nullptr;
  lexer::Lexer* lexer = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  syntax_asdl::braced_var_sub* bvs_part = nullptr;
  StackRoots _roots({&ref_str, &token, &line_reader, &lexer, &w_parser, &bvs_part});

  static_ref_spid = token->span_id;
  line_reader = reader::StringLineReader(ref_str, this->arena);
  lexer = this->parse_ctx->MakeLexer(line_reader);
  w_parser = this->parse_ctx->MakeWordParser(lexer, line_reader);
  {  // with
    alloc::ctx_Location ctx(this->arena, Alloc<source::Variable>(token->val, static_ref_spid));

    try {
      bvs_part = w_parser->ParseVarRef();
    }
    catch (error::Parse* e) {
      this->errfmt->PrettyPrintError(e);
      e_die(fmt283(), static_ref_spid);
    }
  }
  bvs_part->spids->append(static_ref_spid);
  return bvs_part;
}

ArithEvaluator::ArithEvaluator(state::Mem* mem, optview::Exec* exec_opts, parse_lib::ParseContext* parse_ctx, ui::ErrorFormatter* errfmt) 
    : Obj(Tag::FixedSize, maskof_ArithEvaluator(), sizeof(ArithEvaluator))  {
  this->word_ev = nullptr;
  this->mem = mem;
  this->exec_opts = exec_opts;
  this->parse_ctx = parse_ctx;
  this->errfmt = errfmt;
}

void ArithEvaluator::CheckCircularDeps() {
}

int ArithEvaluator::_StringToInteger(Str* s, int span_id) {
  int integer;
  Str* b = nullptr;
  Str* digits = nullptr;
  int base;
  int digit;
  alloc::Arena* arena = nullptr;
  tdop::TdopParser* a_parser = nullptr;
  syntax_asdl::arith_expr_t* node2 = nullptr;
  StackRoots _roots({&s, &b, &digits, &arena, &a_parser, &node2});

  if (s->startswith(str992)) {
    try {
      integer = to_int(s, 16);
    }
    catch (ValueError*) {
      e_strict(fmt284(s), span_id);
    }
    return integer;
  }
  if (s->startswith(str994)) {
    try {
      integer = to_int(s, 8);
    }
    catch (ValueError*) {
      e_strict(fmt285(s), span_id);
    }
    return integer;
  }
  if (str_contains(s, str996)) {
    Tuple2<Str*, Str*> tup0 = mylib::split_once(s, str997);
    b = tup0.at0();
    digits = tup0.at1();
    try {
      base = to_int(b);
    }
    catch (ValueError*) {
      e_strict(fmt286(b), span_id);
    }
    integer = 0;
    for (StrIter it(digits); !it.Done(); it.Next()) {
      Str* ch = it.Value();
      StackRoots _for({&ch    });
      if (IsLower(ch)) {
        digit = ((ord(ch) - ord(str999)) + 10);
      }
      else {
        if (IsUpper(ch)) {
          digit = ((ord(ch) - ord(str1000)) + 36);
        }
        else {
          if (str_equals(ch, str1001)) {
            digit = 62;
          }
          else {
            if (str_equals(ch, str1002)) {
              digit = 63;
            }
            else {
              if (ch->isdigit()) {
                digit = to_int(ch);
              }
              else {
                e_strict(fmt287(digits), span_id);
              }
            }
          }
        }
      }
      if (digit >= base) {
        e_strict(fmt288(digits, base), span_id);
      }
      integer = ((integer * base) + digit);
    }
    return integer;
  }
  try {
    integer = to_int(s);
  }
  catch (ValueError*) {
    if ((this->exec_opts->eval_unsafe_arith() and this->parse_ctx)) {
      arena = this->parse_ctx->arena;
      if (len(s->strip()) == 0) {
        return 0;
      }
      a_parser = this->parse_ctx->MakeArithParser(s);
      {  // with
        alloc::ctx_Location ctx(arena, Alloc<source::Variable>(nullptr, span_id));

        try {
          node2 = a_parser->Parse();
        }
        catch (error::Parse* e) {
          this->errfmt->PrettyPrintError(e);
          e_die(fmt289(), e->span_id);
        }
      }
      if (node2->tag_() == arith_expr_e::Word) {
        e_die(fmt290(s), span_id);
      }
      else {
        integer = this->EvalToInt(node2);
      }
    }
    else {
      if ((len(s->strip()) == 0 or match::IsValidVarName(s))) {
        e_strict(fmt291(s), span_id);
      }
      else {
        e_die(fmt292(s), span_id);
      }
    }
  }
  return integer;
}

int ArithEvaluator::_ValToIntOrError(runtime_asdl::value_t* val) {
  return _ValToIntOrError(val, runtime::NO_SPID);
}

int ArithEvaluator::_ValToIntOrError(runtime_asdl::value_t* val, int span_id) {
  runtime_asdl::value_t* UP_val = nullptr;
  StackRoots _roots({&val, &UP_val});

  try {
    UP_val = val;
    switch (val->tag_()) {
      case value_e::Undef: {
        e_strict(fmt293(), span_id);
      }
        break;
      case value_e::Int: {
        value__Int* val = static_cast<value__Int*>(UP_val);
        return val->i;
      }
        break;
      case value_e::Str: {
        value__Str* val = static_cast<value__Str*>(UP_val);
        return this->_StringToInteger(val->s, span_id);
      }
        break;
      case value_e::Obj: {
        assert(0);  // AssertionError
      }
        break;
    }
  }
  catch (error::Strict* e) {
    if (this->exec_opts->strict_arith()) {
      throw ;
    }
    else {
      return 0;
    }
  }
  e_die(fmt294(ui::ValType(val)), span_id);
}

Tuple2<int, runtime_asdl::lvalue_t*> ArithEvaluator::_EvalLhsAndLookupArith(syntax_asdl::arith_expr_t* node) {
  runtime_asdl::lvalue_t* lval = nullptr;
  runtime_asdl::value_t* val = nullptr;
  int span_id;
  int i;
  StackRoots _roots({&node, &lval, &val});

  lval = this->EvalArithLhs(node, runtime::NO_SPID);
  val = OldValue(lval, this->mem, this->exec_opts);
  if (((val->tag_() == value_e::MaybeStrArray || val->tag_() == value_e::AssocArray) and lval->tag_() == lvalue_e::Named)) {
    lvalue__Named* named_lval = static_cast<lvalue__Named*>(lval);
    if (word_eval::ShouldArrayDecay(named_lval->name, this->exec_opts)) {
      if (val->tag_() == value_e::MaybeStrArray) {
        lval = Alloc<lvalue::Indexed>(named_lval->name, 0);
      }
      else {
        if (val->tag_() == value_e::AssocArray) {
          lval = Alloc<lvalue::Keyed>(named_lval->name, str1011);
        }
      }
      val = word_eval::DecayArray(val);
    }
  }
  span_id = location::SpanForArithExpr(node);
  i = this->_ValToIntOrError(val, span_id);
  return (Tuple2<int, runtime_asdl::lvalue_t*>(i, lval));
}

void ArithEvaluator::_Store(runtime_asdl::lvalue_t* lval, int new_int) {
  runtime_asdl::value__Str* val = nullptr;
  StackRoots _roots({&lval, &val});

  val = Alloc<value::Str>(str(new_int));
  state::OshLanguageSetValue(this->mem, lval, val);
}

int ArithEvaluator::EvalToInt(syntax_asdl::arith_expr_t* node) {
  runtime_asdl::value_t* val = nullptr;
  int span_id;
  int i;
  StackRoots _roots({&node, &val});

  val = this->Eval(node);
  if (((val->tag_() == value_e::MaybeStrArray || val->tag_() == value_e::AssocArray) and node->tag_() == arith_expr_e::VarRef)) {
    Token* tok = static_cast<Token*>(node);
    if (word_eval::ShouldArrayDecay(tok->val, this->exec_opts)) {
      val = word_eval::DecayArray(val);
    }
  }
  span_id = location::SpanForArithExpr(node);
  i = this->_ValToIntOrError(val, span_id);
  return i;
}

runtime_asdl::value_t* ArithEvaluator::Eval(syntax_asdl::arith_expr_t* node) {
  syntax_asdl::arith_expr_t* UP_node = nullptr;
  Str* var_name = nullptr;
  runtime_asdl::value_t* val = nullptr;
  int op_id;
  int old_int;
  runtime_asdl::lvalue_t* lval = nullptr;
  int new_int;
  int ret;
  int rhs_int;
  int rhs;
  int i;
  int lhs;
  runtime_asdl::value_t* left = nullptr;
  runtime_asdl::value_t* UP_left = nullptr;
  int index;
  Str* s = nullptr;
  Str* key = nullptr;
  int cond;
  StackRoots _roots({&node, &UP_node, &var_name, &val, &lval, &left, &UP_left, &s, &key});

  UP_node = node;
  switch (node->tag_()) {
    case arith_expr_e::VarRef: {
      Token* tok = static_cast<Token*>(UP_node);
      var_name = tok->val;
      val = this->mem->GetValue(var_name);
      if ((val->tag_() == value_e::Undef and this->exec_opts->nounset())) {
        e_die(fmt295(var_name), tok);
      }
      return val;
    }
      break;
    case arith_expr_e::Word: {
      compound_word* w = static_cast<compound_word*>(UP_node);
      return this->word_ev->EvalWordToString(w);
    }
      break;
    case arith_expr_e::UnaryAssign: {
      arith_expr__UnaryAssign* node = static_cast<arith_expr__UnaryAssign*>(UP_node);
      op_id = node->op_id;
      Tuple2<int, runtime_asdl::lvalue_t*> tup1 = this->_EvalLhsAndLookupArith(node->child);
      old_int = tup1.at0();
      lval = tup1.at1();
      if (op_id == Id::Node_PostDPlus) {
        new_int = (old_int + 1);
        ret = old_int;
      }
      else {
        if (op_id == Id::Node_PostDMinus) {
          new_int = (old_int - 1);
          ret = old_int;
        }
        else {
          if (op_id == Id::Arith_DPlus) {
            new_int = (old_int + 1);
            ret = new_int;
          }
          else {
            if (op_id == Id::Arith_DMinus) {
              new_int = (old_int - 1);
              ret = new_int;
            }
            else {
              assert(0);  // AssertionError
            }
          }
        }
      }
      this->_Store(lval, new_int);
      return Alloc<value::Int>(ret);
    }
      break;
    case arith_expr_e::BinaryAssign: {
      arith_expr__BinaryAssign* node = static_cast<arith_expr__BinaryAssign*>(UP_node);
      op_id = node->op_id;
      if (op_id == Id::Arith_Equal) {
        lval = this->EvalArithLhs(node->left, runtime::NO_SPID);
        rhs_int = this->EvalToInt(node->right);
        this->_Store(lval, rhs_int);
        return Alloc<value::Int>(rhs_int);
      }
      Tuple2<int, runtime_asdl::lvalue_t*> tup2 = this->_EvalLhsAndLookupArith(node->left);
      old_int = tup2.at0();
      lval = tup2.at1();
      rhs = this->EvalToInt(node->right);
      if (op_id == Id::Arith_PlusEqual) {
        new_int = (old_int + rhs);
      }
      else {
        if (op_id == Id::Arith_MinusEqual) {
          new_int = (old_int - rhs);
        }
        else {
          if (op_id == Id::Arith_StarEqual) {
            new_int = (old_int * rhs);
          }
          else {
            if (op_id == Id::Arith_SlashEqual) {
              if (rhs == 0) {
                e_die(str1013);
              }
              new_int = (old_int / rhs);
            }
            else {
              if (op_id == Id::Arith_PercentEqual) {
                if (rhs == 0) {
                  e_die(str1014);
                }
                new_int = (old_int % rhs);
              }
              else {
                if (op_id == Id::Arith_DGreatEqual) {
                  new_int = (old_int >> rhs);
                }
                else {
                  if (op_id == Id::Arith_DLessEqual) {
                    new_int = (old_int << rhs);
                  }
                  else {
                    if (op_id == Id::Arith_AmpEqual) {
                      new_int = (old_int & rhs);
                    }
                    else {
                      if (op_id == Id::Arith_PipeEqual) {
                        new_int = (old_int | rhs);
                      }
                      else {
                        if (op_id == Id::Arith_CaretEqual) {
                          new_int = (old_int ^ rhs);
                        }
                        else {
                          assert(0);  // AssertionError
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      this->_Store(lval, new_int);
      return Alloc<value::Int>(new_int);
    }
      break;
    case arith_expr_e::Unary: {
      arith_expr__Unary* node = static_cast<arith_expr__Unary*>(UP_node);
      op_id = node->op_id;
      i = this->EvalToInt(node->child);
      if (op_id == Id::Node_UnaryPlus) {
        ret = i;
      }
      else {
        if (op_id == Id::Node_UnaryMinus) {
          ret = -i;
        }
        else {
          if (op_id == Id::Arith_Bang) {
            ret = i == 0 ? 1 : 0;
          }
          else {
            if (op_id == Id::Arith_Tilde) {
              ret = ~i;
            }
            else {
              assert(0);  // AssertionError
            }
          }
        }
      }
      return Alloc<value::Int>(ret);
    }
      break;
    case arith_expr_e::Binary: {
      arith_expr__Binary* node = static_cast<arith_expr__Binary*>(UP_node);
      op_id = node->op_id;
      if (op_id == Id::Arith_DPipe) {
        lhs = this->EvalToInt(node->left);
        if (lhs == 0) {
          rhs = this->EvalToInt(node->right);
          ret = to_int(rhs != 0);
        }
        else {
          ret = 1;
        }
        return Alloc<value::Int>(ret);
      }
      if (op_id == Id::Arith_DAmp) {
        lhs = this->EvalToInt(node->left);
        if (lhs == 0) {
          ret = 0;
        }
        else {
          rhs = this->EvalToInt(node->right);
          ret = to_int(rhs != 0);
        }
        return Alloc<value::Int>(ret);
      }
      if (op_id == Id::Arith_LBracket) {
        left = this->Eval(node->left);
        UP_left = left;
        switch (left->tag_()) {
          case value_e::MaybeStrArray: {
            value__MaybeStrArray* array_val = static_cast<value__MaybeStrArray*>(UP_left);
            index = this->EvalToInt(node->right);
            s = word_eval::GetArrayItem(array_val->strs, index);
          }
            break;
          case value_e::AssocArray: {
            value__AssocArray* left = static_cast<value__AssocArray*>(UP_left);
            key = this->EvalWordToString(node->right);
            s = left->d->get(key);
          }
            break;
          default: {
            e_die(fmt296(ui::ValType(left)));
          }
        }
        if (s == nullptr) {
          val = Alloc<value::Undef>();
        }
        else {
          val = Alloc<value::Str>(s);
        }
        return val;
      }
      if (op_id == Id::Arith_Comma) {
        this->EvalToInt(node->left);
        ret = this->EvalToInt(node->right);
        return Alloc<value::Int>(ret);
      }
      lhs = this->EvalToInt(node->left);
      rhs = this->EvalToInt(node->right);
      if (op_id == Id::Arith_Plus) {
        ret = (lhs + rhs);
      }
      else {
        if (op_id == Id::Arith_Minus) {
          ret = (lhs - rhs);
        }
        else {
          if (op_id == Id::Arith_Star) {
            ret = (lhs * rhs);
          }
          else {
            if (op_id == Id::Arith_Slash) {
              if (rhs == 0) {
                e_die(fmt297(), location::SpanForArithExpr(node->right));
              }
              ret = (lhs / rhs);
            }
            else {
              if (op_id == Id::Arith_Percent) {
                if (rhs == 0) {
                  e_die(fmt298(), location::SpanForArithExpr(node->right));
                }
                ret = (lhs % rhs);
              }
              else {
                if (op_id == Id::Arith_DStar) {
                  if (rhs < 0) {
                    e_die(str1018);
                  }
                  ret = 1;
                  for (int i = 0; i < rhs; ++i) {
                    ret *= lhs;
                  }
                }
                else {
                  if (op_id == Id::Arith_DEqual) {
                    ret = to_int(lhs == rhs);
                  }
                  else {
                    if (op_id == Id::Arith_NEqual) {
                      ret = to_int(lhs != rhs);
                    }
                    else {
                      if (op_id == Id::Arith_Great) {
                        ret = to_int(lhs > rhs);
                      }
                      else {
                        if (op_id == Id::Arith_GreatEqual) {
                          ret = to_int(lhs >= rhs);
                        }
                        else {
                          if (op_id == Id::Arith_Less) {
                            ret = to_int(lhs < rhs);
                          }
                          else {
                            if (op_id == Id::Arith_LessEqual) {
                              ret = to_int(lhs <= rhs);
                            }
                            else {
                              if (op_id == Id::Arith_Pipe) {
                                ret = (lhs | rhs);
                              }
                              else {
                                if (op_id == Id::Arith_Amp) {
                                  ret = (lhs & rhs);
                                }
                                else {
                                  if (op_id == Id::Arith_Caret) {
                                    ret = (lhs ^ rhs);
                                  }
                                  else {
                                    if (op_id == Id::Arith_DLess) {
                                      ret = (lhs << rhs);
                                    }
                                    else {
                                      if (op_id == Id::Arith_DGreat) {
                                        ret = (lhs >> rhs);
                                      }
                                      else {
                                        assert(0);  // AssertionError
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return Alloc<value::Int>(ret);
    }
      break;
    case arith_expr_e::TernaryOp: {
      arith_expr__TernaryOp* node = static_cast<arith_expr__TernaryOp*>(UP_node);
      cond = this->EvalToInt(node->cond);
      if (cond) {
        return this->Eval(node->true_expr);
      }
      else {
        return this->Eval(node->false_expr);
      }
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  assert(0);  // AssertionError
}

Str* ArithEvaluator::EvalWordToString(syntax_asdl::arith_expr_t* node) {
  syntax_asdl::arith_expr_t* UP_node = nullptr;
  runtime_asdl::value__Str* val = nullptr;
  StackRoots _roots({&node, &UP_node, &val});

  UP_node = node;
  if (node->tag_() == arith_expr_e::Word) {
    compound_word* w = static_cast<compound_word*>(UP_node);
    val = this->word_ev->EvalWordToString(w);
    return val->s;
  }
  else {
    e_die(str1020);
  }
}

runtime_asdl::lvalue_t* ArithEvaluator::EvalShellLhs(syntax_asdl::sh_lhs_expr_t* node, int spid, runtime_asdl::scope_t which_scopes) {
  syntax_asdl::sh_lhs_expr_t* UP_node = nullptr;
  runtime_asdl::lvalue_t* lval = nullptr;
  runtime_asdl::lvalue__Named* lval1 = nullptr;
  Str* key = nullptr;
  runtime_asdl::lvalue__Keyed* lval2 = nullptr;
  int index;
  runtime_asdl::lvalue__Indexed* lval3 = nullptr;
  StackRoots _roots({&node, &UP_node, &lval, &lval1, &key, &lval2, &lval3});

  UP_node = node;
  lval = nullptr;
  switch (node->tag_()) {
    case sh_lhs_expr_e::Name: {
      sh_lhs_expr__Name* node = static_cast<sh_lhs_expr__Name*>(UP_node);
      lval1 = Alloc<lvalue::Named>(node->name);
      lval1->spids->append(spid);
      lval = lval1;
    }
      break;
    case sh_lhs_expr_e::IndexedName: {
      sh_lhs_expr__IndexedName* node = static_cast<sh_lhs_expr__IndexedName*>(UP_node);
      if (this->mem->IsAssocArray(node->name)) {
        key = this->EvalWordToString(node->index);
        lval2 = Alloc<lvalue::Keyed>(node->name, key);
        lval2->spids->append(node->spids->index_(0));
        lval = lval2;
      }
      else {
        index = this->EvalToInt(node->index);
        lval3 = Alloc<lvalue::Indexed>(node->name, index);
        lval3->spids->append(node->spids->index_(0));
        lval = lval3;
      }
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return lval;
}

Tuple2<Str*, int> ArithEvaluator::_VarRefOrWord(syntax_asdl::arith_expr_t* anode) {
  syntax_asdl::arith_expr_t* UP_anode = nullptr;
  Str* var_name = nullptr;
  int span_id;
  Str* no_str = nullptr;
  StackRoots _roots({&anode, &UP_anode, &var_name, &no_str});

  UP_anode = anode;
  switch (anode->tag_()) {
    case arith_expr_e::VarRef: {
      Token* tok = static_cast<Token*>(UP_anode);
      return (Tuple2<Str*, int>(tok->val, tok->span_id));
    }
      break;
    case arith_expr_e::Word: {
      compound_word* w = static_cast<compound_word*>(UP_anode);
      var_name = this->EvalWordToString(w);
      span_id = word_::LeftMostSpanForWord(w);
      return (Tuple2<Str*, int>(var_name, span_id));
    }
      break;
  }
  no_str = nullptr;
  return (Tuple2<Str*, int>(no_str, runtime::NO_SPID));
}

runtime_asdl::lvalue_t* ArithEvaluator::EvalArithLhs(syntax_asdl::arith_expr_t* anode, int span_id) {
  syntax_asdl::arith_expr_t* UP_anode = nullptr;
  Str* var_name = nullptr;
  Str* key = nullptr;
  runtime_asdl::lvalue__Keyed* lval2 = nullptr;
  runtime_asdl::lvalue_t* lval = nullptr;
  int index;
  runtime_asdl::lvalue__Indexed* lval3 = nullptr;
  runtime_asdl::lvalue__Named* lval1 = nullptr;
  StackRoots _roots({&anode, &UP_anode, &var_name, &key, &lval2, &lval, &lval3, &lval1});

  UP_anode = anode;
  if (anode->tag_() == arith_expr_e::Binary) {
    arith_expr__Binary* anode = static_cast<arith_expr__Binary*>(UP_anode);
    if (anode->op_id == Id::Arith_LBracket) {
      Tuple2<Str*, int> tup3 = this->_VarRefOrWord(anode->left);
      var_name = tup3.at0();
      span_id = tup3.at1();
      if (var_name != nullptr) {
        if (this->mem->IsAssocArray(var_name)) {
          key = this->EvalWordToString(anode->right);
          lval2 = Alloc<lvalue::Keyed>(var_name, key);
          lval2->spids->append(span_id);
          lval = lval2;
          return lval;
        }
        else {
          index = this->EvalToInt(anode->right);
          lval3 = Alloc<lvalue::Indexed>(var_name, index);
          lval3->spids->append(span_id);
          lval = lval3;
          return lval;
        }
      }
    }
  }
  Tuple2<Str*, int> tup4 = this->_VarRefOrWord(anode);
  var_name = tup4.at0();
  span_id = tup4.at1();
  if (var_name != nullptr) {
    lval1 = Alloc<lvalue::Named>(var_name);
    lval1->spids->append(span_id);
    lval = lval1;
    return lval;
  }
  e_die_status(2, str1021, span_id);
}

BoolEvaluator::BoolEvaluator(state::Mem* mem, optview::Exec* exec_opts, parse_lib::ParseContext* parse_ctx, ui::ErrorFormatter* errfmt) : ArithEvaluator(mem, exec_opts, parse_ctx, errfmt) {
  this->always_strict = false;
}

void BoolEvaluator::Init_AlwaysStrict() {
  this->always_strict = true;
}

int BoolEvaluator::_StringToIntegerOrError(Str* s) {
  return _StringToIntegerOrError(s, nullptr);
}

int BoolEvaluator::_StringToIntegerOrError(Str* s, syntax_asdl::word_t* blame_word) {
  int span_id;
  int i;
  StackRoots _roots({&s, &blame_word});

  if (blame_word) {
    span_id = word_::LeftMostSpanForWord(blame_word);
  }
  else {
    span_id = runtime::NO_SPID;
  }
  try {
    i = this->_StringToInteger(s, span_id);
  }
  catch (error::Strict* e) {
    if ((this->always_strict or this->exec_opts->strict_arith())) {
      throw ;
    }
    else {
      i = 0;
    }
  }
  return i;
}

Str* BoolEvaluator::_EvalCompoundWord(syntax_asdl::word_t* word) {
  return _EvalCompoundWord(word, 0);
}

Str* BoolEvaluator::_EvalCompoundWord(syntax_asdl::word_t* word, int eval_flags) {
  runtime_asdl::value__Str* val = nullptr;
  StackRoots _roots({&word, &val});

  val = this->word_ev->EvalWordToString(word, eval_flags);
  return val->s;
}

bool BoolEvaluator::EvalB(syntax_asdl::bool_expr_t* node) {
  syntax_asdl::bool_expr_t* UP_node = nullptr;
  Str* s = nullptr;
  bool b;
  int op_id;
  types_asdl::bool_arg_type_t arg_type;
  int index;
  runtime_asdl::value_t* val = nullptr;
  int eval_flags;
  Str* s1 = nullptr;
  Str* s2 = nullptr;
  int i1;
  int i2;
  List<Str*>* matches = nullptr;
  Str* msg = nullptr;
  StackRoots _roots({&node, &UP_node, &s, &val, &s1, &s2, &matches, &msg});

  UP_node = node;
  switch (node->tag_()) {
    case bool_expr_e::WordTest: {
      bool_expr__WordTest* node = static_cast<bool_expr__WordTest*>(UP_node);
      s = this->_EvalCompoundWord(node->w);
      return to_bool(s);
    }
      break;
    case bool_expr_e::LogicalNot: {
      bool_expr__LogicalNot* node = static_cast<bool_expr__LogicalNot*>(UP_node);
      b = this->EvalB(node->child);
      return !b;
    }
      break;
    case bool_expr_e::LogicalAnd: {
      bool_expr__LogicalAnd* node = static_cast<bool_expr__LogicalAnd*>(UP_node);
      if (this->EvalB(node->left)) {
        return this->EvalB(node->right);
      }
      else {
        return false;
      }
    }
      break;
    case bool_expr_e::LogicalOr: {
      bool_expr__LogicalOr* node = static_cast<bool_expr__LogicalOr*>(UP_node);
      if (this->EvalB(node->left)) {
        return true;
      }
      else {
        return this->EvalB(node->right);
      }
    }
      break;
    case bool_expr_e::Unary: {
      bool_expr__Unary* node = static_cast<bool_expr__Unary*>(UP_node);
      op_id = node->op_id;
      s = this->_EvalCompoundWord(node->child);
      arg_type = consts::BoolArgType(op_id);
      if (arg_type == bool_arg_type_e::Path) {
        return bool_stat::DoUnaryOp(op_id, s);
      }
      if (arg_type == bool_arg_type_e::Str) {
        if (op_id == Id::BoolUnary_z) {
          return !to_bool(s);
        }
        if (op_id == Id::BoolUnary_n) {
          return to_bool(s);
        }
        assert(0);  // AssertionError
      }
      if (arg_type == bool_arg_type_e::Other) {
        if (op_id == Id::BoolUnary_t) {
          return bool_stat::isatty(s, node->child);
        }
        if (op_id == Id::BoolUnary_o) {
          index = consts::OptionNum(s);
          if (index == 0) {
            return false;
          }
          else {
            return this->exec_opts->opt0_array->index_(index);
          }
        }
        if (op_id == Id::BoolUnary_v) {
          val = this->mem->GetValue(s);
          return val->tag_() != value_e::Undef;
        }
        e_die(fmt299(ui::PrettyId(op_id)));
      }
      assert(0);  // AssertionError
    }
      break;
    case bool_expr_e::Binary: {
      bool_expr__Binary* node = static_cast<bool_expr__Binary*>(UP_node);
      op_id = node->op_id;
      eval_flags = 0;
      switch (op_id) {
        case Id::BoolBinary_GlobEqual: 
        case Id::BoolBinary_GlobDEqual: 
        case Id::BoolBinary_GlobNEqual: {
          eval_flags |= word_eval::QUOTE_FNMATCH;
        }
          break;
        case Id::BoolBinary_EqualTilde: {
          eval_flags |= word_eval::QUOTE_ERE;
        }
          break;
      }
      s1 = this->_EvalCompoundWord(node->left);
      s2 = this->_EvalCompoundWord(node->right, eval_flags);
      arg_type = consts::BoolArgType(op_id);
      if (arg_type == bool_arg_type_e::Path) {
        return bool_stat::DoBinaryOp(op_id, s1, s2);
      }
      if (arg_type == bool_arg_type_e::Int) {
        i1 = this->_StringToIntegerOrError(s1, node->left);
        i2 = this->_StringToIntegerOrError(s2, node->right);
        if (op_id == Id::BoolBinary_eq) {
          return i1 == i2;
        }
        if (op_id == Id::BoolBinary_ne) {
          return i1 != i2;
        }
        if (op_id == Id::BoolBinary_gt) {
          return i1 > i2;
        }
        if (op_id == Id::BoolBinary_ge) {
          return i1 >= i2;
        }
        if (op_id == Id::BoolBinary_lt) {
          return i1 < i2;
        }
        if (op_id == Id::BoolBinary_le) {
          return i1 <= i2;
        }
        assert(0);  // AssertionError
      }
      if (arg_type == bool_arg_type_e::Str) {
        if ((op_id == Id::BoolBinary_GlobEqual || op_id == Id::BoolBinary_GlobDEqual)) {
          return libc::fnmatch(s2, s1);
        }
        if (op_id == Id::BoolBinary_GlobNEqual) {
          return !libc::fnmatch(s2, s1);
        }
        if ((op_id == Id::BoolBinary_Equal || op_id == Id::BoolBinary_DEqual)) {
          return str_equals(s1, s2);
        }
        if (op_id == Id::BoolBinary_NEqual) {
          return !(str_equals(s1, s2));
        }
        if (op_id == Id::BoolBinary_EqualTilde) {
          try {
            matches = libc::regex_match(s2, s1);
          }
          catch (RuntimeError* e) {
            msg = e->message;
            e_die_status(2, fmt300(s2, msg), node->right);
          }
          if (matches == nullptr) {
            return false;
          }
          this->mem->SetMatches(matches);
          return true;
        }
        if (op_id == Id::Op_Less) {
          return str_cmp(s1, s2) < 0;
        }
        if (op_id == Id::Op_Great) {
          return str_cmp(s1, s2) > 0;
        }
        assert(0);  // AssertionError
      }
    }
      break;
  }
  assert(0);  // AssertionError
}

}  // define namespace sh_expr_eval

namespace split {  // define

namespace value_e = runtime_asdl::value_e;
using runtime_asdl::scope_e;
using runtime_asdl::span_e;
using runtime_asdl::value__Str;
namespace emit_i = runtime_asdl::emit_i;
namespace char_kind_i = runtime_asdl::char_kind_i;
namespace state_i = runtime_asdl::state_i;
Str* DEFAULT_IFS = str1024;

List<Str*>* _SpansToParts(Str* s, List<Tuple2<runtime_asdl::span_t, int>*>* spans) {
  List<mylib::BufWriter*>* parts = nullptr;
  int start_index;
  bool join_next;
  bool last_span_was_black;
  runtime_asdl::span_t span_type;
  int end_index;
  mylib::BufWriter* buf = nullptr;
  List<Str*>* result = nullptr;
  StackRoots _roots({&s, &spans, &parts, &buf, &result});

  parts = Alloc<List<mylib::BufWriter*>>();
  start_index = 0;
  join_next = false;
  last_span_was_black = false;
  for (ListIter<Tuple2<runtime_asdl::span_t, int>*> it(spans); !it.Done(); it.Next()) {
    Tuple2<runtime_asdl::span_t, int>* tup0 = it.Value();
    span_type = tup0->at0();
    end_index = tup0->at1();
    if (span_type == span_e::Black) {
      if ((len(parts) and join_next)) {
        parts->index_(-1)->write(s->slice(start_index, end_index));
        join_next = false;
      }
      else {
        buf = Alloc<mylib::BufWriter>();
        buf->write(s->slice(start_index, end_index));
        parts->append(buf);
      }
      last_span_was_black = true;
    }
    else {
      if (span_type == span_e::Backslash) {
        if (last_span_was_black) {
          join_next = true;
        }
        last_span_was_black = false;
      }
      else {
        last_span_was_black = false;
      }
    }
    start_index = end_index;
  }
  result = Alloc<List<Str*>>();
  for (ListIter<mylib::BufWriter*> it(parts); !it.Done(); it.Next()) {
    mylib::BufWriter* buf = it.Value();
    result->append(buf->getvalue());
  }
  return result;
}

SplitContext::SplitContext(state::Mem* mem) 
    : Obj(Tag::FixedSize, maskof_SplitContext(), sizeof(SplitContext))  {
  this->mem = mem;
  this->splitters = Alloc<Dict<Str*, split::IfsSplitter*>>();
}

split::IfsSplitter* SplitContext::_GetSplitter() {
  return _GetSplitter(nullptr);
}

split::IfsSplitter* SplitContext::_GetSplitter(Str* ifs) {
  runtime_asdl::value_t* val = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  split::IfsSplitter* sp = nullptr;
  mylib::BufWriter* ifs_whitespace = nullptr;
  mylib::BufWriter* ifs_other = nullptr;
  StackRoots _roots({&ifs, &val, &UP_val, &sp, &ifs_whitespace, &ifs_other});

  if (ifs == nullptr) {
    val = this->mem->GetValue(str1025, scope_e::Dynamic);
    UP_val = val;
    switch (val->tag_()) {
      case value_e::Undef: {
        ifs = DEFAULT_IFS;
      }
        break;
      case value_e::Str: {
        value__Str* val = static_cast<value__Str*>(UP_val);
        ifs = val->s;
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
  sp = this->splitters->get(ifs);
  if (sp == nullptr) {
    ifs_whitespace = Alloc<mylib::BufWriter>();
    ifs_other = Alloc<mylib::BufWriter>();
    for (StrIter it(ifs); !it.Done(); it.Next()) {
      Str* c = it.Value();
      StackRoots _for({&c    });
      if (str_contains(str1027, c)) {
        ifs_whitespace->write(c);
      }
      else {
        ifs_other->write(c);
      }
    }
    sp = Alloc<IfsSplitter>(ifs_whitespace->getvalue(), ifs_other->getvalue());
    this->splitters->set(ifs, sp);
  }
  return sp;
}

Str* SplitContext::GetJoinChar() {
  runtime_asdl::value_t* val = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  StackRoots _roots({&val, &UP_val});

  val = this->mem->GetValue(str1028, scope_e::Dynamic);
  UP_val = val;
  switch (val->tag_()) {
    case value_e::Undef: {
      return str1029;
    }
      break;
    case value_e::Str: {
      value__Str* val = static_cast<value__Str*>(UP_val);
      if (len(val->s)) {
        return val->s->index_(0);
      }
      else {
        return str1030;
      }
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  assert(0);  // AssertionError
}

Str* SplitContext::Escape(Str* s) {
  split::IfsSplitter* sp = nullptr;
  StackRoots _roots({&s, &sp});

  sp = this->_GetSplitter();
  return sp->Escape(s);
}

List<Str*>* SplitContext::SplitForWordEval(Str* s) {
  return SplitForWordEval(s, nullptr);
}

List<Str*>* SplitContext::SplitForWordEval(Str* s, Str* ifs) {
  split::IfsSplitter* sp = nullptr;
  List<Tuple2<runtime_asdl::span_t, int>*>* spans = nullptr;
  StackRoots _roots({&s, &ifs, &sp, &spans});

  sp = this->_GetSplitter(ifs);
  spans = sp->Split(s, true);
  return _SpansToParts(s, spans);
}

List<Tuple2<runtime_asdl::span_t, int>*>* SplitContext::SplitForRead(Str* line, bool allow_escape) {
  split::IfsSplitter* sp = nullptr;
  StackRoots _roots({&line, &sp});

  sp = this->_GetSplitter();
  return sp->Split(line, allow_escape);
}

List<Str*>* SplitContext::SplitFuncBuiltin(Str* s, Str* ifs) {
  StackRoots _roots({&s, &ifs});

  return this->SplitForWordEval(s, ifs);
}

_BaseSplitter::_BaseSplitter(Str* escape_chars) 
    : Obj(Tag::FixedSize, maskof__BaseSplitter(), sizeof(_BaseSplitter))  {
  this->escape_chars = str_concat(escape_chars, str1033);
}

Str* _BaseSplitter::Escape(Str* s) {
  StackRoots _roots({&s});

  return pyutil::BackslashEscape(s, this->escape_chars);
}

IfsSplitter::IfsSplitter(Str* ifs_whitespace, Str* ifs_other) : _BaseSplitter(str_concat(ifs_whitespace, ifs_other)) {
  field_mask_ |= maskof_IfsSplitter();
  this->ifs_whitespace = ifs_whitespace;
  this->ifs_other = ifs_other;
}

List<Tuple2<runtime_asdl::span_t, int>*>* IfsSplitter::Split(Str* s, bool allow_escape) {
  Str* ws_chars = nullptr;
  Str* other_chars = nullptr;
  int n;
  List<Tuple2<runtime_asdl::span_t, int>*>* spans = nullptr;
  int i;
  int state;
  Str* c = nullptr;
  int ch;
  int new_state;
  int action;
  StackRoots _roots({&s, &ws_chars, &other_chars, &spans, &c});

  ws_chars = this->ifs_whitespace;
  other_chars = this->ifs_other;
  n = len(s);
  spans = Alloc<List<Tuple2<runtime_asdl::span_t, int>*>>();
  if (n == 0) {
    return spans;
  }
  i = 0;
  while ((i < n and str_contains(this->ifs_whitespace, s->index_(i)))) {
    i += 1;
  }
  if (i != 0) {
    spans->append((Alloc<Tuple2<runtime_asdl::span_t, int>>(span_e::Delim, i)));
  }
  if (i == n) {
    return spans;
  }
  state = state_i::Start;
  while (state != state_i::Done) {
    if (i < n) {
      c = s->index_(i);
      if (str_contains(ws_chars, c)) {
        ch = char_kind_i::DE_White;
      }
      else {
        if (str_contains(other_chars, c)) {
          ch = char_kind_i::DE_Gray;
        }
        else {
          if ((allow_escape and str_equals(c, str1034))) {
            ch = char_kind_i::Backslash;
          }
          else {
            ch = char_kind_i::Black;
          }
        }
      }
    }
    else {
      if (i == n) {
        ch = char_kind_i::Sentinel;
      }
      else {
        assert(0);  // AssertionError
      }
    }
    Tuple2<int, int> tup1 = consts::IfsEdge(state, ch);
    new_state = tup1.at0();
    action = tup1.at1();
    if (new_state == state_i::Invalid) {
      assert(0);  // AssertionError
    }
    if (action == emit_i::Part) {
      spans->append((Alloc<Tuple2<runtime_asdl::span_t, int>>(span_e::Black, i)));
    }
    else {
      if (action == emit_i::Delim) {
        spans->append((Alloc<Tuple2<runtime_asdl::span_t, int>>(span_e::Delim, i)));
      }
      else {
        if (action == emit_i::Empty) {
          spans->append((Alloc<Tuple2<runtime_asdl::span_t, int>>(span_e::Delim, i)));
          spans->append((Alloc<Tuple2<runtime_asdl::span_t, int>>(span_e::Black, i)));
        }
        else {
          if (action == emit_i::Escape) {
            spans->append((Alloc<Tuple2<runtime_asdl::span_t, int>>(span_e::Backslash, i)));
          }
          else {
            if (action == emit_i::Nothing) {
              ;  // pass
            }
            else {
              assert(0);  // AssertionError
            }
          }
        }
      }
    }
    state = new_state;
    i += 1;
  }
  return spans;
}

}  // define namespace split

namespace string_ops {  // define

namespace Id = id_kind_asdl::Id;

Str* Utf8Encode(int code) {
  int num_cont_bytes;
  List<int>* bytes_ = nullptr;
  int b;
  List<Str*>* tmp = nullptr;
  StackRoots _roots({&bytes_, &tmp});

  num_cont_bytes = 0;
  if (code <= 127) {
    return chr((code & 127));
  }
  else {
    if (code <= 2047) {
      num_cont_bytes = 1;
    }
    else {
      if (code <= 65535) {
        num_cont_bytes = 2;
      }
      else {
        if (code <= 1114111) {
          num_cont_bytes = 3;
        }
        else {
          return str1036;
        }
      }
    }
  }
  bytes_ = Alloc<List<int>>();
  for (int _ = 0; _ < num_cont_bytes; ++_) {
    bytes_->append((128 | (code & 63)));
    code >>= 6;
  }
  b = ((30 << (6 - num_cont_bytes)) | (code & (63 >> num_cont_bytes)));
  bytes_->append(b);
  bytes_->reverse();
  tmp = Alloc<List<Str*>>();
  for (ListIter<int> it(bytes_); !it.Done(); it.Next()) {
    int b = it.Value();
    tmp->append(chr((b & 255)));
  }
  return str1037->join(tmp);
}
Str* INCOMPLETE_CHAR = str1038;
Str* INVALID_CONT = str1039;
Str* INVALID_START = str1040;

void _CheckContinuationByte(Str* byte) {
  StackRoots _roots({&byte});

  if ((ord(byte) >> 6) != 2) {
    e_strict(INVALID_CONT);
  }
}

int _Utf8CharLen(int starting_byte) {
  if ((starting_byte >> 7) == 0) {
    return 1;
  }
  else {
    if ((starting_byte >> 5) == 6) {
      return 2;
    }
    else {
      if ((starting_byte >> 4) == 14) {
        return 3;
      }
      else {
        if ((starting_byte >> 3) == 30) {
          return 4;
        }
        else {
          e_strict(INVALID_START);
        }
      }
    }
  }
}

int _NextUtf8Char(Str* s, int i) {
  int n;
  int byte_as_int;
  int length;
  StackRoots _roots({&s});

  n = len(s);
  byte_as_int = ord(s->index_(i));
  length = _Utf8CharLen(byte_as_int);
  for (int j = (i + 1); j < (i + length); ++j) {
    if (j >= n) {
      e_strict(INCOMPLETE_CHAR);
    }
    _CheckContinuationByte(s->index_(j));
  }
  return (i + length);
}

int PreviousUtf8Char(Str* s, int i) {
  int orig_i;
  int byte_as_int;
  int offset;
  StackRoots _roots({&s});

  orig_i = i;
  while (i > 0) {
    i -= 1;
    byte_as_int = ord(s->index_(i));
    if ((byte_as_int >> 6) != 2) {
      offset = (orig_i - i);
      if (offset != _Utf8CharLen(byte_as_int)) {
        e_strict(INVALID_START);
      }
      return i;
    }
  }
  e_strict(INVALID_START);
}

int CountUtf8Chars(Str* s) {
  int num_chars;
  int num_bytes;
  int i;
  StackRoots _roots({&s});

  num_chars = 0;
  num_bytes = len(s);
  i = 0;
  while (i < num_bytes) {
    i = _NextUtf8Char(s, i);
    num_chars += 1;
  }
  return num_chars;
}

int AdvanceUtf8Chars(Str* s, int num_chars, int byte_offset) {
  int num_bytes;
  int i;
  StackRoots _roots({&s});

  num_bytes = len(s);
  i = byte_offset;
  for (int _ = 0; _ < num_chars; ++_) {
    if (i >= num_bytes) {
      return i;
    }
    i = _NextUtf8Char(s, i);
  }
  return i;
}

Str* DoUnarySuffixOp(Str* s, syntax_asdl::suffix_op__Unary* op, Str* arg, bool is_extglob) {
  syntax_asdl::Token* tok = nullptr;
  int n;
  int i;
  StackRoots _roots({&s, &op, &arg, &tok});

  tok = op->tok;
  if ((!is_extglob and !glob_::LooksLikeGlob(arg))) {
    arg = glob_::GlobUnescape(arg);
    if ((tok->id == Id::VOp1_Pound || tok->id == Id::VOp1_DPound)) {
      if ((len(arg) and s->startswith(arg))) {
        return s->slice(len(arg));
      }
      else {
        return s;
      }
    }
    else {
      if ((tok->id == Id::VOp1_Percent || tok->id == Id::VOp1_DPercent)) {
        if ((len(arg) and s->endswith(arg))) {
          return s->slice(0, -len(arg));
        }
        else {
          return s;
        }
      }
      else {
        if (tok->id == Id::VOp1_Comma) {
          if (!(str_equals(arg, str1041))) {
            e_die(fmt301(ui::PrettyId(tok->id)), tok);
          }
          if (len(s)) {
            return str_concat(s->index_(0)->lower(), s->slice(1));
          }
          else {
            return s;
          }
        }
        else {
          if (tok->id == Id::VOp1_DComma) {
            if (!(str_equals(arg, str1043))) {
              e_die(fmt302(ui::PrettyId(tok->id)), tok);
            }
            return s->lower();
          }
          else {
            if (tok->id == Id::VOp1_Caret) {
              if (!(str_equals(arg, str1045))) {
                e_die(fmt303(ui::PrettyId(tok->id)), tok);
              }
              if (len(s)) {
                return str_concat(s->index_(0)->upper(), s->slice(1));
              }
              else {
                return s;
              }
            }
            else {
              if (tok->id == Id::VOp1_DCaret) {
                if (!(str_equals(arg, str1047))) {
                  e_die(fmt304(ui::PrettyId(tok->id)), tok);
                }
                return s->upper();
              }
              else {
                assert(0);  // AssertionError
              }
            }
          }
        }
      }
    }
  }
  n = len(s);
  if (tok->id == Id::VOp1_Pound) {
    i = 0;
    while (true) {
      if (libc::fnmatch(arg, s->slice(0, i))) {
        return s->slice(i);
      }
      if (i >= n) {
        break;
      }
      i = _NextUtf8Char(s, i);
    }
    return s;
  }
  else {
    if (tok->id == Id::VOp1_DPound) {
      i = n;
      while (true) {
        if (libc::fnmatch(arg, s->slice(0, i))) {
          return s->slice(i);
        }
        if (i == 0) {
          break;
        }
        i = PreviousUtf8Char(s, i);
      }
      return s;
    }
    else {
      if (tok->id == Id::VOp1_Percent) {
        i = n;
        while (true) {
          if (libc::fnmatch(arg, s->slice(i))) {
            return s->slice(0, i);
          }
          if (i == 0) {
            break;
          }
          i = PreviousUtf8Char(s, i);
        }
        return s;
      }
      else {
        if (tok->id == Id::VOp1_DPercent) {
          i = 0;
          while (true) {
            if (libc::fnmatch(arg, s->slice(i))) {
              return s->slice(0, i);
            }
            if (i >= n) {
              break;
            }
            i = _NextUtf8Char(s, i);
          }
          return s;
        }
        else {
          throw Alloc<NotImplementedError>(ui::PrettyId(tok->id));
        }
      }
    }
  }
}

List<Tuple2<int, int>*>* _AllMatchPositions(Str* s, Str* regex) {
  List<Tuple2<int, int>*>* matches = nullptr;
  int pos;
  int n;
  Tuple2<int, int>* m = nullptr;
  int start;
  int end;
  StackRoots _roots({&s, &regex, &matches, &m});

  matches = Alloc<List<Tuple2<int, int>*>>();
  pos = 0;
  n = len(s);
  while (pos < n) {
    m = libc::regex_first_group_match(regex, s, pos);
    if (m == nullptr) {
      break;
    }
    matches->append(m);
    Tuple2<int, int>* tup0 = m;
    start = tup0->at0();
    end = tup0->at1();
    pos = end;
  }
  return matches;
}

Str* _PatSubAll(Str* s, Str* regex, Str* replace_str) {
  List<Str*>* parts = nullptr;
  int prev_end;
  int start;
  int end;
  StackRoots _roots({&s, &regex, &replace_str, &parts});

  parts = Alloc<List<Str*>>();
  prev_end = 0;
  for (ListIter<Tuple2<int, int>*> it(_AllMatchPositions(s, regex)); !it.Done(); it.Next()) {
    Tuple2<int, int>* tup1 = it.Value();
    start = tup1->at0();
    end = tup1->at1();
    parts->append(s->slice(prev_end, start));
    parts->append(replace_str);
    prev_end = end;
  }
  parts->append(s->slice(prev_end));
  return str1049->join(parts);
}

GlobReplacer::GlobReplacer(Str* regex, Str* replace_str, int slash_spid) 
    : Obj(Tag::FixedSize, maskof_GlobReplacer(), sizeof(GlobReplacer))  {
  this->regex = regex;
  this->replace_str = replace_str;
  this->slash_spid = slash_spid;
}

Str* GlobReplacer::Replace(Str* s, syntax_asdl::suffix_op__PatSub* op) {
  Str* regex = nullptr;
  Str* msg = nullptr;
  Tuple2<int, int>* m = nullptr;
  int start;
  int end;
  StackRoots _roots({&s, &op, &regex, &msg, &m});

  regex = fmt305(this->regex);
  if (op->replace_mode == Id::Lit_Slash) {
    try {
      return _PatSubAll(s, regex, this->replace_str);
    }
    catch (RuntimeError* e) {
      msg = e->message;
      e_die(fmt306(regex, msg), this->slash_spid);
    }
  }
  if (op->replace_mode == Id::Lit_Pound) {
    regex = str_concat(str1053, regex);
  }
  else {
    if (op->replace_mode == Id::Lit_Percent) {
      regex = str_concat(regex, str1054);
    }
  }
  m = libc::regex_first_group_match(regex, s, 0);
  if (m == nullptr) {
    return s;
  }
  Tuple2<int, int>* tup2 = m;
  start = tup2->at0();
  end = tup2->at1();
  return str_concat(str_concat(s->slice(0, start), this->replace_str), s->slice(end));
}

Str* ShellQuoteB(Str* s) {
  StackRoots _roots({&s});

  s = s->replace(str1055, str1056)->replace(str1057, str1058);
  return pyutil::BackslashEscape(s, str1059);
}

}  // define namespace string_ops

namespace tdop {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Id_t;
namespace arith_expr = syntax_asdl::arith_expr;
namespace arith_expr_e = syntax_asdl::arith_expr_e;
using syntax_asdl::arith_expr_t;
using syntax_asdl::arith_expr__Binary;
using syntax_asdl::word_t;
using syntax_asdl::compound_word;
using types_asdl::lex_mode_e;

bool IsIndexable(syntax_asdl::arith_expr_t* node, bool parse_dynamic_arith) {
  int tag;
  StackRoots _roots({&node});

  tag = node->tag_();
  if (tag == arith_expr_e::VarRef) {
    return true;
  }
  if ((parse_dynamic_arith and tag == arith_expr_e::Word)) {
    return true;
  }
  return false;
}

bool _VarRefOrWord(syntax_asdl::arith_expr_t* node, bool dynamic_arith) {
  StackRoots _roots({&node});

  switch (node->tag_()) {
    case arith_expr_e::VarRef: {
      return true;
    }
      break;
    case arith_expr_e::Word: {
      if (dynamic_arith) {
        return true;
      }
    }
      break;
  }
  return false;
}

void CheckLhsExpr(syntax_asdl::arith_expr_t* node, bool dynamic_arith, syntax_asdl::word_t* blame_word) {
  syntax_asdl::arith_expr_t* UP_node = nullptr;
  StackRoots _roots({&node, &blame_word, &UP_node});

  UP_node = node;
  if (node->tag_() == arith_expr_e::Binary) {
    arith_expr__Binary* node = static_cast<arith_expr__Binary*>(UP_node);
    if ((node->op_id == Id::Arith_LBracket and _VarRefOrWord(node->left, dynamic_arith))) {
      return ;
    }
  }
  if (_VarRefOrWord(node, dynamic_arith)) {
    return ;
  }
  p_die(fmt307(), blame_word);
}

syntax_asdl::arith_expr_t* NullError(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp) {
  StackRoots _roots({&p, &t});

  p_die(fmt308(), t);
  return nullptr;
}

syntax_asdl::arith_expr_t* NullConstant(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp) {
  syntax_asdl::Token* var_name_token = nullptr;
  StackRoots _roots({&p, &w, &var_name_token});

  var_name_token = word_::LooksLikeArithVar(w);
  if (var_name_token) {
    return var_name_token;
  }
  return static_cast<compound_word*>(w);
}

syntax_asdl::arith_expr_t* NullParen(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp) {
  syntax_asdl::arith_expr_t* r = nullptr;
  StackRoots _roots({&p, &t, &r});

  r = p->ParseUntil(bp);
  p->Eat(Id::Arith_RParen);
  return r;
}

syntax_asdl::arith_expr_t* NullPrefixOp(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp) {
  syntax_asdl::arith_expr_t* right = nullptr;
  StackRoots _roots({&p, &w, &right});

  right = p->ParseUntil(bp);
  return Alloc<arith_expr::Unary>(word_::ArithId(w), right);
}

syntax_asdl::arith_expr_t* LeftError(tdop::TdopParser* p, syntax_asdl::word_t* t, syntax_asdl::arith_expr_t* left, int rbp) {
  StackRoots _roots({&p, &t, &left});

  p_die(fmt309(), t);
  return nullptr;
}

syntax_asdl::arith_expr_t* LeftBinaryOp(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp) {
  StackRoots _roots({&p, &w, &left});

  return Alloc<arith_expr::Binary>(word_::ArithId(w), left, p->ParseUntil(rbp));
}

syntax_asdl::arith_expr_t* LeftAssign(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp) {
  StackRoots _roots({&p, &w, &left});

  CheckLhsExpr(left, p->parse_opts->parse_dynamic_arith(), w);
  return Alloc<arith_expr::BinaryAssign>(word_::ArithId(w), left, p->ParseUntil(rbp));
}

TdopParser::TdopParser(tdop::ParserSpec* spec, word_parse::WordParser* w_parser, optview::Parse* parse_opts) 
    : Obj(Tag::FixedSize, maskof_TdopParser(), sizeof(TdopParser))  {
  this->spec = spec;
  this->w_parser = w_parser;
  this->parse_opts = parse_opts;
  this->cur_word = nullptr;
  this->op_id = Id::Undefined_Tok;
}

int TdopParser::CurrentId() {
  return word_::CommandId(this->cur_word);
}

bool TdopParser::AtToken(int token_type) {
  return this->op_id == token_type;
}

void TdopParser::Eat(int token_type) {
  if (!this->AtToken(token_type)) {
    p_die(fmt310(ui::PrettyId(token_type), ui::PrettyId(this->op_id)), this->cur_word);
  }
  this->Next();
}

bool TdopParser::Next() {
  this->cur_word = this->w_parser->ReadWord(lex_mode_e::Arith);
  this->op_id = word_::ArithId(this->cur_word);
  return true;
}

syntax_asdl::arith_expr_t* TdopParser::ParseUntil(int rbp) {
  syntax_asdl::word_t* t = nullptr;
  tdop::NullInfo* null_info = nullptr;
  syntax_asdl::arith_expr_t* node = nullptr;
  tdop::LeftInfo* left_info = nullptr;
  StackRoots _roots({&t, &null_info, &node, &left_info});

  if ((this->op_id == Id::Eof_Real || this->op_id == Id::Eof_RParen || this->op_id == Id::Eof_Backtick)) {
    p_die(fmt311(), this->cur_word);
  }
  t = this->cur_word;
  null_info = this->spec->LookupNud(this->op_id);
  this->Next();
  node = null_info->nud(this, t, null_info->bp);
  while (true) {
    t = this->cur_word;
    left_info = this->spec->LookupLed(this->op_id);
    if (rbp >= left_info->lbp) {
      break;
    }
    this->Next();
    node = left_info->led(this, t, node, left_info->rbp);
  }
  return node;
}

syntax_asdl::arith_expr_t* TdopParser::Parse() {
  this->Next();
  return this->ParseUntil(0);
}

}  // define namespace tdop

namespace word_ {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Kind;
using id_kind_asdl::Id_t;
using id_kind_asdl::Kind_t;
using syntax_asdl::Token;
using syntax_asdl::compound_word;
using syntax_asdl::double_quoted;
using syntax_asdl::single_quoted;
using syntax_asdl::simple_var_sub;
using syntax_asdl::braced_var_sub;
using syntax_asdl::command_sub;
using syntax_asdl::sh_array_literal;
namespace word_part = syntax_asdl::word_part;
using syntax_asdl::word_part_t;
namespace word_part_e = syntax_asdl::word_part_e;
using syntax_asdl::word_part__AssocArrayLiteral;
using syntax_asdl::word_part__EscapedLiteral;
using syntax_asdl::word_part__TildeSub;
using syntax_asdl::word_part__ArithSub;
using syntax_asdl::word_part__ExtGlob;
using syntax_asdl::word_part__Splice;
using syntax_asdl::word_part__FuncCall;
using syntax_asdl::word_part__ExprSub;
namespace word_e = syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::word__BracedTree;
using syntax_asdl::word__String;
namespace sh_lhs_expr_e = syntax_asdl::sh_lhs_expr_e;
using syntax_asdl::sh_lhs_expr_t;
using syntax_asdl::sh_lhs_expr__Name;
using syntax_asdl::sh_lhs_expr__IndexedName;

int LiteralId(syntax_asdl::word_part_t* p) {
  syntax_asdl::word_part_t* UP_part = nullptr;
  StackRoots _roots({&p, &UP_part});

  UP_part = p;
  if (p->tag_() == word_part_e::Literal) {
    return static_cast<Token*>(UP_part)->id;
  }
  else {
    return Id::Undefined_Tok;
  }
}

Tuple3<bool, Str*, bool> _EvalWordPart(syntax_asdl::word_part_t* part) {
  syntax_asdl::word_part_t* UP_part = nullptr;
  Str* val = nullptr;
  Str* s = nullptr;
  List<Str*>* tmp = nullptr;
  List<Str*>* strs = nullptr;
  bool ok;
  StackRoots _roots({&part, &UP_part, &val, &s, &tmp, &strs});

  UP_part = part;
  switch (part->tag_()) {
    case word_part_e::ShArrayLiteral: {
      return (Tuple3<bool, Str*, bool>(false, str1065, false));
    }
      break;
    case word_part_e::AssocArrayLiteral: {
      return (Tuple3<bool, Str*, bool>(false, str1066, false));
    }
      break;
    case word_part_e::Literal: {
      Token* tok = static_cast<Token*>(UP_part);
      return (Tuple3<bool, Str*, bool>(true, tok->val, false));
    }
      break;
    case word_part_e::EscapedLiteral: {
      word_part__EscapedLiteral* part = static_cast<word_part__EscapedLiteral*>(UP_part);
      val = part->token->val;
      s = val->index_(1);
      return (Tuple3<bool, Str*, bool>(true, s, true));
    }
      break;
    case word_part_e::SingleQuoted: {
      single_quoted* part = static_cast<single_quoted*>(UP_part);
      tmp = Alloc<List<Str*>>();
      for (ListIter<syntax_asdl::Token*> it(part->tokens); !it.Done(); it.Next()) {
        syntax_asdl::Token* t = it.Value();
        tmp->append(t->val);
      }
      s = str1067->join(tmp);
      return (Tuple3<bool, Str*, bool>(true, s, true));
    }
      break;
    case word_part_e::DoubleQuoted: {
      double_quoted* part = static_cast<double_quoted*>(UP_part);
      strs = Alloc<List<Str*>>();
      for (ListIter<syntax_asdl::word_part_t*> it(part->parts); !it.Done(); it.Next()) {
        syntax_asdl::word_part_t* p = it.Value();
        StackRoots _for({&p      });
        Tuple3<bool, Str*, bool> tup0 = _EvalWordPart(p);
        ok = tup0.at0();
        s = tup0.at1();
        if (!ok) {
          return (Tuple3<bool, Str*, bool>(false, str1068, true));
        }
        strs->append(s);
      }
      return (Tuple3<bool, Str*, bool>(true, str1069->join(strs), true));
    }
      break;
    case word_part_e::CommandSub: 
    case word_part_e::SimpleVarSub: 
    case word_part_e::BracedVarSub: 
    case word_part_e::TildeSub: 
    case word_part_e::ArithSub: 
    case word_part_e::ExtGlob: 
    case word_part_e::Splice: 
    case word_part_e::FuncCall: 
    case word_part_e::ExprSub: {
      return (Tuple3<bool, Str*, bool>(false, str1070, false));
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

Tuple3<bool, Str*, bool> StaticEval(syntax_asdl::word_t* UP_w) {
  bool quoted;
  List<Str*>* strs = nullptr;
  bool ok;
  Str* s = nullptr;
  bool q;
  StackRoots _roots({&UP_w, &strs, &s});

  quoted = false;
  if (UP_w->tag_() != word_e::Compound) {
    return (Tuple3<bool, Str*, bool>(false, str1071, quoted));
  }
  compound_word* w = static_cast<compound_word*>(UP_w);
  strs = Alloc<List<Str*>>();
  for (ListIter<syntax_asdl::word_part_t*> it(w->parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoots _for({&part  });
    Tuple3<bool, Str*, bool> tup1 = _EvalWordPart(part);
    ok = tup1.at0();
    s = tup1.at1();
    q = tup1.at2();
    if (!ok) {
      return (Tuple3<bool, Str*, bool>(false, str1072, quoted));
    }
    if (q) {
      quoted = true;
    }
    strs->append(s);
  }
  return (Tuple3<bool, Str*, bool>(true, str1073->join(strs), quoted));
}

int LeftMostSpanForPart(syntax_asdl::word_part_t* part) {
  syntax_asdl::word_part_t* UP_part = nullptr;
  StackRoots _roots({&part, &UP_part});

  UP_part = part;
  switch (part->tag_()) {
    case word_part_e::ShArrayLiteral: {
      sh_array_literal* part = static_cast<sh_array_literal*>(UP_part);
      return part->left->span_id;
    }
      break;
    case word_part_e::AssocArrayLiteral: {
      word_part__AssocArrayLiteral* part = static_cast<word_part__AssocArrayLiteral*>(UP_part);
      return part->left->span_id;
    }
      break;
    case word_part_e::Literal: {
      Token* tok = static_cast<Token*>(UP_part);
      return tok->span_id;
    }
      break;
    case word_part_e::EscapedLiteral: {
      word_part__EscapedLiteral* part = static_cast<word_part__EscapedLiteral*>(UP_part);
      return part->token->span_id;
    }
      break;
    case word_part_e::SingleQuoted: {
      single_quoted* part = static_cast<single_quoted*>(UP_part);
      return part->left->span_id;
    }
      break;
    case word_part_e::DoubleQuoted: {
      double_quoted* part = static_cast<double_quoted*>(UP_part);
      return part->left->span_id;
    }
      break;
    case word_part_e::SimpleVarSub: {
      simple_var_sub* part = static_cast<simple_var_sub*>(UP_part);
      return part->token->span_id;
    }
      break;
    case word_part_e::BracedVarSub: {
      braced_var_sub* part = static_cast<braced_var_sub*>(UP_part);
      return part->spids->index_(0);
    }
      break;
    case word_part_e::CommandSub: {
      command_sub* part = static_cast<command_sub*>(UP_part);
      return part->spids->index_(0);
    }
      break;
    case word_part_e::TildeSub: {
      word_part__TildeSub* part = static_cast<word_part__TildeSub*>(UP_part);
      return part->token->span_id;
    }
      break;
    case word_part_e::ArithSub: {
      word_part__ArithSub* part = static_cast<word_part__ArithSub*>(UP_part);
      return part->spids->index_(0);
    }
      break;
    case word_part_e::ExtGlob: {
      word_part__ExtGlob* part = static_cast<word_part__ExtGlob*>(UP_part);
      return part->spids->index_(0);
    }
      break;
    case word_part_e::BracedTuple: {
      return runtime::NO_SPID;
    }
      break;
    case word_part_e::Splice: {
      word_part__Splice* part = static_cast<word_part__Splice*>(UP_part);
      return part->name->span_id;
    }
      break;
    case word_part_e::FuncCall: {
      word_part__FuncCall* part = static_cast<word_part__FuncCall*>(UP_part);
      return part->name->span_id;
    }
      break;
    case word_part_e::ExprSub: {
      word_part__ExprSub* part = static_cast<word_part__ExprSub*>(UP_part);
      return part->left->span_id;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

int _RightMostSpanForPart(syntax_asdl::word_part_t* part) {
  syntax_asdl::word_part_t* UP_part = nullptr;
  int spid;
  StackRoots _roots({&part, &UP_part});

  UP_part = part;
  switch (part->tag_()) {
    case word_part_e::ShArrayLiteral: {
      sh_array_literal* part = static_cast<sh_array_literal*>(UP_part);
      return LeftMostSpanForWord(part->words->index_(0));
    }
      break;
    case word_part_e::Literal: {
      Token* tok = static_cast<Token*>(UP_part);
      return tok->span_id;
    }
      break;
    case word_part_e::EscapedLiteral: {
      word_part__EscapedLiteral* part = static_cast<word_part__EscapedLiteral*>(UP_part);
      return part->token->span_id;
    }
      break;
    case word_part_e::SingleQuoted: {
      single_quoted* part = static_cast<single_quoted*>(UP_part);
      return part->spids->index_(1);
    }
      break;
    case word_part_e::DoubleQuoted: {
      double_quoted* part = static_cast<double_quoted*>(UP_part);
      return part->spids->index_(1);
    }
      break;
    case word_part_e::SimpleVarSub: {
      simple_var_sub* part = static_cast<simple_var_sub*>(UP_part);
      return part->token->span_id;
    }
      break;
    case word_part_e::BracedVarSub: {
      braced_var_sub* part = static_cast<braced_var_sub*>(UP_part);
      spid = part->spids->index_(1);
      return spid;
    }
      break;
    case word_part_e::CommandSub: {
      command_sub* part = static_cast<command_sub*>(UP_part);
      return part->spids->index_(1);
    }
      break;
    case word_part_e::TildeSub: {
      return runtime::NO_SPID;
    }
      break;
    case word_part_e::ArithSub: {
      word_part__ArithSub* part = static_cast<word_part__ArithSub*>(UP_part);
      return part->spids->index_(1);
    }
      break;
    case word_part_e::ExtGlob: {
      word_part__ExtGlob* part = static_cast<word_part__ExtGlob*>(UP_part);
      return part->spids->index_(1);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

int LeftMostSpanForWord(syntax_asdl::word_t* w) {
  syntax_asdl::word_t* UP_w = nullptr;
  StackRoots _roots({&w, &UP_w});

  UP_w = w;
  switch (w->tag_()) {
    case word_e::Compound: {
      compound_word* w = static_cast<compound_word*>(UP_w);
      if (len(w->parts)) {
        return LeftMostSpanForPart(w->parts->index_(0));
      }
      else {
        return runtime::NO_SPID;
      }
    }
      break;
    case word_e::Token: {
      Token* tok = static_cast<Token*>(UP_w);
      return tok->span_id;
    }
      break;
    case word_e::Empty: {
      return runtime::NO_SPID;
    }
      break;
    case word_e::BracedTree: {
      word__BracedTree* w = static_cast<word__BracedTree*>(UP_w);
      return LeftMostSpanForPart(w->parts->index_(0));
    }
      break;
    case word_e::String: {
      word__String* w = static_cast<word__String*>(UP_w);
      return w->span_id;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  assert(0);  // AssertionError
}

int RightMostSpanForWord(syntax_asdl::word_t* w) {
  syntax_asdl::word_t* UP_w = nullptr;
  syntax_asdl::word_part_t* end = nullptr;
  StackRoots _roots({&w, &UP_w, &end});

  UP_w = w;
  switch (w->tag_()) {
    case word_e::Compound: {
      compound_word* w = static_cast<compound_word*>(UP_w);
      if (len(w->parts) == 0) {
        assert(0);  // AssertionError
      }
      else {
        end = w->parts->index_(-1);
        return _RightMostSpanForPart(end);
      }
    }
      break;
    case word_e::Empty: {
      return runtime::NO_SPID;
    }
      break;
    case word_e::Token: {
      Token* tok = static_cast<Token*>(UP_w);
      return tok->span_id;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  assert(0);  // AssertionError
}

syntax_asdl::compound_word* TildeDetect(syntax_asdl::word_t* UP_w) {
  syntax_asdl::word_part_t* part0 = nullptr;
  List<syntax_asdl::word_part_t*>* new_parts = nullptr;
  syntax_asdl::word_part_t* part1 = nullptr;
  int id_;
  StackRoots _roots({&UP_w, &part0, &new_parts, &part1});

  if (UP_w->tag_() != word_e::Compound) {
    return nullptr;
  }
  compound_word* w = static_cast<compound_word*>(UP_w);
  if (len(w->parts) == 0) {
    return nullptr;
  }
  part0 = w->parts->index_(0);
  if (LiteralId(part0) != Id::Lit_TildeLike) {
    return nullptr;
  }
  Token* tok0 = static_cast<Token*>(part0);
  new_parts = NewList<syntax_asdl::word_part_t*>(std::initializer_list<syntax_asdl::word_part_t*>{Alloc<word_part::TildeSub>(tok0)});
  if (len(w->parts) == 1) {
    return Alloc<compound_word>(new_parts);
  }
  part1 = w->parts->index_(1);
  id_ = LiteralId(part1);
  if (id_ == Id::Lit_Slash) {
    new_parts->extend(w->parts->slice(1));
    return Alloc<compound_word>(new_parts);
  }
  if ((id_ == Id::Lit_Chars and static_cast<Token*>(part1)->val->startswith(str1077))) {
    new_parts->extend(w->parts->slice(1));
    return Alloc<compound_word>(new_parts);
  }
  return nullptr;
}

void TildeDetectAssign(syntax_asdl::compound_word* w) {
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  int n;
  bool do_expand;
  syntax_asdl::word_part_t* cur = nullptr;
  syntax_asdl::word_part_t* next_part = nullptr;
  bool is_tilde;
  StackRoots _roots({&w, &parts, &cur, &next_part});

  parts = w->parts;
  n = len(parts);
  parts->append(nullptr);
  do_expand = true;
  for (int i = 0; i < n; ++i) {
    cur = parts->index_(i);
    if ((do_expand and LiteralId(cur) == Id::Lit_TildeLike)) {
      next_part = parts->index_((i + 1));
      if (next_part) {
        is_tilde = (LiteralId(next_part) == Id::Lit_Colon or (LiteralId(next_part) == Id::Lit_Chars and static_cast<Token*>(next_part)->val->startswith(str1078)));
      }
      else {
        is_tilde = true;
      }
      if (is_tilde) {
        parts->set(i, Alloc<word_part::TildeSub>(static_cast<Token*>(cur)));
      }
    }
    do_expand = LiteralId(cur) == Id::Lit_Colon;
  }
  parts->pop();
}

List<syntax_asdl::word_t*>* TildeDetectAll(List<syntax_asdl::word_t*>* words) {
  List<syntax_asdl::word_t*>* out = nullptr;
  syntax_asdl::compound_word* t = nullptr;
  StackRoots _roots({&words, &out, &t});

  out = Alloc<List<syntax_asdl::word_t*>>();
  for (ListIter<syntax_asdl::word_t*> it(words); !it.Done(); it.Next()) {
    syntax_asdl::word_t* w = it.Value();
    StackRoots _for({&w  });
    t = TildeDetect(w);
    if (t) {
      out->append(t);
    }
    else {
      out->append(w);
    }
  }
  return out;
}

bool HasArrayPart(syntax_asdl::compound_word* w) {
  StackRoots _roots({&w});

  for (ListIter<syntax_asdl::word_part_t*> it(w->parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoots _for({&part  });
    if (part->tag_() == word_part_e::ShArrayLiteral) {
      return true;
    }
  }
  return false;
}

Str* ShFunctionName(syntax_asdl::compound_word* w) {
  bool ok;
  Str* s = nullptr;
  bool quoted;
  StackRoots _roots({&w, &s});

  Tuple3<bool, Str*, bool> tup2 = StaticEval(w);
  ok = tup2.at0();
  s = tup2.at1();
  quoted = tup2.at2();
  if ((!ok or quoted)) {
    return str1079;
  }
  return s;
}

syntax_asdl::Token* LooksLikeArithVar(syntax_asdl::word_t* UP_w) {
  syntax_asdl::word_part_t* UP_part0 = nullptr;
  StackRoots _roots({&UP_w, &UP_part0});

  if (UP_w->tag_() != word_e::Compound) {
    return nullptr;
  }
  compound_word* w = static_cast<compound_word*>(UP_w);
  if (len(w->parts) != 1) {
    return nullptr;
  }
  UP_part0 = w->parts->index_(0);
  if (LiteralId(UP_part0) != Id::Lit_ArithVarLike) {
    return nullptr;
  }
  return static_cast<Token*>(UP_part0);
}

bool IsVarLike(syntax_asdl::compound_word* w) {
  StackRoots _roots({&w});

  if (len(w->parts) == 0) {
    return false;
  }
  return LiteralId(w->parts->index_(0)) == Id::Lit_VarLike;
}

Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int> DetectShAssignment(syntax_asdl::compound_word* w) {
  syntax_asdl::Token* no_token = nullptr;
  int n;
  syntax_asdl::word_part_t* UP_part0 = nullptr;
  int id0;
  syntax_asdl::word_part_t* UP_part = nullptr;
  StackRoots _roots({&w, &no_token, &UP_part0, &UP_part});

  no_token = nullptr;
  n = len(w->parts);
  if (n == 0) {
    return (Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int>(no_token, no_token, 0));
  }
  UP_part0 = w->parts->index_(0);
  id0 = LiteralId(UP_part0);
  if (id0 == Id::Lit_VarLike) {
    Token* tok = static_cast<Token*>(UP_part0);
    return (Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int>(tok, no_token, 1));
  }
  if (id0 == Id::Lit_ArrayLhsOpen) {
    Token* tok0 = static_cast<Token*>(UP_part0);
    if (n < 2) {
      return (Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int>(no_token, no_token, 0));
    }
    for (int i = 1; i < n; ++i) {
      UP_part = w->parts->index_(i);
      if (LiteralId(UP_part) == Id::Lit_ArrayLhsClose) {
        Token* tok_close = static_cast<Token*>(UP_part);
        return (Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int>(tok0, tok_close, (i + 1)));
      }
    }
  }
  return (Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int>(no_token, no_token, 0));
}

Tuple2<syntax_asdl::compound_word*, syntax_asdl::compound_word*>* DetectAssocPair(syntax_asdl::compound_word* w) {
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  int n;
  int id_;
  syntax_asdl::compound_word* key = nullptr;
  syntax_asdl::compound_word* value = nullptr;
  Tuple2<syntax_asdl::compound_word*, syntax_asdl::compound_word*>* ret = nullptr;
  StackRoots _roots({&w, &parts, &key, &value, &ret});

  parts = w->parts;
  if (LiteralId(parts->index_(0)) != Id::Lit_LBracket) {
    return nullptr;
  }
  n = len(parts);
  for (int i = 0; i < n; ++i) {
    id_ = LiteralId(parts->index_(i));
    if (id_ == Id::Lit_ArrayLhsClose) {
      key = Alloc<compound_word>(parts->slice(1, i));
      value = Alloc<compound_word>(parts->slice((i + 1)));
      ret = (Alloc<Tuple2<syntax_asdl::compound_word*, syntax_asdl::compound_word*>>(key, value));
      return ret;
    }
  }
  return nullptr;
}

Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*> KeywordToken(syntax_asdl::compound_word* w) {
  syntax_asdl::Token* no_token = nullptr;
  syntax_asdl::word_part_t* UP_part0 = nullptr;
  int token_type;
  id_kind_asdl::Kind_t token_kind;
  StackRoots _roots({&w, &no_token, &UP_part0});

  no_token = nullptr;
  if (len(w->parts) != 1) {
    return (Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*>(Kind::Undefined, no_token));
  }
  UP_part0 = w->parts->index_(0);
  token_type = LiteralId(UP_part0);
  if (token_type == Id::Undefined_Tok) {
    return (Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*>(Kind::Undefined, no_token));
  }
  token_kind = consts::GetKind(token_type);
  if (token_kind == Kind::ControlFlow) {
    return (Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*>(token_kind, static_cast<Token*>(UP_part0)));
  }
  return (Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*>(Kind::Undefined, no_token));
}

syntax_asdl::Token* LiteralToken(syntax_asdl::word_t* UP_w) {
  syntax_asdl::word_part_t* part0 = nullptr;
  StackRoots _roots({&UP_w, &part0});

  compound_word* w = static_cast<compound_word*>(UP_w);
  if (len(w->parts) != 1) {
    return nullptr;
  }
  part0 = w->parts->index_(0);
  if (part0->tag_() == word_part_e::Literal) {
    return static_cast<Token*>(part0);
  }
  return nullptr;
}

int ArithId(syntax_asdl::word_t* w) {
  StackRoots _roots({&w});

  if (w->tag_() == word_e::Token) {
    Token* tok = static_cast<Token*>(w);
    return tok->id;
  }
  return Id::Word_Compound;
}

int BoolId(syntax_asdl::word_t* w) {
  syntax_asdl::word_t* UP_w = nullptr;
  int token_type;
  id_kind_asdl::Kind_t token_kind;
  StackRoots _roots({&w, &UP_w});

  UP_w = w;
  switch (w->tag_()) {
    case word_e::String: {
      word__String* w = static_cast<word__String*>(UP_w);
      return w->id;
    }
      break;
    case word_e::Token: {
      Token* tok = static_cast<Token*>(UP_w);
      return tok->id;
    }
      break;
    case word_e::Compound: {
      compound_word* w = static_cast<compound_word*>(UP_w);
      if (len(w->parts) != 1) {
        return Id::Word_Compound;
      }
      token_type = LiteralId(w->parts->index_(0));
      if (token_type == Id::Undefined_Tok) {
        return Id::Word_Compound;
      }
      if ((token_type == Id::KW_Bang || token_type == Id::Lit_DRightBracket)) {
        return token_type;
      }
      token_kind = consts::GetKind(token_type);
      if ((token_kind == Kind::BoolUnary || token_kind == Kind::BoolBinary)) {
        return token_type;
      }
      return Id::Word_Compound;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

int CommandId(syntax_asdl::word_t* w) {
  syntax_asdl::word_t* UP_w = nullptr;
  int token_type;
  id_kind_asdl::Kind_t token_kind;
  StackRoots _roots({&w, &UP_w});

  UP_w = w;
  switch (w->tag_()) {
    case word_e::Token: {
      Token* tok = static_cast<Token*>(UP_w);
      return tok->id;
    }
      break;
    case word_e::Compound: {
      compound_word* w = static_cast<compound_word*>(UP_w);
      if (len(w->parts) != 1) {
        return Id::Word_Compound;
      }
      token_type = LiteralId(w->parts->index_(0));
      if (token_type == Id::Undefined_Tok) {
        return Id::Word_Compound;
      }
      else {
        if ((token_type == Id::Lit_LBrace || token_type == Id::Lit_RBrace || token_type == Id::Lit_Equals || token_type == Id::Lit_Underscore || token_type == Id::ControlFlow_Return)) {
          return token_type;
        }
      }
      token_kind = consts::GetKind(token_type);
      if (token_kind == Kind::KW) {
        return token_type;
      }
      return Id::Word_Compound;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

id_kind_asdl::Kind_t CommandKind(syntax_asdl::word_t* w) {
  StackRoots _roots({&w});

  if (w->tag_() == word_e::Token) {
    Token* tok = static_cast<Token*>(w);
    return consts::GetKind(tok->id);
  }
  return Kind::Word;
}

bool IsVarSub(syntax_asdl::word_t* w) {
  StackRoots _roots({&w});

  return false;
}

int SpanForLhsExpr(syntax_asdl::sh_lhs_expr_t* node) {
  syntax_asdl::sh_lhs_expr_t* UP_node = nullptr;
  List<int>* spids = nullptr;
  StackRoots _roots({&node, &UP_node, &spids});

  UP_node = node;
  switch (node->tag_()) {
    case sh_lhs_expr_e::Name: {
      sh_lhs_expr__Name* node = static_cast<sh_lhs_expr__Name*>(UP_node);
      spids = node->spids;
    }
      break;
    case sh_lhs_expr_e::IndexedName: {
      sh_lhs_expr__IndexedName* node = static_cast<sh_lhs_expr__IndexedName*>(UP_node);
      spids = node->spids;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  if (len(spids)) {
    return spids->index_(0);
  }
  else {
    return runtime::NO_SPID;
  }
}

int SpanIdFromError(error::_ErrorWithLocation* error) {
  StackRoots _roots({&error});

  if (error->span_id != runtime::NO_SPID) {
    return error->span_id;
  }
  if (error->token) {
    return error->token->span_id;
  }
  if (error->part) {
    return LeftMostSpanForPart(error->part);
  }
  if (error->word) {
    return LeftMostSpanForWord(error->word);
  }
  return runtime::NO_SPID;
}

syntax_asdl::compound_word* ErrorWord(Str* error_str) {
  syntax_asdl::Token* t = nullptr;
  StackRoots _roots({&error_str, &t});

  t = Alloc<Token>(Id::Lit_Chars, runtime::NO_SPID, error_str);
  return Alloc<compound_word>(NewList<syntax_asdl::word_part_t*>(std::initializer_list<syntax_asdl::word_part_t*>{t}));
}

Str* Pretty(syntax_asdl::word_t* w) {
  syntax_asdl::word_t* UP_w = nullptr;
  StackRoots _roots({&w, &UP_w});

  UP_w = w;
  if (w->tag_() == word_e::String) {
    word__String* w = static_cast<word__String*>(UP_w);
    if (w->id == Id::Eof_Real) {
      return str1080;
    }
    else {
      return repr(w->s);
    }
  }
  else {
    return str(w);
  }
}

ctx_EmitDocToken::ctx_EmitDocToken(word_parse::WordParser* w_parser) 
    : Obj(Tag::FixedSize, maskof_ctx_EmitDocToken(), sizeof(ctx_EmitDocToken))  {
  w_parser->EmitDocToken(true);
  this->w_parser = w_parser;
}

ctx_EmitDocToken::~ctx_EmitDocToken(){
  this->w_parser->EmitDocToken(false);
}

ctx_Multiline::ctx_Multiline(word_parse::WordParser* w_parser) 
    : Obj(Tag::FixedSize, maskof_ctx_Multiline(), sizeof(ctx_Multiline))  {
  w_parser->Multiline(true);
  this->w_parser = w_parser;
}

ctx_Multiline::~ctx_Multiline(){
  this->w_parser->Multiline(false);
}

}  // define namespace word_

namespace word_compile {  // define

namespace Id = id_kind_asdl::Id;
using syntax_asdl::Token;
using syntax_asdl::single_quoted;
using syntax_asdl::CharCode;
namespace word_part_e = syntax_asdl::word_part_e;
using syntax_asdl::word_part_t;

syntax_asdl::CharCode* EvalCharLiteralForRegex(syntax_asdl::Token* tok) {
  int id_;
  Str* value = nullptr;
  Str* s = nullptr;
  int i;
  Str* one_char_str = nullptr;
  StackRoots _roots({&tok, &value, &s, &one_char_str});

  id_ = tok->id;
  value = tok->val;
  switch (id_) {
    case Id::Char_UBraced: {
      s = value->slice(3, -1);
      i = to_int(s, 16);
      return Alloc<CharCode>(i, true, tok->span_id);
    }
      break;
    case Id::Char_OneChar: {
      one_char_str = consts::LookupCharC(value->index_(1));
      return Alloc<CharCode>(ord(one_char_str), false, tok->span_id);
    }
      break;
    case Id::Char_Hex: {
      s = value->slice(2);
      i = to_int(s, 16);
      return Alloc<CharCode>(i, false, tok->span_id);
    }
      break;
    case Id::Lit_Chars: 
    case Id::Expr_Name: 
    case Id::Expr_DecInt: {
      return Alloc<CharCode>(ord(tok->val->index_(0)), false, tok->span_id);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

Str* EvalCStringToken(syntax_asdl::Token* tok) {
  int id_;
  Str* value = nullptr;
  Str* c = nullptr;
  Str* s = nullptr;
  int i;
  StackRoots _roots({&tok, &value, &c, &s});

  id_ = tok->id;
  value = tok->val;
  if ((id_ == Id::Char_Literals || id_ == Id::Unknown_Backslash)) {
    return value;
  }
  else {
    if (id_ == Id::Right_SingleQuote) {
      return value;
    }
    else {
      if (id_ == Id::Char_OneChar) {
        c = value->index_(1);
        return consts::LookupCharC(c);
      }
      else {
        if (id_ == Id::Char_Stop) {
          return nullptr;
        }
        else {
          if ((id_ == Id::Char_Octal3 || id_ == Id::Char_Octal4)) {
            if (id_ == Id::Char_Octal3) {
              s = value->slice(1);
            }
            else {
              s = value->slice(2);
            }
            i = to_int(s, 8);
            if (i >= 256) {
              i = (i % 256);
            }
            return chr(i);
          }
          else {
            if (id_ == Id::Char_Hex) {
              s = value->slice(2);
              i = to_int(s, 16);
              return chr(i);
            }
            else {
              if ((id_ == Id::Char_Unicode4 || id_ == Id::Char_Unicode8)) {
                s = value->slice(2);
                i = to_int(s, 16);
                return string_ops::Utf8Encode(i);
              }
              else {
                if (id_ == Id::Char_UBraced) {
                  s = value->slice(3, -1);
                  i = to_int(s, 16);
                  return string_ops::Utf8Encode(i);
                }
                else {
                  assert(0);  // AssertionError
                }
              }
            }
          }
        }
      }
    }
  }
}

Str* EvalSingleQuoted(syntax_asdl::single_quoted* part) {
  List<Str*>* tmp = nullptr;
  Str* s = nullptr;
  StackRoots _roots({&part, &tmp, &s});

  if ((part->left->id == Id::Left_SingleQuote || part->left->id == Id::Left_RSingleQuote || part->left->id == Id::Left_TSingleQuote || part->left->id == Id::Left_RTSingleQuote)) {
    tmp = Alloc<List<Str*>>();
    for (ListIter<syntax_asdl::Token*> it(part->tokens); !it.Done(); it.Next()) {
      syntax_asdl::Token* t = it.Value();
      tmp->append(t->val);
    }
    s = str1081->join(tmp);
  }
  else {
    if ((part->left->id == Id::Left_DollarSingleQuote || part->left->id == Id::Left_DollarTSingleQuote)) {
      tmp = Alloc<List<Str*>>();
      for (ListIter<syntax_asdl::Token*> it(part->tokens); !it.Done(); it.Next()) {
        syntax_asdl::Token* t = it.Value();
        tmp->append(EvalCStringToken(t));
      }
      s = str1082->join(tmp);
    }
    else {
      assert(0);  // AssertionError
    }
  }
  return s;
}

bool IsLeadingSpace(Str* s) {
  StackRoots _roots({&s});

  for (StrIter it(s); !it.Done(); it.Next()) {
    Str* ch = it.Value();
    StackRoots _for({&ch  });
    if (!str_contains(str1083, ch)) {
      return false;
    }
  }
  return true;
}

void RemoveLeadingSpaceDQ(List<syntax_asdl::word_part_t*>* parts) {
  bool line_ended;
  syntax_asdl::word_part_t* UP_first = nullptr;
  syntax_asdl::word_part_t* UP_last = nullptr;
  Str* to_strip = nullptr;
  int n;
  StackRoots _roots({&parts, &UP_first, &UP_last, &to_strip});

  if (len(parts) <= 1) {
    return ;
  }
  line_ended = false;
  UP_first = parts->index_(0);
  if (UP_first->tag_() == word_part_e::Literal) {
    Token* first = static_cast<Token*>(UP_first);
    if (qsn_native::IsWhitespace(first->val)) {
      parts->pop(0);
    }
    if (first->val->endswith(str1084)) {
      line_ended = true;
    }
  }
  UP_last = parts->index_(-1);
  to_strip = nullptr;
  if (UP_last->tag_() == word_part_e::Literal) {
    Token* last = static_cast<Token*>(UP_last);
    if (IsLeadingSpace(last->val)) {
      to_strip = last->val;
      parts->pop();
    }
  }
  if (to_strip != nullptr) {
    n = len(to_strip);
    for (ListIter<syntax_asdl::word_part_t*> it(parts); !it.Done(); it.Next()) {
      syntax_asdl::word_part_t* UP_p = it.Value();
      StackRoots _for({&UP_p    });
      if (UP_p->tag_() != word_part_e::Literal) {
        line_ended = false;
        continue;
      }
      Token* p = static_cast<Token*>(UP_p);
      if (line_ended) {
        if (p->val->startswith(to_strip)) {
          p->val = p->val->slice(n);
        }
      }
      line_ended = false;
      if (p->val->endswith(str1085)) {
        line_ended = true;
      }
    }
  }
}

void RemoveLeadingSpaceSQ(List<syntax_asdl::Token*>* tokens) {
  bool line_ended;
  syntax_asdl::Token* first = nullptr;
  syntax_asdl::Token* last = nullptr;
  Str* to_strip = nullptr;
  int n;
  StackRoots _roots({&tokens, &first, &last, &to_strip});

  if (len(tokens) <= 1) {
    return ;
  }
  line_ended = false;
  first = tokens->index_(0);
  if ((first->id == Id::Lit_Chars || first->id == Id::Char_Literals)) {
    if (qsn_native::IsWhitespace(first->val)) {
      tokens->pop(0);
    }
    if (first->val->endswith(str1086)) {
      line_ended = true;
    }
  }
  last = tokens->index_(-1);
  to_strip = nullptr;
  if ((last->id == Id::Lit_Chars || last->id == Id::Char_Literals)) {
    if (IsLeadingSpace(last->val)) {
      to_strip = last->val;
      tokens->pop();
    }
  }
  if (to_strip != nullptr) {
    n = len(to_strip);
    for (ListIter<syntax_asdl::Token*> it(tokens); !it.Done(); it.Next()) {
      syntax_asdl::Token* tok = it.Value();
      StackRoots _for({&tok    });
      if ((tok->id != Id::Lit_Chars && tok->id != Id::Char_Literals)) {
        line_ended = false;
        continue;
      }
      if (line_ended) {
        if (tok->val->startswith(to_strip)) {
          tok->val = tok->val->slice(n);
        }
      }
      line_ended = false;
      if (tok->val->endswith(str1087)) {
        line_ended = true;
      }
    }
  }
}

}  // define namespace word_compile

namespace word_eval {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Kind;
using id_kind_asdl::Kind_str;
using syntax_asdl::braced_var_sub;
using syntax_asdl::Token;
namespace word = syntax_asdl::word;
namespace word_e = syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::compound_word;
namespace bracket_op_e = syntax_asdl::bracket_op_e;
using syntax_asdl::bracket_op__ArrayIndex;
using syntax_asdl::bracket_op__WholeArray;
namespace suffix_op_e = syntax_asdl::suffix_op_e;
using syntax_asdl::suffix_op__PatSub;
using syntax_asdl::suffix_op__Slice;
using syntax_asdl::suffix_op__Unary;
using syntax_asdl::suffix_op__Static;
using syntax_asdl::sh_array_literal;
using syntax_asdl::single_quoted;
using syntax_asdl::double_quoted;
using syntax_asdl::simple_var_sub;
using syntax_asdl::command_sub;
namespace word_part_e = syntax_asdl::word_part_e;
using syntax_asdl::word_part__ArithSub;
using syntax_asdl::word_part__EscapedLiteral;
using syntax_asdl::word_part__AssocArrayLiteral;
using syntax_asdl::word_part__ExprSub;
using syntax_asdl::word_part__ExtGlob;
using syntax_asdl::word_part__FuncCall;
using syntax_asdl::word_part__Splice;
using syntax_asdl::word_part__TildeSub;
namespace part_value = runtime_asdl::part_value;
namespace part_value_e = runtime_asdl::part_value_e;
using runtime_asdl::part_value_t;
using runtime_asdl::part_value__String;
using runtime_asdl::part_value__Array;
using runtime_asdl::part_value__ExtGlob;
namespace value = runtime_asdl::value;
namespace value_e = runtime_asdl::value_e;
using runtime_asdl::value_t;
using runtime_asdl::value__Str;
using runtime_asdl::value__AssocArray;
using runtime_asdl::value__MaybeStrArray;
using runtime_asdl::value__Obj;
namespace lvalue = runtime_asdl::lvalue;
using runtime_asdl::lvalue_t;
using runtime_asdl::assign_arg;
namespace cmd_value_e = runtime_asdl::cmd_value_e;
using runtime_asdl::cmd_value_t;
namespace cmd_value = runtime_asdl::cmd_value;
using runtime_asdl::cmd_value__Assign;
using runtime_asdl::cmd_value__Argv;
namespace a_index = runtime_asdl::a_index;
namespace a_index_e = runtime_asdl::a_index_e;
using runtime_asdl::a_index__Int;
using runtime_asdl::a_index__Str;
using runtime_asdl::VTestPlace;
using runtime_asdl::VarSubState;
int QUOTED = (1 << 0);
int IS_SUBST = (1 << 1);
int EXTGLOB_FILES = (1 << 2);
int EXTGLOB_MATCH = (1 << 3);
int EXTGLOB_NESTED = (1 << 4);
int QUOTE_FNMATCH = (1 << 5);
int QUOTE_ERE = (1 << 6);
GLOBAL_LIST(Str*, 3, _STRING_AND_ARRAY, {str1088 COMMA str1089 COMMA str1090});

bool ShouldArrayDecay(Str* var_name, optview::Exec* exec_opts) {
  return ShouldArrayDecay(var_name, exec_opts, true);
}

bool ShouldArrayDecay(Str* var_name, optview::Exec* exec_opts, bool is_plain_var_sub) {
  StackRoots _roots({&var_name, &exec_opts});

  return (exec_opts->compat_array() or (is_plain_var_sub and list_contains(_STRING_AND_ARRAY, var_name)));
}

runtime_asdl::value_t* DecayArray(runtime_asdl::value_t* val) {
  Str* s = nullptr;
  StackRoots _roots({&val, &s});

  if (val->tag_() == value_e::MaybeStrArray) {
    value__MaybeStrArray* array_val = static_cast<value__MaybeStrArray*>(val);
    s = len(array_val->strs) ? array_val->strs->index_(0) : nullptr;
  }
  else {
    if (val->tag_() == value_e::AssocArray) {
      value__AssocArray* assoc_val = static_cast<value__AssocArray*>(val);
      s = dict_contains(assoc_val->d, str1091) ? assoc_val->d->index_(str1092) : nullptr;
    }
    else {
      assert(0);  // AssertionError
    }
  }
  if (s == nullptr) {
    return Alloc<value::Undef>();
  }
  else {
    return Alloc<value::Str>(s);
  }
}

Str* GetArrayItem(List<Str*>* strs, int index) {
  int n;
  Str* s = nullptr;
  StackRoots _roots({&strs, &s});

  n = len(strs);
  if (index < 0) {
    index += n;
  }
  if ((0 <= index and index < n)) {
    s = strs->index_(index);
  }
  else {
    s = nullptr;
  }
  return s;
}
Str* ASSIGN_ARG_RE = str1093;

runtime_asdl::assign_arg* _SplitAssignArg(Str* arg, int word_spid) {
  List<Str*>* m = nullptr;
  Str* var_name = nullptr;
  Str* op = nullptr;
  runtime_asdl::value_t* val = nullptr;
  bool append;
  StackRoots _roots({&arg, &m, &var_name, &op, &val});

  m = libc::regex_match(ASSIGN_ARG_RE, arg);
  if (m == nullptr) {
    e_die(fmt312(arg), word_spid);
  }
  var_name = m->index_(1);
  op = m->index_(3);
  if (len(op)) {
    val = Alloc<value::Str>(m->index_(4));
    append = str_equals(op->index_(0), str1095);
  }
  else {
    val = nullptr;
    append = false;
  }
  return Alloc<assign_arg>(var_name, val, append, word_spid);
}

Str* _BackslashEscape(Str* s) {
  StackRoots _roots({&s});

  return s->replace(str1096, str1097);
}

runtime_asdl::part_value_t* _ValueToPartValue(runtime_asdl::value_t* val, bool quoted) {
  runtime_asdl::value_t* UP_val = nullptr;
  StackRoots _roots({&val, &UP_val});

  UP_val = val;
  switch (val->tag_()) {
    case value_e::Undef: {
      return Alloc<part_value::String>(str1098, quoted, !quoted);
    }
      break;
    case value_e::Str: {
      value__Str* val = static_cast<value__Str*>(UP_val);
      return Alloc<part_value::String>(val->s, quoted, !quoted);
    }
      break;
    case value_e::MaybeStrArray: {
      value__MaybeStrArray* val = static_cast<value__MaybeStrArray*>(UP_val);
      return Alloc<part_value::Array>(val->strs);
    }
      break;
    case value_e::AssocArray: {
      value__AssocArray* val = static_cast<value__AssocArray*>(UP_val);
      return Alloc<part_value::Array>(val->d->values());
    }
      break;
    case value_e::Obj: {
      assert(0);  // AssertionError
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  assert(0);  // AssertionError
}

List<List<Tuple3<Str*, bool, bool>*>*>* _MakeWordFrames(List<runtime_asdl::part_value_t*>* part_vals) {
  List<Tuple3<Str*, bool, bool>*>* current = nullptr;
  List<List<Tuple3<Str*, bool, bool>*>*>* frames = nullptr;
  runtime_asdl::part_value_t* UP_p = nullptr;
  bool is_first;
  Tuple3<Str*, bool, bool>* portion = nullptr;
  StackRoots _roots({&part_vals, &current, &frames, &UP_p, &portion});

  current = Alloc<List<Tuple3<Str*, bool, bool>*>>();
  frames = NewList<List<Tuple3<Str*, bool, bool>*>*>(std::initializer_list<List<Tuple3<Str*, bool, bool>*>*>{current});
  for (ListIter<runtime_asdl::part_value_t*> it(part_vals); !it.Done(); it.Next()) {
    runtime_asdl::part_value_t* p = it.Value();
    StackRoots _for({&p  });
    UP_p = p;
    switch (p->tag_()) {
      case part_value_e::String: {
        part_value__String* p = static_cast<part_value__String*>(UP_p);
        current->append((Alloc<Tuple3<Str*, bool, bool>>(p->s, p->quoted, p->do_split)));
      }
        break;
      case part_value_e::Array: {
        part_value__Array* p = static_cast<part_value__Array*>(UP_p);
        is_first = true;
        for (ListIter<Str*> it(p->strs); !it.Done(); it.Next()) {
          Str* s = it.Value();
          StackRoots _for({&s        });
          if (s == nullptr) {
            continue;
          }
          portion = (Alloc<Tuple3<Str*, bool, bool>>(s, true, false));
          if (is_first) {
            current->append(portion);
            is_first = false;
          }
          else {
            current = NewList<Tuple3<Str*, bool, bool>*>(std::initializer_list<Tuple3<Str*, bool, bool>*>{portion});
            frames->append(current);
          }
        }
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
  return frames;
}

Str* _DecayPartValuesToString(List<runtime_asdl::part_value_t*>* part_vals, Str* join_char) {
  List<Str*>* out = nullptr;
  runtime_asdl::part_value_t* UP_p = nullptr;
  List<Str*>* tmp = nullptr;
  StackRoots _roots({&part_vals, &join_char, &out, &UP_p, &tmp});

  out = Alloc<List<Str*>>();
  for (ListIter<runtime_asdl::part_value_t*> it(part_vals); !it.Done(); it.Next()) {
    runtime_asdl::part_value_t* p = it.Value();
    StackRoots _for({&p  });
    UP_p = p;
    switch (p->tag_()) {
      case part_value_e::String: {
        part_value__String* p = static_cast<part_value__String*>(UP_p);
        out->append(p->s);
      }
        break;
      case part_value_e::Array: {
        part_value__Array* p = static_cast<part_value__Array*>(UP_p);
        tmp = Alloc<List<Str*>>();
        for (ListIter<Str*> it(p->strs); !it.Done(); it.Next()) {
          Str* s = it.Value();
          if (s != nullptr) {
            tmp->append(s);
          }
        }
        out->append(join_char->join(tmp));
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
  return str1100->join(out);
}

runtime_asdl::value_t* _PerformSlice(runtime_asdl::value_t* val, int begin, int length, bool has_length, syntax_asdl::braced_var_sub* part, runtime_asdl::value__Str* arg0_val) {
  runtime_asdl::value_t* UP_val = nullptr;
  Str* s = nullptr;
  int n;
  int byte_begin;
  int num_iters;
  int byte_end;
  Str* substr = nullptr;
  runtime_asdl::value_t* result = nullptr;
  List<Str*>* orig = nullptr;
  int i;
  List<Str*>* strs = nullptr;
  int count;
  StackRoots _roots({&val, &part, &arg0_val, &UP_val, &s, &substr, &result, &orig, &strs});

  UP_val = val;
  switch (val->tag_()) {
    case value_e::Str: {
      value__Str* val = static_cast<value__Str*>(UP_val);
      s = val->s;
      n = len(s);
      if (begin < 0) {
        byte_begin = n;
        num_iters = -begin;
        for (int _ = 0; _ < num_iters; ++_) {
          byte_begin = string_ops::PreviousUtf8Char(s, byte_begin);
        }
      }
      else {
        byte_begin = string_ops::AdvanceUtf8Chars(s, begin, 0);
      }
      if (has_length) {
        if (length < 0) {
          byte_end = n;
          num_iters = -length;
          for (int _ = 0; _ < num_iters; ++_) {
            byte_end = string_ops::PreviousUtf8Char(s, byte_end);
          }
        }
        else {
          byte_end = string_ops::AdvanceUtf8Chars(s, length, byte_begin);
        }
      }
      else {
        byte_end = len(s);
      }
      substr = s->slice(byte_begin, byte_end);
      result = Alloc<value::Str>(substr);
    }
      break;
    case value_e::MaybeStrArray: {
      value__MaybeStrArray* val = static_cast<value__MaybeStrArray*>(UP_val);
      if ((has_length and length < 0)) {
        e_die(fmt313(length), part);
      }
      if (arg0_val != nullptr) {
        orig = NewList<Str*>(std::initializer_list<Str*>{arg0_val->s});
        orig->extend(val->strs);
      }
      else {
        orig = val->strs;
      }
      n = len(orig);
      if (begin < 0) {
        i = (n + begin);
      }
      else {
        i = begin;
      }
      strs = Alloc<List<Str*>>();
      count = 0;
      while (i < n) {
        if ((has_length and count == length)) {
          break;
        }
        s = orig->index_(i);
        if (s != nullptr) {
          strs->append(s);
          count += 1;
        }
        i += 1;
      }
      result = Alloc<value::MaybeStrArray>(strs);
    }
      break;
    case value_e::AssocArray: {
      e_die(fmt314(), part);
    }
      break;
    default: {
      throw Alloc<NotImplementedError>(val->tag_());
    }
  }
  return result;
}

StringWordEvaluator::StringWordEvaluator() 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(StringWordEvaluator))  {
  ;  // pass
}

runtime_asdl::value__Str* StringWordEvaluator::EvalWordToString(syntax_asdl::word_t* w) {
  return EvalWordToString(w, 0);
}

runtime_asdl::value__Str* StringWordEvaluator::EvalWordToString(syntax_asdl::word_t* w, int eval_flags) {
  StackRoots _roots({&w});

  throw Alloc<NotImplementedError>();
}

Str* _GetDollarHyphen(optview::Exec* exec_opts) {
  List<Str*>* chars = nullptr;
  StackRoots _roots({&exec_opts, &chars});

  chars = Alloc<List<Str*>>();
  if (exec_opts->interactive()) {
    chars->append(str1103);
  }
  if (exec_opts->errexit()) {
    chars->append(str1104);
  }
  if (exec_opts->noglob()) {
    chars->append(str1105);
  }
  if (exec_opts->noexec()) {
    chars->append(str1106);
  }
  if (exec_opts->nounset()) {
    chars->append(str1107);
  }
  if (exec_opts->xtrace()) {
    chars->append(str1108);
  }
  if (exec_opts->noclobber()) {
    chars->append(str1109);
  }
  return str1110->join(chars);
}

TildeEvaluator::TildeEvaluator(state::Mem* mem, optview::Exec* exec_opts) 
    : Obj(Tag::FixedSize, maskof_TildeEvaluator(), sizeof(TildeEvaluator))  {
  this->mem = mem;
  this->exec_opts = exec_opts;
}

Str* TildeEvaluator::Eval(syntax_asdl::Token* token) {
  runtime_asdl::value_t* val = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  Str* result = nullptr;
  StackRoots _roots({&token, &val, &UP_val, &result});

  if (maybe_str_equals(token->val, str1111)) {
    val = this->mem->GetValue(str1112);
    UP_val = val;
    if (val->tag_() == value_e::Str) {
      value__Str* val = static_cast<value__Str*>(UP_val);
      return val->s;
    }
    result = pyos::GetMyHomeDir();
  }
  else {
    result = pyos::GetHomeDir(token->val->slice(1));
  }
  if (result == nullptr) {
    if (this->exec_opts->strict_tilde()) {
      e_die(fmt315(), token);
    }
    else {
      return token->val;
    }
  }
  return result;
}

AbstractWordEvaluator::AbstractWordEvaluator(state::Mem* mem, optview::Exec* exec_opts, state::MutableOpts* mutable_opts, split::SplitContext* splitter, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_AbstractWordEvaluator();
  this->arith_ev = nullptr;
  this->expr_ev = nullptr;
  this->prompt_ev = nullptr;
  this->unsafe_arith = nullptr;
  this->tilde_ev = Alloc<TildeEvaluator>(mem, exec_opts);
  this->mem = mem;
  this->exec_opts = exec_opts;
  this->mutable_opts = mutable_opts;
  this->splitter = splitter;
  this->errfmt = errfmt;
  this->globber = Alloc<glob_::Globber>(exec_opts);
}

void AbstractWordEvaluator::CheckCircularDeps() {
  throw Alloc<NotImplementedError>();
}

runtime_asdl::part_value_t* AbstractWordEvaluator::_EvalCommandSub(syntax_asdl::command_sub* cs_part, bool quoted) {
  StackRoots _roots({&cs_part});

  throw Alloc<NotImplementedError>();
}

runtime_asdl::part_value_t* AbstractWordEvaluator::_EvalProcessSub(syntax_asdl::command_sub* cs_part) {
  StackRoots _roots({&cs_part});

  throw Alloc<NotImplementedError>();
}

runtime_asdl::value_t* AbstractWordEvaluator::_EvalVarNum(int var_num) {
  return this->mem->GetArgNum(var_num);
}

runtime_asdl::value_t* AbstractWordEvaluator::_EvalSpecialVar(int op_id, bool quoted, runtime_asdl::VarSubState* vsub_state) {
  List<Str*>* argv = nullptr;
  runtime_asdl::value_t* val = nullptr;
  StackRoots _roots({&vsub_state, &argv, &val});

  if ((op_id == Id::VSub_At || op_id == Id::VSub_Star)) {
    argv = this->mem->GetArgv();
    val = Alloc<value::MaybeStrArray>(argv);
    if (op_id == Id::VSub_At) {
      vsub_state->join_array = !quoted;
    }
    else {
      vsub_state->join_array = true;
    }
  }
  else {
    if (op_id == Id::VSub_Hyphen) {
      val = Alloc<value::Str>(_GetDollarHyphen(this->exec_opts));
    }
    else {
      val = this->mem->GetSpecialVar(op_id);
    }
  }
  return val;
}

bool AbstractWordEvaluator::_ApplyTestOp(runtime_asdl::value_t* val, syntax_asdl::suffix_op__Unary* op, bool quoted, List<runtime_asdl::part_value_t*>* part_vals, runtime_asdl::VTestPlace* vtest_place, syntax_asdl::Token* blame_token) {
  int eval_flags;
  syntax_asdl::Token* tok = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  bool is_falsey;
  List<runtime_asdl::part_value_t*>* assign_part_vals = nullptr;
  Str* rhs_str = nullptr;
  runtime_asdl::lvalue_t* lval = nullptr;
  Str* var_name = nullptr;
  runtime_asdl::a_index_t* var_index = nullptr;
  runtime_asdl::a_index_t* UP_var_index = nullptr;
  List<runtime_asdl::part_value_t*>* error_part_vals = nullptr;
  Str* error_str = nullptr;
  StackRoots _roots({&val, &op, &part_vals, &vtest_place, &blame_token, &tok, &UP_val, &assign_part_vals, &rhs_str, &lval, &var_name, &var_index, &UP_var_index, &error_part_vals, &error_str});

  eval_flags = IS_SUBST;
  if (quoted) {
    eval_flags |= QUOTED;
  }
  tok = op->tok;
  UP_val = val;
  switch (val->tag_()) {
    case value_e::Undef: {
      is_falsey = true;
    }
      break;
    case value_e::Str: {
      value__Str* val = static_cast<value__Str*>(UP_val);
      if ((tok->id == Id::VTest_ColonHyphen || tok->id == Id::VTest_ColonEquals || tok->id == Id::VTest_ColonQMark || tok->id == Id::VTest_ColonPlus)) {
        is_falsey = len(val->s) == 0;
      }
      else {
        is_falsey = false;
      }
    }
      break;
    case value_e::MaybeStrArray: {
      value__MaybeStrArray* val = static_cast<value__MaybeStrArray*>(UP_val);
      is_falsey = len(val->strs) == 0;
    }
      break;
    case value_e::AssocArray: {
      value__AssocArray* val = static_cast<value__AssocArray*>(UP_val);
      is_falsey = len(val->d) == 0;
    }
      break;
    default: {
      throw Alloc<NotImplementedError>(val->tag_());
    }
  }
  if ((tok->id == Id::VTest_ColonHyphen || tok->id == Id::VTest_Hyphen)) {
    if (is_falsey) {
      this->_EvalWordToParts(op->arg_word, part_vals, eval_flags);
      return true;
    }
    else {
      return false;
    }
  }
  else {
    if ((tok->id == Id::VTest_ColonPlus || tok->id == Id::VTest_Plus)) {
      if (is_falsey) {
        return false;
      }
      else {
        this->_EvalWordToParts(op->arg_word, part_vals, eval_flags);
        return true;
      }
    }
    else {
      if ((tok->id == Id::VTest_ColonEquals || tok->id == Id::VTest_Equals)) {
        if (is_falsey) {
          assign_part_vals = Alloc<List<runtime_asdl::part_value_t*>>();
          this->_EvalWordToParts(op->arg_word, assign_part_vals, eval_flags);
          part_vals->extend(assign_part_vals);
          if (vtest_place->name == nullptr) {
            e_die(str1114);
          }
          else {
            rhs_str = _DecayPartValuesToString(assign_part_vals, this->splitter->GetJoinChar());
            if (vtest_place->index == nullptr) {
              lval = Alloc<lvalue::Named>(vtest_place->name);
            }
            else {
              var_name = vtest_place->name;
              var_index = vtest_place->index;
              UP_var_index = var_index;
              switch (var_index->tag_()) {
                case a_index_e::Int: {
                  a_index__Int* var_index = static_cast<a_index__Int*>(UP_var_index);
                  lval = Alloc<lvalue::Indexed>(var_name, var_index->i);
                }
                  break;
                case a_index_e::Str: {
                  a_index__Str* var_index = static_cast<a_index__Str*>(UP_var_index);
                  lval = Alloc<lvalue::Keyed>(var_name, var_index->s);
                }
                  break;
                default: {
                  assert(0);  // AssertionError
                }
              }
            }
            state::OshLanguageSetValue(this->mem, lval, Alloc<value::Str>(rhs_str));
          }
          return true;
        }
        else {
          return false;
        }
      }
      else {
        if ((tok->id == Id::VTest_ColonQMark || tok->id == Id::VTest_QMark)) {
          if (is_falsey) {
            error_part_vals = Alloc<List<runtime_asdl::part_value_t*>>();
            this->_EvalWordToParts(op->arg_word, error_part_vals, eval_flags);
            error_str = _DecayPartValuesToString(error_part_vals, this->splitter->GetJoinChar());
            e_die(fmt316(error_str), blame_token);
          }
          else {
            return false;
          }
        }
        else {
          throw Alloc<NotImplementedError>(tok->id);
        }
      }
    }
  }
}

runtime_asdl::value_t* AbstractWordEvaluator::_Length(runtime_asdl::value_t* val, syntax_asdl::Token* token) {
  runtime_asdl::value_t* UP_val = nullptr;
  int length;
  StackRoots _roots({&val, &token, &UP_val});

  UP_val = val;
  switch (val->tag_()) {
    case value_e::Str: {
      value__Str* val = static_cast<value__Str*>(UP_val);
      try {
        length = string_ops::CountUtf8Chars(val->s);
      }
      catch (error::Strict* e) {
        e->span_id = token->span_id;
        if (this->exec_opts->strict_word_eval()) {
          throw ;
        }
        else {
          this->errfmt->PrettyPrintError(e, str1116);
          return Alloc<value::Str>(str1117);
        }
      }
    }
      break;
    case value_e::MaybeStrArray: {
      value__MaybeStrArray* val = static_cast<value__MaybeStrArray*>(UP_val);
      length = 0;
      for (ListIter<Str*> it(val->strs); !it.Done(); it.Next()) {
        Str* s = it.Value();
        StackRoots _for({&s      });
        if (s != nullptr) {
          length += 1;
        }
      }
    }
      break;
    case value_e::AssocArray: {
      value__AssocArray* val = static_cast<value__AssocArray*>(UP_val);
      length = len(val->d);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return Alloc<value::Str>(str(length));
}

runtime_asdl::value_t* AbstractWordEvaluator::_Keys(runtime_asdl::value_t* val, syntax_asdl::Token* token) {
  runtime_asdl::value_t* UP_val = nullptr;
  List<Str*>* indices = nullptr;
  int i;
  StackRoots _roots({&val, &token, &UP_val, &indices});

  UP_val = val;
  switch (val->tag_()) {
    case value_e::MaybeStrArray: {
      value__MaybeStrArray* val = static_cast<value__MaybeStrArray*>(UP_val);
      indices = Alloc<List<Str*>>();
      i = 0;
      for (ListIter<Str*> it(val->strs); !it.Done(); it.Next(), ++i) {
        Str* s = it.Value();
        StackRoots _for({&s      });
        if (s != nullptr) {
          indices->append(str(i));
        }
      }
      return Alloc<value::MaybeStrArray>(indices);
    }
      break;
    case value_e::AssocArray: {
      value__AssocArray* val = static_cast<value__AssocArray*>(UP_val);
      return Alloc<value::MaybeStrArray>(val->d->keys());
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

runtime_asdl::value_t* AbstractWordEvaluator::_EvalVarRef(runtime_asdl::value_t* val, syntax_asdl::Token* token, bool quoted, runtime_asdl::VarSubState* vsub_state, runtime_asdl::VTestPlace* vtest_place) {
  runtime_asdl::value_t* UP_val = nullptr;
  syntax_asdl::braced_var_sub* bvs_part = nullptr;
  StackRoots _roots({&val, &token, &vsub_state, &vtest_place, &UP_val, &bvs_part});

  UP_val = val;
  switch (val->tag_()) {
    case value_e::Undef: {
      return Alloc<value::Undef>();
    }
      break;
    case value_e::Str: {
      value__Str* val = static_cast<value__Str*>(UP_val);
      bvs_part = this->unsafe_arith->ParseVarRef(val->s, token);
      if ((!this->exec_opts->eval_unsafe_arith() and bvs_part->bracket_op)) {
        e_die(fmt317(), token);
      }
      return this->_VarRefValue(bvs_part, quoted, vsub_state, vtest_place);
    }
      break;
    case value_e::MaybeStrArray: {
      e_die(str1119);
    }
      break;
    case value_e::AssocArray: {
      e_die(str1120);
    }
      break;
    default: {
      throw Alloc<NotImplementedError>(val->tag_());
    }
  }
}

runtime_asdl::value_t* AbstractWordEvaluator::_ApplyUnarySuffixOp(runtime_asdl::value_t* val, syntax_asdl::suffix_op__Unary* op) {
  id_kind_asdl::Kind_t op_kind;
  runtime_asdl::value__Str* arg_val = nullptr;
  bool has_extglob;
  runtime_asdl::value_t* UP_val = nullptr;
  Str* s = nullptr;
  runtime_asdl::value_t* new_val = nullptr;
  List<Str*>* strs = nullptr;
  StackRoots _roots({&val, &op, &arg_val, &UP_val, &s, &new_val, &strs});

  op_kind = consts::GetKind(op->tok->id);
  if (op_kind == Kind::VOp1) {
    Tuple2<runtime_asdl::value__Str*, bool> tup0 = this->EvalWordToPattern(op->arg_word);
    arg_val = tup0.at0();
    has_extglob = tup0.at1();
    UP_val = val;
    switch (val->tag_()) {
      case value_e::Str: {
        value__Str* val = static_cast<value__Str*>(UP_val);
        s = string_ops::DoUnarySuffixOp(val->s, op, arg_val->s, has_extglob);
        new_val = Alloc<value::Str>(s);
      }
        break;
      case value_e::MaybeStrArray: {
        value__MaybeStrArray* val = static_cast<value__MaybeStrArray*>(UP_val);
        strs = Alloc<List<Str*>>();
        for (ListIter<Str*> it(val->strs); !it.Done(); it.Next()) {
          Str* s = it.Value();
          StackRoots _for({&s        });
          if (s != nullptr) {
            strs->append(string_ops::DoUnarySuffixOp(s, op, arg_val->s, has_extglob));
          }
        }
        new_val = Alloc<value::MaybeStrArray>(strs);
      }
        break;
      case value_e::AssocArray: {
        value__AssocArray* val = static_cast<value__AssocArray*>(UP_val);
        strs = Alloc<List<Str*>>();
        for (ListIter<Str*> it(val->d->values()); !it.Done(); it.Next()) {
          Str* s = it.Value();
          StackRoots _for({&s        });
          strs->append(string_ops::DoUnarySuffixOp(s, op, arg_val->s, has_extglob));
        }
        new_val = Alloc<value::MaybeStrArray>(strs);
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
  else {
    assert(0);  // AssertionError
  }
  return new_val;
}

runtime_asdl::value_t* AbstractWordEvaluator::_PatSub(runtime_asdl::value_t* val, syntax_asdl::suffix_op__PatSub* op) {
  runtime_asdl::value__Str* pat_val = nullptr;
  bool has_extglob;
  runtime_asdl::value__Str* replace_val = nullptr;
  Str* replace_str = nullptr;
  Str* regex = nullptr;
  List<Str*>* warnings = nullptr;
  string_ops::GlobReplacer* replacer = nullptr;
  Str* s = nullptr;
  List<Str*>* strs = nullptr;
  StackRoots _roots({&val, &op, &pat_val, &replace_val, &replace_str, &regex, &warnings, &replacer, &s, &strs});

  Tuple2<runtime_asdl::value__Str*, bool> tup1 = this->EvalWordToPattern(op->pat);
  pat_val = tup1.at0();
  has_extglob = tup1.at1();
  if (has_extglob) {
    e_die(fmt318(), op->pat);
  }
  if (op->replace) {
    replace_val = this->EvalWordToString(op->replace);
    replace_str = replace_val->s;
  }
  else {
    replace_str = str1122;
  }
  Tuple2<Str*, List<Str*>*> tup2 = glob_::GlobToERE(pat_val->s);
  regex = tup2.at0();
  warnings = tup2.at1();
  if (len(warnings)) {
    ;  // pass
  }
  replacer = Alloc<string_ops::GlobReplacer>(regex, replace_str, op->spids->index_(0));
  switch (val->tag_()) {
    case value_e::Str: {
      value__Str* str_val = static_cast<value__Str*>(val);
      s = replacer->Replace(str_val->s, op);
      val = Alloc<value::Str>(s);
    }
      break;
    case value_e::MaybeStrArray: {
      value__MaybeStrArray* array_val = static_cast<value__MaybeStrArray*>(val);
      strs = Alloc<List<Str*>>();
      for (ListIter<Str*> it(array_val->strs); !it.Done(); it.Next()) {
        Str* s = it.Value();
        StackRoots _for({&s      });
        if (s != nullptr) {
          strs->append(replacer->Replace(s, op));
        }
      }
      val = Alloc<value::MaybeStrArray>(strs);
    }
      break;
    case value_e::AssocArray: {
      value__AssocArray* assoc_val = static_cast<value__AssocArray*>(val);
      strs = Alloc<List<Str*>>();
      for (ListIter<Str*> it(assoc_val->d->values()); !it.Done(); it.Next()) {
        Str* s = it.Value();
        StackRoots _for({&s      });
        strs->append(replacer->Replace(s, op));
      }
      val = Alloc<value::MaybeStrArray>(strs);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return val;
}

runtime_asdl::value_t* AbstractWordEvaluator::_Slice(runtime_asdl::value_t* val, syntax_asdl::suffix_op__Slice* op, Str* var_name, syntax_asdl::braced_var_sub* part) {
  int begin;
  bool has_length;
  int length;
  runtime_asdl::value__Str* arg0_val = nullptr;
  StackRoots _roots({&val, &op, &var_name, &part, &arg0_val});

  if (op->begin) {
    begin = this->arith_ev->EvalToInt(op->begin);
  }
  else {
    begin = 0;
  }
  has_length = false;
  length = -1;
  if (op->length) {
    has_length = true;
    length = this->arith_ev->EvalToInt(op->length);
  }
  try {
    arg0_val = nullptr;
    if (var_name == nullptr) {
      arg0_val = this->mem->GetArg0();
    }
    val = _PerformSlice(val, begin, length, has_length, part, arg0_val);
  }
  catch (error::Strict* e) {
    if (this->exec_opts->strict_word_eval()) {
      throw ;
    }
    else {
      this->errfmt->PrettyPrintError(e, str1123);
      switch (val->tag_()) {
        case value_e::Str: {
          val = Alloc<value::Str>(str1124);
        }
          break;
        case value_e::MaybeStrArray: {
          val = Alloc<value::MaybeStrArray>(Alloc<List<Str*>>());
        }
          break;
        default: {
          throw Alloc<NotImplementedError>();
        }
      }
    }
  }
  return val;
}

Tuple2<runtime_asdl::value__Str*, bool> AbstractWordEvaluator::_Nullary(runtime_asdl::value_t* val, syntax_asdl::Token* op, Str* var_name) {
  runtime_asdl::value_t* UP_val = nullptr;
  bool quoted2;
  int op_id;
  Str* prompt = nullptr;
  Str* p = nullptr;
  runtime_asdl::value__Str* result = nullptr;
  List<Str*>* tmp = nullptr;
  List<Str*>* chars = nullptr;
  runtime_asdl::cell* cell = nullptr;
  StackRoots _roots({&val, &op, &var_name, &UP_val, &prompt, &p, &result, &tmp, &chars, &cell});

  UP_val = val;
  quoted2 = false;
  op_id = op->id;
  if (op_id == Id::VOp0_P) {
    switch (val->tag_()) {
      case value_e::Str: {
        value__Str* str_val = static_cast<value__Str*>(UP_val);
        prompt = this->prompt_ev->EvalPrompt(str_val);
        p = prompt->replace(str1125, str1126)->replace(str1127, str1128);
        result = Alloc<value::Str>(p);
      }
        break;
      default: {
        e_die(fmt319(ui::ValType(val)));
      }
    }
  }
  else {
    if (op_id == Id::VOp0_Q) {
      switch (val->tag_()) {
        case value_e::Str: {
          value__Str* str_val = static_cast<value__Str*>(UP_val);
          result = Alloc<value::Str>(qsn::maybe_shell_encode(str_val->s));
          quoted2 = true;
        }
          break;
        case value_e::MaybeStrArray: {
          value__MaybeStrArray* array_val = static_cast<value__MaybeStrArray*>(UP_val);
          tmp = Alloc<List<Str*>>();
          for (ListIter<Str*> it(array_val->strs); !it.Done(); it.Next()) {
            Str* s = it.Value();
            tmp->append(qsn::maybe_shell_encode(s));
          }
          result = Alloc<value::Str>(str1130->join(tmp));
        }
          break;
        default: {
          e_die(fmt320(ui::ValType(val)));
        }
      }
    }
    else {
      if (op_id == Id::VOp0_a) {
        chars = Alloc<List<Str*>>();
        switch (val->tag_()) {
          case value_e::MaybeStrArray: {
            chars->append(str1132);
          }
            break;
          case value_e::AssocArray: {
            chars->append(str1133);
          }
            break;
        }
        if (var_name != nullptr) {
          cell = this->mem->GetCell(var_name);
          if (cell) {
            if (cell->readonly) {
              chars->append(str1134);
            }
            if (cell->exported) {
              chars->append(str1135);
            }
            if (cell->nameref) {
              chars->append(str1136);
            }
          }
        }
        result = Alloc<value::Str>(str1137->join(chars));
      }
      else {
        e_die(fmt321(op->val), op);
      }
    }
  }
  return (Tuple2<runtime_asdl::value__Str*, bool>(result, quoted2));
}

runtime_asdl::value_t* AbstractWordEvaluator::_WholeArray(runtime_asdl::value_t* val, syntax_asdl::braced_var_sub* part, bool quoted, runtime_asdl::VarSubState* vsub_state) {
  int op_id;
  runtime_asdl::value_t* UP_val = nullptr;
  StackRoots _roots({&val, &part, &vsub_state, &UP_val});

  bracket_op__WholeArray* bracket_op = static_cast<bracket_op__WholeArray*>(part->bracket_op);
  op_id = bracket_op->op_id;
  if (op_id == Id::Lit_At) {
    vsub_state->join_array = !quoted;
    UP_val = val;
    switch (val->tag_()) {
      case value_e::Undef: {
        val = this->_EmptyMaybeStrArrayOrError(part->token);
      }
        break;
      case value_e::Str: {
        value__Str* val = static_cast<value__Str*>(UP_val);
        e_die(fmt322(), part);
      }
        break;
      case value_e::MaybeStrArray: {
        value__MaybeStrArray* val = static_cast<value__MaybeStrArray*>(UP_val);
        val = Alloc<value::MaybeStrArray>(val->strs);
      }
        break;
    }
  }
  else {
    if (op_id == Id::Arith_Star) {
      vsub_state->join_array = true;
      UP_val = val;
      switch (val->tag_()) {
        case value_e::Undef: {
          val = this->_EmptyMaybeStrArrayOrError(part->token);
        }
          break;
        case value_e::Str: {
          value__Str* val = static_cast<value__Str*>(UP_val);
          e_die(fmt323(), part);
        }
          break;
        case value_e::MaybeStrArray: {
          value__MaybeStrArray* val = static_cast<value__MaybeStrArray*>(UP_val);
          val = Alloc<value::MaybeStrArray>(val->strs);
        }
          break;
      }
    }
    else {
      assert(0);  // AssertionError
    }
  }
  return val;
}

runtime_asdl::value_t* AbstractWordEvaluator::_ArrayIndex(runtime_asdl::value_t* val, syntax_asdl::braced_var_sub* part, runtime_asdl::VTestPlace* vtest_place) {
  syntax_asdl::arith_expr_t* anode = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  int index;
  Str* s = nullptr;
  Str* key = nullptr;
  StackRoots _roots({&val, &part, &vtest_place, &anode, &UP_val, &s, &key});

  bracket_op__ArrayIndex* bracket_op = static_cast<bracket_op__ArrayIndex*>(part->bracket_op);
  anode = bracket_op->expr;
  UP_val = val;
  switch (val->tag_()) {
    case value_e::Undef: {
      ;  // pass
    }
      break;
    case value_e::Str: {
      e_die(fmt324(part->token->val), part->token);
    }
      break;
    case value_e::MaybeStrArray: {
      value__MaybeStrArray* array_val = static_cast<value__MaybeStrArray*>(UP_val);
      index = this->arith_ev->EvalToInt(anode);
      vtest_place->index = Alloc<a_index::Int>(index);
      s = GetArrayItem(array_val->strs, index);
      if (s == nullptr) {
        val = Alloc<value::Undef>();
      }
      else {
        val = Alloc<value::Str>(s);
      }
    }
      break;
    case value_e::AssocArray: {
      value__AssocArray* assoc_val = static_cast<value__AssocArray*>(UP_val);
      key = this->arith_ev->EvalWordToString(anode);
      vtest_place->index = Alloc<a_index::Str>(key);
      s = assoc_val->d->get(key);
      if (s == nullptr) {
        val = Alloc<value::Undef>();
      }
      else {
        val = Alloc<value::Str>(s);
      }
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return val;
}

void AbstractWordEvaluator::_EvalDoubleQuoted(List<syntax_asdl::word_part_t*>* parts, List<runtime_asdl::part_value_t*>* part_vals) {
  runtime_asdl::part_value__String* v = nullptr;
  StackRoots _roots({&parts, &part_vals, &v});

  if (len(parts) == 0) {
    v = Alloc<part_value::String>(str1142, true, false);
    part_vals->append(v);
    return ;
  }
  for (ListIter<syntax_asdl::word_part_t*> it(parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* p = it.Value();
    StackRoots _for({&p  });
    this->_EvalWordPart(p, part_vals, QUOTED);
  }
}

Str* AbstractWordEvaluator::EvalDoubleQuotedToString(syntax_asdl::double_quoted* dq_part) {
  List<runtime_asdl::part_value_t*>* part_vals = nullptr;
  StackRoots _roots({&dq_part, &part_vals});

  part_vals = Alloc<List<runtime_asdl::part_value_t*>>();
  this->_EvalDoubleQuoted(dq_part->parts, part_vals);
  return this->_ConcatPartVals(part_vals, dq_part->left->span_id);
}

runtime_asdl::value__Str* AbstractWordEvaluator::_DecayArray(runtime_asdl::value__MaybeStrArray* val) {
  Str* sep = nullptr;
  List<Str*>* tmp = nullptr;
  StackRoots _roots({&val, &sep, &tmp});

  sep = this->splitter->GetJoinChar();
  tmp = Alloc<List<Str*>>();
  for (ListIter<Str*> it(val->strs); !it.Done(); it.Next()) {
    Str* s = it.Value();
    if (s != nullptr) {
      tmp->append(s);
    }
  }
  return Alloc<value::Str>(sep->join(tmp));
}

runtime_asdl::value_t* AbstractWordEvaluator::_EmptyStrOrError(runtime_asdl::value_t* val, syntax_asdl::Token* token) {
  Str* name = nullptr;
  StackRoots _roots({&val, &token, &name});

  if (val->tag_() != value_e::Undef) {
    return val;
  }
  if (!this->exec_opts->nounset()) {
    return Alloc<value::Str>(str1143);
  }
  name = token->val->startswith(str1144) ? token->val->slice(1) : token->val;
  e_die(fmt325(name), token);
}

runtime_asdl::value_t* AbstractWordEvaluator::_EmptyMaybeStrArrayOrError(syntax_asdl::Token* token) {
  StackRoots _roots({&token});

  if (this->exec_opts->nounset()) {
    e_die(fmt326(token->val), token);
  }
  else {
    return Alloc<value::MaybeStrArray>(Alloc<List<Str*>>());
  }
}

runtime_asdl::value_t* AbstractWordEvaluator::_EvalBracketOp(runtime_asdl::value_t* val, syntax_asdl::braced_var_sub* part, bool quoted, runtime_asdl::VarSubState* vsub_state, runtime_asdl::VTestPlace* vtest_place) {
  syntax_asdl::bracket_op_t* bracket_op = nullptr;
  syntax_asdl::bracket_op_t* UP_bracket_op = nullptr;
  Str* var_name = nullptr;
  StackRoots _roots({&val, &part, &vsub_state, &vtest_place, &bracket_op, &UP_bracket_op, &var_name});

  if (part->bracket_op) {
    bracket_op = part->bracket_op;
    UP_bracket_op = bracket_op;
    switch (bracket_op->tag_()) {
      case bracket_op_e::WholeArray: {
        val = this->_WholeArray(val, part, quoted, vsub_state);
      }
        break;
      case bracket_op_e::ArrayIndex: {
        bracket_op__ArrayIndex* bracket_op = static_cast<bracket_op__ArrayIndex*>(UP_bracket_op);
        val = this->_ArrayIndex(val, part, vtest_place);
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
  else {
    var_name = vtest_place->name;
    if ((var_name and ((val->tag_() == value_e::MaybeStrArray || val->tag_() == value_e::AssocArray) and !vsub_state->is_type_query))) {
      if (ShouldArrayDecay(var_name, this->exec_opts, !(part->prefix_op or part->suffix_op))) {
        val = DecayArray(val);
      }
      else {
        e_die(fmt327(var_name), part);
      }
    }
  }
  return val;
}

runtime_asdl::value_t* AbstractWordEvaluator::_VarRefValue(syntax_asdl::braced_var_sub* part, bool quoted, runtime_asdl::VarSubState* vsub_state, runtime_asdl::VTestPlace* vtest_place) {
  Str* var_name = nullptr;
  runtime_asdl::value_t* val = nullptr;
  int var_num;
  StackRoots _roots({&part, &vsub_state, &vtest_place, &var_name, &val});

  if (part->token->id == Id::VSub_Name) {
    var_name = part->token->val;
    vtest_place->name = var_name;
    val = this->mem->GetValue(var_name);
  }
  else {
    if (part->token->id == Id::VSub_Number) {
      var_num = to_int(part->token->val);
      val = this->_EvalVarNum(var_num);
    }
    else {
      val = this->_EvalSpecialVar(part->token->id, quoted, vsub_state);
    }
  }
  val = this->_EvalBracketOp(val, part, quoted, vsub_state, vtest_place);
  return val;
}

void AbstractWordEvaluator::_EvalBracedVarSub(syntax_asdl::braced_var_sub* part, List<runtime_asdl::part_value_t*>* part_vals, bool quoted) {
  Str* var_name = nullptr;
  runtime_asdl::VTestPlace* vtest_place = nullptr;
  runtime_asdl::VarSubState* vsub_state = nullptr;
  List<Str*>* names = nullptr;
  Str* sep = nullptr;
  runtime_asdl::value_t* val = nullptr;
  int var_num;
  syntax_asdl::suffix_op_t* suffix_op = nullptr;
  bool suffix_is_test;
  syntax_asdl::suffix_op_t* UP_op = nullptr;
  runtime_asdl::part_value_t* part_val = nullptr;
  syntax_asdl::Token* tok = nullptr;
  bool quoted2;
  syntax_asdl::suffix_op_t* op = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  StackRoots _roots({&part, &part_vals, &var_name, &vtest_place, &vsub_state, &names, &sep, &val, &suffix_op, &UP_op, &part_val, &tok, &op, &UP_val});

  var_name = nullptr;
  vtest_place = Alloc<VTestPlace>(var_name, nullptr);
  vsub_state = Alloc<VarSubState>();
  if (part->token->id == Id::VSub_Name) {
    if ((part->prefix_op != nullptr and (part->bracket_op == nullptr and (part->suffix_op != nullptr and part->suffix_op->tag_() == suffix_op_e::Nullary)))) {
      Token* suffix_op_ = static_cast<Token*>(part->suffix_op);
      if (consts::GetKind(suffix_op_->id) == Kind::VOp3) {
        names = this->mem->VarNamesStartingWith(part->token->val);
        names->sort();
        Token* suffix_op_ = static_cast<Token*>(part->suffix_op);
        if ((quoted and suffix_op_->id == Id::VOp3_At)) {
          part_vals->append(Alloc<part_value::Array>(names));
        }
        else {
          sep = this->splitter->GetJoinChar();
          part_vals->append(Alloc<part_value::String>(sep->join(names), quoted, true));
        }
        return ;
      }
    }
    var_name = part->token->val;
    vtest_place->name = var_name;
    val = this->mem->GetValue(var_name);
  }
  else {
    if (part->token->id == Id::VSub_Number) {
      var_num = to_int(part->token->val);
      val = this->_EvalVarNum(var_num);
    }
    else {
      val = this->_EvalSpecialVar(part->token->id, quoted, vsub_state);
    }
  }
  suffix_op = part->suffix_op;
  if ((suffix_op and (suffix_op->tag_() == suffix_op_e::Nullary and static_cast<Token*>(suffix_op)->id == Id::VOp0_a))) {
    vsub_state->is_type_query = true;
  }
  val = this->_EvalBracketOp(val, part, quoted, vsub_state, vtest_place);
  suffix_is_test = false;
  UP_op = suffix_op;
  if ((suffix_op != nullptr and suffix_op->tag_() == suffix_op_e::Unary)) {
    suffix_op__Unary* suffix_op = static_cast<suffix_op__Unary*>(UP_op);
    if (consts::GetKind(suffix_op->tok->id) == Kind::VTest) {
      suffix_is_test = true;
    }
  }
  if (part->prefix_op) {
    if (part->prefix_op->id == Id::VSub_Pound) {
      if (!suffix_is_test) {
        val = this->_EmptyStrOrError(val, part->token);
      }
      val = this->_Length(val, part->token);
      part_val = _ValueToPartValue(val, false);
      part_vals->append(part_val);
      return ;
    }
    else {
      if (part->prefix_op->id == Id::VSub_Bang) {
        if ((part->bracket_op and part->bracket_op->tag_() == bracket_op_e::WholeArray)) {
          if (suffix_is_test) {
            tok = static_cast<suffix_op__Unary*>(UP_op)->tok;
            e_die(fmt328(), tok);
          }
          val = this->_Keys(val, part->token);
        }
        else {
          vtest_place->name = nullptr;
          vtest_place->index = nullptr;
          val = this->_EvalVarRef(val, part->token, quoted, vsub_state, vtest_place);
          if (!suffix_is_test) {
            val = this->_EmptyStrOrError(val, part->token);
          }
        }
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  else {
    if (!suffix_is_test) {
      val = this->_EmptyStrOrError(val, part->token);
    }
  }
  quoted2 = false;
  if (suffix_op) {
    op = suffix_op;
    switch (suffix_op->tag_()) {
      case suffix_op_e::Nullary: {
        Token* op = static_cast<Token*>(UP_op);
        Tuple2<runtime_asdl::value__Str*, bool> tup3 = this->_Nullary(val, op, var_name);
        val = tup3.at0();
        quoted2 = tup3.at1();
      }
        break;
      case suffix_op_e::Unary: {
        suffix_op__Unary* op = static_cast<suffix_op__Unary*>(UP_op);
        if (consts::GetKind(op->tok->id) == Kind::VTest) {
          if (this->_ApplyTestOp(val, op, quoted, part_vals, vtest_place, part->token)) {
            return ;
          }
        }
        else {
          val = this->_ApplyUnarySuffixOp(val, op);
        }
      }
        break;
      case suffix_op_e::PatSub: {
        suffix_op__PatSub* op = static_cast<suffix_op__PatSub*>(UP_op);
        val = this->_PatSub(val, op);
      }
        break;
      case suffix_op_e::Slice: {
        suffix_op__Slice* op = static_cast<suffix_op__Slice*>(UP_op);
        val = this->_Slice(val, op, var_name, part);
      }
        break;
      case suffix_op_e::Static: {
        suffix_op__Static* op = static_cast<suffix_op__Static*>(UP_op);
        e_die(fmt329(), op->tok);
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
  UP_val = val;
  if (val->tag_() == value_e::MaybeStrArray) {
    value__MaybeStrArray* array_val = static_cast<value__MaybeStrArray*>(UP_val);
    if (vsub_state->join_array) {
      val = this->_DecayArray(array_val);
    }
    else {
      val = array_val;
    }
  }
  part_val = _ValueToPartValue(val, (quoted or quoted2));
  part_vals->append(part_val);
}

Str* AbstractWordEvaluator::_ConcatPartVals(List<runtime_asdl::part_value_t*>* part_vals, int span_id) {
  List<Str*>* strs = nullptr;
  runtime_asdl::part_value_t* UP_part_val = nullptr;
  Str* s = nullptr;
  List<Str*>* tmp = nullptr;
  StackRoots _roots({&part_vals, &strs, &UP_part_val, &s, &tmp});

  strs = Alloc<List<Str*>>();
  for (ListIter<runtime_asdl::part_value_t*> it(part_vals); !it.Done(); it.Next()) {
    runtime_asdl::part_value_t* part_val = it.Value();
    StackRoots _for({&part_val  });
    UP_part_val = part_val;
    switch (part_val->tag_()) {
      case part_value_e::String: {
        part_value__String* part_val = static_cast<part_value__String*>(UP_part_val);
        s = part_val->s;
      }
        break;
      case part_value_e::Array: {
        part_value__Array* part_val = static_cast<part_value__Array*>(UP_part_val);
        if (this->exec_opts->strict_array()) {
          e_die(fmt330(), span_id);
        }
        else {
          tmp = Alloc<List<Str*>>();
          for (ListIter<Str*> it(part_val->strs); !it.Done(); it.Next()) {
            Str* s = it.Value();
            if (s != nullptr) {
              tmp->append(s);
            }
          }
          s = str1151->join(tmp);
        }
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
    strs->append(s);
  }
  return str1152->join(strs);
}

Str* AbstractWordEvaluator::EvalBracedVarSubToString(syntax_asdl::braced_var_sub* part) {
  List<runtime_asdl::part_value_t*>* part_vals = nullptr;
  StackRoots _roots({&part, &part_vals});

  part_vals = Alloc<List<runtime_asdl::part_value_t*>>();
  this->_EvalBracedVarSub(part, part_vals, false);
  return this->_ConcatPartVals(part_vals, part->spids->index_(0));
}

void AbstractWordEvaluator::_EvalSimpleVarSub(syntax_asdl::Token* token, List<runtime_asdl::part_value_t*>* part_vals, bool quoted) {
  runtime_asdl::VarSubState* vsub_state = nullptr;
  Str* var_name = nullptr;
  runtime_asdl::value_t* val = nullptr;
  int var_num;
  runtime_asdl::value_t* UP_val = nullptr;
  runtime_asdl::part_value_t* v = nullptr;
  StackRoots _roots({&token, &part_vals, &vsub_state, &var_name, &val, &UP_val, &v});

  vsub_state = Alloc<VarSubState>();
  if (token->id == Id::VSub_DollarName) {
    var_name = token->val->slice(1);
    val = this->mem->GetValue(var_name);
    if ((val->tag_() == value_e::MaybeStrArray || val->tag_() == value_e::AssocArray)) {
      if (ShouldArrayDecay(var_name, this->exec_opts)) {
        val = DecayArray(val);
      }
      else {
        e_die(fmt331(var_name), token);
      }
    }
  }
  else {
    if (token->id == Id::VSub_Number) {
      var_num = to_int(token->val->slice(1));
      val = this->_EvalVarNum(var_num);
    }
    else {
      val = this->_EvalSpecialVar(token->id, quoted, vsub_state);
    }
  }
  val = this->_EmptyStrOrError(val, token);
  UP_val = val;
  if (val->tag_() == value_e::MaybeStrArray) {
    value__MaybeStrArray* array_val = static_cast<value__MaybeStrArray*>(UP_val);
    if (vsub_state->join_array) {
      val = this->_DecayArray(array_val);
    }
    else {
      val = array_val;
    }
  }
  v = _ValueToPartValue(val, quoted);
  part_vals->append(v);
}

Str* AbstractWordEvaluator::EvalSimpleVarSubToString(syntax_asdl::Token* tok) {
  List<runtime_asdl::part_value_t*>* part_vals = nullptr;
  StackRoots _roots({&tok, &part_vals});

  part_vals = Alloc<List<runtime_asdl::part_value_t*>>();
  this->_EvalSimpleVarSub(tok, part_vals, false);
  return this->_ConcatPartVals(part_vals, tok->span_id);
}

void AbstractWordEvaluator::_EvalExtGlob(syntax_asdl::word_part__ExtGlob* part, List<runtime_asdl::part_value_t*>* part_vals) {
  syntax_asdl::Token* op = nullptr;
  Str* op_str = nullptr;
  int i;
  StackRoots _roots({&part, &part_vals, &op, &op_str});

  op = part->op;
  if (op->id == Id::ExtGlob_Comma) {
    op_str = str1154;
  }
  else {
    op_str = op->val;
  }
  part_vals->append(Alloc<part_value::String>(op_str, false, false));
  i = 0;
  for (ListIter<syntax_asdl::compound_word*> it(part->arms); !it.Done(); it.Next(), ++i) {
    syntax_asdl::compound_word* w = it.Value();
    StackRoots _for({&w  });
    if (i != 0) {
      part_vals->append(Alloc<part_value::String>(str1155, false, false));
    }
    this->_EvalWordToParts(w, part_vals, EXTGLOB_NESTED);
  }
  part_vals->append(Alloc<part_value::String>(str1156, false, false));
}

void AbstractWordEvaluator::_TranslateExtGlob(List<runtime_asdl::part_value_t*>* part_vals, syntax_asdl::compound_word* w, List<Str*>* glob_parts, List<Str*>* fnmatch_parts) {
  int i;
  runtime_asdl::part_value_t* UP_part_val = nullptr;
  Str* s = nullptr;
  StackRoots _roots({&part_vals, &w, &glob_parts, &fnmatch_parts, &UP_part_val, &s});

  i = 0;
  for (ListIter<runtime_asdl::part_value_t*> it(part_vals); !it.Done(); it.Next(), ++i) {
    runtime_asdl::part_value_t* part_val = it.Value();
    StackRoots _for({&part_val  });
    UP_part_val = part_val;
    switch (part_val->tag_()) {
      case part_value_e::String: {
        part_value__String* part_val = static_cast<part_value__String*>(UP_part_val);
        if ((part_val->quoted and !this->exec_opts->noglob())) {
          s = glob_::GlobEscape(part_val->s);
        }
        else {
          s = part_val->s;
        }
        glob_parts->append(s);
        fnmatch_parts->append(s);
      }
        break;
      case part_value_e::Array: {
        e_die(fmt332(), w);
      }
        break;
      case part_value_e::ExtGlob: {
        part_value__ExtGlob* part_val = static_cast<part_value__ExtGlob*>(UP_part_val);
        this->_TranslateExtGlob(part_val->part_vals, w, Alloc<List<Str*>>(), fnmatch_parts);
        glob_parts->append(str1158);
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
}

void AbstractWordEvaluator::_EvalWordPart(syntax_asdl::word_part_t* part, List<runtime_asdl::part_value_t*>* part_vals, int flags) {
  bool quoted;
  bool is_subst;
  syntax_asdl::word_part_t* UP_part = nullptr;
  runtime_asdl::part_value__String* v = nullptr;
  Str* tval = nullptr;
  Str* s = nullptr;
  int id_;
  runtime_asdl::part_value_t* sv = nullptr;
  int num;
  runtime_asdl::part_value__ExtGlob* v2 = nullptr;
  Str* var_name = nullptr;
  runtime_asdl::value_t* val = nullptr;
  runtime_asdl::value_t* UP_val = nullptr;
  List<Str*>* items = nullptr;
  StackRoots _roots({&part, &part_vals, &UP_part, &v, &tval, &s, &sv, &v2, &var_name, &val, &UP_val, &items});

  quoted = to_bool((flags & QUOTED));
  is_subst = to_bool((flags & IS_SUBST));
  UP_part = part;
  switch (part->tag_()) {
    case word_part_e::ShArrayLiteral: {
      sh_array_literal* part = static_cast<sh_array_literal*>(UP_part);
      e_die(fmt333(), part);
    }
      break;
    case word_part_e::AssocArrayLiteral: {
      word_part__AssocArrayLiteral* part = static_cast<word_part__AssocArrayLiteral*>(UP_part);
      e_die(fmt334(), part);
    }
      break;
    case word_part_e::Literal: {
      Token* part = static_cast<Token*>(UP_part);
      v = Alloc<part_value::String>(part->val, quoted, is_subst);
      part_vals->append(v);
    }
      break;
    case word_part_e::EscapedLiteral: {
      word_part__EscapedLiteral* part = static_cast<word_part__EscapedLiteral*>(UP_part);
      tval = part->token->val;
      s = tval->index_(1);
      v = Alloc<part_value::String>(s, true, false);
      part_vals->append(v);
    }
      break;
    case word_part_e::SingleQuoted: {
      single_quoted* part = static_cast<single_quoted*>(UP_part);
      s = word_compile::EvalSingleQuoted(part);
      v = Alloc<part_value::String>(s, true, false);
      part_vals->append(v);
    }
      break;
    case word_part_e::DoubleQuoted: {
      double_quoted* part = static_cast<double_quoted*>(UP_part);
      this->_EvalDoubleQuoted(part->parts, part_vals);
    }
      break;
    case word_part_e::CommandSub: {
      command_sub* part = static_cast<command_sub*>(UP_part);
      id_ = part->left_token->id;
      if ((id_ == Id::Left_DollarParen || id_ == Id::Left_AtParen || id_ == Id::Left_Backtick)) {
        sv = this->_EvalCommandSub(part, quoted);
      }
      else {
        if ((id_ == Id::Left_ProcSubIn || id_ == Id::Left_ProcSubOut)) {
          sv = this->_EvalProcessSub(part);
        }
        else {
          assert(0);  // AssertionError
        }
      }
      part_vals->append(sv);
    }
      break;
    case word_part_e::SimpleVarSub: {
      simple_var_sub* part = static_cast<simple_var_sub*>(UP_part);
      this->_EvalSimpleVarSub(part->token, part_vals, quoted);
    }
      break;
    case word_part_e::BracedVarSub: {
      braced_var_sub* part = static_cast<braced_var_sub*>(UP_part);
      this->_EvalBracedVarSub(part, part_vals, quoted);
    }
      break;
    case word_part_e::TildeSub: {
      word_part__TildeSub* part = static_cast<word_part__TildeSub*>(UP_part);
      s = this->tilde_ev->Eval(part->token);
      v = Alloc<part_value::String>(s, true, false);
      part_vals->append(v);
    }
      break;
    case word_part_e::ArithSub: {
      word_part__ArithSub* part = static_cast<word_part__ArithSub*>(UP_part);
      num = this->arith_ev->EvalToInt(part->anode);
      v = Alloc<part_value::String>(str(num), quoted, !quoted);
      part_vals->append(v);
    }
      break;
    case word_part_e::ExtGlob: {
      word_part__ExtGlob* part = static_cast<word_part__ExtGlob*>(UP_part);
      v2 = Alloc<part_value::ExtGlob>();
      this->_EvalExtGlob(part, v2->part_vals);
      part_vals->append(v2);
    }
      break;
    case word_part_e::Splice: {
      word_part__Splice* part = static_cast<word_part__Splice*>(UP_part);
      var_name = part->name->val->slice(1);
      val = this->mem->GetValue(var_name);
      UP_val = val;
      switch (val->tag_()) {
        case value_e::MaybeStrArray: {
          value__MaybeStrArray* val = static_cast<value__MaybeStrArray*>(UP_val);
          items = val->strs;
        }
          break;
        case value_e::AssocArray: {
          value__AssocArray* val = static_cast<value__AssocArray*>(UP_val);
          items = val->d->keys();
        }
          break;
        case value_e::Obj: {
          // if not PYTHON
          {
            assert(0);  // AssertionError
          }
          // endif MYCPP
        }
          break;
        default: {
          e_die(fmt335(var_name), part);
        }
      }
      part_vals->append(Alloc<part_value::Array>(items));
    }
      break;
    case word_part_e::FuncCall: {
      word_part__FuncCall* part = static_cast<word_part__FuncCall*>(UP_part);
    }
      break;
    case word_part_e::ExprSub: {
      word_part__ExprSub* part = static_cast<word_part__ExprSub*>(UP_part);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

void AbstractWordEvaluator::_EvalWordToParts(syntax_asdl::word_t* w, List<runtime_asdl::part_value_t*>* part_vals, int eval_flags) {
  bool quoted;
  bool is_subst;
  syntax_asdl::word_t* UP_w = nullptr;
  List<runtime_asdl::part_value_t*>* word_part_vals = nullptr;
  bool has_extglob;
  List<Str*>* glob_parts = nullptr;
  List<Str*>* fnmatch_parts = nullptr;
  Str* glob_pat = nullptr;
  Str* fnmatch_pat = nullptr;
  List<Str*>* results = nullptr;
  int n;
  int span_id;
  StackRoots _roots({&w, &part_vals, &UP_w, &word_part_vals, &glob_parts, &fnmatch_parts, &glob_pat, &fnmatch_pat, &results});

  quoted = to_bool((eval_flags & QUOTED));
  is_subst = to_bool((eval_flags & IS_SUBST));
  UP_w = w;
  switch (w->tag_()) {
    case word_e::Compound: {
      compound_word* w = static_cast<compound_word*>(UP_w);
      word_part_vals = Alloc<List<runtime_asdl::part_value_t*>>();
      has_extglob = false;
      for (ListIter<syntax_asdl::word_part_t*> it(w->parts); !it.Done(); it.Next()) {
        syntax_asdl::word_part_t* p = it.Value();
        StackRoots _for({&p      });
        if (p->tag_() == word_part_e::ExtGlob) {
          has_extglob = true;
        }
        this->_EvalWordPart(p, word_part_vals, eval_flags);
      }
      if (has_extglob) {
        if (to_bool((eval_flags & EXTGLOB_FILES))) {
          glob_parts = Alloc<List<Str*>>();
          fnmatch_parts = Alloc<List<Str*>>();
          this->_TranslateExtGlob(word_part_vals, w, glob_parts, fnmatch_parts);
          glob_pat = str1162->join(glob_parts);
          fnmatch_pat = str1163->join(fnmatch_parts);
          results = Alloc<List<Str*>>();
          n = this->globber->ExpandExtended(glob_pat, fnmatch_pat, results);
          if (n < 0) {
            span_id = word_::LeftMostSpanForWord(w);
            throw Alloc<error::FailGlob>(fmt336(fnmatch_pat), span_id);
          }
          part_vals->append(Alloc<part_value::Array>(results));
        }
        else {
          if (to_bool((eval_flags & EXTGLOB_NESTED))) {
            part_vals->extend(word_part_vals);
          }
          else {
            e_die(fmt337(), w);
          }
        }
      }
      else {
        part_vals->extend(word_part_vals);
      }
    }
      break;
    case word_e::Empty: {
      part_vals->append(Alloc<part_value::String>(str1166, quoted, !quoted));
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

void AbstractWordEvaluator::_PartValsToString(List<runtime_asdl::part_value_t*>* part_vals, syntax_asdl::compound_word* w, int eval_flags, List<Str*>* strs) {
  runtime_asdl::part_value_t* UP_part_val = nullptr;
  Str* s = nullptr;
  List<Str*>* tmp = nullptr;
  StackRoots _roots({&part_vals, &w, &strs, &UP_part_val, &s, &tmp});

  for (ListIter<runtime_asdl::part_value_t*> it(part_vals); !it.Done(); it.Next()) {
    runtime_asdl::part_value_t* part_val = it.Value();
    StackRoots _for({&part_val  });
    UP_part_val = part_val;
    switch (part_val->tag_()) {
      case part_value_e::String: {
        part_value__String* part_val = static_cast<part_value__String*>(UP_part_val);
        s = part_val->s;
        if (part_val->quoted) {
          if ((eval_flags & QUOTE_FNMATCH)) {
            s = glob_::GlobEscape(s);
          }
          else {
            if ((eval_flags & QUOTE_ERE)) {
              s = glob_::ExtendedRegexEscape(s);
            }
          }
        }
        strs->append(s);
      }
        break;
      case part_value_e::Array: {
        part_value__Array* part_val = static_cast<part_value__Array*>(UP_part_val);
        if (this->exec_opts->strict_array()) {
          e_die(fmt338(), w);
        }
        else {
          tmp = Alloc<List<Str*>>();
          for (ListIter<Str*> it(part_val->strs); !it.Done(); it.Next()) {
            Str* s = it.Value();
            if (s != nullptr) {
              tmp->append(s);
            }
          }
          s = str1168->join(tmp);
          strs->append(s);
        }
      }
        break;
      case part_value_e::ExtGlob: {
        part_value__ExtGlob* part_val = static_cast<part_value__ExtGlob*>(UP_part_val);
        if (!to_bool((eval_flags & QUOTE_FNMATCH))) {
          e_die(fmt339(), w);
        }
        this->_PartValsToString(part_val->part_vals, w, eval_flags, strs);
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
}

runtime_asdl::value__Str* AbstractWordEvaluator::EvalWordToString(syntax_asdl::word_t* UP_w) {
  return EvalWordToString(UP_w, 0);
}

runtime_asdl::value__Str* AbstractWordEvaluator::EvalWordToString(syntax_asdl::word_t* UP_w, int eval_flags) {
  List<runtime_asdl::part_value_t*>* part_vals = nullptr;
  List<Str*>* strs = nullptr;
  StackRoots _roots({&UP_w, &part_vals, &strs});

  if (UP_w->tag_() == word_e::Empty) {
    return Alloc<value::Str>(str1170);
  }
  compound_word* w = static_cast<compound_word*>(UP_w);
  part_vals = Alloc<List<runtime_asdl::part_value_t*>>();
  for (ListIter<syntax_asdl::word_part_t*> it(w->parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* p = it.Value();
    StackRoots _for({&p  });
    this->_EvalWordPart(p, part_vals, 0);
  }
  strs = Alloc<List<Str*>>();
  this->_PartValsToString(part_vals, w, eval_flags, strs);
  return Alloc<value::Str>(str1171->join(strs));
}

Tuple2<runtime_asdl::value__Str*, bool> AbstractWordEvaluator::EvalWordToPattern(syntax_asdl::word_t* UP_w) {
  bool has_extglob;
  List<runtime_asdl::part_value_t*>* part_vals = nullptr;
  List<Str*>* strs = nullptr;
  StackRoots _roots({&UP_w, &part_vals, &strs});

  if (UP_w->tag_() == word_e::Empty) {
    return (Tuple2<runtime_asdl::value__Str*, bool>(Alloc<value::Str>(str1172), false));
  }
  compound_word* w = static_cast<compound_word*>(UP_w);
  has_extglob = false;
  part_vals = Alloc<List<runtime_asdl::part_value_t*>>();
  for (ListIter<syntax_asdl::word_part_t*> it(w->parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* p = it.Value();
    StackRoots _for({&p  });
    this->_EvalWordPart(p, part_vals, 0);
    if (p->tag_() == word_part_e::ExtGlob) {
      has_extglob = true;
    }
  }
  strs = Alloc<List<Str*>>();
  this->_PartValsToString(part_vals, w, QUOTE_FNMATCH, strs);
  return (Tuple2<runtime_asdl::value__Str*, bool>(Alloc<value::Str>(str1173->join(strs)), has_extglob));
}

runtime_asdl::value__Str* AbstractWordEvaluator::EvalForPlugin(syntax_asdl::compound_word* w) {
  runtime_asdl::value__Str* val = nullptr;
  StackRoots _roots({&w, &val});

  {  // with
    state::ctx_Registers ctx(this->mem);

    try {
      val = this->EvalWordToString(w);
    }
    catch (error::FatalRuntime* e) {
      val = Alloc<value::Str>(fmt340(e->UserErrorString()));
    }
    catch (IOError_OSError* e) {
      val = Alloc<value::Str>(fmt341(pyutil::strerror(e)));
    }
    catch (KeyboardInterrupt*) {
      val = Alloc<value::Str>(str1176);
    }
  }
  return val;
}

runtime_asdl::value_t* AbstractWordEvaluator::EvalRhsWord(syntax_asdl::word_t* UP_w) {
  syntax_asdl::word_part_t* part0 = nullptr;
  syntax_asdl::word_part_t* UP_part0 = nullptr;
  int tag;
  List<syntax_asdl::word_t*>* array_words = nullptr;
  List<syntax_asdl::compound_word*>* words = nullptr;
  List<Str*>* strs = nullptr;
  int n;
  int i;
  runtime_asdl::value__Str* k = nullptr;
  runtime_asdl::value__Str* v = nullptr;
  StackRoots _roots({&UP_w, &part0, &UP_part0, &array_words, &words, &strs, &k, &v});

  if (UP_w->tag_() == word_e::Empty) {
    return Alloc<value::Str>(str1177);
  }
  compound_word* w = static_cast<compound_word*>(UP_w);
  if (len(w->parts) == 1) {
    part0 = w->parts->index_(0);
    UP_part0 = part0;
    tag = part0->tag_();
    if (tag == word_part_e::ShArrayLiteral) {
      sh_array_literal* part0 = static_cast<sh_array_literal*>(UP_part0);
      array_words = part0->words;
      words = braces::BraceExpandWords(array_words);
      strs = this->EvalWordSequence(words);
      return Alloc<value::MaybeStrArray>(strs);
    }
    if (tag == word_part_e::AssocArrayLiteral) {
      word_part__AssocArrayLiteral* part0 = static_cast<word_part__AssocArrayLiteral*>(UP_part0);
      auto* d = NewDict<Str*, Str*>();
      n = len(part0->pairs);
      i = 0;
      while (i < n) {
        k = this->EvalWordToString(part0->pairs->index_(i));
        v = this->EvalWordToString(part0->pairs->index_((i + 1)));
        d->set(k->s, v->s);
        i += 2;
      }
      return Alloc<value::AssocArray>(d);
    }
  }
  return this->EvalWordToString(w);
}

void AbstractWordEvaluator::_EvalWordFrame(List<Tuple3<Str*, bool, bool>*>* frame, List<Str*>* argv) {
  bool all_empty;
  bool all_quoted;
  bool any_quoted;
  Str* s = nullptr;
  bool quoted;
  List<Str*>* tmp = nullptr;
  Str* a = nullptr;
  bool will_glob;
  List<Str*>* frags = nullptr;
  Str* frag = nullptr;
  bool do_split;
  Str* flat = nullptr;
  List<Str*>* args = nullptr;
  int n;
  StackRoots _roots({&frame, &argv, &s, &tmp, &a, &frags, &frag, &flat, &args});

  all_empty = true;
  all_quoted = true;
  any_quoted = false;
  for (ListIter<Tuple3<Str*, bool, bool>*> it(frame); !it.Done(); it.Next()) {
    Tuple3<Str*, bool, bool>* tup4 = it.Value();
    s = tup4->at0();
    quoted = tup4->at1();
    if (len(s)) {
      all_empty = false;
    }
    if (quoted) {
      any_quoted = true;
    }
    else {
      all_quoted = false;
    }
  }
  if ((all_empty and !any_quoted)) {
    return ;
  }
  if (all_quoted) {
    tmp = Alloc<List<Str*>>();
    for (ListIter<Tuple3<Str*, bool, bool>*> it(frame); !it.Done(); it.Next()) {
      Tuple3<Str*, bool, bool>* tup5 = it.Value();
      s = tup5->at0();
      tmp->append(s);
    }
    a = str1178->join(tmp);
    argv->append(a);
    return ;
  }
  will_glob = !this->exec_opts->noglob();
  frags = Alloc<List<Str*>>();
  for (ListIter<Tuple3<Str*, bool, bool>*> it(frame); !it.Done(); it.Next()) {
    Tuple3<Str*, bool, bool>* tup6 = it.Value();
    frag = tup6->at0();
    quoted = tup6->at1();
    do_split = tup6->at2();
    if ((will_glob and quoted)) {
      frag = glob_::GlobEscape(frag);
    }
    else {
      frag = _BackslashEscape(frag);
    }
    if (do_split) {
      frag = _BackslashEscape(frag);
    }
    else {
      frag = this->splitter->Escape(frag);
    }
    frags->append(frag);
  }
  flat = str1179->join(frags);
  args = this->splitter->SplitForWordEval(flat);
  if ((!args and any_quoted)) {
    argv->append(str1180);
    return ;
  }
  for (ListIter<Str*> it(args); !it.Done(); it.Next()) {
    Str* a = it.Value();
    StackRoots _for({&a  });
    if (glob_::LooksLikeGlob(a)) {
      n = this->globber->Expand(a, argv);
      if (n < 0) {
        throw Alloc<error::FailGlob>(fmt342(a), runtime::NO_SPID);
      }
    }
    else {
      argv->append(glob_::GlobUnescape(a));
    }
  }
}

List<Str*>* AbstractWordEvaluator::_EvalWordToArgv(syntax_asdl::compound_word* w) {
  List<runtime_asdl::part_value_t*>* part_vals = nullptr;
  List<List<Tuple3<Str*, bool, bool>*>*>* frames = nullptr;
  List<Str*>* argv = nullptr;
  List<Str*>* tmp = nullptr;
  Str* s = nullptr;
  StackRoots _roots({&w, &part_vals, &frames, &argv, &tmp, &s});

  part_vals = Alloc<List<runtime_asdl::part_value_t*>>();
  this->_EvalWordToParts(w, part_vals, 0);
  frames = _MakeWordFrames(part_vals);
  argv = Alloc<List<Str*>>();
  for (ListIter<List<Tuple3<Str*, bool, bool>*>*> it(frames); !it.Done(); it.Next()) {
    List<Tuple3<Str*, bool, bool>*>* frame = it.Value();
    StackRoots _for({&frame  });
    if (len(frame)) {
      tmp = Alloc<List<Str*>>();
      for (ListIter<Tuple3<Str*, bool, bool>*> it(frame); !it.Done(); it.Next()) {
        Tuple3<Str*, bool, bool>* tup7 = it.Value();
        s = tup7->at0();
        tmp->append(s);
      }
      argv->append(str1182->join(tmp));
    }
  }
  return argv;
}

runtime_asdl::cmd_value__Assign* AbstractWordEvaluator::_EvalAssignBuiltin(int builtin_id, Str* arg0, List<syntax_asdl::compound_word*>* words) {
  bool eval_to_pairs;
  bool started_pairs;
  List<Str*>* flags = nullptr;
  List<int>* flag_spids = nullptr;
  List<runtime_asdl::assign_arg*>* assign_args = nullptr;
  int n;
  syntax_asdl::compound_word* w = nullptr;
  int word_spid;
  syntax_asdl::Token* left_token = nullptr;
  syntax_asdl::Token* close_token = nullptr;
  int part_offset;
  Str* tok_val = nullptr;
  Str* var_name = nullptr;
  bool append;
  syntax_asdl::word_t* rhs_word = nullptr;
  syntax_asdl::compound_word* tmp = nullptr;
  runtime_asdl::value_t* right = nullptr;
  runtime_asdl::assign_arg* arg2 = nullptr;
  List<Str*>* argv = nullptr;
  StackRoots _roots({&arg0, &words, &flags, &flag_spids, &assign_args, &w, &left_token, &close_token, &tok_val, &var_name, &rhs_word, &tmp, &right, &arg2, &argv});

  eval_to_pairs = true;
  started_pairs = false;
  flags = NewList<Str*>(std::initializer_list<Str*>{arg0});
  flag_spids = NewList<int>(std::initializer_list<int>{word_::LeftMostSpanForWord(words->index_(0))});
  assign_args = Alloc<List<runtime_asdl::assign_arg*>>();
  n = len(words);
  for (int i = 1; i < n; ++i) {
    w = words->index_(i);
    word_spid = word_::LeftMostSpanForWord(w);
    if (word_::IsVarLike(w)) {
      started_pairs = true;
    }
    if (started_pairs) {
      Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int> tup8 = word_::DetectShAssignment(w);
      left_token = tup8.at0();
      close_token = tup8.at1();
      part_offset = tup8.at2();
      if (left_token) {
        if (left_token->id != Id::Lit_VarLike) {
          e_die(fmt343(), w);
        }
        tok_val = left_token->val;
        if (str_equals(tok_val->index_(-2), str1184)) {
          var_name = tok_val->slice(0, -2);
          append = true;
        }
        else {
          var_name = tok_val->slice(0, -1);
          append = false;
        }
        if (part_offset == len(w->parts)) {
          rhs_word = Alloc<word::Empty>();
        }
        else {
          tmp = Alloc<compound_word>(w->parts->slice(part_offset));
          word_::TildeDetectAssign(tmp);
          rhs_word = tmp;
        }
        {  // with
          state::ctx_AssignBuiltin ctx(this->mutable_opts);

          right = this->EvalRhsWord(rhs_word);
        }
        arg2 = Alloc<assign_arg>(var_name, right, append, word_spid);
        assign_args->append(arg2);
      }
      else {
        argv = this->_EvalWordToArgv(w);
        for (ListIter<Str*> it(argv); !it.Done(); it.Next()) {
          Str* arg = it.Value();
          StackRoots _for({&arg        });
          arg2 = _SplitAssignArg(arg, word_spid);
          assign_args->append(arg2);
        }
      }
    }
    else {
      argv = this->_EvalWordToArgv(w);
      for (ListIter<Str*> it(argv); !it.Done(); it.Next()) {
        Str* arg = it.Value();
        StackRoots _for({&arg      });
        if ((arg->startswith(str1185) or arg->startswith(str1186))) {
          flags->append(arg);
          flag_spids->append(word_spid);
          if ((str_contains(arg, str1187) or str_contains(arg, str1188))) {
            eval_to_pairs = false;
          }
        }
        else {
          if (eval_to_pairs) {
            arg2 = _SplitAssignArg(arg, word_spid);
            assign_args->append(arg2);
            started_pairs = true;
          }
          else {
            flags->append(arg);
          }
        }
      }
    }
  }
  return Alloc<cmd_value::Assign>(builtin_id, flags, flag_spids, assign_args);
}

runtime_asdl::cmd_value_t* AbstractWordEvaluator::SimpleEvalWordSequence2(List<syntax_asdl::compound_word*>* words, bool allow_assign) {
  List<Str*>* strs = nullptr;
  List<int>* spids = nullptr;
  int n;
  int i;
  int word_spid;
  List<Str*>* strs0 = nullptr;
  Str* arg0 = nullptr;
  int builtin_id;
  runtime_asdl::value__Str* val = nullptr;
  int num_appended;
  List<runtime_asdl::part_value_t*>* part_vals = nullptr;
  List<List<Tuple3<Str*, bool, bool>*>*>* frames = nullptr;
  List<Str*>* tmp = nullptr;
  Str* s = nullptr;
  StackRoots _roots({&words, &strs, &spids, &strs0, &arg0, &val, &part_vals, &frames, &tmp, &s});

  strs = Alloc<List<Str*>>();
  spids = Alloc<List<int>>();
  n = 0;
  i = 0;
  for (ListIter<syntax_asdl::compound_word*> it(words); !it.Done(); it.Next(), ++i) {
    syntax_asdl::compound_word* w = it.Value();
    StackRoots _for({&w  });
    word_spid = word_::LeftMostSpanForWord(w);
    if ((i == 0 and allow_assign)) {
      strs0 = this->_EvalWordToArgv(w);
      if (len(strs0) == 1) {
        arg0 = strs0->index_(0);
        builtin_id = consts::LookupAssignBuiltin(arg0);
        if (builtin_id != consts::NO_INDEX) {
          return this->_EvalAssignBuiltin(builtin_id, arg0, words);
        }
      }
      strs->extend(strs0);
      for (ListIter<Str*> it(strs0); !it.Done(); it.Next()) {
        Str* _ = it.Value();
        StackRoots _for({&_      });
        spids->append(word_spid);
      }
      continue;
    }
    if (glob_::LooksLikeStaticGlob(w)) {
      val = this->EvalWordToString(w);
      num_appended = this->globber->Expand(val->s, strs);
      if (num_appended < 0) {
        throw Alloc<error::FailGlob>(fmt344(val->s), word_spid);
      }
      for (int _ = 0; _ < num_appended; ++_) {
        spids->append(word_spid);
      }
      continue;
    }
    part_vals = Alloc<List<runtime_asdl::part_value_t*>>();
    this->_EvalWordToParts(w, part_vals, 0);
    frames = _MakeWordFrames(part_vals);
    for (ListIter<List<Tuple3<Str*, bool, bool>*>*> it(frames); !it.Done(); it.Next()) {
      List<Tuple3<Str*, bool, bool>*>* frame = it.Value();
      StackRoots _for({&frame    });
      if (len(frame)) {
        tmp = Alloc<List<Str*>>();
        for (ListIter<Tuple3<Str*, bool, bool>*> it(frame); !it.Done(); it.Next()) {
          Tuple3<Str*, bool, bool>* tup9 = it.Value();
          s = tup9->at0();
          tmp->append(s);
        }
        strs->append(str1190->join(tmp));
        spids->append(word_spid);
      }
    }
  }
  return Alloc<cmd_value::Argv>(strs, spids, nullptr);
}

runtime_asdl::cmd_value_t* AbstractWordEvaluator::EvalWordSequence2(List<syntax_asdl::compound_word*>* words) {
  return EvalWordSequence2(words, false);
}

runtime_asdl::cmd_value_t* AbstractWordEvaluator::EvalWordSequence2(List<syntax_asdl::compound_word*>* words, bool allow_assign) {
  List<Str*>* strs = nullptr;
  List<int>* spids = nullptr;
  int n;
  int i;
  List<runtime_asdl::part_value_t*>* part_vals = nullptr;
  runtime_asdl::part_value_t* val0 = nullptr;
  runtime_asdl::part_value_t* UP_val0 = nullptr;
  int builtin_id;
  List<List<Tuple3<Str*, bool, bool>*>*>* frames = nullptr;
  int n_next;
  int spid;
  StackRoots _roots({&words, &strs, &spids, &part_vals, &val0, &UP_val0, &frames});

  if (this->exec_opts->simple_word_eval()) {
    return this->SimpleEvalWordSequence2(words, allow_assign);
  }
  strs = Alloc<List<Str*>>();
  spids = Alloc<List<int>>();
  n = 0;
  i = 0;
  for (ListIter<syntax_asdl::compound_word*> it(words); !it.Done(); it.Next(), ++i) {
    syntax_asdl::compound_word* w = it.Value();
    StackRoots _for({&w  });
    part_vals = Alloc<List<runtime_asdl::part_value_t*>>();
    this->_EvalWordToParts(w, part_vals, EXTGLOB_FILES);
    if ((allow_assign and (i == 0 and len(part_vals) == 1))) {
      val0 = part_vals->index_(0);
      UP_val0 = val0;
      if (val0->tag_() == part_value_e::String) {
        part_value__String* val0 = static_cast<part_value__String*>(UP_val0);
        if (!val0->quoted) {
          builtin_id = consts::LookupAssignBuiltin(val0->s);
          if (builtin_id != consts::NO_INDEX) {
            return this->_EvalAssignBuiltin(builtin_id, val0->s, words);
          }
        }
      }
    }
    frames = _MakeWordFrames(part_vals);
    for (ListIter<List<Tuple3<Str*, bool, bool>*>*> it(frames); !it.Done(); it.Next()) {
      List<Tuple3<Str*, bool, bool>*>* frame = it.Value();
      StackRoots _for({&frame    });
      this->_EvalWordFrame(frame, strs);
    }
    n_next = len(strs);
    spid = word_::LeftMostSpanForWord(w);
    for (int _ = 0; _ < (n_next - n); ++_) {
      spids->append(spid);
    }
    n = n_next;
  }
  return Alloc<cmd_value::Argv>(strs, spids, nullptr);
}

List<Str*>* AbstractWordEvaluator::EvalWordSequence(List<syntax_asdl::compound_word*>* words) {
  runtime_asdl::cmd_value_t* UP_cmd_val = nullptr;
  StackRoots _roots({&words, &UP_cmd_val});

  UP_cmd_val = this->EvalWordSequence2(words);
  cmd_value__Argv* cmd_val = static_cast<cmd_value__Argv*>(UP_cmd_val);
  return cmd_val->argv;
}

NormalWordEvaluator::NormalWordEvaluator(state::Mem* mem, optview::Exec* exec_opts, state::MutableOpts* mutable_opts, split::SplitContext* splitter, ui::ErrorFormatter* errfmt) : AbstractWordEvaluator(mem, exec_opts, mutable_opts, splitter, errfmt) {
  field_mask_ |= maskof_NormalWordEvaluator();
  this->shell_ex = nullptr;
}

void NormalWordEvaluator::CheckCircularDeps() {
}

runtime_asdl::part_value_t* NormalWordEvaluator::_EvalCommandSub(syntax_asdl::command_sub* cs_part, bool quoted) {
  Str* stdout = nullptr;
  List<Str*>* strs = nullptr;
  StackRoots _roots({&cs_part, &stdout, &strs});

  stdout = this->shell_ex->RunCommandSub(cs_part);
  if (cs_part->left_token->id == Id::Left_AtParen) {
    strs = this->splitter->SplitForWordEval(stdout);
    return Alloc<part_value::Array>(strs);
  }
  else {
    return Alloc<part_value::String>(stdout, quoted, !quoted);
  }
}

runtime_asdl::part_value__String* NormalWordEvaluator::_EvalProcessSub(syntax_asdl::command_sub* cs_part) {
  Str* dev_path = nullptr;
  StackRoots _roots({&cs_part, &dev_path});

  dev_path = this->shell_ex->RunProcessSub(cs_part);
  return Alloc<part_value::String>(dev_path, true, false);
}
Str* _DUMMY = str1191;

void CompletionWordEvaluator::CheckCircularDeps() {
}

runtime_asdl::part_value_t* CompletionWordEvaluator::_EvalCommandSub(syntax_asdl::command_sub* cs_part, bool quoted) {
  StackRoots _roots({&cs_part});

  if (cs_part->left_token->id == Id::Left_AtParen) {
    return Alloc<part_value::Array>(NewList<Str*>(std::initializer_list<Str*>{_DUMMY}));
  }
  else {
    return Alloc<part_value::String>(_DUMMY, quoted, !quoted);
  }
}

runtime_asdl::part_value__String* CompletionWordEvaluator::_EvalProcessSub(syntax_asdl::command_sub* cs_part) {
  StackRoots _roots({&cs_part});

  return Alloc<part_value::String>(str1192, true, false);
}

}  // define namespace word_eval

namespace word_parse {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using id_kind_asdl::Kind;
using types_asdl::lex_mode_t;
using types_asdl::lex_mode_e;
using syntax_asdl::Token;
using syntax_asdl::speck;
using syntax_asdl::double_quoted;
using syntax_asdl::single_quoted;
using syntax_asdl::simple_var_sub;
using syntax_asdl::braced_var_sub;
using syntax_asdl::command_sub;
using syntax_asdl::sh_array_literal;
using syntax_asdl::arith_expr_t;
namespace bracket_op = syntax_asdl::bracket_op;
using syntax_asdl::bracket_op_t;
namespace suffix_op = syntax_asdl::suffix_op;
using syntax_asdl::suffix_op_t;
using syntax_asdl::suffix_op__Slice;
using syntax_asdl::suffix_op__PatSub;
namespace word = syntax_asdl::word;
namespace word_e = syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::compound_word;
namespace word_part = syntax_asdl::word_part;
namespace word_part_e = syntax_asdl::word_part_e;
using syntax_asdl::word_part_t;
using syntax_asdl::word_part__ArithSub;
using syntax_asdl::word_part__ExtGlob;
using syntax_asdl::word_part__ExprSub;
namespace command = syntax_asdl::command;
using syntax_asdl::command__ForExpr;
using syntax_asdl::command__Proc;
using syntax_asdl::command__Import;
using syntax_asdl::command__PlaceMutation;
using syntax_asdl::command__VarDecl;
namespace place_expr_e = syntax_asdl::place_expr_e;
using syntax_asdl::place_expr__Var;
using syntax_asdl::expr_t;
namespace source = syntax_asdl::source;
using syntax_asdl::ArgList;
GLOBAL_LIST(id_kind_asdl::Kind_t, 4, KINDS_THAT_END_WORDS, {Kind::Eof COMMA Kind::WS COMMA Kind::Op COMMA Kind::Right});

WordEmitter::WordEmitter() 
    : Obj(Tag::FixedSize, kZeroMask, sizeof(WordEmitter))  {
  ;  // pass
}

syntax_asdl::word_t* WordEmitter::ReadWord(types_asdl::lex_mode_t lex_mode) {
  throw Alloc<NotImplementedError>();
}

WordParser::WordParser(parse_lib::ParseContext* parse_ctx, lexer::Lexer* lexer, reader::_Reader* line_reader)  {
  field_mask_ |= maskof_WordParser();
  this->parse_ctx = parse_ctx;
  this->arena = parse_ctx->arena;
  this->lexer = lexer;
  this->line_reader = line_reader;
  this->parse_opts = parse_ctx->parse_opts;
  this->a_parser = Alloc<tdop::TdopParser>(arith_parse::Spec(), this, this->parse_opts);
  this->Reset();
}

void WordParser::Init(types_asdl::lex_mode_t lex_mode) {
  this->next_lex_mode = lex_mode;
}

void WordParser::Reset() {
  this->cur_token = nullptr;
  this->token_kind = Kind::Undefined;
  this->token_type = Id::Undefined_Tok;
  this->next_lex_mode = lex_mode_e::ShCommand;
  this->emit_doc_token = false;
  this->multiline = false;
  this->newline_state = 0;
  this->returned_newline = false;
  this->buffered_word = nullptr;
}

void WordParser::_Peek() {
  if (this->next_lex_mode != lex_mode_e::Undefined) {
    this->cur_token = this->lexer->Read(this->next_lex_mode);
    this->token_type = this->cur_token->id;
    this->token_kind = consts::GetKind(this->token_type);
    if (this->token_type == Id::Op_Newline) {
      this->newline_state += 1;
    }
    else {
      if (this->token_kind != Kind::WS) {
        this->newline_state = 0;
      }
    }
    this->parse_ctx->trail->AppendToken(this->cur_token);
    this->next_lex_mode = lex_mode_e::Undefined;
  }
}

void WordParser::_Next(types_asdl::lex_mode_t lex_mode) {
  this->next_lex_mode = lex_mode;
}

syntax_asdl::word_t* WordParser::_ReadVarOpArg(types_asdl::lex_mode_t arg_lex_mode) {
  syntax_asdl::compound_word* w = nullptr;
  StackRoots _roots({&w});

  w = this->_ReadVarOpArg2(arg_lex_mode, Id::Undefined_Tok, true);
  if ((len(w->parts) == 0 and arg_lex_mode == lex_mode_e::VSub_ArgDQ)) {
    return Alloc<word::Empty>();
  }
  return w;
}

syntax_asdl::compound_word* WordParser::_ReadVarOpArg2(types_asdl::lex_mode_t arg_lex_mode, int eof_type) {
  return _ReadVarOpArg2(arg_lex_mode, eof_type, false);
}

syntax_asdl::compound_word* WordParser::_ReadVarOpArg2(types_asdl::lex_mode_t arg_lex_mode, int eof_type, bool empty_ok) {
  syntax_asdl::compound_word* w = nullptr;
  syntax_asdl::compound_word* tilde = nullptr;
  StackRoots _roots({&w, &tilde});

  this->_Next(arg_lex_mode);
  this->_Peek();
  w = this->_ReadCompoundWord3(arg_lex_mode, eof_type, empty_ok);
  tilde = word_::TildeDetect(w);
  if (tilde) {
    w = tilde;
  }
  return w;
}

syntax_asdl::suffix_op__Slice* WordParser::_ReadSliceVarOp() {
  int cur_id;
  syntax_asdl::arith_expr_t* begin = nullptr;
  syntax_asdl::arith_expr_t* no_length = nullptr;
  syntax_asdl::arith_expr_t* length = nullptr;
  StackRoots _roots({&begin, &no_length, &length});

  this->_Next(lex_mode_e::Arith);
  this->_Peek();
  cur_id = this->token_type;
  if (this->token_type == Id::Arith_Colon) {
    begin = nullptr;
  }
  else {
    begin = this->a_parser->Parse();
    cur_id = this->a_parser->CurrentId();
  }
  if (cur_id == Id::Arith_RBrace) {
    no_length = nullptr;
    return Alloc<suffix_op::Slice>(begin, no_length);
  }
  if (cur_id == Id::Arith_Colon) {
    this->_Next(lex_mode_e::Arith);
    length = this->_ReadArithExpr(Id::Arith_RBrace);
    return Alloc<suffix_op::Slice>(begin, length);
  }
  p_die(fmt345(), this->cur_token);
  assert(0);  // AssertionError
}

syntax_asdl::suffix_op__PatSub* WordParser::_ReadPatSubVarOp() {
  syntax_asdl::compound_word* pat = nullptr;
  int replace_mode;
  syntax_asdl::word_part_t* UP_first_part = nullptr;
  int lit_id;
  syntax_asdl::compound_word* tilde = nullptr;
  syntax_asdl::word_t* replace = nullptr;
  StackRoots _roots({&pat, &UP_first_part, &tilde, &replace});

  pat = this->_ReadVarOpArg2(lex_mode_e::VSub_ArgUnquoted, Id::Lit_Slash);
  if ((len(pat->parts) == 1 and word_::LiteralId(pat->parts->index_(0)) == Id::Lit_Slash)) {
    this->_Next(lex_mode_e::VSub_ArgUnquoted);
    this->_Peek();
    pat->parts->append(this->cur_token);
  }
  if (len(pat->parts) == 0) {
    p_die(fmt346(), this->cur_token);
  }
  replace_mode = Id::Undefined_Tok;
  UP_first_part = pat->parts->index_(0);
  if (UP_first_part->tag_() == word_part_e::Literal) {
    lit_id = static_cast<Token*>(UP_first_part)->id;
    if ((lit_id == Id::Lit_Slash || lit_id == Id::Lit_Pound || lit_id == Id::Lit_Percent)) {
      pat->parts->pop(0);
      replace_mode = lit_id;
    }
  }
  tilde = word_::TildeDetect(pat);
  if (tilde) {
    pat = tilde;
  }
  if (this->token_type == Id::Right_DollarBrace) {
    return Alloc<suffix_op::PatSub>(pat, nullptr, replace_mode);
  }
  if (this->token_type == Id::Lit_Slash) {
    replace = this->_ReadVarOpArg(lex_mode_e::VSub_ArgUnquoted);
    this->_Peek();
    if (this->token_type != Id::Right_DollarBrace) {
      p_die(fmt347(ui::PrettyId(this->token_type)), this->cur_token);
    }
    return Alloc<suffix_op::PatSub>(pat, replace, replace_mode);
  }
  p_die(fmt348(), this->cur_token);
}

syntax_asdl::bracket_op_t* WordParser::_ReadSubscript() {
  int next_id;
  syntax_asdl::bracket_op_t* op = nullptr;
  syntax_asdl::arith_expr_t* anode = nullptr;
  StackRoots _roots({&op, &anode});

  next_id = this->lexer->LookPastSpace(lex_mode_e::Arith);
  if ((next_id == Id::Lit_At || next_id == Id::Arith_Star)) {
    op = Alloc<bracket_op::WholeArray>(next_id);
    this->_Next(lex_mode_e::Arith);
    this->_Peek();
    this->_Next(lex_mode_e::Arith);
    this->_Peek();
  }
  else {
    this->_Next(lex_mode_e::Arith);
    anode = this->_ReadArithExpr(Id::Arith_RBracket);
    op = Alloc<bracket_op::ArrayIndex>(anode);
  }
  if (this->token_type != Id::Arith_RBracket) {
    p_die(fmt349(), this->cur_token);
  }
  this->_Next(lex_mode_e::VSub_2);
  this->_Peek();
  return op;
}

syntax_asdl::braced_var_sub* WordParser::_ParseVarOf() {
  syntax_asdl::Token* name_token = nullptr;
  syntax_asdl::bracket_op_t* bracket_op = nullptr;
  syntax_asdl::braced_var_sub* part = nullptr;
  StackRoots _roots({&name_token, &bracket_op, &part});

  this->_Peek();
  name_token = this->cur_token;
  this->_Next(lex_mode_e::VSub_2);
  this->_Peek();
  if (this->token_type == Id::VOp2_LBracket) {
    bracket_op = this->_ReadSubscript();
  }
  else {
    bracket_op = nullptr;
  }
  part = Alloc<braced_var_sub>();
  part->token = name_token;
  part->bracket_op = bracket_op;
  return part;
}

syntax_asdl::braced_var_sub* WordParser::_ParseVarExpr(types_asdl::lex_mode_t arg_lex_mode) {
  return _ParseVarExpr(arg_lex_mode, false);
}

syntax_asdl::braced_var_sub* WordParser::_ParseVarExpr(types_asdl::lex_mode_t arg_lex_mode, bool allow_query) {
  syntax_asdl::braced_var_sub* part = nullptr;
  id_kind_asdl::Kind_t op_kind;
  syntax_asdl::Token* tok = nullptr;
  syntax_asdl::word_t* arg_word = nullptr;
  bool ok;
  Str* arg = nullptr;
  bool quoted;
  int op_spid;
  syntax_asdl::suffix_op__PatSub* patsub_op = nullptr;
  suffix_op_t* temp = nullptr;
  StackRoots _roots({&part, &tok, &arg_word, &arg, &patsub_op, &temp});

  part = this->_ParseVarOf();
  this->_Peek();
  if (this->token_type == Id::Right_DollarBrace) {
    return part;
  }
  op_kind = this->token_kind;
  if (op_kind == Kind::VTest) {
    tok = this->cur_token;
    arg_word = this->_ReadVarOpArg(arg_lex_mode);
    if (this->token_type != Id::Right_DollarBrace) {
      p_die(fmt350(), this->cur_token);
    }
    part->suffix_op = Alloc<suffix_op::Unary>(tok, arg_word);
  }
  else {
    if (op_kind == Kind::VOpOil) {
      tok = this->cur_token;
      arg_word = this->_ReadVarOpArg(arg_lex_mode);
      if (this->token_type != Id::Right_DollarBrace) {
        p_die(fmt351(), this->cur_token);
      }
      Tuple3<bool, Str*, bool> tup0 = word_::StaticEval(arg_word);
      ok = tup0.at0();
      arg = tup0.at1();
      quoted = tup0.at2();
      if ((!ok or quoted)) {
        p_die(fmt352(), arg_word);
      }
      part->suffix_op = Alloc<suffix_op::Static>(tok, arg);
    }
    else {
      if (op_kind == Kind::VOp0) {
        part->suffix_op = this->cur_token;
        this->_Next(lex_mode_e::VSub_2);
        this->_Peek();
      }
      else {
        if (op_kind == Kind::VOp1) {
          tok = this->cur_token;
          arg_word = this->_ReadVarOpArg(lex_mode_e::VSub_ArgUnquoted);
          if (this->token_type != Id::Right_DollarBrace) {
            p_die(fmt353(), this->cur_token);
          }
          part->suffix_op = Alloc<suffix_op::Unary>(tok, arg_word);
        }
        else {
          if (op_kind == Kind::VOp2) {
            if (this->token_type == Id::VOp2_Slash) {
              op_spid = this->cur_token->span_id;
              patsub_op = this->_ReadPatSubVarOp();
              patsub_op->spids->append(op_spid);
              temp = static_cast<suffix_op_t*>(patsub_op);
              part->suffix_op = temp;
            }
            else {
              if (this->token_type == Id::VOp2_Colon) {
                part->suffix_op = this->_ReadSliceVarOp();
                if (this->token_type != Id::Arith_RBrace) {
                  p_die(fmt354(), this->cur_token);
                }
              }
              else {
                p_die(fmt355(str1204), this->cur_token);
              }
            }
          }
          else {
            if (op_kind == Kind::VOp3) {
              if (allow_query) {
                part->suffix_op = this->cur_token;
                this->_Next(lex_mode_e::VSub_2);
                this->_Peek();
              }
              else {
                p_die(fmt356(str1206), this->cur_token);
              }
            }
          }
        }
      }
    }
  }
  if ((this->token_type != Id::Right_DollarBrace && this->token_type != Id::Arith_RBrace)) {
    p_die(fmt357(), this->cur_token);
  }
  return part;
}

Tuple2<syntax_asdl::braced_var_sub*, syntax_asdl::Token*> WordParser::ReadBracedVarSub(syntax_asdl::Token* left_token) {
  syntax_asdl::braced_var_sub* part = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&left_token, &part, &last_token});

  part = this->_ReadBracedVarSub(left_token, false);
  last_token = this->cur_token;
  return (Tuple2<syntax_asdl::braced_var_sub*, syntax_asdl::Token*>(part, last_token));
}

syntax_asdl::braced_var_sub* WordParser::_ReadBracedVarSub(syntax_asdl::Token* left_token, bool d_quoted) {
  types_asdl::lex_mode_t arg_lex_mode;
  int ty;
  int next_id;
  syntax_asdl::braced_var_sub* part = nullptr;
  int right_spid;
  StackRoots _roots({&left_token, &part});

  if (d_quoted) {
    arg_lex_mode = lex_mode_e::VSub_ArgDQ;
  }
  else {
    arg_lex_mode = lex_mode_e::VSub_ArgUnquoted;
  }
  this->_Next(lex_mode_e::VSub_1);
  this->_Peek();
  ty = this->token_type;
  if (ty == Id::VSub_Pound) {
    next_id = this->lexer->LookPastSpace(lex_mode_e::VSub_1);
    if ((next_id != Id::Unknown_Tok && next_id != Id::Right_DollarBrace)) {
      this->_Next(lex_mode_e::VSub_1);
      part = this->_ParseVarOf();
      this->_Peek();
      if (this->token_type != Id::Right_DollarBrace) {
        p_die(fmt358(), this->cur_token);
      }
      part->prefix_op = Alloc<speck>(ty, this->cur_token->span_id);
    }
    else {
      part = this->_ParseVarExpr(arg_lex_mode);
    }
  }
  else {
    if (ty == Id::VSub_Bang) {
      next_id = this->lexer->LookPastSpace(lex_mode_e::VSub_1);
      if ((next_id != Id::Unknown_Tok && next_id != Id::Right_DollarBrace)) {
        this->_Next(lex_mode_e::VSub_1);
        part = this->_ParseVarExpr(arg_lex_mode, true);
        part->prefix_op = Alloc<speck>(ty, this->cur_token->span_id);
      }
      else {
        part = this->_ParseVarExpr(arg_lex_mode);
      }
    }
    else {
      if (ty == Id::VSub_Dot) {
        p_die(fmt359(), this->cur_token);
      }
      else {
        if (this->token_kind == Kind::VSub) {
          part = this->_ParseVarExpr(arg_lex_mode);
        }
        else {
          p_die(fmt360(), this->cur_token);
        }
      }
    }
  }
  part->spids->append(left_token->span_id);
  right_spid = this->cur_token->span_id;
  part->spids->append(right_spid);
  return part;
}

syntax_asdl::single_quoted* WordParser::_ReadSingleQuoted(syntax_asdl::Token* left_token, types_asdl::lex_mode_t lex_mode) {
  List<syntax_asdl::Token*>* tokens = nullptr;
  syntax_asdl::single_quoted* node = nullptr;
  StackRoots _roots({&left_token, &tokens, &node});

  tokens = Alloc<List<syntax_asdl::Token*>>();
  this->ReadSingleQuoted(lex_mode, left_token, tokens, false);
  node = Alloc<single_quoted>(left_token, tokens, false);
  node->spids->append(left_token->span_id);
  node->spids->append(this->cur_token->span_id);
  return node;
}

syntax_asdl::Token* WordParser::ReadSingleQuoted(types_asdl::lex_mode_t lex_mode, syntax_asdl::Token* left_token, List<syntax_asdl::Token*>* tokens, bool is_oil_expr) {
  bool no_backslashes;
  int expected_end_tokens;
  int num_end_tokens;
  syntax_asdl::Token* tok = nullptr;
  StackRoots _roots({&left_token, &tokens, &tok});

  no_backslashes = (is_oil_expr and left_token->id == Id::Left_SingleQuote);
  expected_end_tokens = (left_token->id == Id::Left_TSingleQuote || left_token->id == Id::Left_RTSingleQuote || left_token->id == Id::Left_DollarTSingleQuote) ? 3 : 1;
  num_end_tokens = 0;
  while (num_end_tokens < expected_end_tokens) {
    this->_Next(lex_mode);
    this->_Peek();
    if ((this->token_kind == Kind::Lit || this->token_kind == Kind::Char)) {
      tok = this->cur_token;
      if ((no_backslashes and str_contains(tok->val, str1211))) {
        p_die(fmt361(), tok);
      }
      if (is_oil_expr) {
        if (this->token_type == Id::Char_Octal3) {
          p_die(fmt362(), tok);
        }
        if ((this->token_type == Id::Char_Hex and len(this->cur_token->val) != 4)) {
          p_die(fmt363(), tok);
        }
      }
      tokens->append(tok);
    }
    else {
      if (this->token_kind == Kind::Unknown) {
        tok = this->cur_token;
        if ((is_oil_expr or !this->parse_opts->parse_backslash())) {
          p_die(fmt364(), tok);
        }
        tokens->append(tok);
      }
      else {
        if (this->token_kind == Kind::Eof) {
          p_die(fmt365(), left_token);
        }
        else {
          if (this->token_kind == Kind::Right) {
            num_end_tokens += 1;
            tokens->append(this->cur_token);
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
    if (this->token_kind != Kind::Right) {
      num_end_tokens = 0;
    }
  }
  if (expected_end_tokens == 1) {
    tokens->pop();
  }
  else {
    if (expected_end_tokens == 3) {
      tokens->pop();
      tokens->pop();
      tokens->pop();
    }
  }
  if ((left_token->id == Id::Left_TSingleQuote || left_token->id == Id::Left_RTSingleQuote || left_token->id == Id::Left_DollarTSingleQuote)) {
    word_compile::RemoveLeadingSpaceSQ(tokens);
  }
  return this->cur_token;
}

syntax_asdl::word_part_t* WordParser::_ReadDoubleQuotedLeftParts() {
  if ((this->token_type == Id::Left_DollarParen || this->token_type == Id::Left_Backtick)) {
    return this->_ReadCommandSub(this->token_type);
  }
  if (this->token_type == Id::Left_DollarBrace) {
    return this->_ReadBracedVarSub(this->cur_token, true);
  }
  if (this->token_type == Id::Left_DollarDParen) {
    return this->_ReadArithSub();
  }
  if (this->token_type == Id::Left_DollarBracket) {
    return this->_ReadExprSub(lex_mode_e::DQ);
  }
  assert(0);  // AssertionError
}

syntax_asdl::word_part_t* WordParser::_ReadUnquotedLeftParts(bool try_triple_quote, List<bool>* triple_out) {
  syntax_asdl::double_quoted* dq_part = nullptr;
  syntax_asdl::Token* left_dq_token = nullptr;
  types_asdl::lex_mode_t lexer_mode;
  int new_id;
  syntax_asdl::single_quoted* sq_part = nullptr;
  syntax_asdl::Token* left_sq_token = nullptr;
  StackRoots _roots({&triple_out, &dq_part, &left_dq_token, &sq_part, &left_sq_token});

  if ((this->token_type == Id::Left_DoubleQuote || this->token_type == Id::Left_DollarDoubleQuote)) {
    dq_part = this->_ReadDoubleQuoted(this->cur_token);
    if ((try_triple_quote and len(dq_part->parts) == 0)) {
      if (str_equals(this->lexer->ByteLookAhead(), str1217)) {
        this->_Next(lex_mode_e::ShCommand);
        this->_Peek();
        left_dq_token = this->cur_token;
        left_dq_token->id = Id::Left_TDoubleQuote;
        triple_out->set(0, true);
        return this->_ReadDoubleQuoted(left_dq_token);
      }
    }
    return dq_part;
  }
  if ((this->token_type == Id::Left_SingleQuote || this->token_type == Id::Left_RSingleQuote || this->token_type == Id::Left_DollarSingleQuote)) {
    if (this->token_type == Id::Left_DollarSingleQuote) {
      lexer_mode = lex_mode_e::SQ_C;
      new_id = Id::Left_DollarTSingleQuote;
    }
    else {
      lexer_mode = lex_mode_e::SQ_Raw;
      new_id = Id::Left_TSingleQuote;
    }
    sq_part = this->_ReadSingleQuoted(this->cur_token, lexer_mode);
    if ((try_triple_quote and len(sq_part->tokens) == 0)) {
      if (str_equals(this->lexer->ByteLookAhead(), str1218)) {
        this->_Next(lex_mode_e::ShCommand);
        this->_Peek();
        left_sq_token = this->cur_token;
        left_sq_token->id = new_id;
        triple_out->set(0, true);
        return this->_ReadSingleQuoted(left_sq_token, lexer_mode);
      }
    }
    return sq_part;
  }
  if ((this->token_type == Id::Left_DollarParen || this->token_type == Id::Left_Backtick || this->token_type == Id::Left_ProcSubIn || this->token_type == Id::Left_ProcSubOut)) {
    return this->_ReadCommandSub(this->token_type);
  }
  if (this->token_type == Id::Left_DollarBrace) {
    return this->_ReadBracedVarSub(this->cur_token, false);
  }
  if (this->token_type == Id::Left_DollarDParen) {
    return this->_ReadArithSub();
  }
  if (this->token_type == Id::Left_DollarBracket) {
    return this->_ReadExprSub(lex_mode_e::ShCommand);
  }
  assert(0);  // AssertionError
}

syntax_asdl::word_part__ExtGlob* WordParser::_ReadExtGlob() {
  syntax_asdl::Token* left_token = nullptr;
  List<syntax_asdl::compound_word*>* arms = nullptr;
  List<int>* spids = nullptr;
  bool read_word;
  syntax_asdl::compound_word* w = nullptr;
  syntax_asdl::word_part__ExtGlob* part = nullptr;
  StackRoots _roots({&left_token, &arms, &spids, &w, &part});

  left_token = this->cur_token;
  arms = Alloc<List<syntax_asdl::compound_word*>>();
  spids = Alloc<List<int>>();
  spids->append(left_token->span_id);
  this->lexer->PushHint(Id::Op_RParen, Id::Right_ExtGlob);
  this->_Next(lex_mode_e::ExtGlob);
  read_word = false;
  while (true) {
    this->_Peek();
    if (this->token_type == Id::Right_ExtGlob) {
      if (!read_word) {
        arms->append(Alloc<compound_word>());
      }
      spids->append(this->cur_token->span_id);
      break;
    }
    else {
      if (this->token_type == Id::Op_Pipe) {
        if (!read_word) {
          arms->append(Alloc<compound_word>());
        }
        read_word = false;
        this->_Next(lex_mode_e::ExtGlob);
      }
      else {
        if ((this->token_kind == Kind::Lit || this->token_kind == Kind::Left || this->token_kind == Kind::VSub || this->token_kind == Kind::ExtGlob)) {
          w = this->_ReadCompoundWord(lex_mode_e::ExtGlob);
          arms->append(w);
          read_word = true;
        }
        else {
          if (this->token_kind == Kind::Eof) {
            p_die(fmt366(), left_token);
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
  }
  part = Alloc<word_part::ExtGlob>(left_token, arms);
  part->spids->extend(spids);
  return part;
}

void WordParser::_ReadLikeDQ(syntax_asdl::Token* left_token, bool is_oil_expr, List<syntax_asdl::word_part_t*>* out_parts) {
  int expected_end_tokens;
  int num_end_tokens;
  syntax_asdl::word_part_t* part = nullptr;
  StackRoots _roots({&left_token, &out_parts, &part});

  if (left_token) {
    expected_end_tokens = left_token->id == Id::Left_TDoubleQuote ? 3 : 1;
  }
  else {
    expected_end_tokens = 1000;
  }
  num_end_tokens = 0;
  while (num_end_tokens < expected_end_tokens) {
    this->_Next(lex_mode_e::DQ);
    this->_Peek();
    if (this->token_kind == Kind::Lit) {
      if (this->token_type == Id::Lit_EscapedChar) {
        part = Alloc<word_part::EscapedLiteral>(this->cur_token);
      }
      else {
        if (this->token_type == Id::Lit_BadBackslash) {
          if ((is_oil_expr or !this->parse_opts->parse_backslash())) {
            p_die(fmt367(), this->cur_token);
          }
        }
        else {
          if (this->token_type == Id::Lit_Dollar) {
            if ((is_oil_expr or !this->parse_opts->parse_dollar())) {
              p_die(fmt368(), this->cur_token);
            }
          }
        }
        part = this->cur_token;
      }
      out_parts->append(part);
    }
    else {
      if (this->token_kind == Kind::Left) {
        if ((this->token_type == Id::Left_Backtick and is_oil_expr)) {
          p_die(fmt369(), this->cur_token);
        }
        part = this->_ReadDoubleQuotedLeftParts();
        out_parts->append(part);
      }
      else {
        if (this->token_kind == Kind::VSub) {
          part = Alloc<simple_var_sub>(this->cur_token);
          out_parts->append(part);
        }
        else {
          if (this->token_kind == Kind::Right) {
            if (left_token) {
              num_end_tokens += 1;
            }
            out_parts->append(this->cur_token);
          }
          else {
            if (this->token_kind == Kind::Eof) {
              if (left_token) {
                p_die(fmt370(), left_token);
              }
              else {
                break;
              }
            }
            else {
              assert(0);  // AssertionError
            }
          }
        }
      }
    }
    if (this->token_kind != Kind::Right) {
      num_end_tokens = 0;
    }
  }
  if (expected_end_tokens == 1) {
    out_parts->pop();
  }
  else {
    if (expected_end_tokens == 3) {
      out_parts->pop();
      out_parts->pop();
      out_parts->pop();
    }
  }
  if ((left_token and left_token->id == Id::Left_TDoubleQuote)) {
    word_compile::RemoveLeadingSpaceDQ(out_parts);
  }
}

syntax_asdl::double_quoted* WordParser::_ReadDoubleQuoted(syntax_asdl::Token* left_token) {
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  syntax_asdl::double_quoted* dq_part = nullptr;
  StackRoots _roots({&left_token, &parts, &dq_part});

  parts = Alloc<List<syntax_asdl::word_part_t*>>();
  this->_ReadLikeDQ(left_token, false, parts);
  dq_part = Alloc<double_quoted>(left_token, parts, false);
  dq_part->spids->append(left_token->span_id);
  dq_part->spids->append(this->cur_token->span_id);
  return dq_part;
}

syntax_asdl::Token* WordParser::ReadDoubleQuoted(syntax_asdl::Token* left_token, List<syntax_asdl::word_part_t*>* parts) {
  StackRoots _roots({&left_token, &parts});

  this->_ReadLikeDQ(left_token, true, parts);
  return this->cur_token;
}

syntax_asdl::command_sub* WordParser::_ReadCommandSub(int left_id) {
  syntax_asdl::Token* left_token = nullptr;
  int left_spid;
  int right_id;
  cmd_parse::CommandParser* c_parser = nullptr;
  syntax_asdl::command_t* node = nullptr;
  int right_spid;
  List<Str*>* parts = nullptr;
  Str* code_str = nullptr;
  alloc::Arena* arena = nullptr;
  reader::FileLineReader* line_reader = nullptr;
  syntax_asdl::source__Reparsed* src = nullptr;
  syntax_asdl::command_sub* cs_part = nullptr;
  StackRoots _roots({&left_token, &c_parser, &node, &parts, &code_str, &arena, &line_reader, &src, &cs_part});

  left_token = this->cur_token;
  left_spid = left_token->span_id;
  if ((left_id == Id::Left_DollarParen || left_id == Id::Left_AtParen || left_id == Id::Left_ProcSubIn || left_id == Id::Left_ProcSubOut)) {
    this->_Next(lex_mode_e::ShCommand);
    right_id = Id::Eof_RParen;
    this->lexer->PushHint(Id::Op_RParen, right_id);
    c_parser = this->parse_ctx->MakeParserForCommandSub(this->line_reader, this->lexer, right_id);
    node = c_parser->ParseCommandSub();
    right_spid = c_parser->w_parser->cur_token->span_id;
  }
  else {
    if ((left_id == Id::Left_Backtick and this->parse_ctx->one_pass_parse)) {
      right_id = Id::Eof_Backtick;
      this->lexer->PushHint(Id::Left_Backtick, right_id);
      c_parser = this->parse_ctx->MakeParserForCommandSub(this->line_reader, this->lexer, right_id);
      node = c_parser->ParseCommandSub();
      right_spid = c_parser->w_parser->cur_token->span_id;
    }
    else {
      if (left_id == Id::Left_Backtick) {
        if (!this->parse_opts->parse_backticks()) {
          p_die(fmt371(), left_token);
        }
        this->_Next(lex_mode_e::Backtick);
        parts = Alloc<List<Str*>>();
        while (true) {
          this->_Peek();
          if (this->token_type == Id::Backtick_Quoted) {
            parts->append(this->cur_token->val->slice(1));
          }
          else {
            if (this->token_type == Id::Backtick_Other) {
              parts->append(this->cur_token->val);
            }
            else {
              if (this->token_type == Id::Backtick_Right) {
                break;
              }
              else {
                if (this->token_type == Id::Eof_Real) {
                  p_die(fmt372(), left_token);
                }
                else {
                  assert(0);  // AssertionError
                }
              }
            }
          }
          this->_Next(lex_mode_e::Backtick);
        }
        right_spid = this->cur_token->span_id;
        code_str = str1226->join(parts);
        arena = this->parse_ctx->arena;
        line_reader = reader::StringLineReader(code_str, arena);
        c_parser = this->parse_ctx->MakeOshParser(line_reader);
        src = Alloc<source::Reparsed>(str1227, left_spid, right_spid);
        {  // with
          alloc::ctx_Location ctx(arena, src);

          node = c_parser->ParseCommandSub();
        }
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  cs_part = Alloc<command_sub>(left_token, node);
  cs_part->spids->append(left_spid);
  cs_part->spids->append(right_spid);
  return cs_part;
}

syntax_asdl::word_part__ExprSub* WordParser::_ReadExprSub(types_asdl::lex_mode_t lex_mode) {
  syntax_asdl::Token* left_token = nullptr;
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::word_part__ExprSub* node = nullptr;
  StackRoots _roots({&left_token, &enode, &node});

  left_token = this->cur_token;
  this->_Next(lex_mode_e::Expr);
  Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> tup1 = this->parse_ctx->ParseOilExpr(this->lexer, grammar_nt::oil_expr_sub);
  enode = tup1.at0();
  this->_Next(lex_mode);
  node = Alloc<word_part::ExprSub>(left_token, enode);
  return node;
}

syntax_asdl::command__VarDecl* WordParser::ParseVarDecl(syntax_asdl::Token* kw_token) {
  syntax_asdl::command__VarDecl* enode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&kw_token, &enode, &last_token});

  this->_Next(lex_mode_e::Expr);
  Tuple2<syntax_asdl::command__VarDecl*, syntax_asdl::Token*> tup2 = this->parse_ctx->ParseVarDecl(kw_token, this->lexer);
  enode = tup2.at0();
  last_token = tup2.at1();
  if (last_token->id == Id::Op_RBrace) {
    last_token->id = Id::Lit_RBrace;
  }
  this->buffered_word = last_token;
  this->_Next(lex_mode_e::ShCommand);
  return enode;
}

syntax_asdl::command__PlaceMutation* WordParser::ParsePlaceMutation(syntax_asdl::Token* kw_token, cmd_parse::VarChecker* var_checker) {
  syntax_asdl::command__PlaceMutation* enode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  syntax_asdl::place_expr_t* UP_place = nullptr;
  StackRoots _roots({&kw_token, &var_checker, &enode, &last_token, &UP_place});

  this->_Next(lex_mode_e::Expr);
  Tuple2<syntax_asdl::command__PlaceMutation*, syntax_asdl::Token*> tup3 = this->parse_ctx->ParsePlaceMutation(kw_token, this->lexer);
  enode = tup3.at0();
  last_token = tup3.at1();
  if (last_token->id == Id::Op_RBrace) {
    last_token->id = Id::Lit_RBrace;
  }
  for (ListIter<syntax_asdl::place_expr_t*> it(enode->lhs); !it.Done(); it.Next()) {
    syntax_asdl::place_expr_t* place = it.Value();
    StackRoots _for({&place  });
    UP_place = place;
    switch (place->tag_()) {
      case place_expr_e::Var: {
        place_expr__Var* place = static_cast<place_expr__Var*>(UP_place);
        var_checker->Check(kw_token->id, place->name);
      }
        break;
    }
  }
  this->buffered_word = last_token;
  this->_Next(lex_mode_e::ShCommand);
  return enode;
}

syntax_asdl::expr_t* WordParser::ParseBareDecl() {
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&enode, &last_token});

  this->_Next(lex_mode_e::Expr);
  this->_Peek();
  Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> tup4 = this->parse_ctx->ParseOilExpr(this->lexer, grammar_nt::command_expr);
  enode = tup4.at0();
  last_token = tup4.at1();
  if (last_token->id == Id::Op_RBrace) {
    last_token->id = Id::Lit_RBrace;
  }
  this->buffered_word = last_token;
  this->_Next(lex_mode_e::ShCommand);
  return enode;
}

syntax_asdl::expr_t* WordParser::ParseCommandExpr() {
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&enode, &last_token});

  Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> tup5 = this->parse_ctx->ParseOilExpr(this->lexer, grammar_nt::command_expr);
  enode = tup5.at0();
  last_token = tup5.at1();
  if (last_token->id == Id::Op_RBrace) {
    last_token->id = Id::Lit_RBrace;
  }
  this->buffered_word = last_token;
  return enode;
}

void WordParser::ParseProc(syntax_asdl::command__Proc* node) {
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&node, &last_token});

  this->_Next(lex_mode_e::ShCommand);
  this->_Peek();
  if (this->token_type != Id::Lit_Chars) {
    p_die(fmt373(ui::PrettyToken(this->cur_token, this->arena)), this->cur_token);
  }
  node->name = this->cur_token;
  last_token = this->parse_ctx->ParseProc(this->lexer, node);
  if (last_token->id == Id::Op_LBrace) {
    last_token->id = Id::Lit_LBrace;
  }
  this->buffered_word = last_token;
  this->_Next(lex_mode_e::ShCommand);
}

void WordParser::ParseImport(syntax_asdl::command__Import* node) {
  syntax_asdl::Token* last_token = nullptr;
  StackRoots _roots({&node, &last_token});

  last_token = this->parse_ctx->ParseImport(this->lexer, node);
  this->buffered_word = last_token;
}

syntax_asdl::arith_expr_t* WordParser::_ReadArithExpr(int end_id) {
  syntax_asdl::arith_expr_t* anode = nullptr;
  int cur_id;
  StackRoots _roots({&anode});

  anode = this->a_parser->Parse();
  cur_id = this->a_parser->CurrentId();
  if ((end_id != Id::Undefined_Tok and cur_id != end_id)) {
    p_die(fmt374(ui::PrettyId(cur_id), ui::PrettyId(end_id)), this->a_parser->cur_word);
  }
  return anode;
}

syntax_asdl::word_part__ArithSub* WordParser::_ReadArithSub() {
  int left_span_id;
  syntax_asdl::arith_expr_t* anode = nullptr;
  int right_span_id;
  syntax_asdl::word_part__ArithSub* node = nullptr;
  StackRoots _roots({&anode, &node});

  left_span_id = this->cur_token->span_id;
  this->lexer->PushHint(Id::Op_RParen, Id::Right_DollarDParen);
  this->_Next(lex_mode_e::Arith);
  anode = this->_ReadArithExpr(Id::Arith_RParen);
  this->_Next(lex_mode_e::ShCommand);
  this->_Peek();
  if (this->token_type != Id::Right_DollarDParen) {
    p_die(fmt375(), this->cur_token);
  }
  right_span_id = this->cur_token->span_id;
  node = Alloc<word_part::ArithSub>(anode);
  node->spids->append(left_span_id);
  node->spids->append(right_span_id);
  return node;
}

syntax_asdl::arith_expr_t* WordParser::ReadDParen() {
  syntax_asdl::arith_expr_t* anode = nullptr;
  StackRoots _roots({&anode});

  this->lexer->PushHint(Id::Op_RParen, Id::Op_DRightParen);
  this->_Next(lex_mode_e::Arith);
  anode = this->_ReadArithExpr(Id::Arith_RParen);
  this->_Next(lex_mode_e::ShCommand);
  this->_Peek();
  if (this->token_type != Id::Op_DRightParen) {
    p_die(fmt376(), this->cur_token);
  }
  this->_Next(lex_mode_e::ShCommand);
  return anode;
}

void WordParser::_NextNonSpace() {
  while (true) {
    this->_Next(lex_mode_e::Arith);
    this->_Peek();
    if ((this->token_kind != Kind::Ignored && this->token_kind != Kind::WS)) {
      break;
    }
  }
}

syntax_asdl::command__ForExpr* WordParser::ReadForExpression() {
  int cur_id;
  syntax_asdl::arith_expr_t* init_node = nullptr;
  syntax_asdl::arith_expr_t* cond_node = nullptr;
  syntax_asdl::arith_expr_t* update_node = nullptr;
  syntax_asdl::command__ForExpr* node = nullptr;
  StackRoots _roots({&init_node, &cond_node, &update_node, &node});

  this->_NextNonSpace();
  this->_Peek();
  cur_id = this->token_type;
  if (cur_id == Id::Arith_Semi) {
    init_node = nullptr;
  }
  else {
    init_node = this->a_parser->Parse();
    cur_id = this->a_parser->CurrentId();
  }
  this->_NextNonSpace();
  if (cur_id != Id::Arith_Semi) {
    p_die(fmt377(), this->a_parser->cur_word);
  }
  this->_Peek();
  cur_id = this->token_type;
  if (cur_id == Id::Arith_Semi) {
    cond_node = nullptr;
  }
  else {
    cond_node = this->a_parser->Parse();
    cur_id = this->a_parser->CurrentId();
  }
  this->_NextNonSpace();
  if (cur_id != Id::Arith_Semi) {
    p_die(fmt378(), this->a_parser->cur_word);
  }
  this->_Peek();
  cur_id = this->token_type;
  if (cur_id == Id::Arith_RParen) {
    update_node = nullptr;
  }
  else {
    update_node = this->_ReadArithExpr(Id::Arith_RParen);
  }
  this->_NextNonSpace();
  this->_Peek();
  if (this->token_type != Id::Arith_RParen) {
    p_die(fmt379(), this->cur_token);
  }
  this->_Next(lex_mode_e::ShCommand);
  node = Alloc<command::ForExpr>();
  node->init = init_node;
  node->cond = cond_node;
  node->update = update_node;
  return node;
}

syntax_asdl::word_part_t* WordParser::_ReadArrayLiteral() {
  syntax_asdl::Token* left_token = nullptr;
  int paren_spid;
  word_parse::WordParser* w_parser = nullptr;
  List<syntax_asdl::compound_word*>* words = nullptr;
  syntax_asdl::word_t* w = nullptr;
  List<syntax_asdl::word_t*>* no_words = nullptr;
  syntax_asdl::sh_array_literal* node = nullptr;
  Tuple2<syntax_asdl::compound_word*, syntax_asdl::compound_word*>* pair = nullptr;
  syntax_asdl::compound_word* k = nullptr;
  syntax_asdl::compound_word* v = nullptr;
  List<syntax_asdl::compound_word*>* pairs = nullptr;
  int n;
  syntax_asdl::compound_word* w2 = nullptr;
  syntax_asdl::word_part__AssocArrayLiteral* node2 = nullptr;
  List<syntax_asdl::word_t*>* words2 = nullptr;
  List<syntax_asdl::word_t*>* words3 = nullptr;
  StackRoots _roots({&left_token, &w_parser, &words, &w, &no_words, &node, &pair, &k, &v, &pairs, &w2, &node2, &words2, &words3});

  this->_Next(lex_mode_e::ShCommand);
  this->_Peek();
  if (this->cur_token->id != Id::Op_LParen) {
    p_die(fmt380(), this->cur_token);
  }
  left_token = this->cur_token;
  paren_spid = this->cur_token->span_id;
  w_parser = this->parse_ctx->MakeWordParser(this->lexer, this->line_reader);
  words = Alloc<List<syntax_asdl::compound_word*>>();
  while (true) {
    w = w_parser->ReadWord(lex_mode_e::ShCommand);
    if (w->tag_() == word_e::Token) {
      Token* tok = static_cast<Token*>(w);
      if (tok->id == Id::Right_ShArrayLiteral) {
        break;
      }
      else {
        if (tok->id == Id::Op_Newline) {
          continue;
        }
        else {
          p_die(fmt381(), w);
        }
      }
    }
    words->append(static_cast<compound_word*>(w));
  }
  if (len(words) == 0) {
    no_words = Alloc<List<syntax_asdl::word_t*>>();
    node = Alloc<sh_array_literal>(left_token, no_words);
    node->spids->append(left_token->span_id);
    return node;
  }
  pair = word_::DetectAssocPair(words->index_(0));
  if (pair) {
    Tuple2<syntax_asdl::compound_word*, syntax_asdl::compound_word*>* tup6 = pair;
    k = tup6->at0();
    v = tup6->at1();
    pairs = NewList<syntax_asdl::compound_word*>(std::initializer_list<syntax_asdl::compound_word*>{k, v});
    n = len(words);
    for (int i = 1; i < n; ++i) {
      w2 = words->index_(i);
      pair = word_::DetectAssocPair(w2);
      if (!pair) {
        p_die(fmt382(), w2);
      }
      Tuple2<syntax_asdl::compound_word*, syntax_asdl::compound_word*>* tup7 = pair;
      k = tup7->at0();
      v = tup7->at1();
      pairs->append(k);
      pairs->append(v);
    }
    node2 = Alloc<word_part::AssocArrayLiteral>(left_token, pairs);
    node2->spids->append(paren_spid);
    return node2;
  }
  words2 = braces::BraceDetectAll(words);
  words3 = word_::TildeDetectAll(words2);
  node = Alloc<sh_array_literal>(left_token, words3);
  node->spids->append(paren_spid);
  return node;
}

void WordParser::_ParseInlineCallArgs(syntax_asdl::ArgList* arglist) {
  StackRoots _roots({&arglist});

  this->lexer->PushHint(Id::Op_RParen, Id::Op_RParen);
  this->parse_ctx->ParseOilArgList(this->lexer, arglist);
}

syntax_asdl::ArgList* WordParser::ParseProcCallArgs() {
  syntax_asdl::ArgList* arg_list = nullptr;
  StackRoots _roots({&arg_list});

  this->lexer->MaybeUnreadOne();
  this->lexer->PushHint(Id::Op_RParen, Id::Op_RParen);
  arg_list = Alloc<ArgList>();
  arg_list->spids->append(this->cur_token->span_id);
  this->parse_ctx->ParseOilArgList(this->lexer, arg_list);
  return arg_list;
}

bool WordParser::_MaybeReadWholeWord(bool is_first, types_asdl::lex_mode_t lex_mode, List<syntax_asdl::word_part_t*>* parts) {
  bool done;
  Str* tok_val = nullptr;
  Str* ch = nullptr;
  syntax_asdl::word_part_t* part = nullptr;
  int next_id;
  syntax_asdl::word_part_t* part2 = nullptr;
  syntax_asdl::Token* splice_token = nullptr;
  syntax_asdl::ArgList* arglist = nullptr;
  StackRoots _roots({&parts, &tok_val, &ch, &part, &part2, &splice_token, &arglist});

  done = false;
  if (this->token_type == Id::Lit_EscapedChar) {
    if (!this->parse_opts->parse_backslash()) {
      tok_val = this->cur_token->val;
      ch = tok_val->index_(1);
      if (!pyutil::IsValidCharEscape(ord(ch))) {
        p_die(fmt383(), this->cur_token);
      }
    }
    part = Alloc<word_part::EscapedLiteral>(this->cur_token);
  }
  else {
    part = this->cur_token;
  }
  if ((is_first and this->token_type == Id::Lit_VarLike)) {
    parts->append(part);
    next_id = this->lexer->LookPastSpace(lex_mode);
    if (next_id == Id::Op_LParen) {
      this->lexer->PushHint(Id::Op_RParen, Id::Right_ShArrayLiteral);
      part2 = this->_ReadArrayLiteral();
      parts->append(part2);
      this->_Next(lex_mode);
      this->_Peek();
      if (!list_contains(KINDS_THAT_END_WORDS, this->token_kind)) {
        p_die(fmt384(), this->cur_token);
      }
      done = true;
    }
  }
  else {
    if ((is_first and (this->parse_opts->parse_at() and this->token_type == Id::Lit_Splice))) {
      splice_token = this->cur_token;
      next_id = this->lexer->LookAheadOne(lex_mode);
      if (next_id == Id::Op_LParen) {
        arglist = Alloc<ArgList>();
        this->_ParseInlineCallArgs(arglist);
        part2 = Alloc<word_part::FuncCall>(splice_token, arglist);
      }
      else {
        part2 = Alloc<word_part::Splice>(splice_token);
      }
      parts->append(part2);
      this->_Next(lex_mode);
      this->_Peek();
      if (!list_contains(KINDS_THAT_END_WORDS, this->token_kind)) {
        p_die(fmt385(), this->cur_token);
      }
      done = true;
    }
    else {
      if ((is_first and (this->parse_opts->parse_at() and this->token_type == Id::Lit_AtLBraceDot))) {
        p_die(fmt386(), this->cur_token);
      }
      else {
        if ((is_first and (this->parse_opts->parse_at_all() and this->token_type == Id::Lit_At))) {
          p_die(fmt387(), this->cur_token);
        }
        else {
          parts->append(part);
        }
      }
    }
  }
  return done;
}

syntax_asdl::compound_word* WordParser::_ReadCompoundWord(types_asdl::lex_mode_t lex_mode) {
  return this->_ReadCompoundWord3(lex_mode, Id::Undefined_Tok, true);
}

syntax_asdl::compound_word* WordParser::_ReadCompoundWord3(types_asdl::lex_mode_t lex_mode, int eof_type, bool empty_ok) {
  syntax_asdl::compound_word* w = nullptr;
  int num_parts;
  int brace_count;
  bool done;
  List<bool>* triple_out = nullptr;
  bool allow_done;
  Str* next_byte = nullptr;
  syntax_asdl::Token* vsub_token = nullptr;
  syntax_asdl::word_part_t* part = nullptr;
  int next_id;
  syntax_asdl::ArgList* arglist = nullptr;
  syntax_asdl::command_sub* cs_part = nullptr;
  bool try_triple_quote;
  StackRoots _roots({&w, &triple_out, &next_byte, &vsub_token, &part, &arglist, &cs_part});

  w = Alloc<compound_word>();
  num_parts = 0;
  brace_count = 0;
  done = false;
  triple_out = NewList<bool>(std::initializer_list<bool>{false});
  while (!done) {
    this->_Peek();
    allow_done = (empty_ok or num_parts != 0);
    if ((allow_done and this->token_type == eof_type)) {
      done = true;
    }
    else {
      if ((this->token_kind == Kind::Lit || this->token_kind == Kind::History || this->token_kind == Kind::KW || this->token_kind == Kind::ControlFlow || this->token_kind == Kind::BoolUnary || this->token_kind == Kind::BoolBinary)) {
        if (this->token_type == Id::Lit_LBrace) {
          brace_count += 1;
        }
        else {
          if (this->token_type == Id::Lit_RBrace) {
            brace_count -= 1;
          }
          else {
            if (this->token_type == Id::Lit_Dollar) {
              if (!this->parse_opts->parse_dollar()) {
                if ((num_parts == 0 and lex_mode == lex_mode_e::ShCommand)) {
                  next_byte = this->lexer->ByteLookAhead();
                  if (str_equals(next_byte, str1243)) {
                    println_stderr(fmt388(next_byte));
                  }
                }
                p_die(fmt389(), this->cur_token);
              }
            }
          }
        }
        done = this->_MaybeReadWholeWord(num_parts == 0, lex_mode, w->parts);
      }
      else {
        if (this->token_kind == Kind::VSub) {
          vsub_token = this->cur_token;
          part = Alloc<simple_var_sub>(vsub_token);
          if (this->token_type == Id::VSub_DollarName) {
            next_id = this->lexer->LookAheadOne(lex_mode);
            if (next_id == Id::Op_LParen) {
              arglist = Alloc<ArgList>();
              this->_ParseInlineCallArgs(arglist);
              part = Alloc<word_part::FuncCall>(vsub_token, arglist);
            }
          }
          w->parts->append(part);
        }
        else {
          if (this->token_kind == Kind::ExtGlob) {
            if ((this->parse_opts->parse_at() and (this->token_type == Id::ExtGlob_At and num_parts == 0))) {
              cs_part = this->_ReadCommandSub(Id::Left_AtParen);
              cs_part->left_token->id = Id::Left_AtParen;
              part = cs_part;
              this->_Peek();
              if (!list_contains(KINDS_THAT_END_WORDS, this->token_kind)) {
                p_die(fmt390(), this->cur_token);
              }
              done = true;
            }
            else {
              part = this->_ReadExtGlob();
            }
            w->parts->append(part);
          }
          else {
            if (this->token_kind == Kind::Left) {
              try_triple_quote = (this->parse_opts->parse_triple_quote() and (lex_mode == lex_mode_e::ShCommand and num_parts == 0));
              part = this->_ReadUnquotedLeftParts(try_triple_quote, triple_out);
              w->parts->append(part);
            }
            else {
              if (this->token_kind == Kind::Right) {
                if (this->token_type == Id::Right_DoubleQuote) {
                  ;  // pass
                }
                else {
                  if (this->token_type == Id::Right_Subshell) {
                    if (this->lexer->MaybeUnreadOne()) {
                      this->lexer->PushHint(Id::Op_RParen, Id::Right_Subshell);
                      this->_Next(lex_mode);
                    }
                    done = true;
                  }
                  else {
                    done = true;
                  }
                }
              }
              else {
                if (this->token_kind == Kind::Ignored) {
                  done = true;
                }
                else {
                  if ((this->token_type == Id::Op_RParen || this->token_type == Id::Eof_RParen)) {
                    if (this->lexer->MaybeUnreadOne()) {
                      if (this->token_type == Id::Eof_RParen) {
                        this->lexer->PushHint(Id::Op_RParen, Id::Eof_RParen);
                      }
                      this->_Next(lex_mode);
                    }
                  }
                  done = true;
                }
              }
            }
          }
        }
      }
    }
    if (!done) {
      this->_Next(lex_mode);
      num_parts += 1;
    }
  }
  if ((this->parse_opts->parse_brace() and (num_parts > 1 and brace_count != 0))) {
    p_die(fmt391(), w);
  }
  if ((triple_out->index_(0) and num_parts > 1)) {
    p_die(fmt392(), w->parts->index_(-1));
  }
  return w;
}

Tuple2<syntax_asdl::word_t*, bool> WordParser::_ReadArithWord() {
  syntax_asdl::word_t* no_word = nullptr;
  syntax_asdl::compound_word* w = nullptr;
  StackRoots _roots({&no_word, &w});

  this->_Peek();
  if (this->token_kind == Kind::Unknown) {
    p_die(fmt393(this->cur_token->val), this->cur_token);
  }
  else {
    if (this->token_kind == Kind::Eof) {
      return (Tuple2<syntax_asdl::word_t*, bool>(static_cast<word_t*>(this->cur_token), false));
    }
    else {
      if (this->token_kind == Kind::Ignored) {
        this->_Next(lex_mode_e::Arith);
        no_word = nullptr;
        return (Tuple2<syntax_asdl::word_t*, bool>(no_word, true));
      }
      else {
        if ((this->token_kind == Kind::Arith || this->token_kind == Kind::Right)) {
          this->_Next(lex_mode_e::Arith);
          return (Tuple2<syntax_asdl::word_t*, bool>(static_cast<word_t*>(this->cur_token), false));
        }
        else {
          if ((this->token_kind == Kind::Lit || this->token_kind == Kind::Left || this->token_kind == Kind::VSub)) {
            w = this->_ReadCompoundWord(lex_mode_e::Arith);
            return (Tuple2<syntax_asdl::word_t*, bool>(static_cast<word_t*>(w), false));
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
  }
}

Tuple2<syntax_asdl::word_t*, bool> WordParser::_ReadWord(types_asdl::lex_mode_t lex_mode) {
  syntax_asdl::word_t* no_word = nullptr;
  syntax_asdl::compound_word* w = nullptr;
  StackRoots _roots({&no_word, &w});

  no_word = nullptr;
  this->_Peek();
  if (this->token_kind == Kind::Eof) {
    return (Tuple2<syntax_asdl::word_t*, bool>(static_cast<word_t*>(this->cur_token), false));
  }
  else {
    if ((this->token_kind == Kind::Op || this->token_kind == Kind::Redir || this->token_kind == Kind::Arith)) {
      this->_Next(lex_mode);
      if (this->token_type == Id::Op_Newline) {
        if (this->multiline) {
          if (this->newline_state > 1) {
            p_die(fmt394(), this->cur_token);
          }
          return (Tuple2<syntax_asdl::word_t*, bool>(no_word, true));
        }
        if (this->returned_newline) {
          return (Tuple2<syntax_asdl::word_t*, bool>(no_word, true));
        }
      }
      return (Tuple2<syntax_asdl::word_t*, bool>(static_cast<word_t*>(this->cur_token), false));
    }
    else {
      if (this->token_kind == Kind::Right) {
        if ((this->token_type != Id::Right_Subshell && this->token_type != Id::Right_ShFunction && this->token_type != Id::Right_CasePat && this->token_type != Id::Right_ShArrayLiteral)) {
          assert(0);  // AssertionError
        }
        this->_Next(lex_mode);
        return (Tuple2<syntax_asdl::word_t*, bool>(static_cast<word_t*>(this->cur_token), false));
      }
      else {
        if ((this->token_kind == Kind::Ignored || this->token_kind == Kind::WS)) {
          this->_Next(lex_mode);
          return (Tuple2<syntax_asdl::word_t*, bool>(no_word, true));
        }
        else {
          if ((this->token_kind == Kind::VSub || this->token_kind == Kind::Lit || this->token_kind == Kind::History || this->token_kind == Kind::Left || this->token_kind == Kind::KW || this->token_kind == Kind::ControlFlow || this->token_kind == Kind::BoolUnary || this->token_kind == Kind::BoolBinary || this->token_kind == Kind::ExtGlob)) {
            if (this->token_type == Id::Lit_Pound) {
              this->_Next(lex_mode_e::Comment);
              this->_Peek();
              return (Tuple2<syntax_asdl::word_t*, bool>(no_word, true));
            }
            else {
              if (this->token_type == Id::Lit_TPound) {
                this->_Next(lex_mode_e::Comment);
                this->_Peek();
                if ((this->token_type == Id::Ignored_Comment and this->emit_doc_token)) {
                  return (Tuple2<syntax_asdl::word_t*, bool>(static_cast<word_t*>(this->cur_token), false));
                }
                return (Tuple2<syntax_asdl::word_t*, bool>(no_word, true));
              }
              else {
                if ((this->parse_opts->parse_raw_string() and (this->token_type == Id::Lit_Chars and maybe_str_equals(this->cur_token->val, str1251)))) {
                  if (this->lexer->LookAheadOne(lex_mode_e::ShCommand) == Id::Left_SingleQuote) {
                    this->_Next(lex_mode_e::ShCommand);
                  }
                }
                w = this->_ReadCompoundWord(lex_mode);
                return (Tuple2<syntax_asdl::word_t*, bool>(static_cast<word_t*>(w), false));
              }
            }
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
  }
}

syntax_asdl::braced_var_sub* WordParser::ParseVarRef() {
  syntax_asdl::braced_var_sub* part = nullptr;
  StackRoots _roots({&part});

  this->_Next(lex_mode_e::VSub_1);
  this->_Peek();
  if (this->token_kind != Kind::VSub) {
    p_die(fmt395(), this->cur_token);
  }
  part = this->_ParseVarOf();
  this->_Peek();
  if (this->token_type != Id::Eof_Real) {
    p_die(fmt396(), this->cur_token);
  }
  return part;
}

int WordParser::LookPastSpace() {
  int id_;
  if (this->cur_token->id == Id::WS_Space) {
    id_ = this->lexer->LookPastSpace(lex_mode_e::ShCommand);
  }
  else {
    id_ = this->cur_token->id;
  }
  return id_;
}

bool WordParser::LookAheadFuncParens() {
  if (this->cur_token->id == Id::Op_LParen) {
    return this->lexer->LookAheadFuncParens(1);
  }
  else {
    if (this->cur_token->id == Id::WS_Space) {
      return this->lexer->LookAheadFuncParens(0);
    }
    else {
      return false;
    }
  }
}

syntax_asdl::word_t* WordParser::ReadWord(types_asdl::lex_mode_t lex_mode) {
  syntax_asdl::word_t* w = nullptr;
  bool need_more;
  StackRoots _roots({&w});

  if (this->buffered_word) {
    w = this->buffered_word;
    this->buffered_word = nullptr;
  }
  else {
    while (true) {
      if (lex_mode == lex_mode_e::Arith) {
        Tuple2<syntax_asdl::word_t*, bool> tup8 = this->_ReadArithWord();
        w = tup8.at0();
        need_more = tup8.at1();
      }
      else {
        if ((lex_mode == lex_mode_e::ShCommand || lex_mode == lex_mode_e::DBracket || lex_mode == lex_mode_e::BashRegex)) {
          Tuple2<syntax_asdl::word_t*, bool> tup9 = this->_ReadWord(lex_mode);
          w = tup9.at0();
          need_more = tup9.at1();
        }
        else {
          assert(0);  // AssertionError
        }
      }
      if (!need_more) {
        break;
      }
    }
  }
  this->returned_newline = word_::CommandId(w) == Id::Op_Newline;
  return w;
}

void WordParser::ReadHereDocBody(List<syntax_asdl::word_part_t*>* parts) {
  StackRoots _roots({&parts});

  this->_ReadLikeDQ(nullptr, false, parts);
}

syntax_asdl::compound_word* WordParser::ReadForPlugin() {
  syntax_asdl::compound_word* w = nullptr;
  StackRoots _roots({&w});

  w = Alloc<compound_word>();
  this->_ReadLikeDQ(nullptr, false, w->parts);
  return w;
}

void WordParser::EmitDocToken(bool b) {
  this->emit_doc_token = b;
}

void WordParser::Multiline(bool b) {
  this->multiline = b;
}

}  // define namespace word_parse

namespace grammar {  // define


Grammar::Grammar() 
    : Obj(Tag::FixedSize, maskof_Grammar(), sizeof(Grammar))  {
  this->symbol2number = Alloc<Dict<Str*, int>>();
  this->number2symbol = Alloc<Dict<int, Str*>>();
  this->states = Alloc<List<List<Tuple2<int, int>*>*>>();
  this->dfas = Alloc<Dict<int, Tuple2<List<List<Tuple2<int, int>*>*>*, Dict<int, int>*>*>>();
  this->labels = NewList<int>(std::initializer_list<int>{0});
  this->keywords = Alloc<Dict<Str*, int>>();
  this->tokens = Alloc<Dict<int, int>>();
  this->symbol2label = Alloc<Dict<Str*, int>>();
  this->start = 256;
}

}  // define namespace grammar

namespace pnode {  // define


PNode::PNode(int typ, syntax_asdl::Token* tok, List<pnode::PNode*>* children) 
    : Obj(Tag::FixedSize, maskof_PNode(), sizeof(PNode))  {
  this->typ = typ;
  this->tok = tok;
  this->children = children;
}

}  // define namespace pnode

namespace cgi {  // define


Str* escape(Str* s) {
  StackRoots _roots({&s});

  s = s->replace(str1263, str1264);
  s = s->replace(str1265, str1266);
  s = s->replace(str1267, str1268);
  return s;
}

}  // define namespace cgi

namespace os_path {  // define

Str* extsep = str1269;
Str* sep = str1270;

Str* join(Str* s1, Str* s2) {
  StackRoots _roots({&s1, &s2});

  if ((s2->startswith(str1271) or len(s1) == 0)) {
    return s2;
  }
  if (s1->endswith(str1272)) {
    return str_concat(s1, s2);
  }
  return fmt397(s1, s2);
}

Tuple2<Str*, Str*> split(Str* p) {
  int i;
  Str* head = nullptr;
  Str* tail = nullptr;
  StackRoots _roots({&p, &head, &tail});

  i = (p->rfind(str1274) + 1);
  head = p->slice(0, i);
  tail = p->slice(i);
  head = rstrip_slashes(head);
  return (Tuple2<Str*, Str*>(head, tail));
}

Tuple2<Str*, Str*> _splitext(Str* p, Str* sep, Str* extsep) {
  int sepIndex;
  int dotIndex;
  int filenameIndex;
  StackRoots _roots({&p, &sep, &extsep});

  sepIndex = p->rfind(sep);
  dotIndex = p->rfind(extsep);
  if (dotIndex > sepIndex) {
    filenameIndex = (sepIndex + 1);
    while (filenameIndex < dotIndex) {
      if (!(str_equals(p->index_(filenameIndex), extsep))) {
        return (Tuple2<Str*, Str*>(p->slice(0, dotIndex), p->slice(dotIndex)));
      }
      filenameIndex += 1;
    }
  }
  return (Tuple2<Str*, Str*>(p, str1275));
}

Tuple2<Str*, Str*> splitext(Str* p) {
  StackRoots _roots({&p});

  return _splitext(p, sep, extsep);
}

Str* basename(Str* p) {
  int i;
  StackRoots _roots({&p});

  i = (p->rfind(str1276) + 1);
  return p->slice(i);
}

Str* dirname(Str* p) {
  int i;
  Str* head = nullptr;
  StackRoots _roots({&p, &head});

  i = (p->rfind(str1277) + 1);
  head = p->slice(0, i);
  head = rstrip_slashes(head);
  return head;
}

Str* normpath(Str* path) {
  Str* slash = nullptr;
  Str* dot = nullptr;
  int initial_slashes;
  List<Str*>* comps = nullptr;
  List<Str*>* new_comps = nullptr;
  StackRoots _roots({&path, &slash, &dot, &comps, &new_comps});

  slash = str1278;
  dot = str1279;
  if (str_equals(path, str1280)) {
    return dot;
  }
  initial_slashes = path->startswith(str1281);
  if ((initial_slashes and (path->startswith(str1282) and !path->startswith(str1283)))) {
    initial_slashes = 2;
  }
  comps = path->split(str1284);
  new_comps = Alloc<List<Str*>>();
  for (ListIter<Str*> it(comps); !it.Done(); it.Next()) {
    Str* comp = it.Value();
    StackRoots _for({&comp  });
    if ((len(comp) == 0 or str_equals(comp, str1285))) {
      continue;
    }
    if ((!(str_equals(comp, str1286)) or ((initial_slashes == 0 and len(new_comps) == 0) or (len(new_comps) and str_equals(new_comps->index_(-1), str1287))))) {
      new_comps->append(comp);
    }
    else {
      if (len(new_comps)) {
        new_comps->pop();
      }
    }
  }
  comps = new_comps;
  path = slash->join(comps);
  if (initial_slashes) {
    path = str_concat(str_repeat(slash, initial_slashes), path);
  }
  return len(path) ? path : dot;
}

bool isabs(Str* s) {
  StackRoots _roots({&s});

  return s->startswith(str1288);
}

Str* abspath(Str* path) {
  Str* cwd = nullptr;
  StackRoots _roots({&path, &cwd});

  if (!isabs(path)) {
    cwd = posix::getcwd();
    path = join(cwd, path);
  }
  return normpath(path);
}

}  // define namespace os_path

namespace qsn {  // define

int BIT8_UTF8 = 0;
int BIT8_U_ESCAPE = 1;
int BIT8_X_ESCAPE = 2;
int MUST_QUOTE = 4;

bool _encode(Str* s, int bit8_display, bool shell_compat, List<Str*>* parts) {
  StackRoots _roots({&s, &parts});

  if (bit8_display == BIT8_X_ESCAPE) {
    _encode_bytes_x(s, shell_compat, parts);
    return true;
  }
  else {
    return _encode_runes(s, bit8_display, shell_compat, parts);
  }
}

Str* maybe_shell_encode(Str* s) {
  return maybe_shell_encode(s, 0);
}

Str* maybe_shell_encode(Str* s, int flags) {
  int quote;
  int must_quote;
  int bit8_display;
  List<Str*>* parts = nullptr;
  bool valid_utf8;
  Str* prefix = nullptr;
  StackRoots _roots({&s, &parts, &prefix});

  quote = 0;
  must_quote = (flags & 4);
  bit8_display = (flags & 3);
  if (len(s) == 0) {
    quote = 1;
  }
  else {
    for (StrIter it(s); !it.Done(); it.Next()) {
      Str* ch = it.Value();
      StackRoots _for({&ch    });
      if ((!must_quote and IsPlainChar(ch))) {
        continue;
      }
      quote = 1;
      if ((str_contains(str1289, ch) or IsUnprintableLow(ch))) {
        quote = 2;
        break;
      }
    }
  }
  if (quote == 0) {
    return s;
  }
  parts = Alloc<List<Str*>>();
  valid_utf8 = _encode(s, bit8_display, true, parts);
  if ((!valid_utf8 or quote == 2)) {
    prefix = str1290;
  }
  else {
    prefix = str1291;
  }
  parts->append(str1292);
  return str_concat(prefix, str1293->join(parts));
}

Str* maybe_encode(Str* s) {
  return maybe_encode(s, BIT8_UTF8);
}

Str* maybe_encode(Str* s, int bit8_display) {
  int quote;
  List<Str*>* parts = nullptr;
  StackRoots _roots({&s, &parts});

  quote = 0;
  if (len(s) == 0) {
    quote = 1;
  }
  else {
    for (StrIter it(s); !it.Done(); it.Next()) {
      Str* ch = it.Value();
      StackRoots _for({&ch    });
      if (IsPlainChar(ch)) {
        continue;
      }
      quote = 1;
    }
  }
  if (!quote) {
    return s;
  }
  parts = Alloc<List<Str*>>();
  parts->append(str1294);
  _encode(s, bit8_display, false, parts);
  parts->append(str1295);
  return str1296->join(parts);
}

Str* encode(Str* s, int bit8_display) {
  List<Str*>* parts = nullptr;
  StackRoots _roots({&s, &parts});

  parts = Alloc<List<Str*>>();
  parts->append(str1297);
  _encode(s, bit8_display, false, parts);
  parts->append(str1298);
  return str1299->join(parts);
}

void _encode_bytes_x(Str* s, bool shell_compat, List<Str*>* parts) {
  Str* part = nullptr;
  StackRoots _roots({&s, &parts, &part});

  for (StrIter it(s); !it.Done(); it.Next()) {
    Str* byte = it.Value();
    StackRoots _for({&byte  });
    if (str_equals(byte, str1300)) {
      part = str1301;
    }
    else {
      if (str_equals(byte, str1302)) {
        part = str1303;
      }
      else {
        if (str_equals(byte, str1304)) {
          part = str1305;
        }
        else {
          if (str_equals(byte, str1306)) {
            part = str1307;
          }
          else {
            if (str_equals(byte, str1308)) {
              part = str1309;
            }
            else {
              if (str_equals(byte, str1310)) {
                part = shell_compat ? str1311 : str1312;
              }
              else {
                if (IsUnprintableLow(byte)) {
                  part = XEscape(byte);
                }
                else {
                  if (IsUnprintableHigh(byte)) {
                    part = XEscape(byte);
                  }
                  else {
                    part = byte;
                  }
                }
              }
            }
          }
        }
      }
    }
    parts->append(part);
  }
}
int Ascii = 0;
int Begin2 = 1;
int Begin3 = 2;
int Begin4 = 3;
int Cont = 4;
int Invalid = 5;
int Start = 0;
int B2_1 = 1;
int B3_1 = 2;
int B4_1 = 3;
int B3_2 = 4;
int B4_2 = 5;
int B4_3 = 6;

bool _encode_runes(Str* s, int bit8_display, bool shell_compat, List<Str*>* parts) {
  bool valid_utf8;
  int state;
  Str* r1 = nullptr;
  Str* r2 = nullptr;
  Str* r3 = nullptr;
  int b;
  int typ;
  Str* out = nullptr;
  int rune;
  StackRoots _roots({&s, &parts, &r1, &r2, &r3, &out});

  valid_utf8 = true;
  state = Start;
  r1 = str1313;
  r2 = str1314;
  r3 = str1315;
  for (StrIter it(s); !it.Done(); it.Next()) {
    Str* byte = it.Value();
    StackRoots _for({&byte  });
    b = ord(byte);
    if (b < 127) {
      typ = Ascii;
    }
    else {
      if ((b >> 6) == 2) {
        typ = Cont;
      }
      else {
        if ((b >> 5) == 6) {
          typ = Begin2;
        }
        else {
          if ((b >> 4) == 14) {
            typ = Begin3;
          }
          else {
            if ((b >> 3) == 30) {
              typ = Begin4;
            }
            else {
              typ = Invalid;
            }
          }
        }
      }
    }
    if (typ != Cont) {
      if (state >= B2_1) {
        valid_utf8 = false;
        parts->append(XEscape(r1));
      }
      if (state >= B3_2) {
        parts->append(XEscape(r2));
      }
      if (state >= B4_3) {
        parts->append(XEscape(r3));
      }
    }
    if (typ == Ascii) {
      state = Start;
      if (str_equals(byte, str1316)) {
        out = str1317;
      }
      else {
        if (str_equals(byte, str1318)) {
          out = str1319;
        }
        else {
          if (str_equals(byte, str1320)) {
            out = str1321;
          }
          else {
            if (str_equals(byte, str1322)) {
              out = str1323;
            }
            else {
              if (str_equals(byte, str1324)) {
                out = str1325;
              }
              else {
                if (str_equals(byte, str1326)) {
                  out = shell_compat ? str1327 : str1328;
                }
                else {
                  if (IsUnprintableLow(byte)) {
                    if (bit8_display == BIT8_U_ESCAPE) {
                      out = UEscape(ord(byte));
                    }
                    else {
                      out = XEscape(byte);
                    }
                  }
                  else {
                    out = byte;
                  }
                }
              }
            }
          }
        }
      }
      parts->append(out);
    }
    else {
      if (typ == Begin2) {
        state = B2_1;
        r1 = byte;
      }
      else {
        if (typ == Begin3) {
          state = B3_1;
          r1 = byte;
        }
        else {
          if (typ == Begin4) {
            state = B4_1;
            r1 = byte;
          }
          else {
            if (typ == Invalid) {
              state = Start;
              parts->append(XEscape(byte));
              valid_utf8 = false;
            }
            else {
              if (typ == Cont) {
                if (state == Start) {
                  parts->append(XEscape(byte));
                  valid_utf8 = false;
                }
                else {
                  if (state == B2_1) {
                    if (bit8_display == BIT8_UTF8) {
                      out = str_concat(r1, byte);
                    }
                    else {
                      rune = (ord(byte) & 63);
                      rune |= ((ord(r1) & 31) << 6);
                      out = UEscape(rune);
                    }
                    parts->append(out);
                    state = Start;
                  }
                  else {
                    if (state == B3_1) {
                      r2 = byte;
                      state = B3_2;
                    }
                    else {
                      if (state == B3_2) {
                        if (bit8_display == BIT8_UTF8) {
                          out = str_concat(str_concat(r1, r2), byte);
                        }
                        else {
                          rune = (ord(byte) & 63);
                          rune |= ((ord(r2) & 63) << 6);
                          rune |= ((ord(r1) & 15) << 12);
                          out = UEscape(rune);
                        }
                        parts->append(out);
                        state = Start;
                      }
                      else {
                        if (state == B4_1) {
                          r2 = byte;
                          state = B4_2;
                        }
                        else {
                          if (state == B4_2) {
                            r3 = byte;
                            state = B4_3;
                          }
                          else {
                            if (state == B4_3) {
                              if (bit8_display == BIT8_UTF8) {
                                out = str_concat(str_concat(str_concat(r1, r2), r3), byte);
                              }
                              else {
                                rune = (ord(byte) & 63);
                                rune |= ((ord(r3) & 63) << 6);
                                rune |= ((ord(r2) & 63) << 12);
                                rune |= ((ord(r1) & 7) << 18);
                                out = UEscape(rune);
                              }
                              parts->append(out);
                              state = Start;
                            }
                            else {
                              assert(0);  // AssertionError
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              else {
                assert(0);  // AssertionError
              }
            }
          }
        }
      }
    }
  }
  if (state >= B2_1) {
    valid_utf8 = false;
    parts->append(XEscape(r1));
  }
  if (state >= B3_2) {
    parts->append(XEscape(r2));
  }
  if (state >= B4_3) {
    parts->append(XEscape(r3));
  }
  return valid_utf8;
}

Str* maybe_qtt_encode(Str* s, int bit8_display) {
  StackRoots _roots({&s});

  throw Alloc<NotImplementedError>();
}

}  // define namespace qsn

namespace qsn_native {  // define

namespace Id = id_kind_asdl::Id;
using id_kind_asdl::Kind;
using syntax_asdl::Token;
using types_asdl::lex_mode_e;
using types_asdl::lex_mode_t;

bool IsWhitespace(Str* s) {
  StackRoots _roots({&s});

  for (StrIter it(s); !it.Done(); it.Next()) {
    Str* ch = it.Value();
    StackRoots _for({&ch  });
    if (!str_contains(str1329, ch)) {
      return false;
    }
  }
  return true;
}

List<syntax_asdl::Token*>* Parse(lexer::Lexer* lexer) {
  syntax_asdl::Token* tok = nullptr;
  List<syntax_asdl::Token*>* result = nullptr;
  id_kind_asdl::Kind_t kind;
  StackRoots _roots({&lexer, &tok, &result});

  tok = lexer->Read(lex_mode_e::QSN);
  result = Alloc<List<syntax_asdl::Token*>>();
  while (true) {
    tok = lexer->Read(lex_mode_e::QSN);
    if (tok->id == Id::Unknown_Tok) {
      p_die(fmt398(), tok);
    }
    kind = consts::GetKind(tok->id);
    if (kind != Kind::Char) {
      break;
    }
    result->append(tok);
  }
  if (tok->id != Id::Right_SingleQuote) {
    p_die(fmt399(), tok);
  }
  tok = lexer->Read(lex_mode_e::SQ_C);
  if (tok->id == Id::Char_Literals) {
    if (!IsWhitespace(tok->val)) {
      p_die(fmt400(), tok);
    }
    tok = lexer->Read(lex_mode_e::QSN);
  }
  if (tok->id != Id::Eof_Real) {
    p_die(fmt401(), tok);
  }
  return result;
}

}  // define namespace qsn_native

namespace builtin_bracket {  // define

namespace Id = id_kind_asdl::Id;
namespace value = runtime_asdl::value;
namespace word = syntax_asdl::word;
namespace word_e = syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::word__String;
namespace bool_expr = syntax_asdl::bool_expr;
using types_asdl::lex_mode_e;

_StringWordEmitter::_StringWordEmitter(runtime_asdl::cmd_value__Argv* cmd_val)  {
  field_mask_ |= maskof__StringWordEmitter();
  this->cmd_val = cmd_val;
  this->i = 0;
  this->n = len(cmd_val->argv);
}

syntax_asdl::word__String* _StringWordEmitter::ReadWord(types_asdl::lex_mode_t unused_lex_mode) {
  syntax_asdl::word__String* w = nullptr;
  Str* s = nullptr;
  int left_spid;
  int id_;
  StackRoots _roots({&w, &s});

  if (this->i == this->n) {
    w = Alloc<word::String>(Id::Eof_Real, str1334, runtime::NO_SPID);
    return w;
  }
  s = this->cmd_val->argv->index_(this->i);
  left_spid = this->cmd_val->arg_spids->index_(this->i);
  this->i += 1;
  id_ = match::BracketUnary(s);
  if (id_ == Id::Undefined_Tok) {
    id_ = match::BracketBinary(s);
  }
  if (id_ == Id::Undefined_Tok) {
    id_ = match::BracketOther(s);
  }
  if (id_ == Id::Undefined_Tok) {
    id_ = Id::Word_Compound;
  }
  w = Alloc<word::String>(id_, s, left_spid);
  return w;
}

syntax_asdl::word__String* _StringWordEmitter::Read() {
  return this->ReadWord(lex_mode_e::ShCommand);
}

Str* _StringWordEmitter::Peek(int offset) {
  return this->cmd_val->argv->index_((this->i + offset));
}

void _StringWordEmitter::Rewind(int offset) {
  this->i -= offset;
}

_WordEvaluator::_WordEvaluator() : word_eval::StringWordEvaluator() {
}

runtime_asdl::value__Str* _WordEvaluator::EvalWordToString(syntax_asdl::word_t* w) {
  return EvalWordToString(w, 0);
}

runtime_asdl::value__Str* _WordEvaluator::EvalWordToString(syntax_asdl::word_t* w, int eval_flags) {
  StackRoots _roots({&w});

  word__String* string_word = static_cast<word__String*>(w);
  return Alloc<value::Str>(string_word->s);
}

syntax_asdl::bool_expr_t* _TwoArgs(builtin_bracket::_StringWordEmitter* w_parser) {
  syntax_asdl::word__String* w0 = nullptr;
  syntax_asdl::word__String* w1 = nullptr;
  Str* s0 = nullptr;
  int unary_id;
  StackRoots _roots({&w_parser, &w0, &w1, &s0});

  w0 = w_parser->Read();
  w1 = w_parser->Read();
  s0 = w0->s;
  if (maybe_str_equals(s0, str1335)) {
    return Alloc<bool_expr::LogicalNot>(Alloc<bool_expr::WordTest>(w1));
  }
  unary_id = Id::Undefined_Tok;
  if (w0->s->startswith(str1336)) {
    if (maybe_str_equals(s0, str1337)) {
      unary_id = Id::BoolUnary_d;
    }
    else {
      if (maybe_str_equals(s0, str1338)) {
        unary_id = Id::BoolUnary_e;
      }
      else {
        if (maybe_str_equals(s0, str1339)) {
          unary_id = Id::BoolUnary_f;
        }
        else {
          if (maybe_str_equals(s0, str1340)) {
            unary_id = Id::BoolUnary_L;
          }
        }
      }
    }
  }
  if (unary_id == Id::Undefined_Tok) {
    unary_id = match::BracketUnary(w0->s);
  }
  if (unary_id == Id::Undefined_Tok) {
    p_die(fmt402(w0->s), w0);
  }
  return Alloc<bool_expr::Unary>(unary_id, w1);
}

syntax_asdl::bool_expr_t* _ThreeArgs(builtin_bracket::_StringWordEmitter* w_parser) {
  syntax_asdl::word__String* w0 = nullptr;
  syntax_asdl::word__String* w1 = nullptr;
  syntax_asdl::word__String* w2 = nullptr;
  int binary_id;
  syntax_asdl::bool_expr_t* child = nullptr;
  StackRoots _roots({&w_parser, &w0, &w1, &w2, &child});

  w0 = w_parser->Read();
  w1 = w_parser->Read();
  w2 = w_parser->Read();
  binary_id = match::BracketBinary(w1->s);
  if (binary_id != Id::Undefined_Tok) {
    return Alloc<bool_expr::Binary>(binary_id, w0, w2);
  }
  if (maybe_str_equals(w1->s, str1342)) {
    return Alloc<bool_expr::LogicalAnd>(Alloc<bool_expr::WordTest>(w0), Alloc<bool_expr::WordTest>(w2));
  }
  if (maybe_str_equals(w1->s, str1343)) {
    return Alloc<bool_expr::LogicalOr>(Alloc<bool_expr::WordTest>(w0), Alloc<bool_expr::WordTest>(w2));
  }
  if (maybe_str_equals(w0->s, str1344)) {
    w_parser->Rewind(2);
    child = _TwoArgs(w_parser);
    return Alloc<bool_expr::LogicalNot>(child);
  }
  if ((maybe_str_equals(w0->s, str1345) and maybe_str_equals(w2->s, str1346))) {
    return Alloc<bool_expr::WordTest>(w1);
  }
  p_die(fmt403(w1->s), w1);
}

Test::Test(bool need_right_bracket, optview::Exec* exec_opts, state::Mem* mem, ui::ErrorFormatter* errfmt)  {
  field_mask_ |= maskof_Test();
  this->need_right_bracket = need_right_bracket;
  this->exec_opts = exec_opts;
  this->mem = mem;
  this->errfmt = errfmt;
}

int Test::Run(runtime_asdl::cmd_value__Argv* cmd_val) {
  List<Str*>* strs = nullptr;
  builtin_bracket::_StringWordEmitter* w_parser = nullptr;
  bool_parse::BoolParser* b_parser = nullptr;
  syntax_asdl::bool_expr_t* bool_node = nullptr;
  int n;
  syntax_asdl::word__String* w = nullptr;
  Str* a0 = nullptr;
  syntax_asdl::bool_expr_t* child = nullptr;
  builtin_bracket::_WordEvaluator* word_ev = nullptr;
  sh_expr_eval::BoolEvaluator* bool_ev = nullptr;
  bool b;
  int status;
  StackRoots _roots({&cmd_val, &strs, &w_parser, &b_parser, &bool_node, &w, &a0, &child, &word_ev, &bool_ev});

  if (this->need_right_bracket) {
    if (this->exec_opts->simple_test_builtin()) {
      e_usage(str1348);
    }
    strs = cmd_val->argv;
    if ((!strs or !(str_equals(strs->index_(-1), str1349)))) {
      this->errfmt->Print_(str1350, cmd_val->arg_spids->index_(0));
      return 2;
    }
    cmd_val->argv->pop();
    cmd_val->arg_spids->pop();
  }
  w_parser = Alloc<_StringWordEmitter>(cmd_val);
  w_parser->Read();
  b_parser = Alloc<bool_parse::BoolParser>(w_parser);
  bool_node = nullptr;
  n = (len(cmd_val->argv) - 1);
  if ((this->exec_opts->simple_test_builtin() and n > 3)) {
    e_usage(str1351);
  }
  try {
    if (n == 0) {
      return 1;
    }
    else {
      if (n == 1) {
        w = w_parser->Read();
        bool_node = Alloc<bool_expr::WordTest>(w);
      }
      else {
        if (n == 2) {
          bool_node = _TwoArgs(w_parser);
        }
        else {
          if (n == 3) {
            bool_node = _ThreeArgs(w_parser);
          }
        }
      }
    }
    if (n == 4) {
      a0 = w_parser->Peek(0);
      if (str_equals(a0, str1352)) {
        w_parser->Read();
        child = _ThreeArgs(w_parser);
        bool_node = Alloc<bool_expr::LogicalNot>(child);
      }
      else {
        if ((str_equals(a0, str1353) and str_equals(w_parser->Peek(3), str1354))) {
          w_parser->Read();
          bool_node = _TwoArgs(w_parser);
        }
        else {
          ;  // pass
        }
      }
    }
    if (bool_node == nullptr) {
      bool_node = b_parser->ParseForBuiltin();
    }
  }
  catch (error::Parse* e) {
    this->errfmt->PrettyPrintError(e, str1355);
    return 2;
  }
  word_ev = Alloc<_WordEvaluator>();
  bool_ev = Alloc<sh_expr_eval::BoolEvaluator>(this->mem, this->exec_opts, nullptr, this->errfmt);
  bool_ev->Init_AlwaysStrict();
  bool_ev->word_ev = word_ev;
  bool_ev->CheckCircularDeps();
  try {
    b = bool_ev->EvalB(bool_node);
  }
  catch (error::_ErrorWithLocation* e) {
    this->errfmt->PrettyPrintError(e, str1356);
    return 2;
  }
  status = b ? 0 : 1;
  return status;
}

}  // define namespace builtin_bracket

int main(int argc, char **argv) {

  complain_loudly_on_segfault();

  // So big that we don't trigger collection
  gHeap.Init(400 << 20);

  // NOTE(Jesse): Turn off buffered IO
  setvbuf(stdout, 0, _IONBF, 0);
  setvbuf(stderr, 0, _IONBF, 0);

  auto* args = Alloc<List<Str*>>();
  for (int i = 0; i < argc; ++i) {
    args->append(StrFromC(argv[i]));
  }
  int status = 0;

  // For benchmarking
  const char* repeat = getenv("REPEAT");
  if (repeat) {
    Str* r = StrFromC(repeat);
    int n = to_int(r);
    log("Running %d times", n);
    for (int i = 0; i < n; ++i) { 
      status = osh_eval::main(args);
    }
    // TODO: clear memory?
  } else {
    status = osh_eval::main(args);
  }

  gHeap.OnProcessExit();

  return status;
}
