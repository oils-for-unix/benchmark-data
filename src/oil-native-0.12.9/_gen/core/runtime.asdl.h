// _gen/core/runtime.asdl.h is generated by asdl_main.py

#ifndef RUNTIME_ASDL
#define RUNTIME_ASDL

#include <cstdint>

#include "mycpp/runtime.h"
#include "_gen/asdl/hnode.asdl.h"
using hnode_asdl::hnode_t;

#include "_gen/frontend/id_kind.asdl.h"
using id_kind_asdl::Id_t;

namespace syntax_asdl { class ArgList; class command_t; class re_t; class redir_loc_t; class BraceGroup; class Token; class proc_sig_t; }

namespace runtime_asdl {

class assign_arg;
class cmd_value_t;
class part_value_t;
class value_t;
class a_index_t;
class VTestPlace;
class VarSubState;
class cell;
class lvalue_t;
class redirect_arg_t;
class redirect;
class Proc;
class StatusArray;
class CommandStatus;
class wait_status_t;
class trace_t;
class hay_node;

namespace cmd_value_e {
  const int Argv = 1;
  const int Assign = 2;
};

const char* cmd_value_str(int tag);

class cmd_value_t {
 protected:
  cmd_value_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(cmd_value_t)
};

class cmd_value__Argv : public cmd_value_t {
 public:
  cmd_value__Argv();
  cmd_value__Argv(List<Str*>* argv, List<int>* arg_spids, syntax_asdl::ArgList*
                  typed_args);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<Str*>* argv;
  List<int>* arg_spids;
  syntax_asdl::ArgList* typed_args;

  DISALLOW_COPY_AND_ASSIGN(cmd_value__Argv)
};

constexpr uint16_t maskof_cmd_value__Argv() {
  return
    maskbit(offsetof(cmd_value__Argv, argv))
  | maskbit(offsetof(cmd_value__Argv, arg_spids))
  | maskbit(offsetof(cmd_value__Argv, typed_args));
}

inline cmd_value__Argv::cmd_value__Argv()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(cmd_value_e::Argv)),
      field_mask_(maskof_cmd_value__Argv()),
      argv(NewList<Str*>()),
      arg_spids(NewList<int>()),
      typed_args(nullptr) {
}

inline cmd_value__Argv::cmd_value__Argv(List<Str*>* argv, List<int>* arg_spids,
                                        syntax_asdl::ArgList* typed_args)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(cmd_value_e::Argv)),
      field_mask_(maskof_cmd_value__Argv()),
      argv(argv),
      arg_spids(arg_spids),
      typed_args(typed_args) {
}

class cmd_value__Assign : public cmd_value_t {
 public:
  cmd_value__Assign();
  cmd_value__Assign(int builtin_id, List<Str*>* argv, List<int>* arg_spids,
                    List<assign_arg*>* pairs);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int builtin_id;
  List<Str*>* argv;
  List<int>* arg_spids;
  List<assign_arg*>* pairs;

  DISALLOW_COPY_AND_ASSIGN(cmd_value__Assign)
};

constexpr uint16_t maskof_cmd_value__Assign() {
  return
    maskbit(offsetof(cmd_value__Assign, argv))
  | maskbit(offsetof(cmd_value__Assign, arg_spids))
  | maskbit(offsetof(cmd_value__Assign, pairs));
}

inline cmd_value__Assign::cmd_value__Assign()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(cmd_value_e::Assign)),
      field_mask_(maskof_cmd_value__Assign()),
      builtin_id(-1),
      argv(NewList<Str*>()),
      arg_spids(NewList<int>()),
      pairs(NewList<assign_arg*>()) {
}

inline cmd_value__Assign::cmd_value__Assign(int builtin_id, List<Str*>* argv,
                                            List<int>* arg_spids,
                                            List<assign_arg*>* pairs)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(cmd_value_e::Assign)),
      field_mask_(maskof_cmd_value__Assign()),
      builtin_id(builtin_id),
      argv(argv),
      arg_spids(arg_spids),
      pairs(pairs) {
}

namespace cmd_value {
  typedef cmd_value__Argv Argv;
  typedef cmd_value__Assign Assign;
}

namespace part_value_e {
  const int String = 1;
  const int Array = 2;
  const int ExtGlob = 3;
};

const char* part_value_str(int tag);

class part_value_t {
 protected:
  part_value_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(part_value_t)
};

class part_value__String : public part_value_t {
 public:
  part_value__String();
  part_value__String(Str* s, bool quoted, bool do_split);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* s;
  bool quoted;
  bool do_split;

  DISALLOW_COPY_AND_ASSIGN(part_value__String)
};

constexpr uint16_t maskof_part_value__String() {
  return
    maskbit(offsetof(part_value__String, s));
}

inline part_value__String::part_value__String()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(part_value_e::String)),
      field_mask_(maskof_part_value__String()),
      s(StrFromC("")),
      quoted(false),
      do_split(false) {
}

inline part_value__String::part_value__String(Str* s, bool quoted, bool
                                              do_split)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(part_value_e::String)),
      field_mask_(maskof_part_value__String()),
      s(s),
      quoted(quoted),
      do_split(do_split) {
}

class part_value__Array : public part_value_t {
 public:
  part_value__Array();
  part_value__Array(List<Str*>* strs);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<Str*>* strs;

  DISALLOW_COPY_AND_ASSIGN(part_value__Array)
};

constexpr uint16_t maskof_part_value__Array() {
  return
    maskbit(offsetof(part_value__Array, strs));
}

inline part_value__Array::part_value__Array()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(part_value_e::Array)),
      field_mask_(maskof_part_value__Array()),
      strs(NewList<Str*>()) {
}

inline part_value__Array::part_value__Array(List<Str*>* strs)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(part_value_e::Array)),
      field_mask_(maskof_part_value__Array()),
      strs(strs) {
}

class part_value__ExtGlob : public part_value_t {
 public:
  part_value__ExtGlob();
  part_value__ExtGlob(List<part_value_t*>* part_vals);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<part_value_t*>* part_vals;

  DISALLOW_COPY_AND_ASSIGN(part_value__ExtGlob)
};

constexpr uint16_t maskof_part_value__ExtGlob() {
  return
    maskbit(offsetof(part_value__ExtGlob, part_vals));
}

inline part_value__ExtGlob::part_value__ExtGlob()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(part_value_e::ExtGlob)),
      field_mask_(maskof_part_value__ExtGlob()),
      part_vals(NewList<part_value_t*>()) {
}

inline part_value__ExtGlob::part_value__ExtGlob(List<part_value_t*>* part_vals)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(part_value_e::ExtGlob)),
      field_mask_(maskof_part_value__ExtGlob()),
      part_vals(part_vals) {
}

namespace part_value {
  typedef part_value__String String;
  typedef part_value__Array Array;
  typedef part_value__ExtGlob ExtGlob;
}

namespace value_e {
  const int Undef = 1;
  const int Str = 2;
  const int Int = 3;
  const int MaybeStrArray = 4;
  const int AssocArray = 5;
  const int Bool = 6;
  const int Float = 7;
  const int Eggex = 8;
  const int Block = 9;
  const int Obj = 10;
};

const char* value_str(int tag);

class value_t {
 protected:
  value_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(value_t)
};

class value__Undef : public value_t {
 public:
  value__Undef();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(value__Undef)
};

inline value__Undef::value__Undef()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Undef)),
      field_mask_(kZeroMask) {
}

class value__Str : public value_t {
 public:
  value__Str();
  value__Str(Str* s);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* s;

  DISALLOW_COPY_AND_ASSIGN(value__Str)
};

constexpr uint16_t maskof_value__Str() {
  return
    maskbit(offsetof(value__Str, s));
}

inline value__Str::value__Str()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Str)),
      field_mask_(maskof_value__Str()),
      s(StrFromC("")) {
}

inline value__Str::value__Str(Str* s)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Str)),
      field_mask_(maskof_value__Str()),
      s(s) {
}

class value__Int : public value_t {
 public:
  value__Int();
  value__Int(int i);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int i;

  DISALLOW_COPY_AND_ASSIGN(value__Int)
};

inline value__Int::value__Int()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Int)),
      field_mask_(kZeroMask),
      i(-1) {
}

inline value__Int::value__Int(int i)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Int)),
      field_mask_(kZeroMask),
      i(i) {
}

class value__MaybeStrArray : public value_t {
 public:
  value__MaybeStrArray();
  value__MaybeStrArray(List<Str*>* strs);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<Str*>* strs;

  DISALLOW_COPY_AND_ASSIGN(value__MaybeStrArray)
};

constexpr uint16_t maskof_value__MaybeStrArray() {
  return
    maskbit(offsetof(value__MaybeStrArray, strs));
}

inline value__MaybeStrArray::value__MaybeStrArray()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::MaybeStrArray)),
      field_mask_(maskof_value__MaybeStrArray()),
      strs(NewList<Str*>()) {
}

inline value__MaybeStrArray::value__MaybeStrArray(List<Str*>* strs)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::MaybeStrArray)),
      field_mask_(maskof_value__MaybeStrArray()),
      strs(strs) {
}

class value__AssocArray : public value_t {
 public:
  value__AssocArray();
  value__AssocArray(Dict<Str*, Str*>* d);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Dict<Str*, Str*>* d;

  DISALLOW_COPY_AND_ASSIGN(value__AssocArray)
};

constexpr uint16_t maskof_value__AssocArray() {
  return
    maskbit(offsetof(value__AssocArray, d));
}

inline value__AssocArray::value__AssocArray()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::AssocArray)),
      field_mask_(maskof_value__AssocArray()),
      d(NewDict<Str*, Str*>()) {
}

inline value__AssocArray::value__AssocArray(Dict<Str*, Str*>* d)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::AssocArray)),
      field_mask_(maskof_value__AssocArray()),
      d(d) {
}

class value__Bool : public value_t {
 public:
  value__Bool();
  value__Bool(bool b);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool b;

  DISALLOW_COPY_AND_ASSIGN(value__Bool)
};

inline value__Bool::value__Bool()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Bool)),
      field_mask_(kZeroMask),
      b(false) {
}

inline value__Bool::value__Bool(bool b)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Bool)),
      field_mask_(kZeroMask),
      b(b) {
}

class value__Float : public value_t {
 public:
  value__Float();
  value__Float(double f);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  double f;

  DISALLOW_COPY_AND_ASSIGN(value__Float)
};

inline value__Float::value__Float()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Float)),
      field_mask_(kZeroMask),
      f(0.0) {
}

inline value__Float::value__Float(double f)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Float)),
      field_mask_(kZeroMask),
      f(f) {
}

class value__Eggex : public value_t {
 public:
  value__Eggex();
  value__Eggex(syntax_asdl::re_t* expr, Str* as_ere);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  syntax_asdl::re_t* expr;
  Str* as_ere;

  DISALLOW_COPY_AND_ASSIGN(value__Eggex)
};

constexpr uint16_t maskof_value__Eggex() {
  return
    maskbit(offsetof(value__Eggex, expr))
  | maskbit(offsetof(value__Eggex, as_ere));
}

inline value__Eggex::value__Eggex()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Eggex)),
      field_mask_(maskof_value__Eggex()),
      expr(nullptr),
      as_ere(StrFromC("")) {
}

inline value__Eggex::value__Eggex(syntax_asdl::re_t* expr, Str* as_ere)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Eggex)),
      field_mask_(maskof_value__Eggex()),
      expr(expr),
      as_ere(as_ere) {
}

class value__Block : public value_t {
 public:
  value__Block();
  value__Block(syntax_asdl::command_t* body);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  syntax_asdl::command_t* body;

  DISALLOW_COPY_AND_ASSIGN(value__Block)
};

constexpr uint16_t maskof_value__Block() {
  return
    maskbit(offsetof(value__Block, body));
}

inline value__Block::value__Block()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Block)),
      field_mask_(maskof_value__Block()),
      body(nullptr) {
}

inline value__Block::value__Block(syntax_asdl::command_t* body)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Block)),
      field_mask_(maskof_value__Block()),
      body(body) {
}

class value__Obj : public value_t {
 public:
  value__Obj();
  value__Obj(void* obj);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  void* obj;

  DISALLOW_COPY_AND_ASSIGN(value__Obj)
};

constexpr uint16_t maskof_value__Obj() {
  return
    maskbit(offsetof(value__Obj, obj));
}

inline value__Obj::value__Obj()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Obj)),
      field_mask_(maskof_value__Obj()),
      obj(nullptr) {
}

inline value__Obj::value__Obj(void* obj)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(value_e::Obj)),
      field_mask_(maskof_value__Obj()),
      obj(obj) {
}

namespace value {
  typedef value__Undef Undef;
  typedef value__Str Str;
  typedef value__Int Int;
  typedef value__MaybeStrArray MaybeStrArray;
  typedef value__AssocArray AssocArray;
  typedef value__Bool Bool;
  typedef value__Float Float;
  typedef value__Eggex Eggex;
  typedef value__Block Block;
  typedef value__Obj Obj;
}

namespace a_index_e {
  const int Str = 1;
  const int Int = 2;
};

const char* a_index_str(int tag);

class a_index_t {
 protected:
  a_index_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(a_index_t)
};

class a_index__Str : public a_index_t {
 public:
  a_index__Str();
  a_index__Str(Str* s);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* s;

  DISALLOW_COPY_AND_ASSIGN(a_index__Str)
};

constexpr uint16_t maskof_a_index__Str() {
  return
    maskbit(offsetof(a_index__Str, s));
}

inline a_index__Str::a_index__Str()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(a_index_e::Str)),
      field_mask_(maskof_a_index__Str()),
      s(StrFromC("")) {
}

inline a_index__Str::a_index__Str(Str* s)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(a_index_e::Str)),
      field_mask_(maskof_a_index__Str()),
      s(s) {
}

class a_index__Int : public a_index_t {
 public:
  a_index__Int();
  a_index__Int(int i);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int i;

  DISALLOW_COPY_AND_ASSIGN(a_index__Int)
};

inline a_index__Int::a_index__Int()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(a_index_e::Int)),
      field_mask_(kZeroMask),
      i(-1) {
}

inline a_index__Int::a_index__Int(int i)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(a_index_e::Int)),
      field_mask_(kZeroMask),
      i(i) {
}

namespace a_index {
  typedef a_index__Str Str;
  typedef a_index__Int Int;
}

enum class scope_e {
  Parent = 1,
  Shopt = 2,
  Dynamic = 3,
  LocalOrGlobal = 4,
  LocalOnly = 5,
  GlobalOnly = 6,
};
typedef scope_e scope_t;

const char* scope_str(scope_e tag);

namespace lvalue_e {
  const int Named = 1;
  const int Indexed = 2;
  const int Keyed = 3;
  const int ObjIndex = 4;
  const int ObjAttr = 5;
};

const char* lvalue_str(int tag);

class lvalue_t {
 protected:
  lvalue_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(lvalue_t)
};

class lvalue__Named : public lvalue_t {
 public:
  lvalue__Named();
  lvalue__Named(Str* name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* name;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(lvalue__Named)
};

constexpr uint16_t maskof_lvalue__Named() {
  return
    maskbit(offsetof(lvalue__Named, name))
  | maskbit(offsetof(lvalue__Named, spids));
}

inline lvalue__Named::lvalue__Named()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(lvalue_e::Named)),
      field_mask_(maskof_lvalue__Named()),
      name(StrFromC("")),
      spids(NewList<int>()) {
}

inline lvalue__Named::lvalue__Named(Str* name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(lvalue_e::Named)),
      field_mask_(maskof_lvalue__Named()),
      name(name),
      spids(NewList<int>()) {
}

class lvalue__Indexed : public lvalue_t {
 public:
  lvalue__Indexed();
  lvalue__Indexed(Str* name, int index);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* name;
  int index;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(lvalue__Indexed)
};

constexpr uint16_t maskof_lvalue__Indexed() {
  return
    maskbit(offsetof(lvalue__Indexed, name))
  | maskbit(offsetof(lvalue__Indexed, spids));
}

inline lvalue__Indexed::lvalue__Indexed()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(lvalue_e::Indexed)),
      field_mask_(maskof_lvalue__Indexed()),
      name(StrFromC("")),
      index(-1),
      spids(NewList<int>()) {
}

inline lvalue__Indexed::lvalue__Indexed(Str* name, int index)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(lvalue_e::Indexed)),
      field_mask_(maskof_lvalue__Indexed()),
      name(name),
      index(index),
      spids(NewList<int>()) {
}

class lvalue__Keyed : public lvalue_t {
 public:
  lvalue__Keyed();
  lvalue__Keyed(Str* name, Str* key);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* name;
  Str* key;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(lvalue__Keyed)
};

constexpr uint16_t maskof_lvalue__Keyed() {
  return
    maskbit(offsetof(lvalue__Keyed, name))
  | maskbit(offsetof(lvalue__Keyed, key))
  | maskbit(offsetof(lvalue__Keyed, spids));
}

inline lvalue__Keyed::lvalue__Keyed()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(lvalue_e::Keyed)),
      field_mask_(maskof_lvalue__Keyed()),
      name(StrFromC("")),
      key(StrFromC("")),
      spids(NewList<int>()) {
}

inline lvalue__Keyed::lvalue__Keyed(Str* name, Str* key)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(lvalue_e::Keyed)),
      field_mask_(maskof_lvalue__Keyed()),
      name(name),
      key(key),
      spids(NewList<int>()) {
}

class lvalue__ObjIndex : public lvalue_t {
 public:
  lvalue__ObjIndex();
  lvalue__ObjIndex(void* obj, void* index);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  void* obj;
  void* index;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(lvalue__ObjIndex)
};

constexpr uint16_t maskof_lvalue__ObjIndex() {
  return
    maskbit(offsetof(lvalue__ObjIndex, obj))
  | maskbit(offsetof(lvalue__ObjIndex, index))
  | maskbit(offsetof(lvalue__ObjIndex, spids));
}

inline lvalue__ObjIndex::lvalue__ObjIndex()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(lvalue_e::ObjIndex)),
      field_mask_(maskof_lvalue__ObjIndex()),
      obj(nullptr),
      index(nullptr),
      spids(NewList<int>()) {
}

inline lvalue__ObjIndex::lvalue__ObjIndex(void* obj, void* index)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(lvalue_e::ObjIndex)),
      field_mask_(maskof_lvalue__ObjIndex()),
      obj(obj),
      index(index),
      spids(NewList<int>()) {
}

class lvalue__ObjAttr : public lvalue_t {
 public:
  lvalue__ObjAttr();
  lvalue__ObjAttr(void* obj, Str* attr);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  void* obj;
  Str* attr;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(lvalue__ObjAttr)
};

constexpr uint16_t maskof_lvalue__ObjAttr() {
  return
    maskbit(offsetof(lvalue__ObjAttr, obj))
  | maskbit(offsetof(lvalue__ObjAttr, attr))
  | maskbit(offsetof(lvalue__ObjAttr, spids));
}

inline lvalue__ObjAttr::lvalue__ObjAttr()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(lvalue_e::ObjAttr)),
      field_mask_(maskof_lvalue__ObjAttr()),
      obj(nullptr),
      attr(StrFromC("")),
      spids(NewList<int>()) {
}

inline lvalue__ObjAttr::lvalue__ObjAttr(void* obj, Str* attr)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(lvalue_e::ObjAttr)),
      field_mask_(maskof_lvalue__ObjAttr()),
      obj(obj),
      attr(attr),
      spids(NewList<int>()) {
}

namespace lvalue {
  typedef lvalue__Named Named;
  typedef lvalue__Indexed Indexed;
  typedef lvalue__Keyed Keyed;
  typedef lvalue__ObjIndex ObjIndex;
  typedef lvalue__ObjAttr ObjAttr;
}

namespace redirect_arg_e {
  const int Path = 1;
  const int CopyFd = 2;
  const int MoveFd = 3;
  const int CloseFd = 4;
  const int HereDoc = 5;
};

const char* redirect_arg_str(int tag);

class redirect_arg_t {
 protected:
  redirect_arg_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(redirect_arg_t)
};

class redirect_arg__Path : public redirect_arg_t {
 public:
  redirect_arg__Path();
  redirect_arg__Path(Str* filename);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* filename;

  DISALLOW_COPY_AND_ASSIGN(redirect_arg__Path)
};

constexpr uint16_t maskof_redirect_arg__Path() {
  return
    maskbit(offsetof(redirect_arg__Path, filename));
}

inline redirect_arg__Path::redirect_arg__Path()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redirect_arg_e::Path)),
      field_mask_(maskof_redirect_arg__Path()),
      filename(StrFromC("")) {
}

inline redirect_arg__Path::redirect_arg__Path(Str* filename)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redirect_arg_e::Path)),
      field_mask_(maskof_redirect_arg__Path()),
      filename(filename) {
}

class redirect_arg__CopyFd : public redirect_arg_t {
 public:
  redirect_arg__CopyFd();
  redirect_arg__CopyFd(int target_fd);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int target_fd;

  DISALLOW_COPY_AND_ASSIGN(redirect_arg__CopyFd)
};

inline redirect_arg__CopyFd::redirect_arg__CopyFd()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redirect_arg_e::CopyFd)),
      field_mask_(kZeroMask),
      target_fd(-1) {
}

inline redirect_arg__CopyFd::redirect_arg__CopyFd(int target_fd)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redirect_arg_e::CopyFd)),
      field_mask_(kZeroMask),
      target_fd(target_fd) {
}

class redirect_arg__MoveFd : public redirect_arg_t {
 public:
  redirect_arg__MoveFd();
  redirect_arg__MoveFd(int target_fd);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int target_fd;

  DISALLOW_COPY_AND_ASSIGN(redirect_arg__MoveFd)
};

inline redirect_arg__MoveFd::redirect_arg__MoveFd()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redirect_arg_e::MoveFd)),
      field_mask_(kZeroMask),
      target_fd(-1) {
}

inline redirect_arg__MoveFd::redirect_arg__MoveFd(int target_fd)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redirect_arg_e::MoveFd)),
      field_mask_(kZeroMask),
      target_fd(target_fd) {
}

class redirect_arg__CloseFd : public redirect_arg_t {
 public:
  redirect_arg__CloseFd();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(redirect_arg__CloseFd)
};

inline redirect_arg__CloseFd::redirect_arg__CloseFd()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redirect_arg_e::CloseFd)),
      field_mask_(kZeroMask) {
}

class redirect_arg__HereDoc : public redirect_arg_t {
 public:
  redirect_arg__HereDoc();
  redirect_arg__HereDoc(Str* body);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* body;

  DISALLOW_COPY_AND_ASSIGN(redirect_arg__HereDoc)
};

constexpr uint16_t maskof_redirect_arg__HereDoc() {
  return
    maskbit(offsetof(redirect_arg__HereDoc, body));
}

inline redirect_arg__HereDoc::redirect_arg__HereDoc()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redirect_arg_e::HereDoc)),
      field_mask_(maskof_redirect_arg__HereDoc()),
      body(StrFromC("")) {
}

inline redirect_arg__HereDoc::redirect_arg__HereDoc(Str* body)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redirect_arg_e::HereDoc)),
      field_mask_(maskof_redirect_arg__HereDoc()),
      body(body) {
}

namespace redirect_arg {
  typedef redirect_arg__Path Path;
  typedef redirect_arg__CopyFd CopyFd;
  typedef redirect_arg__MoveFd MoveFd;
  typedef redirect_arg__CloseFd CloseFd;
  typedef redirect_arg__HereDoc HereDoc;
}

namespace wait_status_e {
  const int Proc = 1;
  const int Pipeline = 2;
  const int Cancelled = 3;
};

const char* wait_status_str(int tag);

class wait_status_t {
 protected:
  wait_status_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(wait_status_t)
};

class wait_status__Proc : public wait_status_t {
 public:
  wait_status__Proc();
  wait_status__Proc(int code);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int code;

  DISALLOW_COPY_AND_ASSIGN(wait_status__Proc)
};

inline wait_status__Proc::wait_status__Proc()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(wait_status_e::Proc)),
      field_mask_(kZeroMask),
      code(-1) {
}

inline wait_status__Proc::wait_status__Proc(int code)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(wait_status_e::Proc)),
      field_mask_(kZeroMask),
      code(code) {
}

class wait_status__Pipeline : public wait_status_t {
 public:
  wait_status__Pipeline();
  wait_status__Pipeline(List<int>* codes);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<int>* codes;

  DISALLOW_COPY_AND_ASSIGN(wait_status__Pipeline)
};

constexpr uint16_t maskof_wait_status__Pipeline() {
  return
    maskbit(offsetof(wait_status__Pipeline, codes));
}

inline wait_status__Pipeline::wait_status__Pipeline()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(wait_status_e::Pipeline)),
      field_mask_(maskof_wait_status__Pipeline()),
      codes(NewList<int>()) {
}

inline wait_status__Pipeline::wait_status__Pipeline(List<int>* codes)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(wait_status_e::Pipeline)),
      field_mask_(maskof_wait_status__Pipeline()),
      codes(codes) {
}

class wait_status__Cancelled : public wait_status_t {
 public:
  wait_status__Cancelled();
  wait_status__Cancelled(int sig_num);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int sig_num;

  DISALLOW_COPY_AND_ASSIGN(wait_status__Cancelled)
};

inline wait_status__Cancelled::wait_status__Cancelled()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(wait_status_e::Cancelled)),
      field_mask_(kZeroMask),
      sig_num(-1) {
}

inline wait_status__Cancelled::wait_status__Cancelled(int sig_num)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(wait_status_e::Cancelled)),
      field_mask_(kZeroMask),
      sig_num(sig_num) {
}

namespace wait_status {
  typedef wait_status__Proc Proc;
  typedef wait_status__Pipeline Pipeline;
  typedef wait_status__Cancelled Cancelled;
}

enum class span_e {
  Black = 1,
  Delim = 2,
  Backslash = 3,
};
typedef span_e span_t;

const char* span_str(span_e tag);

namespace emit_i {
  const int Part = 1;
  const int Delim = 2;
  const int Empty = 3;
  const int Escape = 4;
  const int Nothing = 5;
  const int ARRAY_SIZE = 6;
};

const char* emit_str(int tag);

typedef int emit_t;

namespace state_i {
  const int Invalid = 1;
  const int Start = 2;
  const int DE_White1 = 3;
  const int DE_Gray = 4;
  const int DE_White2 = 5;
  const int Black = 6;
  const int Backslash = 7;
  const int Done = 8;
  const int ARRAY_SIZE = 9;
};

const char* state_str(int tag);

typedef int state_t;

namespace char_kind_i {
  const int DE_White = 1;
  const int DE_Gray = 2;
  const int Black = 3;
  const int Backslash = 4;
  const int Sentinel = 5;
  const int ARRAY_SIZE = 6;
};

const char* char_kind_str(int tag);

typedef int char_kind_t;

enum class job_state_e {
  Running = 1,
  Done = 2,
  Stopped = 3,
};
typedef job_state_e job_state_t;

const char* job_state_str(job_state_e tag);

enum class flag_type_e {
  Bool = 1,
  Int = 2,
  Float = 3,
  Str = 4,
};
typedef flag_type_e flag_type_t;

const char* flag_type_str(flag_type_e tag);

namespace trace_e {
  const int External = 1;
  const int CommandSub = 2;
  const int ForkWait = 3;
  const int Fork = 4;
  const int PipelinePart = 5;
  const int ProcessSub = 6;
  const int HereDoc = 7;
};

const char* trace_str(int tag);

class trace_t {
 protected:
  trace_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(trace_t)
};

class trace__External : public trace_t {
 public:
  trace__External();
  trace__External(List<Str*>* argv);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<Str*>* argv;

  DISALLOW_COPY_AND_ASSIGN(trace__External)
};

constexpr uint16_t maskof_trace__External() {
  return
    maskbit(offsetof(trace__External, argv));
}

inline trace__External::trace__External()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(trace_e::External)),
      field_mask_(maskof_trace__External()),
      argv(NewList<Str*>()) {
}

inline trace__External::trace__External(List<Str*>* argv)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(trace_e::External)),
      field_mask_(maskof_trace__External()),
      argv(argv) {
}

class trace__CommandSub : public trace_t {
 public:
  trace__CommandSub();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(trace__CommandSub)
};

inline trace__CommandSub::trace__CommandSub()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(trace_e::CommandSub)),
      field_mask_(kZeroMask) {
}

class trace__ForkWait : public trace_t {
 public:
  trace__ForkWait();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(trace__ForkWait)
};

inline trace__ForkWait::trace__ForkWait()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(trace_e::ForkWait)),
      field_mask_(kZeroMask) {
}

class trace__Fork : public trace_t {
 public:
  trace__Fork();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(trace__Fork)
};

inline trace__Fork::trace__Fork()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(trace_e::Fork)),
      field_mask_(kZeroMask) {
}

class trace__PipelinePart : public trace_t {
 public:
  trace__PipelinePart();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(trace__PipelinePart)
};

inline trace__PipelinePart::trace__PipelinePart()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(trace_e::PipelinePart)),
      field_mask_(kZeroMask) {
}

class trace__ProcessSub : public trace_t {
 public:
  trace__ProcessSub();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(trace__ProcessSub)
};

inline trace__ProcessSub::trace__ProcessSub()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(trace_e::ProcessSub)),
      field_mask_(kZeroMask) {
}

class trace__HereDoc : public trace_t {
 public:
  trace__HereDoc();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(trace__HereDoc)
};

inline trace__HereDoc::trace__HereDoc()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(trace_e::HereDoc)),
      field_mask_(kZeroMask) {
}

namespace trace {
  typedef trace__External External;
  typedef trace__CommandSub CommandSub;
  typedef trace__ForkWait ForkWait;
  typedef trace__Fork Fork;
  typedef trace__PipelinePart PipelinePart;
  typedef trace__ProcessSub ProcessSub;
  typedef trace__HereDoc HereDoc;
}

enum class word_style_e {
  Expr = 1,
  Unquoted = 2,
  DQ = 3,
  SQ = 4,
};
typedef word_style_e word_style_t;

const char* word_style_str(word_style_e tag);

class assign_arg {
 public:
  assign_arg();
  assign_arg(Str* var_name, value_t* rval, bool plus_eq, int spid);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* var_name;
  value_t* rval;
  bool plus_eq;
  int spid;

  DISALLOW_COPY_AND_ASSIGN(assign_arg)
};

constexpr uint16_t maskof_assign_arg() {
  return
    maskbit(offsetof(assign_arg, var_name))
  | maskbit(offsetof(assign_arg, rval));
}

inline assign_arg::assign_arg()
    : heap_tag_(Tag::FixedSize),
      type_tag_(200),
      field_mask_(maskof_assign_arg()),
      var_name(StrFromC("")),
      rval(nullptr),
      plus_eq(false),
      spid(-1) {
}

inline assign_arg::assign_arg(Str* var_name, value_t* rval, bool plus_eq, int
                              spid)
    : heap_tag_(Tag::FixedSize),
      type_tag_(200),
      field_mask_(maskof_assign_arg()),
      var_name(var_name),
      rval(rval),
      plus_eq(plus_eq),
      spid(spid) {
}

class VTestPlace {
 public:
  VTestPlace();
  VTestPlace(Str* name, a_index_t* index);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* name;
  a_index_t* index;

  DISALLOW_COPY_AND_ASSIGN(VTestPlace)
};

constexpr uint16_t maskof_VTestPlace() {
  return
    maskbit(offsetof(VTestPlace, name))
  | maskbit(offsetof(VTestPlace, index));
}

inline VTestPlace::VTestPlace()
    : heap_tag_(Tag::FixedSize),
      type_tag_(201),
      field_mask_(maskof_VTestPlace()),
      name(StrFromC("")),
      index(nullptr) {
}

inline VTestPlace::VTestPlace(Str* name, a_index_t* index)
    : heap_tag_(Tag::FixedSize),
      type_tag_(201),
      field_mask_(maskof_VTestPlace()),
      name(name),
      index(index) {
}

class VarSubState {
 public:
  VarSubState();
  VarSubState(bool join_array, bool is_type_query);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool join_array;
  bool is_type_query;

  DISALLOW_COPY_AND_ASSIGN(VarSubState)
};

inline VarSubState::VarSubState()
    : heap_tag_(Tag::FixedSize),
      type_tag_(202),
      field_mask_(kZeroMask),
      join_array(false),
      is_type_query(false) {
}

inline VarSubState::VarSubState(bool join_array, bool is_type_query)
    : heap_tag_(Tag::FixedSize),
      type_tag_(202),
      field_mask_(kZeroMask),
      join_array(join_array),
      is_type_query(is_type_query) {
}

class cell {
 public:
  cell();
  cell(bool exported, bool readonly, bool nameref, value_t* val);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool exported;
  bool readonly;
  bool nameref;
  value_t* val;

  DISALLOW_COPY_AND_ASSIGN(cell)
};

constexpr uint16_t maskof_cell() {
  return
    maskbit(offsetof(cell, val));
}

inline cell::cell()
    : heap_tag_(Tag::FixedSize),
      type_tag_(203),
      field_mask_(maskof_cell()),
      exported(false),
      readonly(false),
      nameref(false),
      val(nullptr) {
}

inline cell::cell(bool exported, bool readonly, bool nameref, value_t* val)
    : heap_tag_(Tag::FixedSize),
      type_tag_(203),
      field_mask_(maskof_cell()),
      exported(exported),
      readonly(readonly),
      nameref(nameref),
      val(val) {
}

class redirect {
 public:
  redirect();
  redirect(Id_t op_id, int op_spid, syntax_asdl::redir_loc_t* loc,
           redirect_arg_t* arg);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t op_id;
  int op_spid;
  syntax_asdl::redir_loc_t* loc;
  redirect_arg_t* arg;

  DISALLOW_COPY_AND_ASSIGN(redirect)
};

constexpr uint16_t maskof_redirect() {
  return
    maskbit(offsetof(redirect, loc))
  | maskbit(offsetof(redirect, arg));
}

inline redirect::redirect()
    : heap_tag_(Tag::FixedSize),
      type_tag_(204),
      field_mask_(maskof_redirect()),
      op_id(-1),
      op_spid(-1),
      loc(nullptr),
      arg(nullptr) {
}

inline redirect::redirect(Id_t op_id, int op_spid, syntax_asdl::redir_loc_t*
                          loc, redirect_arg_t* arg)
    : heap_tag_(Tag::FixedSize),
      type_tag_(204),
      field_mask_(maskof_redirect()),
      op_id(op_id),
      op_spid(op_spid),
      loc(loc),
      arg(arg) {
}

class Proc {
 public:
  Proc();
  Proc(Str* name, int name_spid, syntax_asdl::proc_sig_t* sig,
       syntax_asdl::command_t* body, List<value_t*>* defaults, bool
       dynamic_scope);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* name;
  int name_spid;
  syntax_asdl::proc_sig_t* sig;
  syntax_asdl::command_t* body;
  List<value_t*>* defaults;
  bool dynamic_scope;

  DISALLOW_COPY_AND_ASSIGN(Proc)
};

constexpr uint16_t maskof_Proc() {
  return
    maskbit(offsetof(Proc, name))
  | maskbit(offsetof(Proc, sig))
  | maskbit(offsetof(Proc, body))
  | maskbit(offsetof(Proc, defaults));
}

inline Proc::Proc()
    : heap_tag_(Tag::FixedSize),
      type_tag_(205),
      field_mask_(maskof_Proc()),
      name(StrFromC("")),
      name_spid(-1),
      sig(nullptr),
      body(nullptr),
      defaults(NewList<value_t*>()),
      dynamic_scope(false) {
}

inline Proc::Proc(Str* name, int name_spid, syntax_asdl::proc_sig_t* sig,
                  syntax_asdl::command_t* body, List<value_t*>* defaults, bool
                  dynamic_scope)
    : heap_tag_(Tag::FixedSize),
      type_tag_(205),
      field_mask_(maskof_Proc()),
      name(name),
      name_spid(name_spid),
      sig(sig),
      body(body),
      defaults(defaults),
      dynamic_scope(dynamic_scope) {
}

class StatusArray {
 public:
  StatusArray();
  StatusArray(List<int>* codes, List<int>* spids);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<int>* codes;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(StatusArray)
};

constexpr uint16_t maskof_StatusArray() {
  return
    maskbit(offsetof(StatusArray, codes))
  | maskbit(offsetof(StatusArray, spids));
}

inline StatusArray::StatusArray()
    : heap_tag_(Tag::FixedSize),
      type_tag_(206),
      field_mask_(maskof_StatusArray()),
      codes(NewList<int>()),
      spids(NewList<int>()) {
}

inline StatusArray::StatusArray(List<int>* codes, List<int>* spids)
    : heap_tag_(Tag::FixedSize),
      type_tag_(206),
      field_mask_(maskof_StatusArray()),
      codes(codes),
      spids(spids) {
}

class CommandStatus {
 public:
  CommandStatus();
  CommandStatus(bool check_errexit, bool pipe_negated, List<int>* pipe_status,
                List<int>* pipe_spids, bool show_code);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool check_errexit;
  bool pipe_negated;
  List<int>* pipe_status;
  List<int>* pipe_spids;
  bool show_code;

  DISALLOW_COPY_AND_ASSIGN(CommandStatus)
};

constexpr uint16_t maskof_CommandStatus() {
  return
    maskbit(offsetof(CommandStatus, pipe_status))
  | maskbit(offsetof(CommandStatus, pipe_spids));
}

inline CommandStatus::CommandStatus()
    : heap_tag_(Tag::FixedSize),
      type_tag_(207),
      field_mask_(maskof_CommandStatus()),
      check_errexit(false),
      pipe_negated(false),
      pipe_status(NewList<int>()),
      pipe_spids(NewList<int>()),
      show_code(false) {
}

inline CommandStatus::CommandStatus(bool check_errexit, bool pipe_negated,
                                    List<int>* pipe_status, List<int>*
                                    pipe_spids, bool show_code)
    : heap_tag_(Tag::FixedSize),
      type_tag_(207),
      field_mask_(maskof_CommandStatus()),
      check_errexit(check_errexit),
      pipe_negated(pipe_negated),
      pipe_status(pipe_status),
      pipe_spids(pipe_spids),
      show_code(show_code) {
}

class hay_node {
 public:
  hay_node();
  hay_node(Dict<Str*, hay_node*>* children);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Dict<Str*, hay_node*>* children;

  DISALLOW_COPY_AND_ASSIGN(hay_node)
};

constexpr uint16_t maskof_hay_node() {
  return
    maskbit(offsetof(hay_node, children));
}

inline hay_node::hay_node()
    : heap_tag_(Tag::FixedSize),
      type_tag_(208),
      field_mask_(maskof_hay_node()),
      children(NewDict<Str*, hay_node*>()) {
}

inline hay_node::hay_node(Dict<Str*, hay_node*>* children)
    : heap_tag_(Tag::FixedSize),
      type_tag_(208),
      field_mask_(maskof_hay_node()),
      children(children) {
}


}  // namespace runtime_asdl

#endif  // RUNTIME_ASDL
