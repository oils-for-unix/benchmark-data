// _gen/frontend/syntax.asdl.h is generated by asdl_main.py

#ifndef SYNTAX_ASDL
#define SYNTAX_ASDL

#include <cstdint>

#include "mycpp/runtime.h"
#include "_gen/asdl/hnode.asdl.h"
using hnode_asdl::hnode_t;

#include "_gen/frontend/id_kind.asdl.h"
using id_kind_asdl::Id_t;

namespace syntax_asdl {

class parse_result_t;
class source_t;
class line_span;
class Token;
class speck;
class bracket_op_t;
class suffix_op_t;
class double_quoted;
class single_quoted;
class simple_var_sub;
class braced_var_sub;
class command_sub;
class sh_array_literal;
class ArgList;
class word_part_t;
class compound_word;
class string_line;
class triple_quoted;
class word_t;
class sh_lhs_expr_t;
class arith_expr_t;
class bool_expr_t;
class redir_loc_t;
class redir_param_t;
class redir;
class assign_pair;
class env_pair;
class condition_t;
class case_arm;
class if_arm;
class for_iter_t;
class BraceGroup;
class command_t;
class variant_type_t;
class variant;
class class_item_t;
class import_name;
class UntypedParam;
class TypedParam;
class proc_sig_t;
class param;
class glob_part_t;
class printf_part_t;
class type_expr_t;
class name_type;
class comprehension;
class named_arg;
class subscript;
class attribute;
class place_expr_t;
class expr_t;
class posix_class;
class perl_class;
class class_literal_term_t;
class CharCode;
class char_class_term_t;
class re_repeat_t;
class re_t;

namespace parse_result_e {
  const int EmptyLine = 1;
  const int Eof = 2;
  const int Node = 3;
};

const char* parse_result_str(int tag);

class parse_result_t {
 protected:
  parse_result_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(parse_result_t)
};

class parse_result__EmptyLine : public parse_result_t {
 public:
  parse_result__EmptyLine();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(parse_result__EmptyLine)
};

inline parse_result__EmptyLine::parse_result__EmptyLine()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(parse_result_e::EmptyLine)),
      field_mask_(kZeroMask) {
}

class parse_result__Eof : public parse_result_t {
 public:
  parse_result__Eof();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(parse_result__Eof)
};

inline parse_result__Eof::parse_result__Eof()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(parse_result_e::Eof)),
      field_mask_(kZeroMask) {
}

class parse_result__Node : public parse_result_t {
 public:
  parse_result__Node();
  parse_result__Node(command_t* cmd);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  command_t* cmd;

  DISALLOW_COPY_AND_ASSIGN(parse_result__Node)
};

constexpr uint16_t maskof_parse_result__Node() {
  return
    maskbit(offsetof(parse_result__Node, cmd));
}

inline parse_result__Node::parse_result__Node()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(parse_result_e::Node)),
      field_mask_(maskof_parse_result__Node()),
      cmd(nullptr) {
}

inline parse_result__Node::parse_result__Node(command_t* cmd)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(parse_result_e::Node)),
      field_mask_(maskof_parse_result__Node()),
      cmd(cmd) {
}

namespace parse_result {
  typedef parse_result__EmptyLine EmptyLine;
  typedef parse_result__Eof Eof;
  typedef parse_result__Node Node;
}

namespace source_e {
  const int Interactive = 1;
  const int Headless = 2;
  const int Unused = 3;
  const int CFlag = 4;
  const int Stdin = 5;
  const int MainFile = 6;
  const int SourcedFile = 7;
  const int ArgvWord = 8;
  const int Variable = 9;
  const int Alias = 10;
  const int Reparsed = 11;
  const int Synthetic = 12;
};

const char* source_str(int tag);

class source_t {
 protected:
  source_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(source_t)
};

class source__Interactive : public source_t {
 public:
  source__Interactive();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(source__Interactive)
};

inline source__Interactive::source__Interactive()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Interactive)),
      field_mask_(kZeroMask) {
}

class source__Headless : public source_t {
 public:
  source__Headless();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(source__Headless)
};

inline source__Headless::source__Headless()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Headless)),
      field_mask_(kZeroMask) {
}

class source__Unused : public source_t {
 public:
  source__Unused();
  source__Unused(Str* comment);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* comment;

  DISALLOW_COPY_AND_ASSIGN(source__Unused)
};

constexpr uint16_t maskof_source__Unused() {
  return
    maskbit(offsetof(source__Unused, comment));
}

inline source__Unused::source__Unused()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Unused)),
      field_mask_(maskof_source__Unused()),
      comment(StrFromC("")) {
}

inline source__Unused::source__Unused(Str* comment)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Unused)),
      field_mask_(maskof_source__Unused()),
      comment(comment) {
}

class source__CFlag : public source_t {
 public:
  source__CFlag();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(source__CFlag)
};

inline source__CFlag::source__CFlag()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::CFlag)),
      field_mask_(kZeroMask) {
}

class source__Stdin : public source_t {
 public:
  source__Stdin();
  source__Stdin(Str* comment);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* comment;

  DISALLOW_COPY_AND_ASSIGN(source__Stdin)
};

constexpr uint16_t maskof_source__Stdin() {
  return
    maskbit(offsetof(source__Stdin, comment));
}

inline source__Stdin::source__Stdin()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Stdin)),
      field_mask_(maskof_source__Stdin()),
      comment(StrFromC("")) {
}

inline source__Stdin::source__Stdin(Str* comment)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Stdin)),
      field_mask_(maskof_source__Stdin()),
      comment(comment) {
}

class source__MainFile : public source_t {
 public:
  source__MainFile();
  source__MainFile(Str* path);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* path;

  DISALLOW_COPY_AND_ASSIGN(source__MainFile)
};

constexpr uint16_t maskof_source__MainFile() {
  return
    maskbit(offsetof(source__MainFile, path));
}

inline source__MainFile::source__MainFile()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::MainFile)),
      field_mask_(maskof_source__MainFile()),
      path(StrFromC("")) {
}

inline source__MainFile::source__MainFile(Str* path)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::MainFile)),
      field_mask_(maskof_source__MainFile()),
      path(path) {
}

class source__SourcedFile : public source_t {
 public:
  source__SourcedFile();
  source__SourcedFile(Str* path, int spid);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* path;
  int spid;

  DISALLOW_COPY_AND_ASSIGN(source__SourcedFile)
};

constexpr uint16_t maskof_source__SourcedFile() {
  return
    maskbit(offsetof(source__SourcedFile, path));
}

inline source__SourcedFile::source__SourcedFile()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::SourcedFile)),
      field_mask_(maskof_source__SourcedFile()),
      path(StrFromC("")),
      spid(-1) {
}

inline source__SourcedFile::source__SourcedFile(Str* path, int spid)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::SourcedFile)),
      field_mask_(maskof_source__SourcedFile()),
      path(path),
      spid(spid) {
}

class source__ArgvWord : public source_t {
 public:
  source__ArgvWord();
  source__ArgvWord(Str* what, int span_id);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* what;
  int span_id;

  DISALLOW_COPY_AND_ASSIGN(source__ArgvWord)
};

constexpr uint16_t maskof_source__ArgvWord() {
  return
    maskbit(offsetof(source__ArgvWord, what));
}

inline source__ArgvWord::source__ArgvWord()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::ArgvWord)),
      field_mask_(maskof_source__ArgvWord()),
      what(StrFromC("")),
      span_id(-1) {
}

inline source__ArgvWord::source__ArgvWord(Str* what, int span_id)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::ArgvWord)),
      field_mask_(maskof_source__ArgvWord()),
      what(what),
      span_id(span_id) {
}

class source__Variable : public source_t {
 public:
  source__Variable();
  source__Variable(Str* var_name, int span_id);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* var_name;
  int span_id;

  DISALLOW_COPY_AND_ASSIGN(source__Variable)
};

constexpr uint16_t maskof_source__Variable() {
  return
    maskbit(offsetof(source__Variable, var_name));
}

inline source__Variable::source__Variable()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Variable)),
      field_mask_(maskof_source__Variable()),
      var_name(StrFromC("")),
      span_id(-1) {
}

inline source__Variable::source__Variable(Str* var_name, int span_id)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Variable)),
      field_mask_(maskof_source__Variable()),
      var_name(var_name),
      span_id(span_id) {
}

class source__Alias : public source_t {
 public:
  source__Alias();
  source__Alias(Str* argv0, int argv0_spid);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* argv0;
  int argv0_spid;

  DISALLOW_COPY_AND_ASSIGN(source__Alias)
};

constexpr uint16_t maskof_source__Alias() {
  return
    maskbit(offsetof(source__Alias, argv0));
}

inline source__Alias::source__Alias()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Alias)),
      field_mask_(maskof_source__Alias()),
      argv0(StrFromC("")),
      argv0_spid(-1) {
}

inline source__Alias::source__Alias(Str* argv0, int argv0_spid)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Alias)),
      field_mask_(maskof_source__Alias()),
      argv0(argv0),
      argv0_spid(argv0_spid) {
}

class source__Reparsed : public source_t {
 public:
  source__Reparsed();
  source__Reparsed(Str* what, int left_spid, int right_spid);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* what;
  int left_spid;
  int right_spid;

  DISALLOW_COPY_AND_ASSIGN(source__Reparsed)
};

constexpr uint16_t maskof_source__Reparsed() {
  return
    maskbit(offsetof(source__Reparsed, what));
}

inline source__Reparsed::source__Reparsed()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Reparsed)),
      field_mask_(maskof_source__Reparsed()),
      what(StrFromC("")),
      left_spid(-1),
      right_spid(-1) {
}

inline source__Reparsed::source__Reparsed(Str* what, int left_spid, int
                                          right_spid)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Reparsed)),
      field_mask_(maskof_source__Reparsed()),
      what(what),
      left_spid(left_spid),
      right_spid(right_spid) {
}

class source__Synthetic : public source_t {
 public:
  source__Synthetic();
  source__Synthetic(Str* s);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* s;

  DISALLOW_COPY_AND_ASSIGN(source__Synthetic)
};

constexpr uint16_t maskof_source__Synthetic() {
  return
    maskbit(offsetof(source__Synthetic, s));
}

inline source__Synthetic::source__Synthetic()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Synthetic)),
      field_mask_(maskof_source__Synthetic()),
      s(StrFromC("")) {
}

inline source__Synthetic::source__Synthetic(Str* s)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(source_e::Synthetic)),
      field_mask_(maskof_source__Synthetic()),
      s(s) {
}

namespace source {
  typedef source__Interactive Interactive;
  typedef source__Headless Headless;
  typedef source__Unused Unused;
  typedef source__CFlag CFlag;
  typedef source__Stdin Stdin;
  typedef source__MainFile MainFile;
  typedef source__SourcedFile SourcedFile;
  typedef source__ArgvWord ArgvWord;
  typedef source__Variable Variable;
  typedef source__Alias Alias;
  typedef source__Reparsed Reparsed;
  typedef source__Synthetic Synthetic;
}

namespace bracket_op_e {
  const int WholeArray = 1;
  const int ArrayIndex = 2;
};

const char* bracket_op_str(int tag);

class bracket_op_t {
 protected:
  bracket_op_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(bracket_op_t)
};

class bracket_op__WholeArray : public bracket_op_t {
 public:
  bracket_op__WholeArray();
  bracket_op__WholeArray(Id_t op_id);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t op_id;

  DISALLOW_COPY_AND_ASSIGN(bracket_op__WholeArray)
};

inline bracket_op__WholeArray::bracket_op__WholeArray()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bracket_op_e::WholeArray)),
      field_mask_(kZeroMask),
      op_id(-1) {
}

inline bracket_op__WholeArray::bracket_op__WholeArray(Id_t op_id)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bracket_op_e::WholeArray)),
      field_mask_(kZeroMask),
      op_id(op_id) {
}

class bracket_op__ArrayIndex : public bracket_op_t {
 public:
  bracket_op__ArrayIndex();
  bracket_op__ArrayIndex(arith_expr_t* expr);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  arith_expr_t* expr;

  DISALLOW_COPY_AND_ASSIGN(bracket_op__ArrayIndex)
};

constexpr uint16_t maskof_bracket_op__ArrayIndex() {
  return
    maskbit(offsetof(bracket_op__ArrayIndex, expr));
}

inline bracket_op__ArrayIndex::bracket_op__ArrayIndex()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bracket_op_e::ArrayIndex)),
      field_mask_(maskof_bracket_op__ArrayIndex()),
      expr(nullptr) {
}

inline bracket_op__ArrayIndex::bracket_op__ArrayIndex(arith_expr_t* expr)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bracket_op_e::ArrayIndex)),
      field_mask_(maskof_bracket_op__ArrayIndex()),
      expr(expr) {
}

namespace bracket_op {
  typedef bracket_op__WholeArray WholeArray;
  typedef bracket_op__ArrayIndex ArrayIndex;
}

namespace suffix_op_e {
  const int Nullary = 201;
  const int Unary = 2;
  const int Static = 3;
  const int PatSub = 4;
  const int Slice = 5;
};

const char* suffix_op_str(int tag);

class suffix_op_t {
 protected:
  suffix_op_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(suffix_op_t)
};

class suffix_op__Unary : public suffix_op_t {
 public:
  suffix_op__Unary();
  suffix_op__Unary(Token* tok, word_t* arg_word);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* tok;
  word_t* arg_word;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(suffix_op__Unary)
};

constexpr uint16_t maskof_suffix_op__Unary() {
  return
    maskbit(offsetof(suffix_op__Unary, tok))
  | maskbit(offsetof(suffix_op__Unary, arg_word))
  | maskbit(offsetof(suffix_op__Unary, spids));
}

inline suffix_op__Unary::suffix_op__Unary()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(suffix_op_e::Unary)),
      field_mask_(maskof_suffix_op__Unary()),
      tok(nullptr),
      arg_word(nullptr),
      spids(NewList<int>()) {
}

inline suffix_op__Unary::suffix_op__Unary(Token* tok, word_t* arg_word)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(suffix_op_e::Unary)),
      field_mask_(maskof_suffix_op__Unary()),
      tok(tok),
      arg_word(arg_word),
      spids(NewList<int>()) {
}

class suffix_op__Static : public suffix_op_t {
 public:
  suffix_op__Static();
  suffix_op__Static(Token* tok, Str* arg);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* tok;
  Str* arg;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(suffix_op__Static)
};

constexpr uint16_t maskof_suffix_op__Static() {
  return
    maskbit(offsetof(suffix_op__Static, tok))
  | maskbit(offsetof(suffix_op__Static, arg))
  | maskbit(offsetof(suffix_op__Static, spids));
}

inline suffix_op__Static::suffix_op__Static()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(suffix_op_e::Static)),
      field_mask_(maskof_suffix_op__Static()),
      tok(nullptr),
      arg(StrFromC("")),
      spids(NewList<int>()) {
}

inline suffix_op__Static::suffix_op__Static(Token* tok, Str* arg)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(suffix_op_e::Static)),
      field_mask_(maskof_suffix_op__Static()),
      tok(tok),
      arg(arg),
      spids(NewList<int>()) {
}

class suffix_op__PatSub : public suffix_op_t {
 public:
  suffix_op__PatSub();
  suffix_op__PatSub(word_t* pat, word_t* replace, Id_t replace_mode);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  word_t* pat;
  word_t* replace;
  Id_t replace_mode;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(suffix_op__PatSub)
};

constexpr uint16_t maskof_suffix_op__PatSub() {
  return
    maskbit(offsetof(suffix_op__PatSub, pat))
  | maskbit(offsetof(suffix_op__PatSub, replace))
  | maskbit(offsetof(suffix_op__PatSub, spids));
}

inline suffix_op__PatSub::suffix_op__PatSub()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(suffix_op_e::PatSub)),
      field_mask_(maskof_suffix_op__PatSub()),
      pat(nullptr),
      replace(nullptr),
      replace_mode(-1),
      spids(NewList<int>()) {
}

inline suffix_op__PatSub::suffix_op__PatSub(word_t* pat, word_t* replace, Id_t
                                            replace_mode)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(suffix_op_e::PatSub)),
      field_mask_(maskof_suffix_op__PatSub()),
      pat(pat),
      replace(replace),
      replace_mode(replace_mode),
      spids(NewList<int>()) {
}

class suffix_op__Slice : public suffix_op_t {
 public:
  suffix_op__Slice();
  suffix_op__Slice(arith_expr_t* begin, arith_expr_t* length);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  arith_expr_t* begin;
  arith_expr_t* length;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(suffix_op__Slice)
};

constexpr uint16_t maskof_suffix_op__Slice() {
  return
    maskbit(offsetof(suffix_op__Slice, begin))
  | maskbit(offsetof(suffix_op__Slice, length))
  | maskbit(offsetof(suffix_op__Slice, spids));
}

inline suffix_op__Slice::suffix_op__Slice()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(suffix_op_e::Slice)),
      field_mask_(maskof_suffix_op__Slice()),
      begin(nullptr),
      length(nullptr),
      spids(NewList<int>()) {
}

inline suffix_op__Slice::suffix_op__Slice(arith_expr_t* begin, arith_expr_t*
                                          length)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(suffix_op_e::Slice)),
      field_mask_(maskof_suffix_op__Slice()),
      begin(begin),
      length(length),
      spids(NewList<int>()) {
}

namespace suffix_op {
  typedef suffix_op__Unary Unary;
  typedef suffix_op__Static Static;
  typedef suffix_op__PatSub PatSub;
  typedef suffix_op__Slice Slice;
}

namespace word_part_e {
  const int ShArrayLiteral = 208;
  const int AssocArrayLiteral = 2;
  const int Literal = 201;
  const int EscapedLiteral = 4;
  const int SingleQuoted = 204;
  const int DoubleQuoted = 203;
  const int SimpleVarSub = 205;
  const int BracedVarSub = 206;
  const int CommandSub = 207;
  const int TildeSub = 10;
  const int ArithSub = 11;
  const int BracedTuple = 12;
  const int BracedRange = 13;
  const int ExtGlob = 14;
  const int Splice = 15;
  const int FuncCall = 16;
  const int ExprSub = 17;
};

const char* word_part_str(int tag);

class word_part_t {
 protected:
  word_part_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(word_part_t)
};

class word_part__AssocArrayLiteral : public word_part_t {
 public:
  word_part__AssocArrayLiteral();
  word_part__AssocArrayLiteral(Token* left, List<compound_word*>* pairs);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* left;
  List<compound_word*>* pairs;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(word_part__AssocArrayLiteral)
};

constexpr uint16_t maskof_word_part__AssocArrayLiteral() {
  return
    maskbit(offsetof(word_part__AssocArrayLiteral, left))
  | maskbit(offsetof(word_part__AssocArrayLiteral, pairs))
  | maskbit(offsetof(word_part__AssocArrayLiteral, spids));
}

inline word_part__AssocArrayLiteral::word_part__AssocArrayLiteral()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::AssocArrayLiteral)),
      field_mask_(maskof_word_part__AssocArrayLiteral()),
      left(nullptr),
      pairs(NewList<compound_word*>()),
      spids(NewList<int>()) {
}

inline word_part__AssocArrayLiteral::word_part__AssocArrayLiteral(Token* left,
                                                                  List<compound_word*>* pairs)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::AssocArrayLiteral)),
      field_mask_(maskof_word_part__AssocArrayLiteral()),
      left(left),
      pairs(pairs),
      spids(NewList<int>()) {
}

class word_part__EscapedLiteral : public word_part_t {
 public:
  word_part__EscapedLiteral();
  word_part__EscapedLiteral(Token* token);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* token;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(word_part__EscapedLiteral)
};

constexpr uint16_t maskof_word_part__EscapedLiteral() {
  return
    maskbit(offsetof(word_part__EscapedLiteral, token))
  | maskbit(offsetof(word_part__EscapedLiteral, spids));
}

inline word_part__EscapedLiteral::word_part__EscapedLiteral()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::EscapedLiteral)),
      field_mask_(maskof_word_part__EscapedLiteral()),
      token(nullptr),
      spids(NewList<int>()) {
}

inline word_part__EscapedLiteral::word_part__EscapedLiteral(Token* token)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::EscapedLiteral)),
      field_mask_(maskof_word_part__EscapedLiteral()),
      token(token),
      spids(NewList<int>()) {
}

class word_part__TildeSub : public word_part_t {
 public:
  word_part__TildeSub();
  word_part__TildeSub(Token* token);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* token;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(word_part__TildeSub)
};

constexpr uint16_t maskof_word_part__TildeSub() {
  return
    maskbit(offsetof(word_part__TildeSub, token))
  | maskbit(offsetof(word_part__TildeSub, spids));
}

inline word_part__TildeSub::word_part__TildeSub()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::TildeSub)),
      field_mask_(maskof_word_part__TildeSub()),
      token(nullptr),
      spids(NewList<int>()) {
}

inline word_part__TildeSub::word_part__TildeSub(Token* token)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::TildeSub)),
      field_mask_(maskof_word_part__TildeSub()),
      token(token),
      spids(NewList<int>()) {
}

class word_part__ArithSub : public word_part_t {
 public:
  word_part__ArithSub();
  word_part__ArithSub(arith_expr_t* anode);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  arith_expr_t* anode;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(word_part__ArithSub)
};

constexpr uint16_t maskof_word_part__ArithSub() {
  return
    maskbit(offsetof(word_part__ArithSub, anode))
  | maskbit(offsetof(word_part__ArithSub, spids));
}

inline word_part__ArithSub::word_part__ArithSub()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::ArithSub)),
      field_mask_(maskof_word_part__ArithSub()),
      anode(nullptr),
      spids(NewList<int>()) {
}

inline word_part__ArithSub::word_part__ArithSub(arith_expr_t* anode)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::ArithSub)),
      field_mask_(maskof_word_part__ArithSub()),
      anode(anode),
      spids(NewList<int>()) {
}

class word_part__BracedTuple : public word_part_t {
 public:
  word_part__BracedTuple();
  word_part__BracedTuple(List<compound_word*>* words);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<compound_word*>* words;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(word_part__BracedTuple)
};

constexpr uint16_t maskof_word_part__BracedTuple() {
  return
    maskbit(offsetof(word_part__BracedTuple, words))
  | maskbit(offsetof(word_part__BracedTuple, spids));
}

inline word_part__BracedTuple::word_part__BracedTuple()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::BracedTuple)),
      field_mask_(maskof_word_part__BracedTuple()),
      words(NewList<compound_word*>()),
      spids(NewList<int>()) {
}

inline word_part__BracedTuple::word_part__BracedTuple(List<compound_word*>*
                                                      words)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::BracedTuple)),
      field_mask_(maskof_word_part__BracedTuple()),
      words(words),
      spids(NewList<int>()) {
}

class word_part__BracedRange : public word_part_t {
 public:
  word_part__BracedRange();
  word_part__BracedRange(Id_t kind, Str* start, Str* end, int step);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t kind;
  Str* start;
  Str* end;
  int step;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(word_part__BracedRange)
};

constexpr uint16_t maskof_word_part__BracedRange() {
  return
    maskbit(offsetof(word_part__BracedRange, start))
  | maskbit(offsetof(word_part__BracedRange, end))
  | maskbit(offsetof(word_part__BracedRange, spids));
}

inline word_part__BracedRange::word_part__BracedRange()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::BracedRange)),
      field_mask_(maskof_word_part__BracedRange()),
      kind(-1),
      start(StrFromC("")),
      end(StrFromC("")),
      step(-1),
      spids(NewList<int>()) {
}

inline word_part__BracedRange::word_part__BracedRange(Id_t kind, Str* start,
                                                      Str* end, int step)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::BracedRange)),
      field_mask_(maskof_word_part__BracedRange()),
      kind(kind),
      start(start),
      end(end),
      step(step),
      spids(NewList<int>()) {
}

class word_part__ExtGlob : public word_part_t {
 public:
  word_part__ExtGlob();
  word_part__ExtGlob(Token* op, List<compound_word*>* arms);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* op;
  List<compound_word*>* arms;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(word_part__ExtGlob)
};

constexpr uint16_t maskof_word_part__ExtGlob() {
  return
    maskbit(offsetof(word_part__ExtGlob, op))
  | maskbit(offsetof(word_part__ExtGlob, arms))
  | maskbit(offsetof(word_part__ExtGlob, spids));
}

inline word_part__ExtGlob::word_part__ExtGlob()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::ExtGlob)),
      field_mask_(maskof_word_part__ExtGlob()),
      op(nullptr),
      arms(NewList<compound_word*>()),
      spids(NewList<int>()) {
}

inline word_part__ExtGlob::word_part__ExtGlob(Token* op, List<compound_word*>*
                                              arms)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::ExtGlob)),
      field_mask_(maskof_word_part__ExtGlob()),
      op(op),
      arms(arms),
      spids(NewList<int>()) {
}

class word_part__Splice : public word_part_t {
 public:
  word_part__Splice();
  word_part__Splice(Token* name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(word_part__Splice)
};

constexpr uint16_t maskof_word_part__Splice() {
  return
    maskbit(offsetof(word_part__Splice, name))
  | maskbit(offsetof(word_part__Splice, spids));
}

inline word_part__Splice::word_part__Splice()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::Splice)),
      field_mask_(maskof_word_part__Splice()),
      name(nullptr),
      spids(NewList<int>()) {
}

inline word_part__Splice::word_part__Splice(Token* name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::Splice)),
      field_mask_(maskof_word_part__Splice()),
      name(name),
      spids(NewList<int>()) {
}

class word_part__FuncCall : public word_part_t {
 public:
  word_part__FuncCall();
  word_part__FuncCall(Token* name, ArgList* args);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  ArgList* args;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(word_part__FuncCall)
};

constexpr uint16_t maskof_word_part__FuncCall() {
  return
    maskbit(offsetof(word_part__FuncCall, name))
  | maskbit(offsetof(word_part__FuncCall, args))
  | maskbit(offsetof(word_part__FuncCall, spids));
}

inline word_part__FuncCall::word_part__FuncCall()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::FuncCall)),
      field_mask_(maskof_word_part__FuncCall()),
      name(nullptr),
      args(nullptr),
      spids(NewList<int>()) {
}

inline word_part__FuncCall::word_part__FuncCall(Token* name, ArgList* args)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::FuncCall)),
      field_mask_(maskof_word_part__FuncCall()),
      name(name),
      args(args),
      spids(NewList<int>()) {
}

class word_part__ExprSub : public word_part_t {
 public:
  word_part__ExprSub();
  word_part__ExprSub(Token* left, expr_t* child);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* left;
  expr_t* child;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(word_part__ExprSub)
};

constexpr uint16_t maskof_word_part__ExprSub() {
  return
    maskbit(offsetof(word_part__ExprSub, left))
  | maskbit(offsetof(word_part__ExprSub, child))
  | maskbit(offsetof(word_part__ExprSub, spids));
}

inline word_part__ExprSub::word_part__ExprSub()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::ExprSub)),
      field_mask_(maskof_word_part__ExprSub()),
      left(nullptr),
      child(nullptr),
      spids(NewList<int>()) {
}

inline word_part__ExprSub::word_part__ExprSub(Token* left, expr_t* child)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_part_e::ExprSub)),
      field_mask_(maskof_word_part__ExprSub()),
      left(left),
      child(child),
      spids(NewList<int>()) {
}

namespace word_part {
  typedef word_part__AssocArrayLiteral AssocArrayLiteral;
  typedef word_part__EscapedLiteral EscapedLiteral;
  typedef word_part__TildeSub TildeSub;
  typedef word_part__ArithSub ArithSub;
  typedef word_part__BracedTuple BracedTuple;
  typedef word_part__BracedRange BracedRange;
  typedef word_part__ExtGlob ExtGlob;
  typedef word_part__Splice Splice;
  typedef word_part__FuncCall FuncCall;
  typedef word_part__ExprSub ExprSub;
}

namespace word_e {
  const int Empty = 1;
  const int Token = 201;
  const int Compound = 210;
  const int BracedTree = 4;
  const int String = 5;
};

const char* word_str(int tag);

class word_t {
 protected:
  word_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(word_t)
};

class word__Empty : public word_t {
 public:
  word__Empty();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(word__Empty)
};

inline word__Empty::word__Empty()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_e::Empty)),
      field_mask_(kZeroMask) {
}

class word__BracedTree : public word_t {
 public:
  word__BracedTree();
  word__BracedTree(List<word_part_t*>* parts);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<word_part_t*>* parts;

  DISALLOW_COPY_AND_ASSIGN(word__BracedTree)
};

constexpr uint16_t maskof_word__BracedTree() {
  return
    maskbit(offsetof(word__BracedTree, parts));
}

inline word__BracedTree::word__BracedTree()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_e::BracedTree)),
      field_mask_(maskof_word__BracedTree()),
      parts(NewList<word_part_t*>()) {
}

inline word__BracedTree::word__BracedTree(List<word_part_t*>* parts)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_e::BracedTree)),
      field_mask_(maskof_word__BracedTree()),
      parts(parts) {
}

class word__String : public word_t {
 public:
  word__String();
  word__String(Id_t id, Str* s, int span_id);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t id;
  Str* s;
  int span_id;

  DISALLOW_COPY_AND_ASSIGN(word__String)
};

constexpr uint16_t maskof_word__String() {
  return
    maskbit(offsetof(word__String, s));
}

inline word__String::word__String()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_e::String)),
      field_mask_(maskof_word__String()),
      id(-1),
      s(StrFromC("")),
      span_id(-1) {
}

inline word__String::word__String(Id_t id, Str* s, int span_id)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(word_e::String)),
      field_mask_(maskof_word__String()),
      id(id),
      s(s),
      span_id(span_id) {
}

namespace word {
  typedef word__Empty Empty;
  typedef word__BracedTree BracedTree;
  typedef word__String String;
}

namespace sh_lhs_expr_e {
  const int Name = 1;
  const int IndexedName = 2;
  const int UnparsedIndex = 3;
};

const char* sh_lhs_expr_str(int tag);

class sh_lhs_expr_t {
 protected:
  sh_lhs_expr_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(sh_lhs_expr_t)
};

class sh_lhs_expr__Name : public sh_lhs_expr_t {
 public:
  sh_lhs_expr__Name();
  sh_lhs_expr__Name(Str* name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* name;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(sh_lhs_expr__Name)
};

constexpr uint16_t maskof_sh_lhs_expr__Name() {
  return
    maskbit(offsetof(sh_lhs_expr__Name, name))
  | maskbit(offsetof(sh_lhs_expr__Name, spids));
}

inline sh_lhs_expr__Name::sh_lhs_expr__Name()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(sh_lhs_expr_e::Name)),
      field_mask_(maskof_sh_lhs_expr__Name()),
      name(StrFromC("")),
      spids(NewList<int>()) {
}

inline sh_lhs_expr__Name::sh_lhs_expr__Name(Str* name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(sh_lhs_expr_e::Name)),
      field_mask_(maskof_sh_lhs_expr__Name()),
      name(name),
      spids(NewList<int>()) {
}

class sh_lhs_expr__IndexedName : public sh_lhs_expr_t {
 public:
  sh_lhs_expr__IndexedName();
  sh_lhs_expr__IndexedName(Str* name, arith_expr_t* index);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* name;
  arith_expr_t* index;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(sh_lhs_expr__IndexedName)
};

constexpr uint16_t maskof_sh_lhs_expr__IndexedName() {
  return
    maskbit(offsetof(sh_lhs_expr__IndexedName, name))
  | maskbit(offsetof(sh_lhs_expr__IndexedName, index))
  | maskbit(offsetof(sh_lhs_expr__IndexedName, spids));
}

inline sh_lhs_expr__IndexedName::sh_lhs_expr__IndexedName()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(sh_lhs_expr_e::IndexedName)),
      field_mask_(maskof_sh_lhs_expr__IndexedName()),
      name(StrFromC("")),
      index(nullptr),
      spids(NewList<int>()) {
}

inline sh_lhs_expr__IndexedName::sh_lhs_expr__IndexedName(Str* name,
                                                          arith_expr_t* index)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(sh_lhs_expr_e::IndexedName)),
      field_mask_(maskof_sh_lhs_expr__IndexedName()),
      name(name),
      index(index),
      spids(NewList<int>()) {
}

class sh_lhs_expr__UnparsedIndex : public sh_lhs_expr_t {
 public:
  sh_lhs_expr__UnparsedIndex();
  sh_lhs_expr__UnparsedIndex(Str* name, Str* index);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* name;
  Str* index;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(sh_lhs_expr__UnparsedIndex)
};

constexpr uint16_t maskof_sh_lhs_expr__UnparsedIndex() {
  return
    maskbit(offsetof(sh_lhs_expr__UnparsedIndex, name))
  | maskbit(offsetof(sh_lhs_expr__UnparsedIndex, index))
  | maskbit(offsetof(sh_lhs_expr__UnparsedIndex, spids));
}

inline sh_lhs_expr__UnparsedIndex::sh_lhs_expr__UnparsedIndex()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(sh_lhs_expr_e::UnparsedIndex)),
      field_mask_(maskof_sh_lhs_expr__UnparsedIndex()),
      name(StrFromC("")),
      index(StrFromC("")),
      spids(NewList<int>()) {
}

inline sh_lhs_expr__UnparsedIndex::sh_lhs_expr__UnparsedIndex(Str* name, Str*
                                                              index)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(sh_lhs_expr_e::UnparsedIndex)),
      field_mask_(maskof_sh_lhs_expr__UnparsedIndex()),
      name(name),
      index(index),
      spids(NewList<int>()) {
}

namespace sh_lhs_expr {
  typedef sh_lhs_expr__Name Name;
  typedef sh_lhs_expr__IndexedName IndexedName;
  typedef sh_lhs_expr__UnparsedIndex UnparsedIndex;
}

namespace arith_expr_e {
  const int VarRef = 201;
  const int Word = 210;
  const int UnaryAssign = 3;
  const int BinaryAssign = 4;
  const int Unary = 5;
  const int Binary = 6;
  const int TernaryOp = 7;
};

const char* arith_expr_str(int tag);

class arith_expr_t {
 protected:
  arith_expr_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(arith_expr_t)
};

class arith_expr__UnaryAssign : public arith_expr_t {
 public:
  arith_expr__UnaryAssign();
  arith_expr__UnaryAssign(Id_t op_id, arith_expr_t* child);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t op_id;
  arith_expr_t* child;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__UnaryAssign)
};

constexpr uint16_t maskof_arith_expr__UnaryAssign() {
  return
    maskbit(offsetof(arith_expr__UnaryAssign, child));
}

inline arith_expr__UnaryAssign::arith_expr__UnaryAssign()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(arith_expr_e::UnaryAssign)),
      field_mask_(maskof_arith_expr__UnaryAssign()),
      op_id(-1),
      child(nullptr) {
}

inline arith_expr__UnaryAssign::arith_expr__UnaryAssign(Id_t op_id,
                                                        arith_expr_t* child)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(arith_expr_e::UnaryAssign)),
      field_mask_(maskof_arith_expr__UnaryAssign()),
      op_id(op_id),
      child(child) {
}

class arith_expr__BinaryAssign : public arith_expr_t {
 public:
  arith_expr__BinaryAssign();
  arith_expr__BinaryAssign(Id_t op_id, arith_expr_t* left, arith_expr_t* right);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t op_id;
  arith_expr_t* left;
  arith_expr_t* right;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__BinaryAssign)
};

constexpr uint16_t maskof_arith_expr__BinaryAssign() {
  return
    maskbit(offsetof(arith_expr__BinaryAssign, left))
  | maskbit(offsetof(arith_expr__BinaryAssign, right));
}

inline arith_expr__BinaryAssign::arith_expr__BinaryAssign()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(arith_expr_e::BinaryAssign)),
      field_mask_(maskof_arith_expr__BinaryAssign()),
      op_id(-1),
      left(nullptr),
      right(nullptr) {
}

inline arith_expr__BinaryAssign::arith_expr__BinaryAssign(Id_t op_id,
                                                          arith_expr_t* left,
                                                          arith_expr_t* right)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(arith_expr_e::BinaryAssign)),
      field_mask_(maskof_arith_expr__BinaryAssign()),
      op_id(op_id),
      left(left),
      right(right) {
}

class arith_expr__Unary : public arith_expr_t {
 public:
  arith_expr__Unary();
  arith_expr__Unary(Id_t op_id, arith_expr_t* child);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t op_id;
  arith_expr_t* child;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Unary)
};

constexpr uint16_t maskof_arith_expr__Unary() {
  return
    maskbit(offsetof(arith_expr__Unary, child));
}

inline arith_expr__Unary::arith_expr__Unary()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(arith_expr_e::Unary)),
      field_mask_(maskof_arith_expr__Unary()),
      op_id(-1),
      child(nullptr) {
}

inline arith_expr__Unary::arith_expr__Unary(Id_t op_id, arith_expr_t* child)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(arith_expr_e::Unary)),
      field_mask_(maskof_arith_expr__Unary()),
      op_id(op_id),
      child(child) {
}

class arith_expr__Binary : public arith_expr_t {
 public:
  arith_expr__Binary();
  arith_expr__Binary(Id_t op_id, arith_expr_t* left, arith_expr_t* right);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t op_id;
  arith_expr_t* left;
  arith_expr_t* right;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Binary)
};

constexpr uint16_t maskof_arith_expr__Binary() {
  return
    maskbit(offsetof(arith_expr__Binary, left))
  | maskbit(offsetof(arith_expr__Binary, right));
}

inline arith_expr__Binary::arith_expr__Binary()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(arith_expr_e::Binary)),
      field_mask_(maskof_arith_expr__Binary()),
      op_id(-1),
      left(nullptr),
      right(nullptr) {
}

inline arith_expr__Binary::arith_expr__Binary(Id_t op_id, arith_expr_t* left,
                                              arith_expr_t* right)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(arith_expr_e::Binary)),
      field_mask_(maskof_arith_expr__Binary()),
      op_id(op_id),
      left(left),
      right(right) {
}

class arith_expr__TernaryOp : public arith_expr_t {
 public:
  arith_expr__TernaryOp();
  arith_expr__TernaryOp(arith_expr_t* cond, arith_expr_t* true_expr,
                        arith_expr_t* false_expr);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  arith_expr_t* cond;
  arith_expr_t* true_expr;
  arith_expr_t* false_expr;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__TernaryOp)
};

constexpr uint16_t maskof_arith_expr__TernaryOp() {
  return
    maskbit(offsetof(arith_expr__TernaryOp, cond))
  | maskbit(offsetof(arith_expr__TernaryOp, true_expr))
  | maskbit(offsetof(arith_expr__TernaryOp, false_expr));
}

inline arith_expr__TernaryOp::arith_expr__TernaryOp()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(arith_expr_e::TernaryOp)),
      field_mask_(maskof_arith_expr__TernaryOp()),
      cond(nullptr),
      true_expr(nullptr),
      false_expr(nullptr) {
}

inline arith_expr__TernaryOp::arith_expr__TernaryOp(arith_expr_t* cond,
                                                    arith_expr_t* true_expr,
                                                    arith_expr_t* false_expr)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(arith_expr_e::TernaryOp)),
      field_mask_(maskof_arith_expr__TernaryOp()),
      cond(cond),
      true_expr(true_expr),
      false_expr(false_expr) {
}

namespace arith_expr {
  typedef arith_expr__UnaryAssign UnaryAssign;
  typedef arith_expr__BinaryAssign BinaryAssign;
  typedef arith_expr__Unary Unary;
  typedef arith_expr__Binary Binary;
  typedef arith_expr__TernaryOp TernaryOp;
}

namespace bool_expr_e {
  const int WordTest = 1;
  const int Binary = 2;
  const int Unary = 3;
  const int LogicalNot = 4;
  const int LogicalAnd = 5;
  const int LogicalOr = 6;
};

const char* bool_expr_str(int tag);

class bool_expr_t {
 protected:
  bool_expr_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(bool_expr_t)
};

class bool_expr__WordTest : public bool_expr_t {
 public:
  bool_expr__WordTest();
  bool_expr__WordTest(word_t* w);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  word_t* w;

  DISALLOW_COPY_AND_ASSIGN(bool_expr__WordTest)
};

constexpr uint16_t maskof_bool_expr__WordTest() {
  return
    maskbit(offsetof(bool_expr__WordTest, w));
}

inline bool_expr__WordTest::bool_expr__WordTest()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::WordTest)),
      field_mask_(maskof_bool_expr__WordTest()),
      w(nullptr) {
}

inline bool_expr__WordTest::bool_expr__WordTest(word_t* w)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::WordTest)),
      field_mask_(maskof_bool_expr__WordTest()),
      w(w) {
}

class bool_expr__Binary : public bool_expr_t {
 public:
  bool_expr__Binary();
  bool_expr__Binary(Id_t op_id, word_t* left, word_t* right);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t op_id;
  word_t* left;
  word_t* right;

  DISALLOW_COPY_AND_ASSIGN(bool_expr__Binary)
};

constexpr uint16_t maskof_bool_expr__Binary() {
  return
    maskbit(offsetof(bool_expr__Binary, left))
  | maskbit(offsetof(bool_expr__Binary, right));
}

inline bool_expr__Binary::bool_expr__Binary()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::Binary)),
      field_mask_(maskof_bool_expr__Binary()),
      op_id(-1),
      left(nullptr),
      right(nullptr) {
}

inline bool_expr__Binary::bool_expr__Binary(Id_t op_id, word_t* left, word_t*
                                            right)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::Binary)),
      field_mask_(maskof_bool_expr__Binary()),
      op_id(op_id),
      left(left),
      right(right) {
}

class bool_expr__Unary : public bool_expr_t {
 public:
  bool_expr__Unary();
  bool_expr__Unary(Id_t op_id, word_t* child);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t op_id;
  word_t* child;

  DISALLOW_COPY_AND_ASSIGN(bool_expr__Unary)
};

constexpr uint16_t maskof_bool_expr__Unary() {
  return
    maskbit(offsetof(bool_expr__Unary, child));
}

inline bool_expr__Unary::bool_expr__Unary()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::Unary)),
      field_mask_(maskof_bool_expr__Unary()),
      op_id(-1),
      child(nullptr) {
}

inline bool_expr__Unary::bool_expr__Unary(Id_t op_id, word_t* child)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::Unary)),
      field_mask_(maskof_bool_expr__Unary()),
      op_id(op_id),
      child(child) {
}

class bool_expr__LogicalNot : public bool_expr_t {
 public:
  bool_expr__LogicalNot();
  bool_expr__LogicalNot(bool_expr_t* child);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool_expr_t* child;

  DISALLOW_COPY_AND_ASSIGN(bool_expr__LogicalNot)
};

constexpr uint16_t maskof_bool_expr__LogicalNot() {
  return
    maskbit(offsetof(bool_expr__LogicalNot, child));
}

inline bool_expr__LogicalNot::bool_expr__LogicalNot()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::LogicalNot)),
      field_mask_(maskof_bool_expr__LogicalNot()),
      child(nullptr) {
}

inline bool_expr__LogicalNot::bool_expr__LogicalNot(bool_expr_t* child)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::LogicalNot)),
      field_mask_(maskof_bool_expr__LogicalNot()),
      child(child) {
}

class bool_expr__LogicalAnd : public bool_expr_t {
 public:
  bool_expr__LogicalAnd();
  bool_expr__LogicalAnd(bool_expr_t* left, bool_expr_t* right);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool_expr_t* left;
  bool_expr_t* right;

  DISALLOW_COPY_AND_ASSIGN(bool_expr__LogicalAnd)
};

constexpr uint16_t maskof_bool_expr__LogicalAnd() {
  return
    maskbit(offsetof(bool_expr__LogicalAnd, left))
  | maskbit(offsetof(bool_expr__LogicalAnd, right));
}

inline bool_expr__LogicalAnd::bool_expr__LogicalAnd()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::LogicalAnd)),
      field_mask_(maskof_bool_expr__LogicalAnd()),
      left(nullptr),
      right(nullptr) {
}

inline bool_expr__LogicalAnd::bool_expr__LogicalAnd(bool_expr_t* left,
                                                    bool_expr_t* right)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::LogicalAnd)),
      field_mask_(maskof_bool_expr__LogicalAnd()),
      left(left),
      right(right) {
}

class bool_expr__LogicalOr : public bool_expr_t {
 public:
  bool_expr__LogicalOr();
  bool_expr__LogicalOr(bool_expr_t* left, bool_expr_t* right);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool_expr_t* left;
  bool_expr_t* right;

  DISALLOW_COPY_AND_ASSIGN(bool_expr__LogicalOr)
};

constexpr uint16_t maskof_bool_expr__LogicalOr() {
  return
    maskbit(offsetof(bool_expr__LogicalOr, left))
  | maskbit(offsetof(bool_expr__LogicalOr, right));
}

inline bool_expr__LogicalOr::bool_expr__LogicalOr()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::LogicalOr)),
      field_mask_(maskof_bool_expr__LogicalOr()),
      left(nullptr),
      right(nullptr) {
}

inline bool_expr__LogicalOr::bool_expr__LogicalOr(bool_expr_t* left,
                                                  bool_expr_t* right)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(bool_expr_e::LogicalOr)),
      field_mask_(maskof_bool_expr__LogicalOr()),
      left(left),
      right(right) {
}

namespace bool_expr {
  typedef bool_expr__WordTest WordTest;
  typedef bool_expr__Binary Binary;
  typedef bool_expr__Unary Unary;
  typedef bool_expr__LogicalNot LogicalNot;
  typedef bool_expr__LogicalAnd LogicalAnd;
  typedef bool_expr__LogicalOr LogicalOr;
}

namespace redir_loc_e {
  const int Fd = 1;
  const int VarName = 2;
};

const char* redir_loc_str(int tag);

class redir_loc_t {
 protected:
  redir_loc_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(redir_loc_t)
};

class redir_loc__Fd : public redir_loc_t {
 public:
  redir_loc__Fd();
  redir_loc__Fd(int fd);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int fd;

  DISALLOW_COPY_AND_ASSIGN(redir_loc__Fd)
};

inline redir_loc__Fd::redir_loc__Fd()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redir_loc_e::Fd)),
      field_mask_(kZeroMask),
      fd(-1) {
}

inline redir_loc__Fd::redir_loc__Fd(int fd)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redir_loc_e::Fd)),
      field_mask_(kZeroMask),
      fd(fd) {
}

class redir_loc__VarName : public redir_loc_t {
 public:
  redir_loc__VarName();
  redir_loc__VarName(Str* name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* name;

  DISALLOW_COPY_AND_ASSIGN(redir_loc__VarName)
};

constexpr uint16_t maskof_redir_loc__VarName() {
  return
    maskbit(offsetof(redir_loc__VarName, name));
}

inline redir_loc__VarName::redir_loc__VarName()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redir_loc_e::VarName)),
      field_mask_(maskof_redir_loc__VarName()),
      name(StrFromC("")) {
}

inline redir_loc__VarName::redir_loc__VarName(Str* name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redir_loc_e::VarName)),
      field_mask_(maskof_redir_loc__VarName()),
      name(name) {
}

namespace redir_loc {
  typedef redir_loc__Fd Fd;
  typedef redir_loc__VarName VarName;
}

namespace redir_param_e {
  const int Word = 210;
  const int HereDoc = 2;
};

const char* redir_param_str(int tag);

class redir_param_t {
 protected:
  redir_param_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(redir_param_t)
};

class redir_param__HereDoc : public redir_param_t {
 public:
  redir_param__HereDoc();
  redir_param__HereDoc(word_t* here_begin, int here_end_span_id,
                       List<word_part_t*>* stdin_parts);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  word_t* here_begin;
  int here_end_span_id;
  List<word_part_t*>* stdin_parts;

  DISALLOW_COPY_AND_ASSIGN(redir_param__HereDoc)
};

constexpr uint16_t maskof_redir_param__HereDoc() {
  return
    maskbit(offsetof(redir_param__HereDoc, here_begin))
  | maskbit(offsetof(redir_param__HereDoc, stdin_parts));
}

inline redir_param__HereDoc::redir_param__HereDoc()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redir_param_e::HereDoc)),
      field_mask_(maskof_redir_param__HereDoc()),
      here_begin(nullptr),
      here_end_span_id(-1),
      stdin_parts(NewList<word_part_t*>()) {
}

inline redir_param__HereDoc::redir_param__HereDoc(word_t* here_begin, int
                                                  here_end_span_id,
                                                  List<word_part_t*>*
                                                  stdin_parts)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(redir_param_e::HereDoc)),
      field_mask_(maskof_redir_param__HereDoc()),
      here_begin(here_begin),
      here_end_span_id(here_end_span_id),
      stdin_parts(stdin_parts) {
}

namespace redir_param {
  typedef redir_param__HereDoc HereDoc;
}

enum class assign_op_e {
  Equal = 1,
  PlusEqual = 2,
};
typedef assign_op_e assign_op_t;

const char* assign_op_str(assign_op_e tag);

namespace condition_e {
  const int Shell = 1;
  const int Oil = 2;
};

const char* condition_str(int tag);

class condition_t {
 protected:
  condition_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(condition_t)
};

class condition__Shell : public condition_t {
 public:
  condition__Shell();
  condition__Shell(List<command_t*>* commands);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<command_t*>* commands;

  DISALLOW_COPY_AND_ASSIGN(condition__Shell)
};

constexpr uint16_t maskof_condition__Shell() {
  return
    maskbit(offsetof(condition__Shell, commands));
}

inline condition__Shell::condition__Shell()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(condition_e::Shell)),
      field_mask_(maskof_condition__Shell()),
      commands(NewList<command_t*>()) {
}

inline condition__Shell::condition__Shell(List<command_t*>* commands)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(condition_e::Shell)),
      field_mask_(maskof_condition__Shell()),
      commands(commands) {
}

class condition__Oil : public condition_t {
 public:
  condition__Oil();
  condition__Oil(expr_t* e);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* e;

  DISALLOW_COPY_AND_ASSIGN(condition__Oil)
};

constexpr uint16_t maskof_condition__Oil() {
  return
    maskbit(offsetof(condition__Oil, e));
}

inline condition__Oil::condition__Oil()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(condition_e::Oil)),
      field_mask_(maskof_condition__Oil()),
      e(nullptr) {
}

inline condition__Oil::condition__Oil(expr_t* e)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(condition_e::Oil)),
      field_mask_(maskof_condition__Oil()),
      e(e) {
}

namespace condition {
  typedef condition__Shell Shell;
  typedef condition__Oil Oil;
}

namespace for_iter_e {
  const int Args = 1;
  const int Words = 2;
  const int Oil = 3;
};

const char* for_iter_str(int tag);

class for_iter_t {
 protected:
  for_iter_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(for_iter_t)
};

class for_iter__Args : public for_iter_t {
 public:
  for_iter__Args();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(for_iter__Args)
};

inline for_iter__Args::for_iter__Args()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(for_iter_e::Args)),
      field_mask_(kZeroMask) {
}

class for_iter__Words : public for_iter_t {
 public:
  for_iter__Words();
  for_iter__Words(List<word_t*>* words);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<word_t*>* words;

  DISALLOW_COPY_AND_ASSIGN(for_iter__Words)
};

constexpr uint16_t maskof_for_iter__Words() {
  return
    maskbit(offsetof(for_iter__Words, words));
}

inline for_iter__Words::for_iter__Words()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(for_iter_e::Words)),
      field_mask_(maskof_for_iter__Words()),
      words(NewList<word_t*>()) {
}

inline for_iter__Words::for_iter__Words(List<word_t*>* words)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(for_iter_e::Words)),
      field_mask_(maskof_for_iter__Words()),
      words(words) {
}

class for_iter__Oil : public for_iter_t {
 public:
  for_iter__Oil();
  for_iter__Oil(expr_t* e, Token* blame);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* e;
  Token* blame;

  DISALLOW_COPY_AND_ASSIGN(for_iter__Oil)
};

constexpr uint16_t maskof_for_iter__Oil() {
  return
    maskbit(offsetof(for_iter__Oil, e))
  | maskbit(offsetof(for_iter__Oil, blame));
}

inline for_iter__Oil::for_iter__Oil()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(for_iter_e::Oil)),
      field_mask_(maskof_for_iter__Oil()),
      e(nullptr),
      blame(nullptr) {
}

inline for_iter__Oil::for_iter__Oil(expr_t* e, Token* blame)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(for_iter_e::Oil)),
      field_mask_(maskof_for_iter__Oil()),
      e(e),
      blame(blame) {
}

namespace for_iter {
  typedef for_iter__Args Args;
  typedef for_iter__Words Words;
  typedef for_iter__Oil Oil;
}

namespace command_e {
  const int NoOp = 1;
  const int Simple = 2;
  const int ExpandedAlias = 3;
  const int Sentence = 4;
  const int ShAssignment = 5;
  const int ControlFlow = 6;
  const int Pipeline = 7;
  const int AndOr = 8;
  const int DoGroup = 9;
  const int BraceGroup = 218;
  const int Subshell = 11;
  const int DParen = 12;
  const int DBracket = 13;
  const int ForEach = 14;
  const int ForExpr = 15;
  const int WhileUntil = 16;
  const int If = 17;
  const int Case = 18;
  const int ShFunction = 19;
  const int TimeBlock = 20;
  const int CommandList = 21;
  const int BareDecl = 22;
  const int VarDecl = 23;
  const int PlaceMutation = 24;
  const int Expr = 25;
  const int Proc = 26;
  const int Func = 27;
  const int Data = 28;
  const int Enum = 29;
  const int Class = 30;
  const int Import = 31;
  const int For = 32;
  const int While = 33;
  const int Break = 34;
  const int Continue = 35;
  const int Return = 36;
};

const char* command_str(int tag);

class command_t {
 protected:
  command_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(command_t)
};

class command__NoOp : public command_t {
 public:
  command__NoOp();
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__NoOp)
};

constexpr uint16_t maskof_command__NoOp() {
  return
    maskbit(offsetof(command__NoOp, spids));
}

inline command__NoOp::command__NoOp()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::NoOp)),
      field_mask_(maskof_command__NoOp()),
      spids(NewList<int>()) {
}

class command__Simple : public command_t {
 public:
  command__Simple();
  command__Simple(List<word_t*>* words, List<redir*>* redirects,
                  List<env_pair*>* more_env, ArgList* typed_args, BraceGroup*
                  block, bool do_fork);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<word_t*>* words;
  List<redir*>* redirects;
  List<env_pair*>* more_env;
  ArgList* typed_args;
  BraceGroup* block;
  bool do_fork;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Simple)
};

constexpr uint16_t maskof_command__Simple() {
  return
    maskbit(offsetof(command__Simple, words))
  | maskbit(offsetof(command__Simple, redirects))
  | maskbit(offsetof(command__Simple, more_env))
  | maskbit(offsetof(command__Simple, typed_args))
  | maskbit(offsetof(command__Simple, block))
  | maskbit(offsetof(command__Simple, spids));
}

inline command__Simple::command__Simple()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Simple)),
      field_mask_(maskof_command__Simple()),
      words(NewList<word_t*>()),
      redirects(NewList<redir*>()),
      more_env(NewList<env_pair*>()),
      typed_args(nullptr),
      block(nullptr),
      do_fork(false),
      spids(NewList<int>()) {
}

inline command__Simple::command__Simple(List<word_t*>* words, List<redir*>*
                                        redirects, List<env_pair*>* more_env,
                                        ArgList* typed_args, BraceGroup* block,
                                        bool do_fork)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Simple)),
      field_mask_(maskof_command__Simple()),
      words(words),
      redirects(redirects),
      more_env(more_env),
      typed_args(typed_args),
      block(block),
      do_fork(do_fork),
      spids(NewList<int>()) {
}

class command__ExpandedAlias : public command_t {
 public:
  command__ExpandedAlias();
  command__ExpandedAlias(command_t* child, List<redir*>* redirects,
                         List<env_pair*>* more_env);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  command_t* child;
  List<redir*>* redirects;
  List<env_pair*>* more_env;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__ExpandedAlias)
};

constexpr uint16_t maskof_command__ExpandedAlias() {
  return
    maskbit(offsetof(command__ExpandedAlias, child))
  | maskbit(offsetof(command__ExpandedAlias, redirects))
  | maskbit(offsetof(command__ExpandedAlias, more_env))
  | maskbit(offsetof(command__ExpandedAlias, spids));
}

inline command__ExpandedAlias::command__ExpandedAlias()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ExpandedAlias)),
      field_mask_(maskof_command__ExpandedAlias()),
      child(nullptr),
      redirects(NewList<redir*>()),
      more_env(NewList<env_pair*>()),
      spids(NewList<int>()) {
}

inline command__ExpandedAlias::command__ExpandedAlias(command_t* child,
                                                      List<redir*>* redirects,
                                                      List<env_pair*>* more_env)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ExpandedAlias)),
      field_mask_(maskof_command__ExpandedAlias()),
      child(child),
      redirects(redirects),
      more_env(more_env),
      spids(NewList<int>()) {
}

class command__Sentence : public command_t {
 public:
  command__Sentence();
  command__Sentence(command_t* child, Token* terminator);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  command_t* child;
  Token* terminator;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Sentence)
};

constexpr uint16_t maskof_command__Sentence() {
  return
    maskbit(offsetof(command__Sentence, child))
  | maskbit(offsetof(command__Sentence, terminator))
  | maskbit(offsetof(command__Sentence, spids));
}

inline command__Sentence::command__Sentence()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Sentence)),
      field_mask_(maskof_command__Sentence()),
      child(nullptr),
      terminator(nullptr),
      spids(NewList<int>()) {
}

inline command__Sentence::command__Sentence(command_t* child, Token* terminator)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Sentence)),
      field_mask_(maskof_command__Sentence()),
      child(child),
      terminator(terminator),
      spids(NewList<int>()) {
}

class command__ShAssignment : public command_t {
 public:
  command__ShAssignment();
  command__ShAssignment(List<assign_pair*>* pairs, List<redir*>* redirects);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<assign_pair*>* pairs;
  List<redir*>* redirects;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__ShAssignment)
};

constexpr uint16_t maskof_command__ShAssignment() {
  return
    maskbit(offsetof(command__ShAssignment, pairs))
  | maskbit(offsetof(command__ShAssignment, redirects))
  | maskbit(offsetof(command__ShAssignment, spids));
}

inline command__ShAssignment::command__ShAssignment()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ShAssignment)),
      field_mask_(maskof_command__ShAssignment()),
      pairs(NewList<assign_pair*>()),
      redirects(NewList<redir*>()),
      spids(NewList<int>()) {
}

inline command__ShAssignment::command__ShAssignment(List<assign_pair*>* pairs,
                                                    List<redir*>* redirects)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ShAssignment)),
      field_mask_(maskof_command__ShAssignment()),
      pairs(pairs),
      redirects(redirects),
      spids(NewList<int>()) {
}

class command__ControlFlow : public command_t {
 public:
  command__ControlFlow();
  command__ControlFlow(Token* token, word_t* arg_word);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* token;
  word_t* arg_word;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__ControlFlow)
};

constexpr uint16_t maskof_command__ControlFlow() {
  return
    maskbit(offsetof(command__ControlFlow, token))
  | maskbit(offsetof(command__ControlFlow, arg_word))
  | maskbit(offsetof(command__ControlFlow, spids));
}

inline command__ControlFlow::command__ControlFlow()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ControlFlow)),
      field_mask_(maskof_command__ControlFlow()),
      token(nullptr),
      arg_word(nullptr),
      spids(NewList<int>()) {
}

inline command__ControlFlow::command__ControlFlow(Token* token, word_t*
                                                  arg_word)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ControlFlow)),
      field_mask_(maskof_command__ControlFlow()),
      token(token),
      arg_word(arg_word),
      spids(NewList<int>()) {
}

class command__Pipeline : public command_t {
 public:
  command__Pipeline();
  command__Pipeline(List<command_t*>* children, bool negated, List<int>*
                    stderr_indices);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<command_t*>* children;
  bool negated;
  List<int>* stderr_indices;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Pipeline)
};

constexpr uint16_t maskof_command__Pipeline() {
  return
    maskbit(offsetof(command__Pipeline, children))
  | maskbit(offsetof(command__Pipeline, stderr_indices))
  | maskbit(offsetof(command__Pipeline, spids));
}

inline command__Pipeline::command__Pipeline()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Pipeline)),
      field_mask_(maskof_command__Pipeline()),
      children(NewList<command_t*>()),
      negated(false),
      stderr_indices(NewList<int>()),
      spids(NewList<int>()) {
}

inline command__Pipeline::command__Pipeline(List<command_t*>* children, bool
                                            negated, List<int>* stderr_indices)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Pipeline)),
      field_mask_(maskof_command__Pipeline()),
      children(children),
      negated(negated),
      stderr_indices(stderr_indices),
      spids(NewList<int>()) {
}

class command__AndOr : public command_t {
 public:
  command__AndOr();
  command__AndOr(List<Id_t>* ops, List<command_t*>* children);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<Id_t>* ops;
  List<command_t*>* children;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__AndOr)
};

constexpr uint16_t maskof_command__AndOr() {
  return
    maskbit(offsetof(command__AndOr, ops))
  | maskbit(offsetof(command__AndOr, children))
  | maskbit(offsetof(command__AndOr, spids));
}

inline command__AndOr::command__AndOr()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::AndOr)),
      field_mask_(maskof_command__AndOr()),
      ops(NewList<Id_t>()),
      children(NewList<command_t*>()),
      spids(NewList<int>()) {
}

inline command__AndOr::command__AndOr(List<Id_t>* ops, List<command_t*>*
                                      children)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::AndOr)),
      field_mask_(maskof_command__AndOr()),
      ops(ops),
      children(children),
      spids(NewList<int>()) {
}

class command__DoGroup : public command_t {
 public:
  command__DoGroup();
  command__DoGroup(List<command_t*>* children);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<command_t*>* children;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__DoGroup)
};

constexpr uint16_t maskof_command__DoGroup() {
  return
    maskbit(offsetof(command__DoGroup, children))
  | maskbit(offsetof(command__DoGroup, spids));
}

inline command__DoGroup::command__DoGroup()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::DoGroup)),
      field_mask_(maskof_command__DoGroup()),
      children(NewList<command_t*>()),
      spids(NewList<int>()) {
}

inline command__DoGroup::command__DoGroup(List<command_t*>* children)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::DoGroup)),
      field_mask_(maskof_command__DoGroup()),
      children(children),
      spids(NewList<int>()) {
}

class command__Subshell : public command_t {
 public:
  command__Subshell();
  command__Subshell(command_t* child, List<redir*>* redirects);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  command_t* child;
  List<redir*>* redirects;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Subshell)
};

constexpr uint16_t maskof_command__Subshell() {
  return
    maskbit(offsetof(command__Subshell, child))
  | maskbit(offsetof(command__Subshell, redirects))
  | maskbit(offsetof(command__Subshell, spids));
}

inline command__Subshell::command__Subshell()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Subshell)),
      field_mask_(maskof_command__Subshell()),
      child(nullptr),
      redirects(NewList<redir*>()),
      spids(NewList<int>()) {
}

inline command__Subshell::command__Subshell(command_t* child, List<redir*>*
                                            redirects)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Subshell)),
      field_mask_(maskof_command__Subshell()),
      child(child),
      redirects(redirects),
      spids(NewList<int>()) {
}

class command__DParen : public command_t {
 public:
  command__DParen();
  command__DParen(arith_expr_t* child, List<redir*>* redirects);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  arith_expr_t* child;
  List<redir*>* redirects;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__DParen)
};

constexpr uint16_t maskof_command__DParen() {
  return
    maskbit(offsetof(command__DParen, child))
  | maskbit(offsetof(command__DParen, redirects))
  | maskbit(offsetof(command__DParen, spids));
}

inline command__DParen::command__DParen()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::DParen)),
      field_mask_(maskof_command__DParen()),
      child(nullptr),
      redirects(NewList<redir*>()),
      spids(NewList<int>()) {
}

inline command__DParen::command__DParen(arith_expr_t* child, List<redir*>*
                                        redirects)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::DParen)),
      field_mask_(maskof_command__DParen()),
      child(child),
      redirects(redirects),
      spids(NewList<int>()) {
}

class command__DBracket : public command_t {
 public:
  command__DBracket();
  command__DBracket(bool_expr_t* expr, List<redir*>* redirects);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool_expr_t* expr;
  List<redir*>* redirects;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__DBracket)
};

constexpr uint16_t maskof_command__DBracket() {
  return
    maskbit(offsetof(command__DBracket, expr))
  | maskbit(offsetof(command__DBracket, redirects))
  | maskbit(offsetof(command__DBracket, spids));
}

inline command__DBracket::command__DBracket()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::DBracket)),
      field_mask_(maskof_command__DBracket()),
      expr(nullptr),
      redirects(NewList<redir*>()),
      spids(NewList<int>()) {
}

inline command__DBracket::command__DBracket(bool_expr_t* expr, List<redir*>*
                                            redirects)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::DBracket)),
      field_mask_(maskof_command__DBracket()),
      expr(expr),
      redirects(redirects),
      spids(NewList<int>()) {
}

class command__ForEach : public command_t {
 public:
  command__ForEach();
  command__ForEach(List<Str*>* iter_names, for_iter_t* iterable, command_t*
                   body, List<redir*>* redirects);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<Str*>* iter_names;
  for_iter_t* iterable;
  command_t* body;
  List<redir*>* redirects;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__ForEach)
};

constexpr uint16_t maskof_command__ForEach() {
  return
    maskbit(offsetof(command__ForEach, iter_names))
  | maskbit(offsetof(command__ForEach, iterable))
  | maskbit(offsetof(command__ForEach, body))
  | maskbit(offsetof(command__ForEach, redirects))
  | maskbit(offsetof(command__ForEach, spids));
}

inline command__ForEach::command__ForEach()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ForEach)),
      field_mask_(maskof_command__ForEach()),
      iter_names(NewList<Str*>()),
      iterable(nullptr),
      body(nullptr),
      redirects(NewList<redir*>()),
      spids(NewList<int>()) {
}

inline command__ForEach::command__ForEach(List<Str*>* iter_names, for_iter_t*
                                          iterable, command_t* body,
                                          List<redir*>* redirects)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ForEach)),
      field_mask_(maskof_command__ForEach()),
      iter_names(iter_names),
      iterable(iterable),
      body(body),
      redirects(redirects),
      spids(NewList<int>()) {
}

class command__ForExpr : public command_t {
 public:
  command__ForExpr();
  command__ForExpr(arith_expr_t* init, arith_expr_t* cond, arith_expr_t*
                   update, command_t* body, List<redir*>* redirects);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  arith_expr_t* init;
  arith_expr_t* cond;
  arith_expr_t* update;
  command_t* body;
  List<redir*>* redirects;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__ForExpr)
};

constexpr uint16_t maskof_command__ForExpr() {
  return
    maskbit(offsetof(command__ForExpr, init))
  | maskbit(offsetof(command__ForExpr, cond))
  | maskbit(offsetof(command__ForExpr, update))
  | maskbit(offsetof(command__ForExpr, body))
  | maskbit(offsetof(command__ForExpr, redirects))
  | maskbit(offsetof(command__ForExpr, spids));
}

inline command__ForExpr::command__ForExpr()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ForExpr)),
      field_mask_(maskof_command__ForExpr()),
      init(nullptr),
      cond(nullptr),
      update(nullptr),
      body(nullptr),
      redirects(NewList<redir*>()),
      spids(NewList<int>()) {
}

inline command__ForExpr::command__ForExpr(arith_expr_t* init, arith_expr_t*
                                          cond, arith_expr_t* update,
                                          command_t* body, List<redir*>*
                                          redirects)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ForExpr)),
      field_mask_(maskof_command__ForExpr()),
      init(init),
      cond(cond),
      update(update),
      body(body),
      redirects(redirects),
      spids(NewList<int>()) {
}

class command__WhileUntil : public command_t {
 public:
  command__WhileUntil();
  command__WhileUntil(Token* keyword, condition_t* cond, command_t* body,
                      List<redir*>* redirects);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* keyword;
  condition_t* cond;
  command_t* body;
  List<redir*>* redirects;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__WhileUntil)
};

constexpr uint16_t maskof_command__WhileUntil() {
  return
    maskbit(offsetof(command__WhileUntil, keyword))
  | maskbit(offsetof(command__WhileUntil, cond))
  | maskbit(offsetof(command__WhileUntil, body))
  | maskbit(offsetof(command__WhileUntil, redirects))
  | maskbit(offsetof(command__WhileUntil, spids));
}

inline command__WhileUntil::command__WhileUntil()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::WhileUntil)),
      field_mask_(maskof_command__WhileUntil()),
      keyword(nullptr),
      cond(nullptr),
      body(nullptr),
      redirects(NewList<redir*>()),
      spids(NewList<int>()) {
}

inline command__WhileUntil::command__WhileUntil(Token* keyword, condition_t*
                                                cond, command_t* body,
                                                List<redir*>* redirects)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::WhileUntil)),
      field_mask_(maskof_command__WhileUntil()),
      keyword(keyword),
      cond(cond),
      body(body),
      redirects(redirects),
      spids(NewList<int>()) {
}

class command__If : public command_t {
 public:
  command__If();
  command__If(List<if_arm*>* arms, List<command_t*>* else_action, List<redir*>*
              redirects);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<if_arm*>* arms;
  List<command_t*>* else_action;
  List<redir*>* redirects;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__If)
};

constexpr uint16_t maskof_command__If() {
  return
    maskbit(offsetof(command__If, arms))
  | maskbit(offsetof(command__If, else_action))
  | maskbit(offsetof(command__If, redirects))
  | maskbit(offsetof(command__If, spids));
}

inline command__If::command__If()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::If)),
      field_mask_(maskof_command__If()),
      arms(NewList<if_arm*>()),
      else_action(NewList<command_t*>()),
      redirects(NewList<redir*>()),
      spids(NewList<int>()) {
}

inline command__If::command__If(List<if_arm*>* arms, List<command_t*>*
                                else_action, List<redir*>* redirects)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::If)),
      field_mask_(maskof_command__If()),
      arms(arms),
      else_action(else_action),
      redirects(redirects),
      spids(NewList<int>()) {
}

class command__Case : public command_t {
 public:
  command__Case();
  command__Case(word_t* to_match, List<case_arm*>* arms, List<redir*>*
                redirects);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  word_t* to_match;
  List<case_arm*>* arms;
  List<redir*>* redirects;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Case)
};

constexpr uint16_t maskof_command__Case() {
  return
    maskbit(offsetof(command__Case, to_match))
  | maskbit(offsetof(command__Case, arms))
  | maskbit(offsetof(command__Case, redirects))
  | maskbit(offsetof(command__Case, spids));
}

inline command__Case::command__Case()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Case)),
      field_mask_(maskof_command__Case()),
      to_match(nullptr),
      arms(NewList<case_arm*>()),
      redirects(NewList<redir*>()),
      spids(NewList<int>()) {
}

inline command__Case::command__Case(word_t* to_match, List<case_arm*>* arms,
                                    List<redir*>* redirects)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Case)),
      field_mask_(maskof_command__Case()),
      to_match(to_match),
      arms(arms),
      redirects(redirects),
      spids(NewList<int>()) {
}

class command__ShFunction : public command_t {
 public:
  command__ShFunction();
  command__ShFunction(Str* name, command_t* body);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* name;
  command_t* body;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__ShFunction)
};

constexpr uint16_t maskof_command__ShFunction() {
  return
    maskbit(offsetof(command__ShFunction, name))
  | maskbit(offsetof(command__ShFunction, body))
  | maskbit(offsetof(command__ShFunction, spids));
}

inline command__ShFunction::command__ShFunction()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ShFunction)),
      field_mask_(maskof_command__ShFunction()),
      name(StrFromC("")),
      body(nullptr),
      spids(NewList<int>()) {
}

inline command__ShFunction::command__ShFunction(Str* name, command_t* body)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::ShFunction)),
      field_mask_(maskof_command__ShFunction()),
      name(name),
      body(body),
      spids(NewList<int>()) {
}

class command__TimeBlock : public command_t {
 public:
  command__TimeBlock();
  command__TimeBlock(command_t* pipeline);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  command_t* pipeline;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__TimeBlock)
};

constexpr uint16_t maskof_command__TimeBlock() {
  return
    maskbit(offsetof(command__TimeBlock, pipeline))
  | maskbit(offsetof(command__TimeBlock, spids));
}

inline command__TimeBlock::command__TimeBlock()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::TimeBlock)),
      field_mask_(maskof_command__TimeBlock()),
      pipeline(nullptr),
      spids(NewList<int>()) {
}

inline command__TimeBlock::command__TimeBlock(command_t* pipeline)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::TimeBlock)),
      field_mask_(maskof_command__TimeBlock()),
      pipeline(pipeline),
      spids(NewList<int>()) {
}

class command__CommandList : public command_t {
 public:
  command__CommandList();
  command__CommandList(List<command_t*>* children);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<command_t*>* children;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__CommandList)
};

constexpr uint16_t maskof_command__CommandList() {
  return
    maskbit(offsetof(command__CommandList, children))
  | maskbit(offsetof(command__CommandList, spids));
}

inline command__CommandList::command__CommandList()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::CommandList)),
      field_mask_(maskof_command__CommandList()),
      children(NewList<command_t*>()),
      spids(NewList<int>()) {
}

inline command__CommandList::command__CommandList(List<command_t*>* children)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::CommandList)),
      field_mask_(maskof_command__CommandList()),
      children(children),
      spids(NewList<int>()) {
}

class command__BareDecl : public command_t {
 public:
  command__BareDecl();
  command__BareDecl(Token* lhs, expr_t* rhs);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* lhs;
  expr_t* rhs;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__BareDecl)
};

constexpr uint16_t maskof_command__BareDecl() {
  return
    maskbit(offsetof(command__BareDecl, lhs))
  | maskbit(offsetof(command__BareDecl, rhs))
  | maskbit(offsetof(command__BareDecl, spids));
}

inline command__BareDecl::command__BareDecl()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::BareDecl)),
      field_mask_(maskof_command__BareDecl()),
      lhs(nullptr),
      rhs(nullptr),
      spids(NewList<int>()) {
}

inline command__BareDecl::command__BareDecl(Token* lhs, expr_t* rhs)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::BareDecl)),
      field_mask_(maskof_command__BareDecl()),
      lhs(lhs),
      rhs(rhs),
      spids(NewList<int>()) {
}

class command__VarDecl : public command_t {
 public:
  command__VarDecl();
  command__VarDecl(Token* keyword, List<name_type*>* lhs, expr_t* rhs);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* keyword;
  List<name_type*>* lhs;
  expr_t* rhs;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__VarDecl)
};

constexpr uint16_t maskof_command__VarDecl() {
  return
    maskbit(offsetof(command__VarDecl, keyword))
  | maskbit(offsetof(command__VarDecl, lhs))
  | maskbit(offsetof(command__VarDecl, rhs))
  | maskbit(offsetof(command__VarDecl, spids));
}

inline command__VarDecl::command__VarDecl()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::VarDecl)),
      field_mask_(maskof_command__VarDecl()),
      keyword(nullptr),
      lhs(NewList<name_type*>()),
      rhs(nullptr),
      spids(NewList<int>()) {
}

inline command__VarDecl::command__VarDecl(Token* keyword, List<name_type*>*
                                          lhs, expr_t* rhs)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::VarDecl)),
      field_mask_(maskof_command__VarDecl()),
      keyword(keyword),
      lhs(lhs),
      rhs(rhs),
      spids(NewList<int>()) {
}

class command__PlaceMutation : public command_t {
 public:
  command__PlaceMutation();
  command__PlaceMutation(Token* keyword, List<place_expr_t*>* lhs, Token* op,
                         expr_t* rhs);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* keyword;
  List<place_expr_t*>* lhs;
  Token* op;
  expr_t* rhs;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__PlaceMutation)
};

constexpr uint16_t maskof_command__PlaceMutation() {
  return
    maskbit(offsetof(command__PlaceMutation, keyword))
  | maskbit(offsetof(command__PlaceMutation, lhs))
  | maskbit(offsetof(command__PlaceMutation, op))
  | maskbit(offsetof(command__PlaceMutation, rhs))
  | maskbit(offsetof(command__PlaceMutation, spids));
}

inline command__PlaceMutation::command__PlaceMutation()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::PlaceMutation)),
      field_mask_(maskof_command__PlaceMutation()),
      keyword(nullptr),
      lhs(NewList<place_expr_t*>()),
      op(nullptr),
      rhs(nullptr),
      spids(NewList<int>()) {
}

inline command__PlaceMutation::command__PlaceMutation(Token* keyword,
                                                      List<place_expr_t*>* lhs,
                                                      Token* op, expr_t* rhs)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::PlaceMutation)),
      field_mask_(maskof_command__PlaceMutation()),
      keyword(keyword),
      lhs(lhs),
      op(op),
      rhs(rhs),
      spids(NewList<int>()) {
}

class command__Expr : public command_t {
 public:
  command__Expr();
  command__Expr(speck* keyword, expr_t* e);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  speck* keyword;
  expr_t* e;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Expr)
};

constexpr uint16_t maskof_command__Expr() {
  return
    maskbit(offsetof(command__Expr, keyword))
  | maskbit(offsetof(command__Expr, e))
  | maskbit(offsetof(command__Expr, spids));
}

inline command__Expr::command__Expr()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Expr)),
      field_mask_(maskof_command__Expr()),
      keyword(nullptr),
      e(nullptr),
      spids(NewList<int>()) {
}

inline command__Expr::command__Expr(speck* keyword, expr_t* e)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Expr)),
      field_mask_(maskof_command__Expr()),
      keyword(keyword),
      e(e),
      spids(NewList<int>()) {
}

class command__Proc : public command_t {
 public:
  command__Proc();
  command__Proc(Token* name, proc_sig_t* sig, command_t* body);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  proc_sig_t* sig;
  command_t* body;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Proc)
};

constexpr uint16_t maskof_command__Proc() {
  return
    maskbit(offsetof(command__Proc, name))
  | maskbit(offsetof(command__Proc, sig))
  | maskbit(offsetof(command__Proc, body))
  | maskbit(offsetof(command__Proc, spids));
}

inline command__Proc::command__Proc()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Proc)),
      field_mask_(maskof_command__Proc()),
      name(nullptr),
      sig(nullptr),
      body(nullptr),
      spids(NewList<int>()) {
}

inline command__Proc::command__Proc(Token* name, proc_sig_t* sig, command_t*
                                    body)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Proc)),
      field_mask_(maskof_command__Proc()),
      name(name),
      sig(sig),
      body(body),
      spids(NewList<int>()) {
}

class command__Func : public command_t {
 public:
  command__Func();
  command__Func(Token* name, List<param*>* pos_params, Token* pos_splat,
                List<param*>* named_params, Token* named_splat,
                List<type_expr_t*>* return_types, command_t* body);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  List<param*>* pos_params;
  Token* pos_splat;
  List<param*>* named_params;
  Token* named_splat;
  List<type_expr_t*>* return_types;
  command_t* body;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Func)
};

constexpr uint16_t maskof_command__Func() {
  return
    maskbit(offsetof(command__Func, name))
  | maskbit(offsetof(command__Func, pos_params))
  | maskbit(offsetof(command__Func, pos_splat))
  | maskbit(offsetof(command__Func, named_params))
  | maskbit(offsetof(command__Func, named_splat))
  | maskbit(offsetof(command__Func, return_types))
  | maskbit(offsetof(command__Func, body))
  | maskbit(offsetof(command__Func, spids));
}

inline command__Func::command__Func()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Func)),
      field_mask_(maskof_command__Func()),
      name(nullptr),
      pos_params(NewList<param*>()),
      pos_splat(nullptr),
      named_params(NewList<param*>()),
      named_splat(nullptr),
      return_types(NewList<type_expr_t*>()),
      body(nullptr),
      spids(NewList<int>()) {
}

inline command__Func::command__Func(Token* name, List<param*>* pos_params,
                                    Token* pos_splat, List<param*>*
                                    named_params, Token* named_splat,
                                    List<type_expr_t*>* return_types,
                                    command_t* body)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Func)),
      field_mask_(maskof_command__Func()),
      name(name),
      pos_params(pos_params),
      pos_splat(pos_splat),
      named_params(named_params),
      named_splat(named_splat),
      return_types(return_types),
      body(body),
      spids(NewList<int>()) {
}

class command__Data : public command_t {
 public:
  command__Data();
  command__Data(Token* name, List<param*>* params);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  List<param*>* params;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Data)
};

constexpr uint16_t maskof_command__Data() {
  return
    maskbit(offsetof(command__Data, name))
  | maskbit(offsetof(command__Data, params))
  | maskbit(offsetof(command__Data, spids));
}

inline command__Data::command__Data()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Data)),
      field_mask_(maskof_command__Data()),
      name(nullptr),
      params(NewList<param*>()),
      spids(NewList<int>()) {
}

inline command__Data::command__Data(Token* name, List<param*>* params)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Data)),
      field_mask_(maskof_command__Data()),
      name(name),
      params(params),
      spids(NewList<int>()) {
}

class command__Enum : public command_t {
 public:
  command__Enum();
  command__Enum(Token* name, List<variant*>* variants);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  List<variant*>* variants;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Enum)
};

constexpr uint16_t maskof_command__Enum() {
  return
    maskbit(offsetof(command__Enum, name))
  | maskbit(offsetof(command__Enum, variants))
  | maskbit(offsetof(command__Enum, spids));
}

inline command__Enum::command__Enum()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Enum)),
      field_mask_(maskof_command__Enum()),
      name(nullptr),
      variants(NewList<variant*>()),
      spids(NewList<int>()) {
}

inline command__Enum::command__Enum(Token* name, List<variant*>* variants)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Enum)),
      field_mask_(maskof_command__Enum()),
      name(name),
      variants(variants),
      spids(NewList<int>()) {
}

class command__Class : public command_t {
 public:
  command__Class();
  command__Class(Token* name, Token* extends, List<class_item_t*>* items);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  Token* extends;
  List<class_item_t*>* items;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Class)
};

constexpr uint16_t maskof_command__Class() {
  return
    maskbit(offsetof(command__Class, name))
  | maskbit(offsetof(command__Class, extends))
  | maskbit(offsetof(command__Class, items))
  | maskbit(offsetof(command__Class, spids));
}

inline command__Class::command__Class()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Class)),
      field_mask_(maskof_command__Class()),
      name(nullptr),
      extends(nullptr),
      items(NewList<class_item_t*>()),
      spids(NewList<int>()) {
}

inline command__Class::command__Class(Token* name, Token* extends,
                                      List<class_item_t*>* items)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Class)),
      field_mask_(maskof_command__Class()),
      name(name),
      extends(extends),
      items(items),
      spids(NewList<int>()) {
}

class command__Import : public command_t {
 public:
  command__Import();
  command__Import(single_quoted* path, Token* alias, List<import_name*>* names);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  single_quoted* path;
  Token* alias;
  List<import_name*>* names;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Import)
};

constexpr uint16_t maskof_command__Import() {
  return
    maskbit(offsetof(command__Import, path))
  | maskbit(offsetof(command__Import, alias))
  | maskbit(offsetof(command__Import, names))
  | maskbit(offsetof(command__Import, spids));
}

inline command__Import::command__Import()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Import)),
      field_mask_(maskof_command__Import()),
      path(nullptr),
      alias(nullptr),
      names(NewList<import_name*>()),
      spids(NewList<int>()) {
}

inline command__Import::command__Import(single_quoted* path, Token* alias,
                                        List<import_name*>* names)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Import)),
      field_mask_(maskof_command__Import()),
      path(path),
      alias(alias),
      names(names),
      spids(NewList<int>()) {
}

class command__For : public command_t {
 public:
  command__For();
  command__For(List<name_type*>* targets, expr_t* iterable, command_t* body);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<name_type*>* targets;
  expr_t* iterable;
  command_t* body;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__For)
};

constexpr uint16_t maskof_command__For() {
  return
    maskbit(offsetof(command__For, targets))
  | maskbit(offsetof(command__For, iterable))
  | maskbit(offsetof(command__For, body))
  | maskbit(offsetof(command__For, spids));
}

inline command__For::command__For()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::For)),
      field_mask_(maskof_command__For()),
      targets(NewList<name_type*>()),
      iterable(nullptr),
      body(nullptr),
      spids(NewList<int>()) {
}

inline command__For::command__For(List<name_type*>* targets, expr_t* iterable,
                                  command_t* body)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::For)),
      field_mask_(maskof_command__For()),
      targets(targets),
      iterable(iterable),
      body(body),
      spids(NewList<int>()) {
}

class command__While : public command_t {
 public:
  command__While();
  command__While(expr_t* test, command_t* body);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* test;
  command_t* body;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__While)
};

constexpr uint16_t maskof_command__While() {
  return
    maskbit(offsetof(command__While, test))
  | maskbit(offsetof(command__While, body))
  | maskbit(offsetof(command__While, spids));
}

inline command__While::command__While()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::While)),
      field_mask_(maskof_command__While()),
      test(nullptr),
      body(nullptr),
      spids(NewList<int>()) {
}

inline command__While::command__While(expr_t* test, command_t* body)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::While)),
      field_mask_(maskof_command__While()),
      test(test),
      body(body),
      spids(NewList<int>()) {
}

class command__Break : public command_t {
 public:
  command__Break();
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Break)
};

constexpr uint16_t maskof_command__Break() {
  return
    maskbit(offsetof(command__Break, spids));
}

inline command__Break::command__Break()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Break)),
      field_mask_(maskof_command__Break()),
      spids(NewList<int>()) {
}

class command__Continue : public command_t {
 public:
  command__Continue();
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Continue)
};

constexpr uint16_t maskof_command__Continue() {
  return
    maskbit(offsetof(command__Continue, spids));
}

inline command__Continue::command__Continue()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Continue)),
      field_mask_(maskof_command__Continue()),
      spids(NewList<int>()) {
}

class command__Return : public command_t {
 public:
  command__Return();
  command__Return(expr_t* value);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* value;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command__Return)
};

constexpr uint16_t maskof_command__Return() {
  return
    maskbit(offsetof(command__Return, value))
  | maskbit(offsetof(command__Return, spids));
}

inline command__Return::command__Return()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Return)),
      field_mask_(maskof_command__Return()),
      value(nullptr),
      spids(NewList<int>()) {
}

inline command__Return::command__Return(expr_t* value)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(command_e::Return)),
      field_mask_(maskof_command__Return()),
      value(value),
      spids(NewList<int>()) {
}

namespace command {
  typedef command__NoOp NoOp;
  typedef command__Simple Simple;
  typedef command__ExpandedAlias ExpandedAlias;
  typedef command__Sentence Sentence;
  typedef command__ShAssignment ShAssignment;
  typedef command__ControlFlow ControlFlow;
  typedef command__Pipeline Pipeline;
  typedef command__AndOr AndOr;
  typedef command__DoGroup DoGroup;
  typedef command__Subshell Subshell;
  typedef command__DParen DParen;
  typedef command__DBracket DBracket;
  typedef command__ForEach ForEach;
  typedef command__ForExpr ForExpr;
  typedef command__WhileUntil WhileUntil;
  typedef command__If If;
  typedef command__Case Case;
  typedef command__ShFunction ShFunction;
  typedef command__TimeBlock TimeBlock;
  typedef command__CommandList CommandList;
  typedef command__BareDecl BareDecl;
  typedef command__VarDecl VarDecl;
  typedef command__PlaceMutation PlaceMutation;
  typedef command__Expr Expr;
  typedef command__Proc Proc;
  typedef command__Func Func;
  typedef command__Data Data;
  typedef command__Enum Enum;
  typedef command__Class Class;
  typedef command__Import Import;
  typedef command__For For;
  typedef command__While While;
  typedef command__Break Break;
  typedef command__Continue Continue;
  typedef command__Return Return;
}

namespace variant_type_e {
  const int Anon = 1;
  const int Ref = 2;
};

const char* variant_type_str(int tag);

class variant_type_t {
 protected:
  variant_type_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(variant_type_t)
};

class variant_type__Anon : public variant_type_t {
 public:
  variant_type__Anon();
  variant_type__Anon(List<param*>* params);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<param*>* params;

  DISALLOW_COPY_AND_ASSIGN(variant_type__Anon)
};

constexpr uint16_t maskof_variant_type__Anon() {
  return
    maskbit(offsetof(variant_type__Anon, params));
}

inline variant_type__Anon::variant_type__Anon()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(variant_type_e::Anon)),
      field_mask_(maskof_variant_type__Anon()),
      params(NewList<param*>()) {
}

inline variant_type__Anon::variant_type__Anon(List<param*>* params)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(variant_type_e::Anon)),
      field_mask_(maskof_variant_type__Anon()),
      params(params) {
}

class variant_type__Ref : public variant_type_t {
 public:
  variant_type__Ref();
  variant_type__Ref(Token* type_name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* type_name;

  DISALLOW_COPY_AND_ASSIGN(variant_type__Ref)
};

constexpr uint16_t maskof_variant_type__Ref() {
  return
    maskbit(offsetof(variant_type__Ref, type_name));
}

inline variant_type__Ref::variant_type__Ref()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(variant_type_e::Ref)),
      field_mask_(maskof_variant_type__Ref()),
      type_name(nullptr) {
}

inline variant_type__Ref::variant_type__Ref(Token* type_name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(variant_type_e::Ref)),
      field_mask_(maskof_variant_type__Ref()),
      type_name(type_name) {
}

namespace variant_type {
  typedef variant_type__Anon Anon;
  typedef variant_type__Ref Ref;
}

namespace class_item_e {
  const int Data = 1;
  const int Method = 2;
};

const char* class_item_str(int tag);

class class_item_t {
 protected:
  class_item_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(class_item_t)
};

class class_item__Data : public class_item_t {
 public:
  class_item__Data();
  class_item__Data(Token* keyword, List<name_type*>* fields);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* keyword;
  List<name_type*>* fields;

  DISALLOW_COPY_AND_ASSIGN(class_item__Data)
};

constexpr uint16_t maskof_class_item__Data() {
  return
    maskbit(offsetof(class_item__Data, keyword))
  | maskbit(offsetof(class_item__Data, fields));
}

inline class_item__Data::class_item__Data()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(class_item_e::Data)),
      field_mask_(maskof_class_item__Data()),
      keyword(nullptr),
      fields(NewList<name_type*>()) {
}

inline class_item__Data::class_item__Data(Token* keyword, List<name_type*>*
                                          fields)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(class_item_e::Data)),
      field_mask_(maskof_class_item__Data()),
      keyword(keyword),
      fields(fields) {
}

class class_item__Method : public class_item_t {
 public:
  class_item__Method();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(class_item__Method)
};

inline class_item__Method::class_item__Method()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(class_item_e::Method)),
      field_mask_(kZeroMask) {
}

namespace class_item {
  typedef class_item__Data Data;
  typedef class_item__Method Method;
}

namespace proc_sig_e {
  const int Open = 1;
  const int Closed = 2;
};

const char* proc_sig_str(int tag);

class proc_sig_t {
 protected:
  proc_sig_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(proc_sig_t)
};

class proc_sig__Open : public proc_sig_t {
 public:
  proc_sig__Open();
  hnode_t* PrettyTree();

  OBJ_HEADER();

  DISALLOW_COPY_AND_ASSIGN(proc_sig__Open)
};

inline proc_sig__Open::proc_sig__Open()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(proc_sig_e::Open)),
      field_mask_(kZeroMask) {
}

class proc_sig__Closed : public proc_sig_t {
 public:
  proc_sig__Closed();
  proc_sig__Closed(List<UntypedParam*>* untyped, Token* rest,
                   List<TypedParam*>* typed);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<UntypedParam*>* untyped;
  Token* rest;
  List<TypedParam*>* typed;

  DISALLOW_COPY_AND_ASSIGN(proc_sig__Closed)
};

constexpr uint16_t maskof_proc_sig__Closed() {
  return
    maskbit(offsetof(proc_sig__Closed, untyped))
  | maskbit(offsetof(proc_sig__Closed, rest))
  | maskbit(offsetof(proc_sig__Closed, typed));
}

inline proc_sig__Closed::proc_sig__Closed()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(proc_sig_e::Closed)),
      field_mask_(maskof_proc_sig__Closed()),
      untyped(NewList<UntypedParam*>()),
      rest(nullptr),
      typed(NewList<TypedParam*>()) {
}

inline proc_sig__Closed::proc_sig__Closed(List<UntypedParam*>* untyped, Token*
                                          rest, List<TypedParam*>* typed)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(proc_sig_e::Closed)),
      field_mask_(maskof_proc_sig__Closed()),
      untyped(untyped),
      rest(rest),
      typed(typed) {
}

namespace proc_sig {
  typedef proc_sig__Open Open;
  typedef proc_sig__Closed Closed;
}

namespace glob_part_e {
  const int Literal = 1;
  const int Operator = 2;
  const int CharClass = 3;
};

const char* glob_part_str(int tag);

class glob_part_t {
 protected:
  glob_part_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(glob_part_t)
};

class glob_part__Literal : public glob_part_t {
 public:
  glob_part__Literal();
  glob_part__Literal(Id_t id, Str* s);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t id;
  Str* s;

  DISALLOW_COPY_AND_ASSIGN(glob_part__Literal)
};

constexpr uint16_t maskof_glob_part__Literal() {
  return
    maskbit(offsetof(glob_part__Literal, s));
}

inline glob_part__Literal::glob_part__Literal()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(glob_part_e::Literal)),
      field_mask_(maskof_glob_part__Literal()),
      id(-1),
      s(StrFromC("")) {
}

inline glob_part__Literal::glob_part__Literal(Id_t id, Str* s)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(glob_part_e::Literal)),
      field_mask_(maskof_glob_part__Literal()),
      id(id),
      s(s) {
}

class glob_part__Operator : public glob_part_t {
 public:
  glob_part__Operator();
  glob_part__Operator(Id_t op_id);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t op_id;

  DISALLOW_COPY_AND_ASSIGN(glob_part__Operator)
};

inline glob_part__Operator::glob_part__Operator()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(glob_part_e::Operator)),
      field_mask_(kZeroMask),
      op_id(-1) {
}

inline glob_part__Operator::glob_part__Operator(Id_t op_id)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(glob_part_e::Operator)),
      field_mask_(kZeroMask),
      op_id(op_id) {
}

class glob_part__CharClass : public glob_part_t {
 public:
  glob_part__CharClass();
  glob_part__CharClass(bool negated, List<Str*>* strs);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool negated;
  List<Str*>* strs;

  DISALLOW_COPY_AND_ASSIGN(glob_part__CharClass)
};

constexpr uint16_t maskof_glob_part__CharClass() {
  return
    maskbit(offsetof(glob_part__CharClass, strs));
}

inline glob_part__CharClass::glob_part__CharClass()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(glob_part_e::CharClass)),
      field_mask_(maskof_glob_part__CharClass()),
      negated(false),
      strs(NewList<Str*>()) {
}

inline glob_part__CharClass::glob_part__CharClass(bool negated, List<Str*>*
                                                  strs)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(glob_part_e::CharClass)),
      field_mask_(maskof_glob_part__CharClass()),
      negated(negated),
      strs(strs) {
}

namespace glob_part {
  typedef glob_part__Literal Literal;
  typedef glob_part__Operator Operator;
  typedef glob_part__CharClass CharClass;
}

namespace printf_part_e {
  const int Literal = 1;
  const int Percent = 2;
};

const char* printf_part_str(int tag);

class printf_part_t {
 protected:
  printf_part_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(printf_part_t)
};

class printf_part__Literal : public printf_part_t {
 public:
  printf_part__Literal();
  printf_part__Literal(Token* token);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* token;

  DISALLOW_COPY_AND_ASSIGN(printf_part__Literal)
};

constexpr uint16_t maskof_printf_part__Literal() {
  return
    maskbit(offsetof(printf_part__Literal, token));
}

inline printf_part__Literal::printf_part__Literal()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(printf_part_e::Literal)),
      field_mask_(maskof_printf_part__Literal()),
      token(nullptr) {
}

inline printf_part__Literal::printf_part__Literal(Token* token)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(printf_part_e::Literal)),
      field_mask_(maskof_printf_part__Literal()),
      token(token) {
}

class printf_part__Percent : public printf_part_t {
 public:
  printf_part__Percent();
  printf_part__Percent(List<Token*>* flags, Token* width, Token* precision,
                       Token* type);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<Token*>* flags;
  Token* width;
  Token* precision;
  Token* type;

  DISALLOW_COPY_AND_ASSIGN(printf_part__Percent)
};

constexpr uint16_t maskof_printf_part__Percent() {
  return
    maskbit(offsetof(printf_part__Percent, flags))
  | maskbit(offsetof(printf_part__Percent, width))
  | maskbit(offsetof(printf_part__Percent, precision))
  | maskbit(offsetof(printf_part__Percent, type));
}

inline printf_part__Percent::printf_part__Percent()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(printf_part_e::Percent)),
      field_mask_(maskof_printf_part__Percent()),
      flags(NewList<Token*>()),
      width(nullptr),
      precision(nullptr),
      type(nullptr) {
}

inline printf_part__Percent::printf_part__Percent(List<Token*>* flags, Token*
                                                  width, Token* precision,
                                                  Token* type)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(printf_part_e::Percent)),
      field_mask_(maskof_printf_part__Percent()),
      flags(flags),
      width(width),
      precision(precision),
      type(type) {
}

namespace printf_part {
  typedef printf_part__Literal Literal;
  typedef printf_part__Percent Percent;
}

enum class expr_context_e {
  Load = 1,
  Store = 2,
  Del = 3,
  AugLoad = 4,
  AugStore = 5,
  Param = 6,
};
typedef expr_context_e expr_context_t;

const char* expr_context_str(expr_context_e tag);

namespace type_expr_e {
  const int Simple = 1;
  const int Compound = 2;
};

const char* type_expr_str(int tag);

class type_expr_t {
 protected:
  type_expr_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(type_expr_t)
};

class type_expr__Simple : public type_expr_t {
 public:
  type_expr__Simple();
  type_expr__Simple(Token* name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;

  DISALLOW_COPY_AND_ASSIGN(type_expr__Simple)
};

constexpr uint16_t maskof_type_expr__Simple() {
  return
    maskbit(offsetof(type_expr__Simple, name));
}

inline type_expr__Simple::type_expr__Simple()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(type_expr_e::Simple)),
      field_mask_(maskof_type_expr__Simple()),
      name(nullptr) {
}

inline type_expr__Simple::type_expr__Simple(Token* name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(type_expr_e::Simple)),
      field_mask_(maskof_type_expr__Simple()),
      name(name) {
}

class type_expr__Compound : public type_expr_t {
 public:
  type_expr__Compound();
  type_expr__Compound(Token* name, List<type_expr_t*>* params);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  List<type_expr_t*>* params;

  DISALLOW_COPY_AND_ASSIGN(type_expr__Compound)
};

constexpr uint16_t maskof_type_expr__Compound() {
  return
    maskbit(offsetof(type_expr__Compound, name))
  | maskbit(offsetof(type_expr__Compound, params));
}

inline type_expr__Compound::type_expr__Compound()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(type_expr_e::Compound)),
      field_mask_(maskof_type_expr__Compound()),
      name(nullptr),
      params(NewList<type_expr_t*>()) {
}

inline type_expr__Compound::type_expr__Compound(Token* name,
                                                List<type_expr_t*>* params)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(type_expr_e::Compound)),
      field_mask_(maskof_type_expr__Compound()),
      name(name),
      params(params) {
}

namespace type_expr {
  typedef type_expr__Simple Simple;
  typedef type_expr__Compound Compound;
}

namespace place_expr_e {
  const int Var = 1;
  const int Subscript = 227;
  const int Attribute = 228;
};

const char* place_expr_str(int tag);

class place_expr_t {
 protected:
  place_expr_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(place_expr_t)
};

class place_expr__Var : public place_expr_t {
 public:
  place_expr__Var();
  place_expr__Var(Token* name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;

  DISALLOW_COPY_AND_ASSIGN(place_expr__Var)
};

constexpr uint16_t maskof_place_expr__Var() {
  return
    maskbit(offsetof(place_expr__Var, name));
}

inline place_expr__Var::place_expr__Var()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(place_expr_e::Var)),
      field_mask_(maskof_place_expr__Var()),
      name(nullptr) {
}

inline place_expr__Var::place_expr__Var(Token* name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(place_expr_e::Var)),
      field_mask_(maskof_place_expr__Var()),
      name(name) {
}

namespace place_expr {
  typedef place_expr__Var Var;
}

namespace expr_e {
  const int Var = 1;
  const int Const = 2;
  const int ShArrayLiteral = 208;
  const int RegexLiteral = 4;
  const int SimpleVarSub = 205;
  const int BracedVarSub = 206;
  const int CommandSub = 207;
  const int SingleQuoted = 204;
  const int DoubleQuoted = 203;
  const int BlockArg = 10;
  const int Lambda = 11;
  const int Unary = 12;
  const int Binary = 13;
  const int Compare = 14;
  const int FuncCall = 15;
  const int IfExp = 16;
  const int Tuple = 17;
  const int List = 18;
  const int Dict = 19;
  const int Implicit = 20;
  const int ListComp = 21;
  const int DictComp = 22;
  const int GeneratorExp = 23;
  const int Range = 24;
  const int Slice = 25;
  const int Subscript = 227;
  const int Attribute = 228;
  const int Spread = 28;
};

const char* expr_str(int tag);

class expr_t {
 protected:
  expr_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(expr_t)
};

class expr__Var : public expr_t {
 public:
  expr__Var();
  expr__Var(Token* name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Var)
};

constexpr uint16_t maskof_expr__Var() {
  return
    maskbit(offsetof(expr__Var, name))
  | maskbit(offsetof(expr__Var, spids));
}

inline expr__Var::expr__Var()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Var)),
      field_mask_(maskof_expr__Var()),
      name(nullptr),
      spids(NewList<int>()) {
}

inline expr__Var::expr__Var(Token* name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Var)),
      field_mask_(maskof_expr__Var()),
      name(name),
      spids(NewList<int>()) {
}

class expr__Const : public expr_t {
 public:
  expr__Const();
  expr__Const(Token* c);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* c;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Const)
};

constexpr uint16_t maskof_expr__Const() {
  return
    maskbit(offsetof(expr__Const, c))
  | maskbit(offsetof(expr__Const, spids));
}

inline expr__Const::expr__Const()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Const)),
      field_mask_(maskof_expr__Const()),
      c(nullptr),
      spids(NewList<int>()) {
}

inline expr__Const::expr__Const(Token* c)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Const)),
      field_mask_(maskof_expr__Const()),
      c(c),
      spids(NewList<int>()) {
}

class expr__RegexLiteral : public expr_t {
 public:
  expr__RegexLiteral();
  expr__RegexLiteral(Token* left, re_t* regex, List<Token*>* flags, Token*
                     trans_pref);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* left;
  re_t* regex;
  List<Token*>* flags;
  Token* trans_pref;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__RegexLiteral)
};

constexpr uint16_t maskof_expr__RegexLiteral() {
  return
    maskbit(offsetof(expr__RegexLiteral, left))
  | maskbit(offsetof(expr__RegexLiteral, regex))
  | maskbit(offsetof(expr__RegexLiteral, flags))
  | maskbit(offsetof(expr__RegexLiteral, trans_pref))
  | maskbit(offsetof(expr__RegexLiteral, spids));
}

inline expr__RegexLiteral::expr__RegexLiteral()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::RegexLiteral)),
      field_mask_(maskof_expr__RegexLiteral()),
      left(nullptr),
      regex(nullptr),
      flags(NewList<Token*>()),
      trans_pref(nullptr),
      spids(NewList<int>()) {
}

inline expr__RegexLiteral::expr__RegexLiteral(Token* left, re_t* regex,
                                              List<Token*>* flags, Token*
                                              trans_pref)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::RegexLiteral)),
      field_mask_(maskof_expr__RegexLiteral()),
      left(left),
      regex(regex),
      flags(flags),
      trans_pref(trans_pref),
      spids(NewList<int>()) {
}

class expr__BlockArg : public expr_t {
 public:
  expr__BlockArg();
  expr__BlockArg(BraceGroup* block);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  BraceGroup* block;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__BlockArg)
};

constexpr uint16_t maskof_expr__BlockArg() {
  return
    maskbit(offsetof(expr__BlockArg, block))
  | maskbit(offsetof(expr__BlockArg, spids));
}

inline expr__BlockArg::expr__BlockArg()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::BlockArg)),
      field_mask_(maskof_expr__BlockArg()),
      block(nullptr),
      spids(NewList<int>()) {
}

inline expr__BlockArg::expr__BlockArg(BraceGroup* block)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::BlockArg)),
      field_mask_(maskof_expr__BlockArg()),
      block(block),
      spids(NewList<int>()) {
}

class expr__Lambda : public expr_t {
 public:
  expr__Lambda();
  expr__Lambda(List<name_type*>* params, expr_t* body);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<name_type*>* params;
  expr_t* body;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Lambda)
};

constexpr uint16_t maskof_expr__Lambda() {
  return
    maskbit(offsetof(expr__Lambda, params))
  | maskbit(offsetof(expr__Lambda, body))
  | maskbit(offsetof(expr__Lambda, spids));
}

inline expr__Lambda::expr__Lambda()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Lambda)),
      field_mask_(maskof_expr__Lambda()),
      params(NewList<name_type*>()),
      body(nullptr),
      spids(NewList<int>()) {
}

inline expr__Lambda::expr__Lambda(List<name_type*>* params, expr_t* body)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Lambda)),
      field_mask_(maskof_expr__Lambda()),
      params(params),
      body(body),
      spids(NewList<int>()) {
}

class expr__Unary : public expr_t {
 public:
  expr__Unary();
  expr__Unary(Token* op, expr_t* child);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* op;
  expr_t* child;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Unary)
};

constexpr uint16_t maskof_expr__Unary() {
  return
    maskbit(offsetof(expr__Unary, op))
  | maskbit(offsetof(expr__Unary, child))
  | maskbit(offsetof(expr__Unary, spids));
}

inline expr__Unary::expr__Unary()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Unary)),
      field_mask_(maskof_expr__Unary()),
      op(nullptr),
      child(nullptr),
      spids(NewList<int>()) {
}

inline expr__Unary::expr__Unary(Token* op, expr_t* child)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Unary)),
      field_mask_(maskof_expr__Unary()),
      op(op),
      child(child),
      spids(NewList<int>()) {
}

class expr__Binary : public expr_t {
 public:
  expr__Binary();
  expr__Binary(Token* op, expr_t* left, expr_t* right);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* op;
  expr_t* left;
  expr_t* right;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Binary)
};

constexpr uint16_t maskof_expr__Binary() {
  return
    maskbit(offsetof(expr__Binary, op))
  | maskbit(offsetof(expr__Binary, left))
  | maskbit(offsetof(expr__Binary, right))
  | maskbit(offsetof(expr__Binary, spids));
}

inline expr__Binary::expr__Binary()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Binary)),
      field_mask_(maskof_expr__Binary()),
      op(nullptr),
      left(nullptr),
      right(nullptr),
      spids(NewList<int>()) {
}

inline expr__Binary::expr__Binary(Token* op, expr_t* left, expr_t* right)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Binary)),
      field_mask_(maskof_expr__Binary()),
      op(op),
      left(left),
      right(right),
      spids(NewList<int>()) {
}

class expr__Compare : public expr_t {
 public:
  expr__Compare();
  expr__Compare(expr_t* left, List<speck*>* ops, List<expr_t*>* comparators);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* left;
  List<speck*>* ops;
  List<expr_t*>* comparators;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Compare)
};

constexpr uint16_t maskof_expr__Compare() {
  return
    maskbit(offsetof(expr__Compare, left))
  | maskbit(offsetof(expr__Compare, ops))
  | maskbit(offsetof(expr__Compare, comparators))
  | maskbit(offsetof(expr__Compare, spids));
}

inline expr__Compare::expr__Compare()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Compare)),
      field_mask_(maskof_expr__Compare()),
      left(nullptr),
      ops(NewList<speck*>()),
      comparators(NewList<expr_t*>()),
      spids(NewList<int>()) {
}

inline expr__Compare::expr__Compare(expr_t* left, List<speck*>* ops,
                                    List<expr_t*>* comparators)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Compare)),
      field_mask_(maskof_expr__Compare()),
      left(left),
      ops(ops),
      comparators(comparators),
      spids(NewList<int>()) {
}

class expr__FuncCall : public expr_t {
 public:
  expr__FuncCall();
  expr__FuncCall(expr_t* func, ArgList* args);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* func;
  ArgList* args;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__FuncCall)
};

constexpr uint16_t maskof_expr__FuncCall() {
  return
    maskbit(offsetof(expr__FuncCall, func))
  | maskbit(offsetof(expr__FuncCall, args))
  | maskbit(offsetof(expr__FuncCall, spids));
}

inline expr__FuncCall::expr__FuncCall()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::FuncCall)),
      field_mask_(maskof_expr__FuncCall()),
      func(nullptr),
      args(nullptr),
      spids(NewList<int>()) {
}

inline expr__FuncCall::expr__FuncCall(expr_t* func, ArgList* args)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::FuncCall)),
      field_mask_(maskof_expr__FuncCall()),
      func(func),
      args(args),
      spids(NewList<int>()) {
}

class expr__IfExp : public expr_t {
 public:
  expr__IfExp();
  expr__IfExp(expr_t* test, expr_t* body, expr_t* orelse);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* test;
  expr_t* body;
  expr_t* orelse;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__IfExp)
};

constexpr uint16_t maskof_expr__IfExp() {
  return
    maskbit(offsetof(expr__IfExp, test))
  | maskbit(offsetof(expr__IfExp, body))
  | maskbit(offsetof(expr__IfExp, orelse))
  | maskbit(offsetof(expr__IfExp, spids));
}

inline expr__IfExp::expr__IfExp()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::IfExp)),
      field_mask_(maskof_expr__IfExp()),
      test(nullptr),
      body(nullptr),
      orelse(nullptr),
      spids(NewList<int>()) {
}

inline expr__IfExp::expr__IfExp(expr_t* test, expr_t* body, expr_t* orelse)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::IfExp)),
      field_mask_(maskof_expr__IfExp()),
      test(test),
      body(body),
      orelse(orelse),
      spids(NewList<int>()) {
}

class expr__Tuple : public expr_t {
 public:
  expr__Tuple();
  expr__Tuple(List<expr_t*>* elts, expr_context_t ctx);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<expr_t*>* elts;
  expr_context_t ctx;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Tuple)
};

constexpr uint16_t maskof_expr__Tuple() {
  return
    maskbit(offsetof(expr__Tuple, elts))
  | maskbit(offsetof(expr__Tuple, spids));
}

inline expr__Tuple::expr__Tuple()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Tuple)),
      field_mask_(maskof_expr__Tuple()),
      elts(NewList<expr_t*>()),
      ctx(expr_context_e::Load),
      spids(NewList<int>()) {
}

inline expr__Tuple::expr__Tuple(List<expr_t*>* elts, expr_context_t ctx)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Tuple)),
      field_mask_(maskof_expr__Tuple()),
      elts(elts),
      ctx(ctx),
      spids(NewList<int>()) {
}

class expr__List : public expr_t {
 public:
  expr__List();
  expr__List(List<expr_t*>* elts, expr_context_t ctx);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<expr_t*>* elts;
  expr_context_t ctx;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__List)
};

constexpr uint16_t maskof_expr__List() {
  return
    maskbit(offsetof(expr__List, elts))
  | maskbit(offsetof(expr__List, spids));
}

inline expr__List::expr__List()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::List)),
      field_mask_(maskof_expr__List()),
      elts(NewList<expr_t*>()),
      ctx(expr_context_e::Load),
      spids(NewList<int>()) {
}

inline expr__List::expr__List(List<expr_t*>* elts, expr_context_t ctx)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::List)),
      field_mask_(maskof_expr__List()),
      elts(elts),
      ctx(ctx),
      spids(NewList<int>()) {
}

class expr__Dict : public expr_t {
 public:
  expr__Dict();
  expr__Dict(List<expr_t*>* keys, List<expr_t*>* values);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<expr_t*>* keys;
  List<expr_t*>* values;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Dict)
};

constexpr uint16_t maskof_expr__Dict() {
  return
    maskbit(offsetof(expr__Dict, keys))
  | maskbit(offsetof(expr__Dict, values))
  | maskbit(offsetof(expr__Dict, spids));
}

inline expr__Dict::expr__Dict()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Dict)),
      field_mask_(maskof_expr__Dict()),
      keys(NewList<expr_t*>()),
      values(NewList<expr_t*>()),
      spids(NewList<int>()) {
}

inline expr__Dict::expr__Dict(List<expr_t*>* keys, List<expr_t*>* values)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Dict)),
      field_mask_(maskof_expr__Dict()),
      keys(keys),
      values(values),
      spids(NewList<int>()) {
}

class expr__Implicit : public expr_t {
 public:
  expr__Implicit();
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Implicit)
};

constexpr uint16_t maskof_expr__Implicit() {
  return
    maskbit(offsetof(expr__Implicit, spids));
}

inline expr__Implicit::expr__Implicit()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Implicit)),
      field_mask_(maskof_expr__Implicit()),
      spids(NewList<int>()) {
}

class expr__ListComp : public expr_t {
 public:
  expr__ListComp();
  expr__ListComp(expr_t* elt, List<comprehension*>* generators);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* elt;
  List<comprehension*>* generators;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__ListComp)
};

constexpr uint16_t maskof_expr__ListComp() {
  return
    maskbit(offsetof(expr__ListComp, elt))
  | maskbit(offsetof(expr__ListComp, generators))
  | maskbit(offsetof(expr__ListComp, spids));
}

inline expr__ListComp::expr__ListComp()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::ListComp)),
      field_mask_(maskof_expr__ListComp()),
      elt(nullptr),
      generators(NewList<comprehension*>()),
      spids(NewList<int>()) {
}

inline expr__ListComp::expr__ListComp(expr_t* elt, List<comprehension*>*
                                      generators)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::ListComp)),
      field_mask_(maskof_expr__ListComp()),
      elt(elt),
      generators(generators),
      spids(NewList<int>()) {
}

class expr__DictComp : public expr_t {
 public:
  expr__DictComp();
  expr__DictComp(expr_t* key, expr_t* value, List<comprehension*>* generators);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* key;
  expr_t* value;
  List<comprehension*>* generators;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__DictComp)
};

constexpr uint16_t maskof_expr__DictComp() {
  return
    maskbit(offsetof(expr__DictComp, key))
  | maskbit(offsetof(expr__DictComp, value))
  | maskbit(offsetof(expr__DictComp, generators))
  | maskbit(offsetof(expr__DictComp, spids));
}

inline expr__DictComp::expr__DictComp()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::DictComp)),
      field_mask_(maskof_expr__DictComp()),
      key(nullptr),
      value(nullptr),
      generators(NewList<comprehension*>()),
      spids(NewList<int>()) {
}

inline expr__DictComp::expr__DictComp(expr_t* key, expr_t* value,
                                      List<comprehension*>* generators)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::DictComp)),
      field_mask_(maskof_expr__DictComp()),
      key(key),
      value(value),
      generators(generators),
      spids(NewList<int>()) {
}

class expr__GeneratorExp : public expr_t {
 public:
  expr__GeneratorExp();
  expr__GeneratorExp(expr_t* elt, List<comprehension*>* generators);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* elt;
  List<comprehension*>* generators;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__GeneratorExp)
};

constexpr uint16_t maskof_expr__GeneratorExp() {
  return
    maskbit(offsetof(expr__GeneratorExp, elt))
  | maskbit(offsetof(expr__GeneratorExp, generators))
  | maskbit(offsetof(expr__GeneratorExp, spids));
}

inline expr__GeneratorExp::expr__GeneratorExp()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::GeneratorExp)),
      field_mask_(maskof_expr__GeneratorExp()),
      elt(nullptr),
      generators(NewList<comprehension*>()),
      spids(NewList<int>()) {
}

inline expr__GeneratorExp::expr__GeneratorExp(expr_t* elt,
                                              List<comprehension*>* generators)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::GeneratorExp)),
      field_mask_(maskof_expr__GeneratorExp()),
      elt(elt),
      generators(generators),
      spids(NewList<int>()) {
}

class expr__Range : public expr_t {
 public:
  expr__Range();
  expr__Range(expr_t* lower, expr_t* upper);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* lower;
  expr_t* upper;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Range)
};

constexpr uint16_t maskof_expr__Range() {
  return
    maskbit(offsetof(expr__Range, lower))
  | maskbit(offsetof(expr__Range, upper))
  | maskbit(offsetof(expr__Range, spids));
}

inline expr__Range::expr__Range()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Range)),
      field_mask_(maskof_expr__Range()),
      lower(nullptr),
      upper(nullptr),
      spids(NewList<int>()) {
}

inline expr__Range::expr__Range(expr_t* lower, expr_t* upper)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Range)),
      field_mask_(maskof_expr__Range()),
      lower(lower),
      upper(upper),
      spids(NewList<int>()) {
}

class expr__Slice : public expr_t {
 public:
  expr__Slice();
  expr__Slice(expr_t* lower, expr_t* upper);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* lower;
  expr_t* upper;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Slice)
};

constexpr uint16_t maskof_expr__Slice() {
  return
    maskbit(offsetof(expr__Slice, lower))
  | maskbit(offsetof(expr__Slice, upper))
  | maskbit(offsetof(expr__Slice, spids));
}

inline expr__Slice::expr__Slice()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Slice)),
      field_mask_(maskof_expr__Slice()),
      lower(nullptr),
      upper(nullptr),
      spids(NewList<int>()) {
}

inline expr__Slice::expr__Slice(expr_t* lower, expr_t* upper)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Slice)),
      field_mask_(maskof_expr__Slice()),
      lower(lower),
      upper(upper),
      spids(NewList<int>()) {
}

class expr__Spread : public expr_t {
 public:
  expr__Spread();
  expr__Spread(expr_t* child, expr_context_t ctx);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* child;
  expr_context_t ctx;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(expr__Spread)
};

constexpr uint16_t maskof_expr__Spread() {
  return
    maskbit(offsetof(expr__Spread, child))
  | maskbit(offsetof(expr__Spread, spids));
}

inline expr__Spread::expr__Spread()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Spread)),
      field_mask_(maskof_expr__Spread()),
      child(nullptr),
      ctx(expr_context_e::Load),
      spids(NewList<int>()) {
}

inline expr__Spread::expr__Spread(expr_t* child, expr_context_t ctx)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(expr_e::Spread)),
      field_mask_(maskof_expr__Spread()),
      child(child),
      ctx(ctx),
      spids(NewList<int>()) {
}

namespace expr {
  typedef expr__Var Var;
  typedef expr__Const Const;
  typedef expr__RegexLiteral RegexLiteral;
  typedef expr__BlockArg BlockArg;
  typedef expr__Lambda Lambda;
  typedef expr__Unary Unary;
  typedef expr__Binary Binary;
  typedef expr__Compare Compare;
  typedef expr__FuncCall FuncCall;
  typedef expr__IfExp IfExp;
  typedef expr__Tuple Tuple;
  typedef expr__List List;
  typedef expr__Dict Dict;
  typedef expr__Implicit Implicit;
  typedef expr__ListComp ListComp;
  typedef expr__DictComp DictComp;
  typedef expr__GeneratorExp GeneratorExp;
  typedef expr__Range Range;
  typedef expr__Slice Slice;
  typedef expr__Spread Spread;
}

namespace class_literal_term_e {
  const int PosixClass = 229;
  const int PerlClass = 230;
  const int Range = 3;
  const int CharLiteral = 4;
  const int SimpleVarSub = 205;
  const int BracedVarSub = 206;
  const int SingleQuoted = 204;
  const int DoubleQuoted = 203;
};

const char* class_literal_term_str(int tag);

class class_literal_term_t {
 protected:
  class_literal_term_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(class_literal_term_t)
};

class class_literal_term__Range : public class_literal_term_t {
 public:
  class_literal_term__Range();
  class_literal_term__Range(Token* start, Token* end);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* start;
  Token* end;

  DISALLOW_COPY_AND_ASSIGN(class_literal_term__Range)
};

constexpr uint16_t maskof_class_literal_term__Range() {
  return
    maskbit(offsetof(class_literal_term__Range, start))
  | maskbit(offsetof(class_literal_term__Range, end));
}

inline class_literal_term__Range::class_literal_term__Range()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(class_literal_term_e::Range)),
      field_mask_(maskof_class_literal_term__Range()),
      start(nullptr),
      end(nullptr) {
}

inline class_literal_term__Range::class_literal_term__Range(Token* start,
                                                            Token* end)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(class_literal_term_e::Range)),
      field_mask_(maskof_class_literal_term__Range()),
      start(start),
      end(end) {
}

class class_literal_term__CharLiteral : public class_literal_term_t {
 public:
  class_literal_term__CharLiteral();
  class_literal_term__CharLiteral(Token* tok);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* tok;

  DISALLOW_COPY_AND_ASSIGN(class_literal_term__CharLiteral)
};

constexpr uint16_t maskof_class_literal_term__CharLiteral() {
  return
    maskbit(offsetof(class_literal_term__CharLiteral, tok));
}

inline class_literal_term__CharLiteral::class_literal_term__CharLiteral()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(class_literal_term_e::CharLiteral)),
      field_mask_(maskof_class_literal_term__CharLiteral()),
      tok(nullptr) {
}

inline class_literal_term__CharLiteral::class_literal_term__CharLiteral(Token*
                                                                        tok)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(class_literal_term_e::CharLiteral)),
      field_mask_(maskof_class_literal_term__CharLiteral()),
      tok(tok) {
}

namespace class_literal_term {
  typedef class_literal_term__Range Range;
  typedef class_literal_term__CharLiteral CharLiteral;
}

namespace char_class_term_e {
  const int PosixClass = 229;
  const int PerlClass = 230;
  const int Range = 3;
  const int CharCode = 231;
};

const char* char_class_term_str(int tag);

class char_class_term_t {
 protected:
  char_class_term_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(char_class_term_t)
};

class char_class_term__Range : public char_class_term_t {
 public:
  char_class_term__Range();
  char_class_term__Range(CharCode* start, CharCode* end);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  CharCode* start;
  CharCode* end;

  DISALLOW_COPY_AND_ASSIGN(char_class_term__Range)
};

constexpr uint16_t maskof_char_class_term__Range() {
  return
    maskbit(offsetof(char_class_term__Range, start))
  | maskbit(offsetof(char_class_term__Range, end));
}

inline char_class_term__Range::char_class_term__Range()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(char_class_term_e::Range)),
      field_mask_(maskof_char_class_term__Range()),
      start(nullptr),
      end(nullptr) {
}

inline char_class_term__Range::char_class_term__Range(CharCode* start,
                                                      CharCode* end)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(char_class_term_e::Range)),
      field_mask_(maskof_char_class_term__Range()),
      start(start),
      end(end) {
}

namespace char_class_term {
  typedef char_class_term__Range Range;
}

namespace re_repeat_e {
  const int Op = 1;
  const int Num = 2;
  const int Range = 3;
};

const char* re_repeat_str(int tag);

class re_repeat_t {
 protected:
  re_repeat_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(re_repeat_t)
};

class re_repeat__Op : public re_repeat_t {
 public:
  re_repeat__Op();
  re_repeat__Op(Token* op);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* op;

  DISALLOW_COPY_AND_ASSIGN(re_repeat__Op)
};

constexpr uint16_t maskof_re_repeat__Op() {
  return
    maskbit(offsetof(re_repeat__Op, op));
}

inline re_repeat__Op::re_repeat__Op()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_repeat_e::Op)),
      field_mask_(maskof_re_repeat__Op()),
      op(nullptr) {
}

inline re_repeat__Op::re_repeat__Op(Token* op)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_repeat_e::Op)),
      field_mask_(maskof_re_repeat__Op()),
      op(op) {
}

class re_repeat__Num : public re_repeat_t {
 public:
  re_repeat__Num();
  re_repeat__Num(Token* times);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* times;

  DISALLOW_COPY_AND_ASSIGN(re_repeat__Num)
};

constexpr uint16_t maskof_re_repeat__Num() {
  return
    maskbit(offsetof(re_repeat__Num, times));
}

inline re_repeat__Num::re_repeat__Num()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_repeat_e::Num)),
      field_mask_(maskof_re_repeat__Num()),
      times(nullptr) {
}

inline re_repeat__Num::re_repeat__Num(Token* times)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_repeat_e::Num)),
      field_mask_(maskof_re_repeat__Num()),
      times(times) {
}

class re_repeat__Range : public re_repeat_t {
 public:
  re_repeat__Range();
  re_repeat__Range(Token* lower, Token* upper);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* lower;
  Token* upper;

  DISALLOW_COPY_AND_ASSIGN(re_repeat__Range)
};

constexpr uint16_t maskof_re_repeat__Range() {
  return
    maskbit(offsetof(re_repeat__Range, lower))
  | maskbit(offsetof(re_repeat__Range, upper));
}

inline re_repeat__Range::re_repeat__Range()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_repeat_e::Range)),
      field_mask_(maskof_re_repeat__Range()),
      lower(nullptr),
      upper(nullptr) {
}

inline re_repeat__Range::re_repeat__Range(Token* lower, Token* upper)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_repeat_e::Range)),
      field_mask_(maskof_re_repeat__Range()),
      lower(lower),
      upper(upper) {
}

namespace re_repeat {
  typedef re_repeat__Op Op;
  typedef re_repeat__Num Num;
  typedef re_repeat__Range Range;
}

namespace re_e {
  const int Speck = 202;
  const int Token = 201;
  const int PosixClass = 229;
  const int PerlClass = 230;
  const int CharClassLiteral = 5;
  const int CharClass = 6;
  const int Splice = 7;
  const int SimpleVarSub = 205;
  const int BracedVarSub = 206;
  const int SingleQuoted = 204;
  const int DoubleQuoted = 203;
  const int Repeat = 12;
  const int Seq = 13;
  const int Alt = 14;
  const int Group = 15;
  const int Capture = 16;
  const int Backtracking = 17;
  const int Primitive = 18;
  const int LiteralChars = 19;
};

const char* re_str(int tag);

class re_t {
 protected:
  re_t() {}
 public:
  int tag_() const {
    return reinterpret_cast<const Obj*>(this)->type_tag_;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(re_t)
};

class re__CharClassLiteral : public re_t {
 public:
  re__CharClassLiteral();
  re__CharClassLiteral(bool negated, List<class_literal_term_t*>* terms);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool negated;
  List<class_literal_term_t*>* terms;

  DISALLOW_COPY_AND_ASSIGN(re__CharClassLiteral)
};

constexpr uint16_t maskof_re__CharClassLiteral() {
  return
    maskbit(offsetof(re__CharClassLiteral, terms));
}

inline re__CharClassLiteral::re__CharClassLiteral()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::CharClassLiteral)),
      field_mask_(maskof_re__CharClassLiteral()),
      negated(false),
      terms(NewList<class_literal_term_t*>()) {
}

inline re__CharClassLiteral::re__CharClassLiteral(bool negated,
                                                  List<class_literal_term_t*>*
                                                  terms)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::CharClassLiteral)),
      field_mask_(maskof_re__CharClassLiteral()),
      negated(negated),
      terms(terms) {
}

class re__CharClass : public re_t {
 public:
  re__CharClass();
  re__CharClass(bool negated, List<char_class_term_t*>* terms);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool negated;
  List<char_class_term_t*>* terms;

  DISALLOW_COPY_AND_ASSIGN(re__CharClass)
};

constexpr uint16_t maskof_re__CharClass() {
  return
    maskbit(offsetof(re__CharClass, terms));
}

inline re__CharClass::re__CharClass()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::CharClass)),
      field_mask_(maskof_re__CharClass()),
      negated(false),
      terms(NewList<char_class_term_t*>()) {
}

inline re__CharClass::re__CharClass(bool negated, List<char_class_term_t*>*
                                    terms)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::CharClass)),
      field_mask_(maskof_re__CharClass()),
      negated(negated),
      terms(terms) {
}

class re__Splice : public re_t {
 public:
  re__Splice();
  re__Splice(Token* name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;

  DISALLOW_COPY_AND_ASSIGN(re__Splice)
};

constexpr uint16_t maskof_re__Splice() {
  return
    maskbit(offsetof(re__Splice, name));
}

inline re__Splice::re__Splice()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Splice)),
      field_mask_(maskof_re__Splice()),
      name(nullptr) {
}

inline re__Splice::re__Splice(Token* name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Splice)),
      field_mask_(maskof_re__Splice()),
      name(name) {
}

class re__Repeat : public re_t {
 public:
  re__Repeat();
  re__Repeat(re_t* child, re_repeat_t* op);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  re_t* child;
  re_repeat_t* op;

  DISALLOW_COPY_AND_ASSIGN(re__Repeat)
};

constexpr uint16_t maskof_re__Repeat() {
  return
    maskbit(offsetof(re__Repeat, child))
  | maskbit(offsetof(re__Repeat, op));
}

inline re__Repeat::re__Repeat()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Repeat)),
      field_mask_(maskof_re__Repeat()),
      child(nullptr),
      op(nullptr) {
}

inline re__Repeat::re__Repeat(re_t* child, re_repeat_t* op)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Repeat)),
      field_mask_(maskof_re__Repeat()),
      child(child),
      op(op) {
}

class re__Seq : public re_t {
 public:
  re__Seq();
  re__Seq(List<re_t*>* children);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<re_t*>* children;

  DISALLOW_COPY_AND_ASSIGN(re__Seq)
};

constexpr uint16_t maskof_re__Seq() {
  return
    maskbit(offsetof(re__Seq, children));
}

inline re__Seq::re__Seq()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Seq)),
      field_mask_(maskof_re__Seq()),
      children(NewList<re_t*>()) {
}

inline re__Seq::re__Seq(List<re_t*>* children)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Seq)),
      field_mask_(maskof_re__Seq()),
      children(children) {
}

class re__Alt : public re_t {
 public:
  re__Alt();
  re__Alt(List<re_t*>* children);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<re_t*>* children;

  DISALLOW_COPY_AND_ASSIGN(re__Alt)
};

constexpr uint16_t maskof_re__Alt() {
  return
    maskbit(offsetof(re__Alt, children));
}

inline re__Alt::re__Alt()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Alt)),
      field_mask_(maskof_re__Alt()),
      children(NewList<re_t*>()) {
}

inline re__Alt::re__Alt(List<re_t*>* children)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Alt)),
      field_mask_(maskof_re__Alt()),
      children(children) {
}

class re__Group : public re_t {
 public:
  re__Group();
  re__Group(re_t* child);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  re_t* child;

  DISALLOW_COPY_AND_ASSIGN(re__Group)
};

constexpr uint16_t maskof_re__Group() {
  return
    maskbit(offsetof(re__Group, child));
}

inline re__Group::re__Group()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Group)),
      field_mask_(maskof_re__Group()),
      child(nullptr) {
}

inline re__Group::re__Group(re_t* child)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Group)),
      field_mask_(maskof_re__Group()),
      child(child) {
}

class re__Capture : public re_t {
 public:
  re__Capture();
  re__Capture(re_t* child, Token* var_name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  re_t* child;
  Token* var_name;

  DISALLOW_COPY_AND_ASSIGN(re__Capture)
};

constexpr uint16_t maskof_re__Capture() {
  return
    maskbit(offsetof(re__Capture, child))
  | maskbit(offsetof(re__Capture, var_name));
}

inline re__Capture::re__Capture()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Capture)),
      field_mask_(maskof_re__Capture()),
      child(nullptr),
      var_name(nullptr) {
}

inline re__Capture::re__Capture(re_t* child, Token* var_name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Capture)),
      field_mask_(maskof_re__Capture()),
      child(child),
      var_name(var_name) {
}

class re__Backtracking : public re_t {
 public:
  re__Backtracking();
  re__Backtracking(bool negated, Token* name, re_t* child);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  bool negated;
  Token* name;
  re_t* child;

  DISALLOW_COPY_AND_ASSIGN(re__Backtracking)
};

constexpr uint16_t maskof_re__Backtracking() {
  return
    maskbit(offsetof(re__Backtracking, name))
  | maskbit(offsetof(re__Backtracking, child));
}

inline re__Backtracking::re__Backtracking()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Backtracking)),
      field_mask_(maskof_re__Backtracking()),
      negated(false),
      name(nullptr),
      child(nullptr) {
}

inline re__Backtracking::re__Backtracking(bool negated, Token* name, re_t*
                                          child)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Backtracking)),
      field_mask_(maskof_re__Backtracking()),
      negated(negated),
      name(name),
      child(child) {
}

class re__Primitive : public re_t {
 public:
  re__Primitive();
  re__Primitive(Id_t id);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t id;

  DISALLOW_COPY_AND_ASSIGN(re__Primitive)
};

inline re__Primitive::re__Primitive()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Primitive)),
      field_mask_(kZeroMask),
      id(-1) {
}

inline re__Primitive::re__Primitive(Id_t id)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::Primitive)),
      field_mask_(kZeroMask),
      id(id) {
}

class re__LiteralChars : public re_t {
 public:
  re__LiteralChars();
  re__LiteralChars(Str* s, int spid);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* s;
  int spid;

  DISALLOW_COPY_AND_ASSIGN(re__LiteralChars)
};

constexpr uint16_t maskof_re__LiteralChars() {
  return
    maskbit(offsetof(re__LiteralChars, s));
}

inline re__LiteralChars::re__LiteralChars()
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::LiteralChars)),
      field_mask_(maskof_re__LiteralChars()),
      s(StrFromC("")),
      spid(-1) {
}

inline re__LiteralChars::re__LiteralChars(Str* s, int spid)
    : heap_tag_(Tag::FixedSize),
      type_tag_(static_cast<uint16_t>(re_e::LiteralChars)),
      field_mask_(maskof_re__LiteralChars()),
      s(s),
      spid(spid) {
}

namespace re {
  typedef re__CharClassLiteral CharClassLiteral;
  typedef re__CharClass CharClass;
  typedef re__Splice Splice;
  typedef re__Repeat Repeat;
  typedef re__Seq Seq;
  typedef re__Alt Alt;
  typedef re__Group Group;
  typedef re__Capture Capture;
  typedef re__Backtracking Backtracking;
  typedef re__Primitive Primitive;
  typedef re__LiteralChars LiteralChars;
}

class line_span {
 public:
  line_span();
  line_span(int line_id, int col, int length);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int line_id;
  int col;
  int length;

  DISALLOW_COPY_AND_ASSIGN(line_span)
};

inline line_span::line_span()
    : heap_tag_(Tag::FixedSize),
      type_tag_(200),
      field_mask_(kZeroMask),
      line_id(-1),
      col(-1),
      length(-1) {
}

inline line_span::line_span(int line_id, int col, int length)
    : heap_tag_(Tag::FixedSize),
      type_tag_(200),
      field_mask_(kZeroMask),
      line_id(line_id),
      col(col),
      length(length) {
}

class Token : public suffix_op_t, public word_part_t, public word_t, public
arith_expr_t, public re_t {
 public:
  Token();
  Token(Id_t id, int span_id, Str* val);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t id;
  int span_id;
  Str* val;

  DISALLOW_COPY_AND_ASSIGN(Token)
};

constexpr uint16_t maskof_Token() {
  return
    maskbit(offsetof(Token, val));
}

inline Token::Token()
    : heap_tag_(Tag::FixedSize),
      type_tag_(201),
      field_mask_(maskof_Token()),
      id(-1),
      span_id(-1),
      val(StrFromC("")) {
}

inline Token::Token(Id_t id, int span_id, Str* val)
    : heap_tag_(Tag::FixedSize),
      type_tag_(201),
      field_mask_(maskof_Token()),
      id(id),
      span_id(span_id),
      val(val) {
}

class speck : public re_t {
 public:
  speck();
  speck(Id_t id, int span_id);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Id_t id;
  int span_id;

  DISALLOW_COPY_AND_ASSIGN(speck)
};

inline speck::speck()
    : heap_tag_(Tag::FixedSize),
      type_tag_(202),
      field_mask_(kZeroMask),
      id(-1),
      span_id(-1) {
}

inline speck::speck(Id_t id, int span_id)
    : heap_tag_(Tag::FixedSize),
      type_tag_(202),
      field_mask_(kZeroMask),
      id(id),
      span_id(span_id) {
}

class double_quoted : public word_part_t, public expr_t, public
class_literal_term_t, public re_t {
 public:
  double_quoted();
  double_quoted(Token* left, List<word_part_t*>* parts, bool multiline);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* left;
  List<word_part_t*>* parts;
  bool multiline;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(double_quoted)
};

constexpr uint16_t maskof_double_quoted() {
  return
    maskbit(offsetof(double_quoted, left))
  | maskbit(offsetof(double_quoted, parts))
  | maskbit(offsetof(double_quoted, spids));
}

inline double_quoted::double_quoted()
    : heap_tag_(Tag::FixedSize),
      type_tag_(203),
      field_mask_(maskof_double_quoted()),
      left(nullptr),
      parts(NewList<word_part_t*>()),
      multiline(false),
      spids(NewList<int>()) {
}

inline double_quoted::double_quoted(Token* left, List<word_part_t*>* parts,
                                    bool multiline)
    : heap_tag_(Tag::FixedSize),
      type_tag_(203),
      field_mask_(maskof_double_quoted()),
      left(left),
      parts(parts),
      multiline(multiline),
      spids(NewList<int>()) {
}

class single_quoted : public word_part_t, public expr_t, public
class_literal_term_t, public re_t {
 public:
  single_quoted();
  single_quoted(Token* left, List<Token*>* tokens, bool multiline);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* left;
  List<Token*>* tokens;
  bool multiline;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(single_quoted)
};

constexpr uint16_t maskof_single_quoted() {
  return
    maskbit(offsetof(single_quoted, left))
  | maskbit(offsetof(single_quoted, tokens))
  | maskbit(offsetof(single_quoted, spids));
}

inline single_quoted::single_quoted()
    : heap_tag_(Tag::FixedSize),
      type_tag_(204),
      field_mask_(maskof_single_quoted()),
      left(nullptr),
      tokens(NewList<Token*>()),
      multiline(false),
      spids(NewList<int>()) {
}

inline single_quoted::single_quoted(Token* left, List<Token*>* tokens, bool
                                    multiline)
    : heap_tag_(Tag::FixedSize),
      type_tag_(204),
      field_mask_(maskof_single_quoted()),
      left(left),
      tokens(tokens),
      multiline(multiline),
      spids(NewList<int>()) {
}

class simple_var_sub : public word_part_t, public expr_t, public
class_literal_term_t, public re_t {
 public:
  simple_var_sub();
  simple_var_sub(Token* token);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* token;

  DISALLOW_COPY_AND_ASSIGN(simple_var_sub)
};

constexpr uint16_t maskof_simple_var_sub() {
  return
    maskbit(offsetof(simple_var_sub, token));
}

inline simple_var_sub::simple_var_sub()
    : heap_tag_(Tag::FixedSize),
      type_tag_(205),
      field_mask_(maskof_simple_var_sub()),
      token(nullptr) {
}

inline simple_var_sub::simple_var_sub(Token* token)
    : heap_tag_(Tag::FixedSize),
      type_tag_(205),
      field_mask_(maskof_simple_var_sub()),
      token(token) {
}

class braced_var_sub : public word_part_t, public expr_t, public
class_literal_term_t, public re_t {
 public:
  braced_var_sub();
  braced_var_sub(Token* token, speck* prefix_op, bracket_op_t* bracket_op,
                 suffix_op_t* suffix_op);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* token;
  speck* prefix_op;
  bracket_op_t* bracket_op;
  suffix_op_t* suffix_op;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(braced_var_sub)
};

constexpr uint16_t maskof_braced_var_sub() {
  return
    maskbit(offsetof(braced_var_sub, token))
  | maskbit(offsetof(braced_var_sub, prefix_op))
  | maskbit(offsetof(braced_var_sub, bracket_op))
  | maskbit(offsetof(braced_var_sub, suffix_op))
  | maskbit(offsetof(braced_var_sub, spids));
}

inline braced_var_sub::braced_var_sub()
    : heap_tag_(Tag::FixedSize),
      type_tag_(206),
      field_mask_(maskof_braced_var_sub()),
      token(nullptr),
      prefix_op(nullptr),
      bracket_op(nullptr),
      suffix_op(nullptr),
      spids(NewList<int>()) {
}

inline braced_var_sub::braced_var_sub(Token* token, speck* prefix_op,
                                      bracket_op_t* bracket_op, suffix_op_t*
                                      suffix_op)
    : heap_tag_(Tag::FixedSize),
      type_tag_(206),
      field_mask_(maskof_braced_var_sub()),
      token(token),
      prefix_op(prefix_op),
      bracket_op(bracket_op),
      suffix_op(suffix_op),
      spids(NewList<int>()) {
}

class command_sub : public word_part_t, public expr_t {
 public:
  command_sub();
  command_sub(Token* left_token, command_t* child);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* left_token;
  command_t* child;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(command_sub)
};

constexpr uint16_t maskof_command_sub() {
  return
    maskbit(offsetof(command_sub, left_token))
  | maskbit(offsetof(command_sub, child))
  | maskbit(offsetof(command_sub, spids));
}

inline command_sub::command_sub()
    : heap_tag_(Tag::FixedSize),
      type_tag_(207),
      field_mask_(maskof_command_sub()),
      left_token(nullptr),
      child(nullptr),
      spids(NewList<int>()) {
}

inline command_sub::command_sub(Token* left_token, command_t* child)
    : heap_tag_(Tag::FixedSize),
      type_tag_(207),
      field_mask_(maskof_command_sub()),
      left_token(left_token),
      child(child),
      spids(NewList<int>()) {
}

class sh_array_literal : public word_part_t, public expr_t {
 public:
  sh_array_literal();
  sh_array_literal(Token* left, List<word_t*>* words);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* left;
  List<word_t*>* words;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(sh_array_literal)
};

constexpr uint16_t maskof_sh_array_literal() {
  return
    maskbit(offsetof(sh_array_literal, left))
  | maskbit(offsetof(sh_array_literal, words))
  | maskbit(offsetof(sh_array_literal, spids));
}

inline sh_array_literal::sh_array_literal()
    : heap_tag_(Tag::FixedSize),
      type_tag_(208),
      field_mask_(maskof_sh_array_literal()),
      left(nullptr),
      words(NewList<word_t*>()),
      spids(NewList<int>()) {
}

inline sh_array_literal::sh_array_literal(Token* left, List<word_t*>* words)
    : heap_tag_(Tag::FixedSize),
      type_tag_(208),
      field_mask_(maskof_sh_array_literal()),
      left(left),
      words(words),
      spids(NewList<int>()) {
}

class ArgList {
 public:
  ArgList();
  ArgList(List<expr_t*>* positional, List<named_arg*>* named);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<expr_t*>* positional;
  List<named_arg*>* named;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(ArgList)
};

constexpr uint16_t maskof_ArgList() {
  return
    maskbit(offsetof(ArgList, positional))
  | maskbit(offsetof(ArgList, named))
  | maskbit(offsetof(ArgList, spids));
}

inline ArgList::ArgList()
    : heap_tag_(Tag::FixedSize),
      type_tag_(209),
      field_mask_(maskof_ArgList()),
      positional(NewList<expr_t*>()),
      named(NewList<named_arg*>()),
      spids(NewList<int>()) {
}

inline ArgList::ArgList(List<expr_t*>* positional, List<named_arg*>* named)
    : heap_tag_(Tag::FixedSize),
      type_tag_(209),
      field_mask_(maskof_ArgList()),
      positional(positional),
      named(named),
      spids(NewList<int>()) {
}

class compound_word : public word_t, public arith_expr_t, public redir_param_t {
 public:
  compound_word();
  compound_word(List<word_part_t*>* parts);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<word_part_t*>* parts;

  DISALLOW_COPY_AND_ASSIGN(compound_word)
};

constexpr uint16_t maskof_compound_word() {
  return
    maskbit(offsetof(compound_word, parts));
}

inline compound_word::compound_word()
    : heap_tag_(Tag::FixedSize),
      type_tag_(210),
      field_mask_(maskof_compound_word()),
      parts(NewList<word_part_t*>()) {
}

inline compound_word::compound_word(List<word_part_t*>* parts)
    : heap_tag_(Tag::FixedSize),
      type_tag_(210),
      field_mask_(maskof_compound_word()),
      parts(parts) {
}

class string_line {
 public:
  string_line();
  string_line(int dedent, List<word_part_t*>* part);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int dedent;
  List<word_part_t*>* part;

  DISALLOW_COPY_AND_ASSIGN(string_line)
};

constexpr uint16_t maskof_string_line() {
  return
    maskbit(offsetof(string_line, part));
}

inline string_line::string_line()
    : heap_tag_(Tag::FixedSize),
      type_tag_(211),
      field_mask_(maskof_string_line()),
      dedent(-1),
      part(NewList<word_part_t*>()) {
}

inline string_line::string_line(int dedent, List<word_part_t*>* part)
    : heap_tag_(Tag::FixedSize),
      type_tag_(211),
      field_mask_(maskof_string_line()),
      dedent(dedent),
      part(part) {
}

class triple_quoted {
 public:
  triple_quoted();
  triple_quoted(int min_dedent, List<string_line*>* lines);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int min_dedent;
  List<string_line*>* lines;

  DISALLOW_COPY_AND_ASSIGN(triple_quoted)
};

constexpr uint16_t maskof_triple_quoted() {
  return
    maskbit(offsetof(triple_quoted, lines));
}

inline triple_quoted::triple_quoted()
    : heap_tag_(Tag::FixedSize),
      type_tag_(212),
      field_mask_(maskof_triple_quoted()),
      min_dedent(-1),
      lines(NewList<string_line*>()) {
}

inline triple_quoted::triple_quoted(int min_dedent, List<string_line*>* lines)
    : heap_tag_(Tag::FixedSize),
      type_tag_(212),
      field_mask_(maskof_triple_quoted()),
      min_dedent(min_dedent),
      lines(lines) {
}

class redir {
 public:
  redir();
  redir(Token* op, redir_loc_t* loc, redir_param_t* arg);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* op;
  redir_loc_t* loc;
  redir_param_t* arg;

  DISALLOW_COPY_AND_ASSIGN(redir)
};

constexpr uint16_t maskof_redir() {
  return
    maskbit(offsetof(redir, op))
  | maskbit(offsetof(redir, loc))
  | maskbit(offsetof(redir, arg));
}

inline redir::redir()
    : heap_tag_(Tag::FixedSize),
      type_tag_(213),
      field_mask_(maskof_redir()),
      op(nullptr),
      loc(nullptr),
      arg(nullptr) {
}

inline redir::redir(Token* op, redir_loc_t* loc, redir_param_t* arg)
    : heap_tag_(Tag::FixedSize),
      type_tag_(213),
      field_mask_(maskof_redir()),
      op(op),
      loc(loc),
      arg(arg) {
}

class assign_pair {
 public:
  assign_pair();
  assign_pair(sh_lhs_expr_t* lhs, assign_op_t op, word_t* rhs, List<int>*
              spids);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  sh_lhs_expr_t* lhs;
  assign_op_t op;
  word_t* rhs;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(assign_pair)
};

constexpr uint16_t maskof_assign_pair() {
  return
    maskbit(offsetof(assign_pair, lhs))
  | maskbit(offsetof(assign_pair, rhs))
  | maskbit(offsetof(assign_pair, spids));
}

inline assign_pair::assign_pair()
    : heap_tag_(Tag::FixedSize),
      type_tag_(214),
      field_mask_(maskof_assign_pair()),
      lhs(nullptr),
      op(assign_op_e::Equal),
      rhs(nullptr),
      spids(NewList<int>()) {
}

inline assign_pair::assign_pair(sh_lhs_expr_t* lhs, assign_op_t op, word_t*
                                rhs, List<int>* spids)
    : heap_tag_(Tag::FixedSize),
      type_tag_(214),
      field_mask_(maskof_assign_pair()),
      lhs(lhs),
      op(op),
      rhs(rhs),
      spids(spids) {
}

class env_pair {
 public:
  env_pair();
  env_pair(Str* name, word_t* val, List<int>* spids);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Str* name;
  word_t* val;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(env_pair)
};

constexpr uint16_t maskof_env_pair() {
  return
    maskbit(offsetof(env_pair, name))
  | maskbit(offsetof(env_pair, val))
  | maskbit(offsetof(env_pair, spids));
}

inline env_pair::env_pair()
    : heap_tag_(Tag::FixedSize),
      type_tag_(215),
      field_mask_(maskof_env_pair()),
      name(StrFromC("")),
      val(nullptr),
      spids(NewList<int>()) {
}

inline env_pair::env_pair(Str* name, word_t* val, List<int>* spids)
    : heap_tag_(Tag::FixedSize),
      type_tag_(215),
      field_mask_(maskof_env_pair()),
      name(name),
      val(val),
      spids(spids) {
}

class case_arm {
 public:
  case_arm();
  case_arm(List<word_t*>* pat_list, List<command_t*>* action, List<int>* spids);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<word_t*>* pat_list;
  List<command_t*>* action;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(case_arm)
};

constexpr uint16_t maskof_case_arm() {
  return
    maskbit(offsetof(case_arm, pat_list))
  | maskbit(offsetof(case_arm, action))
  | maskbit(offsetof(case_arm, spids));
}

inline case_arm::case_arm()
    : heap_tag_(Tag::FixedSize),
      type_tag_(216),
      field_mask_(maskof_case_arm()),
      pat_list(NewList<word_t*>()),
      action(NewList<command_t*>()),
      spids(NewList<int>()) {
}

inline case_arm::case_arm(List<word_t*>* pat_list, List<command_t*>* action,
                          List<int>* spids)
    : heap_tag_(Tag::FixedSize),
      type_tag_(216),
      field_mask_(maskof_case_arm()),
      pat_list(pat_list),
      action(action),
      spids(spids) {
}

class if_arm {
 public:
  if_arm();
  if_arm(condition_t* cond, List<command_t*>* action, List<int>* spids);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  condition_t* cond;
  List<command_t*>* action;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(if_arm)
};

constexpr uint16_t maskof_if_arm() {
  return
    maskbit(offsetof(if_arm, cond))
  | maskbit(offsetof(if_arm, action))
  | maskbit(offsetof(if_arm, spids));
}

inline if_arm::if_arm()
    : heap_tag_(Tag::FixedSize),
      type_tag_(217),
      field_mask_(maskof_if_arm()),
      cond(nullptr),
      action(NewList<command_t*>()),
      spids(NewList<int>()) {
}

inline if_arm::if_arm(condition_t* cond, List<command_t*>* action, List<int>*
                      spids)
    : heap_tag_(Tag::FixedSize),
      type_tag_(217),
      field_mask_(maskof_if_arm()),
      cond(cond),
      action(action),
      spids(spids) {
}

class BraceGroup : public command_t {
 public:
  BraceGroup();
  BraceGroup(Token* doc_token, List<command_t*>* children, List<redir*>*
             redirects);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* doc_token;
  List<command_t*>* children;
  List<redir*>* redirects;
  List<int>* spids;

  DISALLOW_COPY_AND_ASSIGN(BraceGroup)
};

constexpr uint16_t maskof_BraceGroup() {
  return
    maskbit(offsetof(BraceGroup, doc_token))
  | maskbit(offsetof(BraceGroup, children))
  | maskbit(offsetof(BraceGroup, redirects))
  | maskbit(offsetof(BraceGroup, spids));
}

inline BraceGroup::BraceGroup()
    : heap_tag_(Tag::FixedSize),
      type_tag_(218),
      field_mask_(maskof_BraceGroup()),
      doc_token(nullptr),
      children(NewList<command_t*>()),
      redirects(NewList<redir*>()),
      spids(NewList<int>()) {
}

inline BraceGroup::BraceGroup(Token* doc_token, List<command_t*>* children,
                              List<redir*>* redirects)
    : heap_tag_(Tag::FixedSize),
      type_tag_(218),
      field_mask_(maskof_BraceGroup()),
      doc_token(doc_token),
      children(children),
      redirects(redirects),
      spids(NewList<int>()) {
}

class variant {
 public:
  variant();
  variant(Token* tag_name, variant_type_t* typ);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* tag_name;
  variant_type_t* typ;

  DISALLOW_COPY_AND_ASSIGN(variant)
};

constexpr uint16_t maskof_variant() {
  return
    maskbit(offsetof(variant, tag_name))
  | maskbit(offsetof(variant, typ));
}

inline variant::variant()
    : heap_tag_(Tag::FixedSize),
      type_tag_(219),
      field_mask_(maskof_variant()),
      tag_name(nullptr),
      typ(nullptr) {
}

inline variant::variant(Token* tag_name, variant_type_t* typ)
    : heap_tag_(Tag::FixedSize),
      type_tag_(219),
      field_mask_(maskof_variant()),
      tag_name(tag_name),
      typ(typ) {
}

class import_name {
 public:
  import_name();
  import_name(Token* name, Token* alias);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  Token* alias;

  DISALLOW_COPY_AND_ASSIGN(import_name)
};

constexpr uint16_t maskof_import_name() {
  return
    maskbit(offsetof(import_name, name))
  | maskbit(offsetof(import_name, alias));
}

inline import_name::import_name()
    : heap_tag_(Tag::FixedSize),
      type_tag_(220),
      field_mask_(maskof_import_name()),
      name(nullptr),
      alias(nullptr) {
}

inline import_name::import_name(Token* name, Token* alias)
    : heap_tag_(Tag::FixedSize),
      type_tag_(220),
      field_mask_(maskof_import_name()),
      name(name),
      alias(alias) {
}

class UntypedParam {
 public:
  UntypedParam();
  UntypedParam(Token* ref, Token* name, expr_t* default_val);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* ref;
  Token* name;
  expr_t* default_val;

  DISALLOW_COPY_AND_ASSIGN(UntypedParam)
};

constexpr uint16_t maskof_UntypedParam() {
  return
    maskbit(offsetof(UntypedParam, ref))
  | maskbit(offsetof(UntypedParam, name))
  | maskbit(offsetof(UntypedParam, default_val));
}

inline UntypedParam::UntypedParam()
    : heap_tag_(Tag::FixedSize),
      type_tag_(221),
      field_mask_(maskof_UntypedParam()),
      ref(nullptr),
      name(nullptr),
      default_val(nullptr) {
}

inline UntypedParam::UntypedParam(Token* ref, Token* name, expr_t* default_val)
    : heap_tag_(Tag::FixedSize),
      type_tag_(221),
      field_mask_(maskof_UntypedParam()),
      ref(ref),
      name(name),
      default_val(default_val) {
}

class TypedParam {
 public:
  TypedParam();
  TypedParam(Token* name, Token* type, expr_t* default_val);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  Token* type;
  expr_t* default_val;

  DISALLOW_COPY_AND_ASSIGN(TypedParam)
};

constexpr uint16_t maskof_TypedParam() {
  return
    maskbit(offsetof(TypedParam, name))
  | maskbit(offsetof(TypedParam, type))
  | maskbit(offsetof(TypedParam, default_val));
}

inline TypedParam::TypedParam()
    : heap_tag_(Tag::FixedSize),
      type_tag_(222),
      field_mask_(maskof_TypedParam()),
      name(nullptr),
      type(nullptr),
      default_val(nullptr) {
}

inline TypedParam::TypedParam(Token* name, Token* type, expr_t* default_val)
    : heap_tag_(Tag::FixedSize),
      type_tag_(222),
      field_mask_(maskof_TypedParam()),
      name(name),
      type(type),
      default_val(default_val) {
}

class param {
 public:
  param();
  param(Token* prefix, Token* name, type_expr_t* type, expr_t* default_val);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* prefix;
  Token* name;
  type_expr_t* type;
  expr_t* default_val;

  DISALLOW_COPY_AND_ASSIGN(param)
};

constexpr uint16_t maskof_param() {
  return
    maskbit(offsetof(param, prefix))
  | maskbit(offsetof(param, name))
  | maskbit(offsetof(param, type))
  | maskbit(offsetof(param, default_val));
}

inline param::param()
    : heap_tag_(Tag::FixedSize),
      type_tag_(223),
      field_mask_(maskof_param()),
      prefix(nullptr),
      name(nullptr),
      type(nullptr),
      default_val(nullptr) {
}

inline param::param(Token* prefix, Token* name, type_expr_t* type, expr_t*
                    default_val)
    : heap_tag_(Tag::FixedSize),
      type_tag_(223),
      field_mask_(maskof_param()),
      prefix(prefix),
      name(name),
      type(type),
      default_val(default_val) {
}

class name_type {
 public:
  name_type();
  name_type(Token* name, type_expr_t* typ);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  type_expr_t* typ;

  DISALLOW_COPY_AND_ASSIGN(name_type)
};

constexpr uint16_t maskof_name_type() {
  return
    maskbit(offsetof(name_type, name))
  | maskbit(offsetof(name_type, typ));
}

inline name_type::name_type()
    : heap_tag_(Tag::FixedSize),
      type_tag_(224),
      field_mask_(maskof_name_type()),
      name(nullptr),
      typ(nullptr) {
}

inline name_type::name_type(Token* name, type_expr_t* typ)
    : heap_tag_(Tag::FixedSize),
      type_tag_(224),
      field_mask_(maskof_name_type()),
      name(name),
      typ(typ) {
}

class comprehension {
 public:
  comprehension();
  comprehension(List<name_type*>* lhs, expr_t* iter, expr_t* cond);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  List<name_type*>* lhs;
  expr_t* iter;
  expr_t* cond;

  DISALLOW_COPY_AND_ASSIGN(comprehension)
};

constexpr uint16_t maskof_comprehension() {
  return
    maskbit(offsetof(comprehension, lhs))
  | maskbit(offsetof(comprehension, iter))
  | maskbit(offsetof(comprehension, cond));
}

inline comprehension::comprehension()
    : heap_tag_(Tag::FixedSize),
      type_tag_(225),
      field_mask_(maskof_comprehension()),
      lhs(NewList<name_type*>()),
      iter(nullptr),
      cond(nullptr) {
}

inline comprehension::comprehension(List<name_type*>* lhs, expr_t* iter,
                                    expr_t* cond)
    : heap_tag_(Tag::FixedSize),
      type_tag_(225),
      field_mask_(maskof_comprehension()),
      lhs(lhs),
      iter(iter),
      cond(cond) {
}

class named_arg {
 public:
  named_arg();
  named_arg(Token* name, expr_t* value);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  Token* name;
  expr_t* value;

  DISALLOW_COPY_AND_ASSIGN(named_arg)
};

constexpr uint16_t maskof_named_arg() {
  return
    maskbit(offsetof(named_arg, name))
  | maskbit(offsetof(named_arg, value));
}

inline named_arg::named_arg()
    : heap_tag_(Tag::FixedSize),
      type_tag_(226),
      field_mask_(maskof_named_arg()),
      name(nullptr),
      value(nullptr) {
}

inline named_arg::named_arg(Token* name, expr_t* value)
    : heap_tag_(Tag::FixedSize),
      type_tag_(226),
      field_mask_(maskof_named_arg()),
      name(name),
      value(value) {
}

class subscript : public place_expr_t, public expr_t {
 public:
  subscript();
  subscript(expr_t* obj, List<expr_t*>* indices);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* obj;
  List<expr_t*>* indices;

  DISALLOW_COPY_AND_ASSIGN(subscript)
};

constexpr uint16_t maskof_subscript() {
  return
    maskbit(offsetof(subscript, obj))
  | maskbit(offsetof(subscript, indices));
}

inline subscript::subscript()
    : heap_tag_(Tag::FixedSize),
      type_tag_(227),
      field_mask_(maskof_subscript()),
      obj(nullptr),
      indices(NewList<expr_t*>()) {
}

inline subscript::subscript(expr_t* obj, List<expr_t*>* indices)
    : heap_tag_(Tag::FixedSize),
      type_tag_(227),
      field_mask_(maskof_subscript()),
      obj(obj),
      indices(indices) {
}

class attribute : public place_expr_t, public expr_t {
 public:
  attribute();
  attribute(expr_t* obj, Token* op, Token* attr, expr_context_t ctx);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  expr_t* obj;
  Token* op;
  Token* attr;
  expr_context_t ctx;

  DISALLOW_COPY_AND_ASSIGN(attribute)
};

constexpr uint16_t maskof_attribute() {
  return
    maskbit(offsetof(attribute, obj))
  | maskbit(offsetof(attribute, op))
  | maskbit(offsetof(attribute, attr));
}

inline attribute::attribute()
    : heap_tag_(Tag::FixedSize),
      type_tag_(228),
      field_mask_(maskof_attribute()),
      obj(nullptr),
      op(nullptr),
      attr(nullptr),
      ctx(expr_context_e::Load) {
}

inline attribute::attribute(expr_t* obj, Token* op, Token* attr, expr_context_t
                            ctx)
    : heap_tag_(Tag::FixedSize),
      type_tag_(228),
      field_mask_(maskof_attribute()),
      obj(obj),
      op(op),
      attr(attr),
      ctx(ctx) {
}

class posix_class : public class_literal_term_t, public char_class_term_t,
public re_t {
 public:
  posix_class();
  posix_class(speck* negated, Str* name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  speck* negated;
  Str* name;

  DISALLOW_COPY_AND_ASSIGN(posix_class)
};

constexpr uint16_t maskof_posix_class() {
  return
    maskbit(offsetof(posix_class, negated))
  | maskbit(offsetof(posix_class, name));
}

inline posix_class::posix_class()
    : heap_tag_(Tag::FixedSize),
      type_tag_(229),
      field_mask_(maskof_posix_class()),
      negated(nullptr),
      name(StrFromC("")) {
}

inline posix_class::posix_class(speck* negated, Str* name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(229),
      field_mask_(maskof_posix_class()),
      negated(negated),
      name(name) {
}

class perl_class : public class_literal_term_t, public char_class_term_t,
public re_t {
 public:
  perl_class();
  perl_class(speck* negated, Str* name);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  speck* negated;
  Str* name;

  DISALLOW_COPY_AND_ASSIGN(perl_class)
};

constexpr uint16_t maskof_perl_class() {
  return
    maskbit(offsetof(perl_class, negated))
  | maskbit(offsetof(perl_class, name));
}

inline perl_class::perl_class()
    : heap_tag_(Tag::FixedSize),
      type_tag_(230),
      field_mask_(maskof_perl_class()),
      negated(nullptr),
      name(StrFromC("")) {
}

inline perl_class::perl_class(speck* negated, Str* name)
    : heap_tag_(Tag::FixedSize),
      type_tag_(230),
      field_mask_(maskof_perl_class()),
      negated(negated),
      name(name) {
}

class CharCode : public char_class_term_t {
 public:
  CharCode();
  CharCode(int i, bool u_braced, int spid);
  hnode_t* PrettyTree();

  OBJ_HEADER();
  int i;
  bool u_braced;
  int spid;

  DISALLOW_COPY_AND_ASSIGN(CharCode)
};

inline CharCode::CharCode()
    : heap_tag_(Tag::FixedSize),
      type_tag_(231),
      field_mask_(kZeroMask),
      i(-1),
      u_braced(false),
      spid(-1) {
}

inline CharCode::CharCode(int i, bool u_braced, int spid)
    : heap_tag_(Tag::FixedSize),
      type_tag_(231),
      field_mask_(kZeroMask),
      i(i),
      u_braced(u_braced),
      spid(spid) {
}


}  // namespace syntax_asdl

#endif  // SYNTAX_ASDL
