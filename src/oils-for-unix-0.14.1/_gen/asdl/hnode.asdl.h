// _gen/asdl/hnode.asdl.h is generated by asdl_main.py

#ifndef HNODE_ASDL
#define HNODE_ASDL

#include <cstdint>

#include "mycpp/runtime.h"
namespace hnode_asdl {

// use struct instead of namespace so 'using' works consistently
#define ASDL_NAMES struct

class field;
class hnode_t;

enum class color_e {
  TypeName = 1,
  StringConst = 2,
  OtherConst = 3,
  UserType = 4,
  External = 5,
};
typedef color_e color_t;

ASDL_NAMES hnode_e {
  enum no_name {
  Record = 1,
  Array = 2,
  Leaf = 3,
  External = 4,
  };
};

class hnode_t {
 protected:
  hnode_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  DISALLOW_COPY_AND_ASSIGN(hnode_t)
};

class hnode__Record : public hnode_t {
 public:
  hnode__Record(Str* node_type, List<field*>* fields, bool abbrev, Str* left,
                Str* right, List<hnode_t*>* unnamed_fields)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(hnode_e::Record),
                      field_mask(), sizeof(hnode__Record)),
        node_type(node_type),
        fields(fields),
        abbrev(abbrev),
        left(left),
        right(right),
        unnamed_fields(unnamed_fields) {
  }

  static hnode__Record* Create() { 
    return Alloc<hnode__Record>(nullptr, Alloc<List<field*>>(), false,
                                kEmptyString, kEmptyString,
                                Alloc<List<hnode_t*>>());
  }

  GC_OBJ(header_);
  Str* node_type;
  List<field*>* fields;
  bool abbrev;
  Str* left;
  Str* right;
  List<hnode_t*>* unnamed_fields;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(hnode__Record, node_type))
         | maskbit(offsetof(hnode__Record, fields))
         | maskbit(offsetof(hnode__Record, left))
         | maskbit(offsetof(hnode__Record, right))
         | maskbit(offsetof(hnode__Record, unnamed_fields));
  }

  DISALLOW_COPY_AND_ASSIGN(hnode__Record)
};

class hnode__Array : public hnode_t {
 public:
  hnode__Array(List<hnode_t*>* children)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(hnode_e::Array),
                      field_mask(), sizeof(hnode__Array)),
        children(children) {
  }

  static hnode__Array* Create() { 
    return Alloc<hnode__Array>(Alloc<List<hnode_t*>>());
  }

  GC_OBJ(header_);
  List<hnode_t*>* children;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(hnode__Array, children));
  }

  DISALLOW_COPY_AND_ASSIGN(hnode__Array)
};

class hnode__Leaf : public hnode_t {
 public:
  hnode__Leaf(Str* s, color_t color)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(hnode_e::Leaf),
                      field_mask(), sizeof(hnode__Leaf)),
        s(s),
        color(color) {
  }

  static hnode__Leaf* Create() { 
    return Alloc<hnode__Leaf>(kEmptyString, color_e::TypeName);
  }

  GC_OBJ(header_);
  Str* s;
  color_t color;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(hnode__Leaf, s));
  }

  DISALLOW_COPY_AND_ASSIGN(hnode__Leaf)
};

class hnode__External : public hnode_t {
 public:
  hnode__External(void* obj)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(hnode_e::External),
                      field_mask(), sizeof(hnode__External)),
        obj(obj) {
  }

  static hnode__External* Create() { 
    return Alloc<hnode__External>(nullptr);
  }

  GC_OBJ(header_);
  void* obj;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(hnode__External, obj));
  }

  DISALLOW_COPY_AND_ASSIGN(hnode__External)
};

ASDL_NAMES hnode {
  typedef hnode__Record Record;
  typedef hnode__Array Array;
  typedef hnode__Leaf Leaf;
  typedef hnode__External External;
};

class field {
 public:
  field(Str* name, hnode_t* val)
      : GC_ASDL_CLASS(header_, 64,
                      field_mask(), sizeof(field)),
        name(name),
        val(val) {
  }

  static field* Create() { 
    return Alloc<field>(kEmptyString, nullptr);
  }

  GC_OBJ(header_);
  Str* name;
  hnode_t* val;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(field, name))
         | maskbit(offsetof(field, val));
  }

  DISALLOW_COPY_AND_ASSIGN(field)
};


}  // namespace hnode_asdl

#endif  // HNODE_ASDL
