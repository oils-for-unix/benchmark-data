// _gen/frontend/syntax.asdl.h is generated by asdl_main.py

#ifndef SYNTAX_ASDL
#define SYNTAX_ASDL

#include <cstdint>

#include "mycpp/runtime.h"
#include "_gen/asdl/hnode.asdl.h"
using hnode_asdl::hnode_t;

#include "_gen/frontend/id_kind.asdl.h"
using id_kind_asdl::Id_t;

namespace syntax_asdl {

// use struct instead of namespace so 'using' works consistently
#define ASDL_NAMES struct

class BoolOutParam;
class parse_result_t;
class source_t;
class SourceLine;
class Token;
class loc_t;
class bracket_op_t;
class suffix_op_t;
class braced_var_sub;
class double_quoted;
class single_quoted;
class simple_var_sub;
class command_sub;
class sh_array_literal;
class ArgList;
class assoc_pair;
class word_part_t;
class compound_word;
class string_line;
class triple_quoted;
class rhs_word_t;
class word_t;
class sh_lhs_expr_t;
class arith_expr_t;
class bool_expr_t;
class redir_loc_t;
class redir_param_t;
class redir;
class assign_pair;
class env_pair;
class condition_t;
class case_arm;
class if_arm;
class for_iter_t;
class BraceGroup;
class BlockArg;
class command_t;
class variant_type_t;
class variant;
class class_item_t;
class import_name;
class UntypedParam;
class TypedParam;
class proc_sig_t;
class param;
class glob_part_t;
class printf_part_t;
class type_expr_t;
class name_type;
class comprehension;
class named_arg;
class subscript;
class attribute;
class place_expr_t;
class expr_t;
class posix_class;
class perl_class;
class class_literal_term_t;
class CharCode;
class char_class_term_t;
class re_repeat_t;
class re_t;

ASDL_NAMES parse_result_e {
  enum no_name {
  EmptyLine = 1,
  Eof = 2,
  Node = 3,
  };
};

const char* parse_result_str(int tag);

class parse_result_t {
 protected:
  parse_result_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(parse_result_t)
};

class parse_result__EmptyLine : public parse_result_t {
 public:
  parse_result__EmptyLine()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(parse_result_e::EmptyLine),
                      kZeroMask, sizeof(parse_result__EmptyLine)) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);

  DISALLOW_COPY_AND_ASSIGN(parse_result__EmptyLine)
};

class parse_result__Eof : public parse_result_t {
 public:
  parse_result__Eof()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(parse_result_e::Eof),
                      kZeroMask, sizeof(parse_result__Eof)) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);

  DISALLOW_COPY_AND_ASSIGN(parse_result__Eof)
};

class parse_result__Node : public parse_result_t {
 public:
  parse_result__Node(command_t* cmd)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(parse_result_e::Node),
                      field_mask(), sizeof(parse_result__Node)),
        cmd(cmd) {
  }

  static parse_result__Node* Create() { 
    return Alloc<parse_result__Node>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  command_t* cmd;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(parse_result__Node, cmd));
  }

  DISALLOW_COPY_AND_ASSIGN(parse_result__Node)
};

ASDL_NAMES parse_result {
  typedef parse_result__EmptyLine EmptyLine;
  typedef parse_result__Eof Eof;
  typedef parse_result__Node Node;
};

ASDL_NAMES source_e {
  enum no_name {
  Interactive = 1,
  Headless = 2,
  Unused = 3,
  CFlag = 4,
  Stdin = 5,
  MainFile = 6,
  SourcedFile = 7,
  ArgvWord = 8,
  Variable = 9,
  VarRef = 10,
  Alias = 11,
  Reparsed = 12,
  Synthetic = 13,
  };
};

const char* source_str(int tag);

class source_t {
 protected:
  source_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(source_t)
};

class source__Interactive : public source_t {
 public:
  source__Interactive()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::Interactive),
                      kZeroMask, sizeof(source__Interactive)) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);

  DISALLOW_COPY_AND_ASSIGN(source__Interactive)
};

class source__Headless : public source_t {
 public:
  source__Headless()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::Headless),
                      kZeroMask, sizeof(source__Headless)) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);

  DISALLOW_COPY_AND_ASSIGN(source__Headless)
};

class source__Unused : public source_t {
 public:
  source__Unused(Str* comment)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::Unused),
                      field_mask(), sizeof(source__Unused)),
        comment(comment) {
  }

  static source__Unused* Create() { 
    return Alloc<source__Unused>(kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* comment;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(source__Unused, comment));
  }

  DISALLOW_COPY_AND_ASSIGN(source__Unused)
};

class source__CFlag : public source_t {
 public:
  source__CFlag()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::CFlag),
                      kZeroMask, sizeof(source__CFlag)) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);

  DISALLOW_COPY_AND_ASSIGN(source__CFlag)
};

class source__Stdin : public source_t {
 public:
  source__Stdin(Str* comment)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::Stdin),
                      field_mask(), sizeof(source__Stdin)),
        comment(comment) {
  }

  static source__Stdin* Create() { 
    return Alloc<source__Stdin>(kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* comment;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(source__Stdin, comment));
  }

  DISALLOW_COPY_AND_ASSIGN(source__Stdin)
};

class source__MainFile : public source_t {
 public:
  source__MainFile(Str* path)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::MainFile),
                      field_mask(), sizeof(source__MainFile)),
        path(path) {
  }

  static source__MainFile* Create() { 
    return Alloc<source__MainFile>(kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* path;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(source__MainFile, path));
  }

  DISALLOW_COPY_AND_ASSIGN(source__MainFile)
};

class source__SourcedFile : public source_t {
 public:
  source__SourcedFile(Str* path, int spid)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::SourcedFile),
                      field_mask(), sizeof(source__SourcedFile)),
        path(path),
        spid(spid) {
  }

  static source__SourcedFile* Create() { 
    return Alloc<source__SourcedFile>(kEmptyString, -1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* path;
  int spid;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(source__SourcedFile, path));
  }

  DISALLOW_COPY_AND_ASSIGN(source__SourcedFile)
};

class source__ArgvWord : public source_t {
 public:
  source__ArgvWord(Str* what, int span_id)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::ArgvWord),
                      field_mask(), sizeof(source__ArgvWord)),
        what(what),
        span_id(span_id) {
  }

  static source__ArgvWord* Create() { 
    return Alloc<source__ArgvWord>(kEmptyString, -1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* what;
  int span_id;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(source__ArgvWord, what));
  }

  DISALLOW_COPY_AND_ASSIGN(source__ArgvWord)
};

class source__Variable : public source_t {
 public:
  source__Variable(Str* var_name, int span_id)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::Variable),
                      field_mask(), sizeof(source__Variable)),
        var_name(var_name),
        span_id(span_id) {
  }

  static source__Variable* Create() { 
    return Alloc<source__Variable>(kEmptyString, -1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* var_name;
  int span_id;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(source__Variable, var_name));
  }

  DISALLOW_COPY_AND_ASSIGN(source__Variable)
};

class source__VarRef : public source_t {
 public:
  source__VarRef(Token* orig_tok)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::VarRef),
                      field_mask(), sizeof(source__VarRef)),
        orig_tok(orig_tok) {
  }

  static source__VarRef* Create() { 
    return Alloc<source__VarRef>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* orig_tok;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(source__VarRef, orig_tok));
  }

  DISALLOW_COPY_AND_ASSIGN(source__VarRef)
};

class source__Alias : public source_t {
 public:
  source__Alias(Str* argv0, int argv0_spid)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::Alias),
                      field_mask(), sizeof(source__Alias)),
        argv0(argv0),
        argv0_spid(argv0_spid) {
  }

  static source__Alias* Create() { 
    return Alloc<source__Alias>(kEmptyString, -1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* argv0;
  int argv0_spid;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(source__Alias, argv0));
  }

  DISALLOW_COPY_AND_ASSIGN(source__Alias)
};

class source__Reparsed : public source_t {
 public:
  source__Reparsed(Str* what, Token* left_token, Token* right_token)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::Reparsed),
                      field_mask(), sizeof(source__Reparsed)),
        what(what),
        left_token(left_token),
        right_token(right_token) {
  }

  static source__Reparsed* Create() { 
    return Alloc<source__Reparsed>(kEmptyString, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* what;
  Token* left_token;
  Token* right_token;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(source__Reparsed, what))
         | maskbit(offsetof(source__Reparsed, left_token))
         | maskbit(offsetof(source__Reparsed, right_token));
  }

  DISALLOW_COPY_AND_ASSIGN(source__Reparsed)
};

class source__Synthetic : public source_t {
 public:
  source__Synthetic(Str* s)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(source_e::Synthetic),
                      field_mask(), sizeof(source__Synthetic)),
        s(s) {
  }

  static source__Synthetic* Create() { 
    return Alloc<source__Synthetic>(kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* s;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(source__Synthetic, s));
  }

  DISALLOW_COPY_AND_ASSIGN(source__Synthetic)
};

ASDL_NAMES source {
  typedef source__Interactive Interactive;
  typedef source__Headless Headless;
  typedef source__Unused Unused;
  typedef source__CFlag CFlag;
  typedef source__Stdin Stdin;
  typedef source__MainFile MainFile;
  typedef source__SourcedFile SourcedFile;
  typedef source__ArgvWord ArgvWord;
  typedef source__Variable Variable;
  typedef source__VarRef VarRef;
  typedef source__Alias Alias;
  typedef source__Reparsed Reparsed;
  typedef source__Synthetic Synthetic;
};

ASDL_NAMES loc_e {
  enum no_name {
  Missing = 1,
  Span = 2,
  Token = 66,
  WordPart = 4,
  Word = 5,
  Arith = 6,
  Command = 7,
  };
};

const char* loc_str(int tag);

class loc_t {
 protected:
  loc_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(loc_t)
};

class loc__Missing : public loc_t {
 public:
  loc__Missing()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(loc_e::Missing),
                      kZeroMask, sizeof(loc__Missing)) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);

  DISALLOW_COPY_AND_ASSIGN(loc__Missing)
};

class loc__Span : public loc_t {
 public:
  loc__Span(int span_id)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(loc_e::Span),
                      kZeroMask, sizeof(loc__Span)),
        span_id(span_id) {
  }

  static loc__Span* Create() { 
    return Alloc<loc__Span>(-1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  int span_id;

  DISALLOW_COPY_AND_ASSIGN(loc__Span)
};

class loc__WordPart : public loc_t {
 public:
  loc__WordPart(word_part_t* p)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(loc_e::WordPart),
                      field_mask(), sizeof(loc__WordPart)),
        p(p) {
  }

  static loc__WordPart* Create() { 
    return Alloc<loc__WordPart>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  word_part_t* p;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(loc__WordPart, p));
  }

  DISALLOW_COPY_AND_ASSIGN(loc__WordPart)
};

class loc__Word : public loc_t {
 public:
  loc__Word(word_t* w)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(loc_e::Word),
                      field_mask(), sizeof(loc__Word)),
        w(w) {
  }

  static loc__Word* Create() { 
    return Alloc<loc__Word>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  word_t* w;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(loc__Word, w));
  }

  DISALLOW_COPY_AND_ASSIGN(loc__Word)
};

class loc__Arith : public loc_t {
 public:
  loc__Arith(arith_expr_t* a)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(loc_e::Arith),
                      field_mask(), sizeof(loc__Arith)),
        a(a) {
  }

  static loc__Arith* Create() { 
    return Alloc<loc__Arith>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  arith_expr_t* a;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(loc__Arith, a));
  }

  DISALLOW_COPY_AND_ASSIGN(loc__Arith)
};

class loc__Command : public loc_t {
 public:
  loc__Command(command_t* c)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(loc_e::Command),
                      field_mask(), sizeof(loc__Command)),
        c(c) {
  }

  static loc__Command* Create() { 
    return Alloc<loc__Command>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  command_t* c;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(loc__Command, c));
  }

  DISALLOW_COPY_AND_ASSIGN(loc__Command)
};

ASDL_NAMES loc {
  typedef loc__Missing Missing;
  typedef loc__Span Span;
  typedef loc__WordPart WordPart;
  typedef loc__Word Word;
  typedef loc__Arith Arith;
  typedef loc__Command Command;
};

ASDL_NAMES bracket_op_e {
  enum no_name {
  WholeArray = 1,
  ArrayIndex = 2,
  };
};

const char* bracket_op_str(int tag);

class bracket_op_t {
 protected:
  bracket_op_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(bracket_op_t)
};

class bracket_op__WholeArray : public bracket_op_t {
 public:
  bracket_op__WholeArray(Id_t op_id)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(bracket_op_e::WholeArray),
                      kZeroMask, sizeof(bracket_op__WholeArray)),
        op_id(op_id) {
  }

  static bracket_op__WholeArray* Create() { 
    return Alloc<bracket_op__WholeArray>(-1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t op_id;

  DISALLOW_COPY_AND_ASSIGN(bracket_op__WholeArray)
};

class bracket_op__ArrayIndex : public bracket_op_t {
 public:
  bracket_op__ArrayIndex(arith_expr_t* expr)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(bracket_op_e::ArrayIndex),
                      field_mask(), sizeof(bracket_op__ArrayIndex)),
        expr(expr) {
  }

  static bracket_op__ArrayIndex* Create() { 
    return Alloc<bracket_op__ArrayIndex>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  arith_expr_t* expr;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(bracket_op__ArrayIndex, expr));
  }

  DISALLOW_COPY_AND_ASSIGN(bracket_op__ArrayIndex)
};

ASDL_NAMES bracket_op {
  typedef bracket_op__WholeArray WholeArray;
  typedef bracket_op__ArrayIndex ArrayIndex;
};

ASDL_NAMES suffix_op_e {
  enum no_name {
  Nullary = 66,
  Unary = 2,
  Static = 3,
  PatSub = 4,
  Slice = 5,
  };
};

const char* suffix_op_str(int tag);

class suffix_op_t {
 protected:
  suffix_op_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(suffix_op_t)
};

class suffix_op__Unary : public suffix_op_t {
 public:
  suffix_op__Unary(Token* op, rhs_word_t* arg_word)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(suffix_op_e::Unary),
                      field_mask(), sizeof(suffix_op__Unary)),
        op(op),
        arg_word(arg_word) {
  }

  static suffix_op__Unary* Create() { 
    return Alloc<suffix_op__Unary>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* op;
  rhs_word_t* arg_word;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(suffix_op__Unary, op))
         | maskbit(offsetof(suffix_op__Unary, arg_word));
  }

  DISALLOW_COPY_AND_ASSIGN(suffix_op__Unary)
};

class suffix_op__Static : public suffix_op_t {
 public:
  suffix_op__Static(Token* tok, Str* arg)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(suffix_op_e::Static),
                      field_mask(), sizeof(suffix_op__Static)),
        tok(tok),
        arg(arg) {
  }

  static suffix_op__Static* Create() { 
    return Alloc<suffix_op__Static>(nullptr, kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* tok;
  Str* arg;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(suffix_op__Static, tok))
         | maskbit(offsetof(suffix_op__Static, arg));
  }

  DISALLOW_COPY_AND_ASSIGN(suffix_op__Static)
};

class suffix_op__PatSub : public suffix_op_t {
 public:
  suffix_op__PatSub(compound_word* pat, rhs_word_t* replace, Id_t replace_mode,
                    Token* slash_tok)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(suffix_op_e::PatSub),
                      field_mask(), sizeof(suffix_op__PatSub)),
        pat(pat),
        replace(replace),
        replace_mode(replace_mode),
        slash_tok(slash_tok) {
  }

  static suffix_op__PatSub* Create() { 
    return Alloc<suffix_op__PatSub>(nullptr, nullptr, -1, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  compound_word* pat;
  rhs_word_t* replace;
  Id_t replace_mode;
  Token* slash_tok;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(suffix_op__PatSub, pat))
         | maskbit(offsetof(suffix_op__PatSub, replace))
         | maskbit(offsetof(suffix_op__PatSub, slash_tok));
  }

  DISALLOW_COPY_AND_ASSIGN(suffix_op__PatSub)
};

class suffix_op__Slice : public suffix_op_t {
 public:
  suffix_op__Slice(arith_expr_t* begin, arith_expr_t* length)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(suffix_op_e::Slice),
                      field_mask(), sizeof(suffix_op__Slice)),
        begin(begin),
        length(length) {
  }

  static suffix_op__Slice* Create() { 
    return Alloc<suffix_op__Slice>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  arith_expr_t* begin;
  arith_expr_t* length;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(suffix_op__Slice, begin))
         | maskbit(offsetof(suffix_op__Slice, length));
  }

  DISALLOW_COPY_AND_ASSIGN(suffix_op__Slice)
};

ASDL_NAMES suffix_op {
  typedef suffix_op__Unary Unary;
  typedef suffix_op__Static Static;
  typedef suffix_op__PatSub PatSub;
  typedef suffix_op__Slice Slice;
};

ASDL_NAMES word_part_e {
  enum no_name {
  ShArrayLiteral = 72,
  AssocArrayLiteral = 2,
  Literal = 66,
  EscapedLiteral = 4,
  SingleQuoted = 69,
  DoubleQuoted = 68,
  SimpleVarSub = 70,
  BracedVarSub = 67,
  CommandSub = 71,
  TildeSub = 10,
  ArithSub = 11,
  BracedTuple = 12,
  BracedRange = 13,
  ExtGlob = 14,
  Splice = 15,
  FuncCall = 16,
  ExprSub = 17,
  };
};

const char* word_part_str(int tag);

class word_part_t {
 protected:
  word_part_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(word_part_t)
};

class word_part__AssocArrayLiteral : public word_part_t {
 public:
  word_part__AssocArrayLiteral(Token* left, List<assoc_pair*>* pairs)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_part_e::AssocArrayLiteral),
                      field_mask(), sizeof(word_part__AssocArrayLiteral)),
        left(left),
        pairs(pairs),
        spids(Alloc<List<int>>()) {
  }

  static word_part__AssocArrayLiteral* Create() { 
    return Alloc<word_part__AssocArrayLiteral>(nullptr,
                                               Alloc<List<assoc_pair*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  List<assoc_pair*>* pairs;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word_part__AssocArrayLiteral, left))
         | maskbit(offsetof(word_part__AssocArrayLiteral, pairs))
         | maskbit(offsetof(word_part__AssocArrayLiteral, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(word_part__AssocArrayLiteral)
};

class word_part__EscapedLiteral : public word_part_t {
 public:
  word_part__EscapedLiteral(Token* token, Str* ch)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_part_e::EscapedLiteral),
                      field_mask(), sizeof(word_part__EscapedLiteral)),
        token(token),
        ch(ch),
        spids(Alloc<List<int>>()) {
  }

  static word_part__EscapedLiteral* Create() { 
    return Alloc<word_part__EscapedLiteral>(nullptr, kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* token;
  Str* ch;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word_part__EscapedLiteral, token))
         | maskbit(offsetof(word_part__EscapedLiteral, ch))
         | maskbit(offsetof(word_part__EscapedLiteral, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(word_part__EscapedLiteral)
};

class word_part__TildeSub : public word_part_t {
 public:
  word_part__TildeSub(Token* token, Str* user_name)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_part_e::TildeSub),
                      field_mask(), sizeof(word_part__TildeSub)),
        token(token),
        user_name(user_name),
        spids(Alloc<List<int>>()) {
  }

  static word_part__TildeSub* Create() { 
    return Alloc<word_part__TildeSub>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* token;
  Str* user_name;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word_part__TildeSub, token))
         | maskbit(offsetof(word_part__TildeSub, user_name))
         | maskbit(offsetof(word_part__TildeSub, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(word_part__TildeSub)
};

class word_part__ArithSub : public word_part_t {
 public:
  word_part__ArithSub(arith_expr_t* anode)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_part_e::ArithSub),
                      field_mask(), sizeof(word_part__ArithSub)),
        anode(anode),
        spids(Alloc<List<int>>()) {
  }

  static word_part__ArithSub* Create() { 
    return Alloc<word_part__ArithSub>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  arith_expr_t* anode;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word_part__ArithSub, anode))
         | maskbit(offsetof(word_part__ArithSub, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(word_part__ArithSub)
};

class word_part__BracedTuple : public word_part_t {
 public:
  word_part__BracedTuple(List<compound_word*>* words)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_part_e::BracedTuple),
                      field_mask(), sizeof(word_part__BracedTuple)),
        words(words),
        spids(Alloc<List<int>>()) {
  }

  static word_part__BracedTuple* Create() { 
    return Alloc<word_part__BracedTuple>(Alloc<List<compound_word*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<compound_word*>* words;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word_part__BracedTuple, words))
         | maskbit(offsetof(word_part__BracedTuple, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(word_part__BracedTuple)
};

class word_part__BracedRange : public word_part_t {
 public:
  word_part__BracedRange(Id_t kind, Str* start, Str* end, int step)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_part_e::BracedRange),
                      field_mask(), sizeof(word_part__BracedRange)),
        kind(kind),
        start(start),
        end(end),
        step(step),
        spids(Alloc<List<int>>()) {
  }

  static word_part__BracedRange* Create() { 
    return Alloc<word_part__BracedRange>(-1, kEmptyString, kEmptyString, -1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t kind;
  Str* start;
  Str* end;
  int step;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word_part__BracedRange, start))
         | maskbit(offsetof(word_part__BracedRange, end))
         | maskbit(offsetof(word_part__BracedRange, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(word_part__BracedRange)
};

class word_part__ExtGlob : public word_part_t {
 public:
  word_part__ExtGlob(Token* op, List<compound_word*>* arms)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_part_e::ExtGlob),
                      field_mask(), sizeof(word_part__ExtGlob)),
        op(op),
        arms(arms),
        spids(Alloc<List<int>>()) {
  }

  static word_part__ExtGlob* Create() { 
    return Alloc<word_part__ExtGlob>(nullptr, Alloc<List<compound_word*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* op;
  List<compound_word*>* arms;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word_part__ExtGlob, op))
         | maskbit(offsetof(word_part__ExtGlob, arms))
         | maskbit(offsetof(word_part__ExtGlob, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(word_part__ExtGlob)
};

class word_part__Splice : public word_part_t {
 public:
  word_part__Splice(Token* name, Str* var_name)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_part_e::Splice),
                      field_mask(), sizeof(word_part__Splice)),
        name(name),
        var_name(var_name),
        spids(Alloc<List<int>>()) {
  }

  static word_part__Splice* Create() { 
    return Alloc<word_part__Splice>(nullptr, kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  Str* var_name;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word_part__Splice, name))
         | maskbit(offsetof(word_part__Splice, var_name))
         | maskbit(offsetof(word_part__Splice, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(word_part__Splice)
};

class word_part__FuncCall : public word_part_t {
 public:
  word_part__FuncCall(Token* name, ArgList* args)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_part_e::FuncCall),
                      field_mask(), sizeof(word_part__FuncCall)),
        name(name),
        args(args),
        spids(Alloc<List<int>>()) {
  }

  static word_part__FuncCall* Create() { 
    return Alloc<word_part__FuncCall>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  ArgList* args;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word_part__FuncCall, name))
         | maskbit(offsetof(word_part__FuncCall, args))
         | maskbit(offsetof(word_part__FuncCall, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(word_part__FuncCall)
};

class word_part__ExprSub : public word_part_t {
 public:
  word_part__ExprSub(Token* left, expr_t* child)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_part_e::ExprSub),
                      field_mask(), sizeof(word_part__ExprSub)),
        left(left),
        child(child),
        spids(Alloc<List<int>>()) {
  }

  static word_part__ExprSub* Create() { 
    return Alloc<word_part__ExprSub>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  expr_t* child;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word_part__ExprSub, left))
         | maskbit(offsetof(word_part__ExprSub, child))
         | maskbit(offsetof(word_part__ExprSub, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(word_part__ExprSub)
};

ASDL_NAMES word_part {
  typedef word_part__AssocArrayLiteral AssocArrayLiteral;
  typedef word_part__EscapedLiteral EscapedLiteral;
  typedef word_part__TildeSub TildeSub;
  typedef word_part__ArithSub ArithSub;
  typedef word_part__BracedTuple BracedTuple;
  typedef word_part__BracedRange BracedRange;
  typedef word_part__ExtGlob ExtGlob;
  typedef word_part__Splice Splice;
  typedef word_part__FuncCall FuncCall;
  typedef word_part__ExprSub ExprSub;
};

ASDL_NAMES rhs_word_e {
  enum no_name {
  Empty = 1,
  Compound = 75,
  };
};

const char* rhs_word_str(int tag);

class rhs_word_t {
 protected:
  rhs_word_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(rhs_word_t)
};

class rhs_word__Empty : public rhs_word_t {
 public:
  rhs_word__Empty()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(rhs_word_e::Empty),
                      kZeroMask, sizeof(rhs_word__Empty)) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);

  DISALLOW_COPY_AND_ASSIGN(rhs_word__Empty)
};

ASDL_NAMES rhs_word {
  typedef rhs_word__Empty Empty;
};

ASDL_NAMES word_e {
  enum no_name {
  Token = 66,
  Compound = 75,
  BracedTree = 3,
  String = 4,
  };
};

const char* word_str(int tag);

class word_t {
 protected:
  word_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(word_t)
};

class word__BracedTree : public word_t {
 public:
  word__BracedTree(List<word_part_t*>* parts)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_e::BracedTree),
                      field_mask(), sizeof(word__BracedTree)),
        parts(parts) {
  }

  static word__BracedTree* Create() { 
    return Alloc<word__BracedTree>(Alloc<List<word_part_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<word_part_t*>* parts;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word__BracedTree, parts));
  }

  DISALLOW_COPY_AND_ASSIGN(word__BracedTree)
};

class word__String : public word_t {
 public:
  word__String(Id_t id, Str* s, int span_id)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(word_e::String),
                      field_mask(), sizeof(word__String)),
        id(id),
        s(s),
        span_id(span_id) {
  }

  static word__String* Create() { 
    return Alloc<word__String>(-1, kEmptyString, -1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t id;
  Str* s;
  int span_id;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(word__String, s));
  }

  DISALLOW_COPY_AND_ASSIGN(word__String)
};

ASDL_NAMES word {
  typedef word__BracedTree BracedTree;
  typedef word__String String;
};

ASDL_NAMES sh_lhs_expr_e {
  enum no_name {
  Name = 1,
  IndexedName = 2,
  UnparsedIndex = 3,
  };
};

const char* sh_lhs_expr_str(int tag);

class sh_lhs_expr_t {
 protected:
  sh_lhs_expr_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(sh_lhs_expr_t)
};

class sh_lhs_expr__Name : public sh_lhs_expr_t {
 public:
  sh_lhs_expr__Name(Token* left, Str* name)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(sh_lhs_expr_e::Name),
                      field_mask(), sizeof(sh_lhs_expr__Name)),
        left(left),
        name(name) {
  }

  static sh_lhs_expr__Name* Create() { 
    return Alloc<sh_lhs_expr__Name>(nullptr, kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  Str* name;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(sh_lhs_expr__Name, left))
         | maskbit(offsetof(sh_lhs_expr__Name, name));
  }

  DISALLOW_COPY_AND_ASSIGN(sh_lhs_expr__Name)
};

class sh_lhs_expr__IndexedName : public sh_lhs_expr_t {
 public:
  sh_lhs_expr__IndexedName(Token* left, Str* name, arith_expr_t* index)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(sh_lhs_expr_e::IndexedName),
                      field_mask(), sizeof(sh_lhs_expr__IndexedName)),
        left(left),
        name(name),
        index(index) {
  }

  static sh_lhs_expr__IndexedName* Create() { 
    return Alloc<sh_lhs_expr__IndexedName>(nullptr, kEmptyString, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  Str* name;
  arith_expr_t* index;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(sh_lhs_expr__IndexedName, left))
         | maskbit(offsetof(sh_lhs_expr__IndexedName, name))
         | maskbit(offsetof(sh_lhs_expr__IndexedName, index));
  }

  DISALLOW_COPY_AND_ASSIGN(sh_lhs_expr__IndexedName)
};

class sh_lhs_expr__UnparsedIndex : public sh_lhs_expr_t {
 public:
  sh_lhs_expr__UnparsedIndex(Token* left, Str* name, Str* index)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(sh_lhs_expr_e::UnparsedIndex),
                      field_mask(), sizeof(sh_lhs_expr__UnparsedIndex)),
        left(left),
        name(name),
        index(index) {
  }

  static sh_lhs_expr__UnparsedIndex* Create() { 
    return Alloc<sh_lhs_expr__UnparsedIndex>(nullptr, kEmptyString,
                                             kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  Str* name;
  Str* index;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(sh_lhs_expr__UnparsedIndex, left))
         | maskbit(offsetof(sh_lhs_expr__UnparsedIndex, name))
         | maskbit(offsetof(sh_lhs_expr__UnparsedIndex, index));
  }

  DISALLOW_COPY_AND_ASSIGN(sh_lhs_expr__UnparsedIndex)
};

ASDL_NAMES sh_lhs_expr {
  typedef sh_lhs_expr__Name Name;
  typedef sh_lhs_expr__IndexedName IndexedName;
  typedef sh_lhs_expr__UnparsedIndex UnparsedIndex;
};

ASDL_NAMES arith_expr_e {
  enum no_name {
  VarSub = 70,
  Word = 75,
  UnaryAssign = 3,
  BinaryAssign = 4,
  Unary = 5,
  Binary = 6,
  TernaryOp = 7,
  };
};

const char* arith_expr_str(int tag);

class arith_expr_t {
 protected:
  arith_expr_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(arith_expr_t)
};

class arith_expr__UnaryAssign : public arith_expr_t {
 public:
  arith_expr__UnaryAssign(Id_t op_id, arith_expr_t* child)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(arith_expr_e::UnaryAssign),
                      field_mask(), sizeof(arith_expr__UnaryAssign)),
        op_id(op_id),
        child(child) {
  }

  static arith_expr__UnaryAssign* Create() { 
    return Alloc<arith_expr__UnaryAssign>(-1, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t op_id;
  arith_expr_t* child;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(arith_expr__UnaryAssign, child));
  }

  DISALLOW_COPY_AND_ASSIGN(arith_expr__UnaryAssign)
};

class arith_expr__BinaryAssign : public arith_expr_t {
 public:
  arith_expr__BinaryAssign(Id_t op_id, arith_expr_t* left, arith_expr_t* right)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(arith_expr_e::BinaryAssign),
                      field_mask(), sizeof(arith_expr__BinaryAssign)),
        op_id(op_id),
        left(left),
        right(right) {
  }

  static arith_expr__BinaryAssign* Create() { 
    return Alloc<arith_expr__BinaryAssign>(-1, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t op_id;
  arith_expr_t* left;
  arith_expr_t* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(arith_expr__BinaryAssign, left))
         | maskbit(offsetof(arith_expr__BinaryAssign, right));
  }

  DISALLOW_COPY_AND_ASSIGN(arith_expr__BinaryAssign)
};

class arith_expr__Unary : public arith_expr_t {
 public:
  arith_expr__Unary(Id_t op_id, arith_expr_t* child)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(arith_expr_e::Unary),
                      field_mask(), sizeof(arith_expr__Unary)),
        op_id(op_id),
        child(child) {
  }

  static arith_expr__Unary* Create() { 
    return Alloc<arith_expr__Unary>(-1, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t op_id;
  arith_expr_t* child;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(arith_expr__Unary, child));
  }

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Unary)
};

class arith_expr__Binary : public arith_expr_t {
 public:
  arith_expr__Binary(Id_t op_id, arith_expr_t* left, arith_expr_t* right)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(arith_expr_e::Binary),
                      field_mask(), sizeof(arith_expr__Binary)),
        op_id(op_id),
        left(left),
        right(right) {
  }

  static arith_expr__Binary* Create() { 
    return Alloc<arith_expr__Binary>(-1, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t op_id;
  arith_expr_t* left;
  arith_expr_t* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(arith_expr__Binary, left))
         | maskbit(offsetof(arith_expr__Binary, right));
  }

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Binary)
};

class arith_expr__TernaryOp : public arith_expr_t {
 public:
  arith_expr__TernaryOp(arith_expr_t* cond, arith_expr_t* true_expr,
                        arith_expr_t* false_expr)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(arith_expr_e::TernaryOp),
                      field_mask(), sizeof(arith_expr__TernaryOp)),
        cond(cond),
        true_expr(true_expr),
        false_expr(false_expr) {
  }

  static arith_expr__TernaryOp* Create() { 
    return Alloc<arith_expr__TernaryOp>(nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  arith_expr_t* cond;
  arith_expr_t* true_expr;
  arith_expr_t* false_expr;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(arith_expr__TernaryOp, cond))
         | maskbit(offsetof(arith_expr__TernaryOp, true_expr))
         | maskbit(offsetof(arith_expr__TernaryOp, false_expr));
  }

  DISALLOW_COPY_AND_ASSIGN(arith_expr__TernaryOp)
};

ASDL_NAMES arith_expr {
  typedef arith_expr__UnaryAssign UnaryAssign;
  typedef arith_expr__BinaryAssign BinaryAssign;
  typedef arith_expr__Unary Unary;
  typedef arith_expr__Binary Binary;
  typedef arith_expr__TernaryOp TernaryOp;
};

ASDL_NAMES bool_expr_e {
  enum no_name {
  WordTest = 1,
  Binary = 2,
  Unary = 3,
  LogicalNot = 4,
  LogicalAnd = 5,
  LogicalOr = 6,
  };
};

const char* bool_expr_str(int tag);

class bool_expr_t {
 protected:
  bool_expr_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(bool_expr_t)
};

class bool_expr__WordTest : public bool_expr_t {
 public:
  bool_expr__WordTest(word_t* w)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(bool_expr_e::WordTest),
                      field_mask(), sizeof(bool_expr__WordTest)),
        w(w) {
  }

  static bool_expr__WordTest* Create() { 
    return Alloc<bool_expr__WordTest>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  word_t* w;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(bool_expr__WordTest, w));
  }

  DISALLOW_COPY_AND_ASSIGN(bool_expr__WordTest)
};

class bool_expr__Binary : public bool_expr_t {
 public:
  bool_expr__Binary(Id_t op_id, word_t* left, word_t* right)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(bool_expr_e::Binary),
                      field_mask(), sizeof(bool_expr__Binary)),
        op_id(op_id),
        left(left),
        right(right) {
  }

  static bool_expr__Binary* Create() { 
    return Alloc<bool_expr__Binary>(-1, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t op_id;
  word_t* left;
  word_t* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(bool_expr__Binary, left))
         | maskbit(offsetof(bool_expr__Binary, right));
  }

  DISALLOW_COPY_AND_ASSIGN(bool_expr__Binary)
};

class bool_expr__Unary : public bool_expr_t {
 public:
  bool_expr__Unary(Id_t op_id, word_t* child)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(bool_expr_e::Unary),
                      field_mask(), sizeof(bool_expr__Unary)),
        op_id(op_id),
        child(child) {
  }

  static bool_expr__Unary* Create() { 
    return Alloc<bool_expr__Unary>(-1, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t op_id;
  word_t* child;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(bool_expr__Unary, child));
  }

  DISALLOW_COPY_AND_ASSIGN(bool_expr__Unary)
};

class bool_expr__LogicalNot : public bool_expr_t {
 public:
  bool_expr__LogicalNot(bool_expr_t* child)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(bool_expr_e::LogicalNot),
                      field_mask(), sizeof(bool_expr__LogicalNot)),
        child(child) {
  }

  static bool_expr__LogicalNot* Create() { 
    return Alloc<bool_expr__LogicalNot>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  bool_expr_t* child;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(bool_expr__LogicalNot, child));
  }

  DISALLOW_COPY_AND_ASSIGN(bool_expr__LogicalNot)
};

class bool_expr__LogicalAnd : public bool_expr_t {
 public:
  bool_expr__LogicalAnd(bool_expr_t* left, bool_expr_t* right)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(bool_expr_e::LogicalAnd),
                      field_mask(), sizeof(bool_expr__LogicalAnd)),
        left(left),
        right(right) {
  }

  static bool_expr__LogicalAnd* Create() { 
    return Alloc<bool_expr__LogicalAnd>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  bool_expr_t* left;
  bool_expr_t* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(bool_expr__LogicalAnd, left))
         | maskbit(offsetof(bool_expr__LogicalAnd, right));
  }

  DISALLOW_COPY_AND_ASSIGN(bool_expr__LogicalAnd)
};

class bool_expr__LogicalOr : public bool_expr_t {
 public:
  bool_expr__LogicalOr(bool_expr_t* left, bool_expr_t* right)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(bool_expr_e::LogicalOr),
                      field_mask(), sizeof(bool_expr__LogicalOr)),
        left(left),
        right(right) {
  }

  static bool_expr__LogicalOr* Create() { 
    return Alloc<bool_expr__LogicalOr>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  bool_expr_t* left;
  bool_expr_t* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(bool_expr__LogicalOr, left))
         | maskbit(offsetof(bool_expr__LogicalOr, right));
  }

  DISALLOW_COPY_AND_ASSIGN(bool_expr__LogicalOr)
};

ASDL_NAMES bool_expr {
  typedef bool_expr__WordTest WordTest;
  typedef bool_expr__Binary Binary;
  typedef bool_expr__Unary Unary;
  typedef bool_expr__LogicalNot LogicalNot;
  typedef bool_expr__LogicalAnd LogicalAnd;
  typedef bool_expr__LogicalOr LogicalOr;
};

ASDL_NAMES redir_loc_e {
  enum no_name {
  Fd = 1,
  VarName = 2,
  };
};

const char* redir_loc_str(int tag);

class redir_loc_t {
 protected:
  redir_loc_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(redir_loc_t)
};

class redir_loc__Fd : public redir_loc_t {
 public:
  redir_loc__Fd(int fd)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(redir_loc_e::Fd),
                      kZeroMask, sizeof(redir_loc__Fd)),
        fd(fd) {
  }

  static redir_loc__Fd* Create() { 
    return Alloc<redir_loc__Fd>(-1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  int fd;

  DISALLOW_COPY_AND_ASSIGN(redir_loc__Fd)
};

class redir_loc__VarName : public redir_loc_t {
 public:
  redir_loc__VarName(Str* name)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(redir_loc_e::VarName),
                      field_mask(), sizeof(redir_loc__VarName)),
        name(name) {
  }

  static redir_loc__VarName* Create() { 
    return Alloc<redir_loc__VarName>(kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* name;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(redir_loc__VarName, name));
  }

  DISALLOW_COPY_AND_ASSIGN(redir_loc__VarName)
};

ASDL_NAMES redir_loc {
  typedef redir_loc__Fd Fd;
  typedef redir_loc__VarName VarName;
};

ASDL_NAMES redir_param_e {
  enum no_name {
  Word = 75,
  HereDoc = 2,
  };
};

const char* redir_param_str(int tag);

class redir_param_t {
 protected:
  redir_param_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(redir_param_t)
};

class redir_param__HereDoc : public redir_param_t {
 public:
  redir_param__HereDoc(word_t* here_begin, int here_end_span_id,
                       List<word_part_t*>* stdin_parts)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(redir_param_e::HereDoc),
                      field_mask(), sizeof(redir_param__HereDoc)),
        here_begin(here_begin),
        here_end_span_id(here_end_span_id),
        stdin_parts(stdin_parts) {
  }

  static redir_param__HereDoc* Create() { 
    return Alloc<redir_param__HereDoc>(nullptr, -1,
                                       Alloc<List<word_part_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  word_t* here_begin;
  int here_end_span_id;
  List<word_part_t*>* stdin_parts;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(redir_param__HereDoc, here_begin))
         | maskbit(offsetof(redir_param__HereDoc, stdin_parts));
  }

  DISALLOW_COPY_AND_ASSIGN(redir_param__HereDoc)
};

ASDL_NAMES redir_param {
  typedef redir_param__HereDoc HereDoc;
};

enum class assign_op_e {
  Equal = 1,
  PlusEqual = 2,
};
typedef assign_op_e assign_op_t;

const char* assign_op_str(assign_op_e tag);

ASDL_NAMES condition_e {
  enum no_name {
  Shell = 1,
  Oil = 2,
  };
};

const char* condition_str(int tag);

class condition_t {
 protected:
  condition_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(condition_t)
};

class condition__Shell : public condition_t {
 public:
  condition__Shell(List<command_t*>* commands)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(condition_e::Shell),
                      field_mask(), sizeof(condition__Shell)),
        commands(commands) {
  }

  static condition__Shell* Create() { 
    return Alloc<condition__Shell>(Alloc<List<command_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<command_t*>* commands;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(condition__Shell, commands));
  }

  DISALLOW_COPY_AND_ASSIGN(condition__Shell)
};

class condition__Oil : public condition_t {
 public:
  condition__Oil(expr_t* e)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(condition_e::Oil),
                      field_mask(), sizeof(condition__Oil)),
        e(e) {
  }

  static condition__Oil* Create() { 
    return Alloc<condition__Oil>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* e;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(condition__Oil, e));
  }

  DISALLOW_COPY_AND_ASSIGN(condition__Oil)
};

ASDL_NAMES condition {
  typedef condition__Shell Shell;
  typedef condition__Oil Oil;
};

ASDL_NAMES for_iter_e {
  enum no_name {
  Args = 1,
  Words = 2,
  Oil = 3,
  };
};

const char* for_iter_str(int tag);

class for_iter_t {
 protected:
  for_iter_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(for_iter_t)
};

class for_iter__Args : public for_iter_t {
 public:
  for_iter__Args()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(for_iter_e::Args),
                      kZeroMask, sizeof(for_iter__Args)) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);

  DISALLOW_COPY_AND_ASSIGN(for_iter__Args)
};

class for_iter__Words : public for_iter_t {
 public:
  for_iter__Words(List<word_t*>* words)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(for_iter_e::Words),
                      field_mask(), sizeof(for_iter__Words)),
        words(words) {
  }

  static for_iter__Words* Create() { 
    return Alloc<for_iter__Words>(Alloc<List<word_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<word_t*>* words;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(for_iter__Words, words));
  }

  DISALLOW_COPY_AND_ASSIGN(for_iter__Words)
};

class for_iter__Oil : public for_iter_t {
 public:
  for_iter__Oil(expr_t* e, Token* blame)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(for_iter_e::Oil),
                      field_mask(), sizeof(for_iter__Oil)),
        e(e),
        blame(blame) {
  }

  static for_iter__Oil* Create() { 
    return Alloc<for_iter__Oil>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* e;
  Token* blame;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(for_iter__Oil, e))
         | maskbit(offsetof(for_iter__Oil, blame));
  }

  DISALLOW_COPY_AND_ASSIGN(for_iter__Oil)
};

ASDL_NAMES for_iter {
  typedef for_iter__Args Args;
  typedef for_iter__Words Words;
  typedef for_iter__Oil Oil;
};

ASDL_NAMES command_e {
  enum no_name {
  NoOp = 1,
  Simple = 2,
  ExpandedAlias = 3,
  Sentence = 4,
  ShAssignment = 5,
  ControlFlow = 6,
  Pipeline = 7,
  AndOr = 8,
  DoGroup = 9,
  BraceGroup = 83,
  Subshell = 11,
  DParen = 12,
  DBracket = 13,
  ForEach = 14,
  ForExpr = 15,
  WhileUntil = 16,
  If = 17,
  Case = 18,
  ShFunction = 19,
  TimeBlock = 20,
  CommandList = 21,
  BareDecl = 22,
  VarDecl = 23,
  PlaceMutation = 24,
  Expr = 25,
  Proc = 26,
  Func = 27,
  Data = 28,
  Enum = 29,
  Class = 30,
  Import = 31,
  For = 32,
  While = 33,
  Break = 34,
  Continue = 35,
  Return = 36,
  };
};

const char* command_str(int tag);

class command_t {
 protected:
  command_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(command_t)
};

class command__NoOp : public command_t {
 public:
  command__NoOp()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::NoOp),
                      field_mask(), sizeof(command__NoOp)),
        spids(Alloc<List<int>>()) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__NoOp, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__NoOp)
};

class command__Simple : public command_t {
 public:
  command__Simple(List<word_t*>* words, List<redir*>* redirects,
                  List<env_pair*>* more_env, ArgList* typed_args, BlockArg*
                  block, bool do_fork)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Simple),
                      field_mask(), sizeof(command__Simple)),
        words(words),
        redirects(redirects),
        more_env(more_env),
        typed_args(typed_args),
        block(block),
        do_fork(do_fork),
        spids(Alloc<List<int>>()) {
  }

  static command__Simple* Create() { 
    return Alloc<command__Simple>(Alloc<List<word_t*>>(),
                                  Alloc<List<redir*>>(),
                                  Alloc<List<env_pair*>>(), nullptr, nullptr,
                                  false);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<word_t*>* words;
  List<redir*>* redirects;
  List<env_pair*>* more_env;
  ArgList* typed_args;
  BlockArg* block;
  bool do_fork;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Simple, words))
         | maskbit(offsetof(command__Simple, redirects))
         | maskbit(offsetof(command__Simple, more_env))
         | maskbit(offsetof(command__Simple, typed_args))
         | maskbit(offsetof(command__Simple, block))
         | maskbit(offsetof(command__Simple, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Simple)
};

class command__ExpandedAlias : public command_t {
 public:
  command__ExpandedAlias(command_t* child, List<redir*>* redirects,
                         List<env_pair*>* more_env)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::ExpandedAlias),
                      field_mask(), sizeof(command__ExpandedAlias)),
        child(child),
        redirects(redirects),
        more_env(more_env),
        spids(Alloc<List<int>>()) {
  }

  static command__ExpandedAlias* Create() { 
    return Alloc<command__ExpandedAlias>(nullptr, Alloc<List<redir*>>(),
                                         Alloc<List<env_pair*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  command_t* child;
  List<redir*>* redirects;
  List<env_pair*>* more_env;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__ExpandedAlias, child))
         | maskbit(offsetof(command__ExpandedAlias, redirects))
         | maskbit(offsetof(command__ExpandedAlias, more_env))
         | maskbit(offsetof(command__ExpandedAlias, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__ExpandedAlias)
};

class command__Sentence : public command_t {
 public:
  command__Sentence(command_t* child, Token* terminator)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Sentence),
                      field_mask(), sizeof(command__Sentence)),
        child(child),
        terminator(terminator),
        spids(Alloc<List<int>>()) {
  }

  static command__Sentence* Create() { 
    return Alloc<command__Sentence>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  command_t* child;
  Token* terminator;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Sentence, child))
         | maskbit(offsetof(command__Sentence, terminator))
         | maskbit(offsetof(command__Sentence, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Sentence)
};

class command__ShAssignment : public command_t {
 public:
  command__ShAssignment(List<assign_pair*>* pairs, List<redir*>* redirects)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::ShAssignment),
                      field_mask(), sizeof(command__ShAssignment)),
        pairs(pairs),
        redirects(redirects),
        spids(Alloc<List<int>>()) {
  }

  static command__ShAssignment* Create() { 
    return Alloc<command__ShAssignment>(Alloc<List<assign_pair*>>(),
                                        Alloc<List<redir*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<assign_pair*>* pairs;
  List<redir*>* redirects;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__ShAssignment, pairs))
         | maskbit(offsetof(command__ShAssignment, redirects))
         | maskbit(offsetof(command__ShAssignment, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__ShAssignment)
};

class command__ControlFlow : public command_t {
 public:
  command__ControlFlow(Token* token, word_t* arg_word)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::ControlFlow),
                      field_mask(), sizeof(command__ControlFlow)),
        token(token),
        arg_word(arg_word),
        spids(Alloc<List<int>>()) {
  }

  static command__ControlFlow* Create() { 
    return Alloc<command__ControlFlow>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* token;
  word_t* arg_word;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__ControlFlow, token))
         | maskbit(offsetof(command__ControlFlow, arg_word))
         | maskbit(offsetof(command__ControlFlow, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__ControlFlow)
};

class command__Pipeline : public command_t {
 public:
  command__Pipeline(List<command_t*>* children, bool negated, List<int>*
                    stderr_indices)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Pipeline),
                      field_mask(), sizeof(command__Pipeline)),
        children(children),
        negated(negated),
        stderr_indices(stderr_indices),
        spids(Alloc<List<int>>()) {
  }

  static command__Pipeline* Create() { 
    return Alloc<command__Pipeline>(Alloc<List<command_t*>>(), false,
                                    Alloc<List<int>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<command_t*>* children;
  bool negated;
  List<int>* stderr_indices;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Pipeline, children))
         | maskbit(offsetof(command__Pipeline, stderr_indices))
         | maskbit(offsetof(command__Pipeline, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Pipeline)
};

class command__AndOr : public command_t {
 public:
  command__AndOr(List<Id_t>* ops, List<command_t*>* children)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::AndOr),
                      field_mask(), sizeof(command__AndOr)),
        ops(ops),
        children(children),
        spids(Alloc<List<int>>()) {
  }

  static command__AndOr* Create() { 
    return Alloc<command__AndOr>(Alloc<List<Id_t>>(),
                                 Alloc<List<command_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<Id_t>* ops;
  List<command_t*>* children;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__AndOr, ops))
         | maskbit(offsetof(command__AndOr, children))
         | maskbit(offsetof(command__AndOr, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__AndOr)
};

class command__DoGroup : public command_t {
 public:
  command__DoGroup(List<command_t*>* children)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::DoGroup),
                      field_mask(), sizeof(command__DoGroup)),
        children(children),
        spids(Alloc<List<int>>()) {
  }

  static command__DoGroup* Create() { 
    return Alloc<command__DoGroup>(Alloc<List<command_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<command_t*>* children;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__DoGroup, children))
         | maskbit(offsetof(command__DoGroup, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__DoGroup)
};

class command__Subshell : public command_t {
 public:
  command__Subshell(command_t* child, List<redir*>* redirects)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Subshell),
                      field_mask(), sizeof(command__Subshell)),
        child(child),
        redirects(redirects),
        spids(Alloc<List<int>>()) {
  }

  static command__Subshell* Create() { 
    return Alloc<command__Subshell>(nullptr, Alloc<List<redir*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  command_t* child;
  List<redir*>* redirects;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Subshell, child))
         | maskbit(offsetof(command__Subshell, redirects))
         | maskbit(offsetof(command__Subshell, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Subshell)
};

class command__DParen : public command_t {
 public:
  command__DParen(arith_expr_t* child, List<redir*>* redirects)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::DParen),
                      field_mask(), sizeof(command__DParen)),
        child(child),
        redirects(redirects),
        spids(Alloc<List<int>>()) {
  }

  static command__DParen* Create() { 
    return Alloc<command__DParen>(nullptr, Alloc<List<redir*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  arith_expr_t* child;
  List<redir*>* redirects;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__DParen, child))
         | maskbit(offsetof(command__DParen, redirects))
         | maskbit(offsetof(command__DParen, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__DParen)
};

class command__DBracket : public command_t {
 public:
  command__DBracket(bool_expr_t* expr, List<redir*>* redirects)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::DBracket),
                      field_mask(), sizeof(command__DBracket)),
        expr(expr),
        redirects(redirects),
        spids(Alloc<List<int>>()) {
  }

  static command__DBracket* Create() { 
    return Alloc<command__DBracket>(nullptr, Alloc<List<redir*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  bool_expr_t* expr;
  List<redir*>* redirects;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__DBracket, expr))
         | maskbit(offsetof(command__DBracket, redirects))
         | maskbit(offsetof(command__DBracket, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__DBracket)
};

class command__ForEach : public command_t {
 public:
  command__ForEach(List<Str*>* iter_names, for_iter_t* iterable, command_t*
                   body, List<redir*>* redirects)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::ForEach),
                      field_mask(), sizeof(command__ForEach)),
        iter_names(iter_names),
        iterable(iterable),
        body(body),
        redirects(redirects),
        spids(Alloc<List<int>>()) {
  }

  static command__ForEach* Create() { 
    return Alloc<command__ForEach>(Alloc<List<Str*>>(), nullptr, nullptr,
                                   Alloc<List<redir*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<Str*>* iter_names;
  for_iter_t* iterable;
  command_t* body;
  List<redir*>* redirects;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__ForEach, iter_names))
         | maskbit(offsetof(command__ForEach, iterable))
         | maskbit(offsetof(command__ForEach, body))
         | maskbit(offsetof(command__ForEach, redirects))
         | maskbit(offsetof(command__ForEach, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__ForEach)
};

class command__ForExpr : public command_t {
 public:
  command__ForExpr(arith_expr_t* init, arith_expr_t* cond, arith_expr_t*
                   update, command_t* body, List<redir*>* redirects)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::ForExpr),
                      field_mask(), sizeof(command__ForExpr)),
        init(init),
        cond(cond),
        update(update),
        body(body),
        redirects(redirects),
        spids(Alloc<List<int>>()) {
  }

  static command__ForExpr* Create() { 
    return Alloc<command__ForExpr>(nullptr, nullptr, nullptr, nullptr,
                                   Alloc<List<redir*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  arith_expr_t* init;
  arith_expr_t* cond;
  arith_expr_t* update;
  command_t* body;
  List<redir*>* redirects;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__ForExpr, init))
         | maskbit(offsetof(command__ForExpr, cond))
         | maskbit(offsetof(command__ForExpr, update))
         | maskbit(offsetof(command__ForExpr, body))
         | maskbit(offsetof(command__ForExpr, redirects))
         | maskbit(offsetof(command__ForExpr, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__ForExpr)
};

class command__WhileUntil : public command_t {
 public:
  command__WhileUntil(Token* keyword, condition_t* cond, command_t* body,
                      List<redir*>* redirects)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::WhileUntil),
                      field_mask(), sizeof(command__WhileUntil)),
        keyword(keyword),
        cond(cond),
        body(body),
        redirects(redirects),
        spids(Alloc<List<int>>()) {
  }

  static command__WhileUntil* Create() { 
    return Alloc<command__WhileUntil>(nullptr, nullptr, nullptr,
                                      Alloc<List<redir*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* keyword;
  condition_t* cond;
  command_t* body;
  List<redir*>* redirects;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__WhileUntil, keyword))
         | maskbit(offsetof(command__WhileUntil, cond))
         | maskbit(offsetof(command__WhileUntil, body))
         | maskbit(offsetof(command__WhileUntil, redirects))
         | maskbit(offsetof(command__WhileUntil, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__WhileUntil)
};

class command__If : public command_t {
 public:
  command__If(List<if_arm*>* arms, List<command_t*>* else_action, List<redir*>*
              redirects)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::If),
                      field_mask(), sizeof(command__If)),
        arms(arms),
        else_action(else_action),
        redirects(redirects),
        spids(Alloc<List<int>>()) {
  }

  static command__If* Create() { 
    return Alloc<command__If>(Alloc<List<if_arm*>>(),
                              Alloc<List<command_t*>>(), Alloc<List<redir*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<if_arm*>* arms;
  List<command_t*>* else_action;
  List<redir*>* redirects;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__If, arms))
         | maskbit(offsetof(command__If, else_action))
         | maskbit(offsetof(command__If, redirects))
         | maskbit(offsetof(command__If, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__If)
};

class command__Case : public command_t {
 public:
  command__Case(word_t* to_match, List<case_arm*>* arms, List<redir*>*
                redirects)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Case),
                      field_mask(), sizeof(command__Case)),
        to_match(to_match),
        arms(arms),
        redirects(redirects),
        spids(Alloc<List<int>>()) {
  }

  static command__Case* Create() { 
    return Alloc<command__Case>(nullptr, Alloc<List<case_arm*>>(),
                                Alloc<List<redir*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  word_t* to_match;
  List<case_arm*>* arms;
  List<redir*>* redirects;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Case, to_match))
         | maskbit(offsetof(command__Case, arms))
         | maskbit(offsetof(command__Case, redirects))
         | maskbit(offsetof(command__Case, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Case)
};

class command__ShFunction : public command_t {
 public:
  command__ShFunction(Str* name, command_t* body)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::ShFunction),
                      field_mask(), sizeof(command__ShFunction)),
        name(name),
        body(body),
        spids(Alloc<List<int>>()) {
  }

  static command__ShFunction* Create() { 
    return Alloc<command__ShFunction>(kEmptyString, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* name;
  command_t* body;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__ShFunction, name))
         | maskbit(offsetof(command__ShFunction, body))
         | maskbit(offsetof(command__ShFunction, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__ShFunction)
};

class command__TimeBlock : public command_t {
 public:
  command__TimeBlock(command_t* pipeline)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::TimeBlock),
                      field_mask(), sizeof(command__TimeBlock)),
        pipeline(pipeline),
        spids(Alloc<List<int>>()) {
  }

  static command__TimeBlock* Create() { 
    return Alloc<command__TimeBlock>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  command_t* pipeline;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__TimeBlock, pipeline))
         | maskbit(offsetof(command__TimeBlock, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__TimeBlock)
};

class command__CommandList : public command_t {
 public:
  command__CommandList(List<command_t*>* children)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::CommandList),
                      field_mask(), sizeof(command__CommandList)),
        children(children),
        spids(Alloc<List<int>>()) {
  }

  static command__CommandList* Create() { 
    return Alloc<command__CommandList>(Alloc<List<command_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<command_t*>* children;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__CommandList, children))
         | maskbit(offsetof(command__CommandList, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__CommandList)
};

class command__BareDecl : public command_t {
 public:
  command__BareDecl(Token* lhs, expr_t* rhs)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::BareDecl),
                      field_mask(), sizeof(command__BareDecl)),
        lhs(lhs),
        rhs(rhs),
        spids(Alloc<List<int>>()) {
  }

  static command__BareDecl* Create() { 
    return Alloc<command__BareDecl>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* lhs;
  expr_t* rhs;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__BareDecl, lhs))
         | maskbit(offsetof(command__BareDecl, rhs))
         | maskbit(offsetof(command__BareDecl, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__BareDecl)
};

class command__VarDecl : public command_t {
 public:
  command__VarDecl(Token* keyword, List<name_type*>* lhs, expr_t* rhs)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::VarDecl),
                      field_mask(), sizeof(command__VarDecl)),
        keyword(keyword),
        lhs(lhs),
        rhs(rhs),
        spids(Alloc<List<int>>()) {
  }

  static command__VarDecl* Create() { 
    return Alloc<command__VarDecl>(nullptr, Alloc<List<name_type*>>(), nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* keyword;
  List<name_type*>* lhs;
  expr_t* rhs;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__VarDecl, keyword))
         | maskbit(offsetof(command__VarDecl, lhs))
         | maskbit(offsetof(command__VarDecl, rhs))
         | maskbit(offsetof(command__VarDecl, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__VarDecl)
};

class command__PlaceMutation : public command_t {
 public:
  command__PlaceMutation(Token* keyword, List<place_expr_t*>* lhs, Token* op,
                         expr_t* rhs)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::PlaceMutation),
                      field_mask(), sizeof(command__PlaceMutation)),
        keyword(keyword),
        lhs(lhs),
        op(op),
        rhs(rhs),
        spids(Alloc<List<int>>()) {
  }

  static command__PlaceMutation* Create() { 
    return Alloc<command__PlaceMutation>(nullptr, Alloc<List<place_expr_t*>>(),
                                         nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* keyword;
  List<place_expr_t*>* lhs;
  Token* op;
  expr_t* rhs;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__PlaceMutation, keyword))
         | maskbit(offsetof(command__PlaceMutation, lhs))
         | maskbit(offsetof(command__PlaceMutation, op))
         | maskbit(offsetof(command__PlaceMutation, rhs))
         | maskbit(offsetof(command__PlaceMutation, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__PlaceMutation)
};

class command__Expr : public command_t {
 public:
  command__Expr(Token* keyword, expr_t* e)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Expr),
                      field_mask(), sizeof(command__Expr)),
        keyword(keyword),
        e(e),
        spids(Alloc<List<int>>()) {
  }

  static command__Expr* Create() { 
    return Alloc<command__Expr>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* keyword;
  expr_t* e;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Expr, keyword))
         | maskbit(offsetof(command__Expr, e))
         | maskbit(offsetof(command__Expr, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Expr)
};

class command__Proc : public command_t {
 public:
  command__Proc(Token* name, proc_sig_t* sig, command_t* body)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Proc),
                      field_mask(), sizeof(command__Proc)),
        name(name),
        sig(sig),
        body(body),
        spids(Alloc<List<int>>()) {
  }

  static command__Proc* Create() { 
    return Alloc<command__Proc>(nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  proc_sig_t* sig;
  command_t* body;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Proc, name))
         | maskbit(offsetof(command__Proc, sig))
         | maskbit(offsetof(command__Proc, body))
         | maskbit(offsetof(command__Proc, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Proc)
};

class command__Func : public command_t {
 public:
  command__Func(Token* name, List<param*>* pos_params, Token* pos_splat,
                List<param*>* named_params, Token* named_splat,
                List<type_expr_t*>* return_types, command_t* body)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Func),
                      field_mask(), sizeof(command__Func)),
        name(name),
        pos_params(pos_params),
        pos_splat(pos_splat),
        named_params(named_params),
        named_splat(named_splat),
        return_types(return_types),
        body(body),
        spids(Alloc<List<int>>()) {
  }

  static command__Func* Create() { 
    return Alloc<command__Func>(nullptr, Alloc<List<param*>>(), nullptr,
                                Alloc<List<param*>>(), nullptr,
                                Alloc<List<type_expr_t*>>(), nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  List<param*>* pos_params;
  Token* pos_splat;
  List<param*>* named_params;
  Token* named_splat;
  List<type_expr_t*>* return_types;
  command_t* body;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Func, name))
         | maskbit(offsetof(command__Func, pos_params))
         | maskbit(offsetof(command__Func, pos_splat))
         | maskbit(offsetof(command__Func, named_params))
         | maskbit(offsetof(command__Func, named_splat))
         | maskbit(offsetof(command__Func, return_types))
         | maskbit(offsetof(command__Func, body))
         | maskbit(offsetof(command__Func, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Func)
};

class command__Data : public command_t {
 public:
  command__Data(Token* name, List<param*>* params)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Data),
                      field_mask(), sizeof(command__Data)),
        name(name),
        params(params),
        spids(Alloc<List<int>>()) {
  }

  static command__Data* Create() { 
    return Alloc<command__Data>(nullptr, Alloc<List<param*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  List<param*>* params;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Data, name))
         | maskbit(offsetof(command__Data, params))
         | maskbit(offsetof(command__Data, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Data)
};

class command__Enum : public command_t {
 public:
  command__Enum(Token* name, List<variant*>* variants)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Enum),
                      field_mask(), sizeof(command__Enum)),
        name(name),
        variants(variants),
        spids(Alloc<List<int>>()) {
  }

  static command__Enum* Create() { 
    return Alloc<command__Enum>(nullptr, Alloc<List<variant*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  List<variant*>* variants;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Enum, name))
         | maskbit(offsetof(command__Enum, variants))
         | maskbit(offsetof(command__Enum, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Enum)
};

class command__Class : public command_t {
 public:
  command__Class(Token* name, Token* extends, List<class_item_t*>* items)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Class),
                      field_mask(), sizeof(command__Class)),
        name(name),
        extends(extends),
        items(items),
        spids(Alloc<List<int>>()) {
  }

  static command__Class* Create() { 
    return Alloc<command__Class>(nullptr, nullptr,
                                 Alloc<List<class_item_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  Token* extends;
  List<class_item_t*>* items;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Class, name))
         | maskbit(offsetof(command__Class, extends))
         | maskbit(offsetof(command__Class, items))
         | maskbit(offsetof(command__Class, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Class)
};

class command__Import : public command_t {
 public:
  command__Import(single_quoted* path, Token* alias, List<import_name*>* names)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Import),
                      field_mask(), sizeof(command__Import)),
        path(path),
        alias(alias),
        names(names),
        spids(Alloc<List<int>>()) {
  }

  static command__Import* Create() { 
    return Alloc<command__Import>(nullptr, nullptr,
                                  Alloc<List<import_name*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  single_quoted* path;
  Token* alias;
  List<import_name*>* names;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Import, path))
         | maskbit(offsetof(command__Import, alias))
         | maskbit(offsetof(command__Import, names))
         | maskbit(offsetof(command__Import, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Import)
};

class command__For : public command_t {
 public:
  command__For(List<name_type*>* targets, expr_t* iterable, command_t* body)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::For),
                      field_mask(), sizeof(command__For)),
        targets(targets),
        iterable(iterable),
        body(body),
        spids(Alloc<List<int>>()) {
  }

  static command__For* Create() { 
    return Alloc<command__For>(Alloc<List<name_type*>>(), nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<name_type*>* targets;
  expr_t* iterable;
  command_t* body;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__For, targets))
         | maskbit(offsetof(command__For, iterable))
         | maskbit(offsetof(command__For, body))
         | maskbit(offsetof(command__For, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__For)
};

class command__While : public command_t {
 public:
  command__While(expr_t* test, command_t* body)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::While),
                      field_mask(), sizeof(command__While)),
        test(test),
        body(body),
        spids(Alloc<List<int>>()) {
  }

  static command__While* Create() { 
    return Alloc<command__While>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* test;
  command_t* body;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__While, test))
         | maskbit(offsetof(command__While, body))
         | maskbit(offsetof(command__While, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__While)
};

class command__Break : public command_t {
 public:
  command__Break()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Break),
                      field_mask(), sizeof(command__Break)),
        spids(Alloc<List<int>>()) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Break, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Break)
};

class command__Continue : public command_t {
 public:
  command__Continue()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Continue),
                      field_mask(), sizeof(command__Continue)),
        spids(Alloc<List<int>>()) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Continue, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Continue)
};

class command__Return : public command_t {
 public:
  command__Return(expr_t* value)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(command_e::Return),
                      field_mask(), sizeof(command__Return)),
        value(value),
        spids(Alloc<List<int>>()) {
  }

  static command__Return* Create() { 
    return Alloc<command__Return>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* value;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command__Return, value))
         | maskbit(offsetof(command__Return, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(command__Return)
};

ASDL_NAMES command {
  typedef command__NoOp NoOp;
  typedef command__Simple Simple;
  typedef command__ExpandedAlias ExpandedAlias;
  typedef command__Sentence Sentence;
  typedef command__ShAssignment ShAssignment;
  typedef command__ControlFlow ControlFlow;
  typedef command__Pipeline Pipeline;
  typedef command__AndOr AndOr;
  typedef command__DoGroup DoGroup;
  typedef command__Subshell Subshell;
  typedef command__DParen DParen;
  typedef command__DBracket DBracket;
  typedef command__ForEach ForEach;
  typedef command__ForExpr ForExpr;
  typedef command__WhileUntil WhileUntil;
  typedef command__If If;
  typedef command__Case Case;
  typedef command__ShFunction ShFunction;
  typedef command__TimeBlock TimeBlock;
  typedef command__CommandList CommandList;
  typedef command__BareDecl BareDecl;
  typedef command__VarDecl VarDecl;
  typedef command__PlaceMutation PlaceMutation;
  typedef command__Expr Expr;
  typedef command__Proc Proc;
  typedef command__Func Func;
  typedef command__Data Data;
  typedef command__Enum Enum;
  typedef command__Class Class;
  typedef command__Import Import;
  typedef command__For For;
  typedef command__While While;
  typedef command__Break Break;
  typedef command__Continue Continue;
  typedef command__Return Return;
};

ASDL_NAMES variant_type_e {
  enum no_name {
  Anon = 1,
  Ref = 2,
  };
};

const char* variant_type_str(int tag);

class variant_type_t {
 protected:
  variant_type_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(variant_type_t)
};

class variant_type__Anon : public variant_type_t {
 public:
  variant_type__Anon(List<param*>* params)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(variant_type_e::Anon),
                      field_mask(), sizeof(variant_type__Anon)),
        params(params) {
  }

  static variant_type__Anon* Create() { 
    return Alloc<variant_type__Anon>(Alloc<List<param*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<param*>* params;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(variant_type__Anon, params));
  }

  DISALLOW_COPY_AND_ASSIGN(variant_type__Anon)
};

class variant_type__Ref : public variant_type_t {
 public:
  variant_type__Ref(Token* type_name)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(variant_type_e::Ref),
                      field_mask(), sizeof(variant_type__Ref)),
        type_name(type_name) {
  }

  static variant_type__Ref* Create() { 
    return Alloc<variant_type__Ref>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* type_name;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(variant_type__Ref, type_name));
  }

  DISALLOW_COPY_AND_ASSIGN(variant_type__Ref)
};

ASDL_NAMES variant_type {
  typedef variant_type__Anon Anon;
  typedef variant_type__Ref Ref;
};

ASDL_NAMES class_item_e {
  enum no_name {
  Data = 1,
  Method = 2,
  };
};

const char* class_item_str(int tag);

class class_item_t {
 protected:
  class_item_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(class_item_t)
};

class class_item__Data : public class_item_t {
 public:
  class_item__Data(Token* keyword, List<name_type*>* fields)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(class_item_e::Data),
                      field_mask(), sizeof(class_item__Data)),
        keyword(keyword),
        fields(fields) {
  }

  static class_item__Data* Create() { 
    return Alloc<class_item__Data>(nullptr, Alloc<List<name_type*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* keyword;
  List<name_type*>* fields;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(class_item__Data, keyword))
         | maskbit(offsetof(class_item__Data, fields));
  }

  DISALLOW_COPY_AND_ASSIGN(class_item__Data)
};

class class_item__Method : public class_item_t {
 public:
  class_item__Method()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(class_item_e::Method),
                      kZeroMask, sizeof(class_item__Method)) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);

  DISALLOW_COPY_AND_ASSIGN(class_item__Method)
};

ASDL_NAMES class_item {
  typedef class_item__Data Data;
  typedef class_item__Method Method;
};

ASDL_NAMES proc_sig_e {
  enum no_name {
  Open = 1,
  Closed = 2,
  };
};

const char* proc_sig_str(int tag);

class proc_sig_t {
 protected:
  proc_sig_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(proc_sig_t)
};

class proc_sig__Open : public proc_sig_t {
 public:
  proc_sig__Open()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(proc_sig_e::Open),
                      kZeroMask, sizeof(proc_sig__Open)) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);

  DISALLOW_COPY_AND_ASSIGN(proc_sig__Open)
};

class proc_sig__Closed : public proc_sig_t {
 public:
  proc_sig__Closed(List<UntypedParam*>* untyped, Token* rest,
                   List<TypedParam*>* typed)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(proc_sig_e::Closed),
                      field_mask(), sizeof(proc_sig__Closed)),
        untyped(untyped),
        rest(rest),
        typed(typed) {
  }

  static proc_sig__Closed* Create() { 
    return Alloc<proc_sig__Closed>(Alloc<List<UntypedParam*>>(), nullptr,
                                   Alloc<List<TypedParam*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<UntypedParam*>* untyped;
  Token* rest;
  List<TypedParam*>* typed;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(proc_sig__Closed, untyped))
         | maskbit(offsetof(proc_sig__Closed, rest))
         | maskbit(offsetof(proc_sig__Closed, typed));
  }

  DISALLOW_COPY_AND_ASSIGN(proc_sig__Closed)
};

ASDL_NAMES proc_sig {
  typedef proc_sig__Open Open;
  typedef proc_sig__Closed Closed;
};

ASDL_NAMES glob_part_e {
  enum no_name {
  Literal = 1,
  Operator = 2,
  CharClass = 3,
  };
};

const char* glob_part_str(int tag);

class glob_part_t {
 protected:
  glob_part_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(glob_part_t)
};

class glob_part__Literal : public glob_part_t {
 public:
  glob_part__Literal(Id_t id, Str* s)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(glob_part_e::Literal),
                      field_mask(), sizeof(glob_part__Literal)),
        id(id),
        s(s) {
  }

  static glob_part__Literal* Create() { 
    return Alloc<glob_part__Literal>(-1, kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t id;
  Str* s;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(glob_part__Literal, s));
  }

  DISALLOW_COPY_AND_ASSIGN(glob_part__Literal)
};

class glob_part__Operator : public glob_part_t {
 public:
  glob_part__Operator(Id_t op_id)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(glob_part_e::Operator),
                      kZeroMask, sizeof(glob_part__Operator)),
        op_id(op_id) {
  }

  static glob_part__Operator* Create() { 
    return Alloc<glob_part__Operator>(-1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t op_id;

  DISALLOW_COPY_AND_ASSIGN(glob_part__Operator)
};

class glob_part__CharClass : public glob_part_t {
 public:
  glob_part__CharClass(bool negated, List<Str*>* strs)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(glob_part_e::CharClass),
                      field_mask(), sizeof(glob_part__CharClass)),
        negated(negated),
        strs(strs) {
  }

  static glob_part__CharClass* Create() { 
    return Alloc<glob_part__CharClass>(false, Alloc<List<Str*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  bool negated;
  List<Str*>* strs;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(glob_part__CharClass, strs));
  }

  DISALLOW_COPY_AND_ASSIGN(glob_part__CharClass)
};

ASDL_NAMES glob_part {
  typedef glob_part__Literal Literal;
  typedef glob_part__Operator Operator;
  typedef glob_part__CharClass CharClass;
};

ASDL_NAMES printf_part_e {
  enum no_name {
  Literal = 1,
  Percent = 2,
  };
};

const char* printf_part_str(int tag);

class printf_part_t {
 protected:
  printf_part_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(printf_part_t)
};

class printf_part__Literal : public printf_part_t {
 public:
  printf_part__Literal(Token* token)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(printf_part_e::Literal),
                      field_mask(), sizeof(printf_part__Literal)),
        token(token) {
  }

  static printf_part__Literal* Create() { 
    return Alloc<printf_part__Literal>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* token;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(printf_part__Literal, token));
  }

  DISALLOW_COPY_AND_ASSIGN(printf_part__Literal)
};

class printf_part__Percent : public printf_part_t {
 public:
  printf_part__Percent(List<Token*>* flags, Token* width, Token* precision,
                       Token* type)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(printf_part_e::Percent),
                      field_mask(), sizeof(printf_part__Percent)),
        flags(flags),
        width(width),
        precision(precision),
        type(type) {
  }

  static printf_part__Percent* Create() { 
    return Alloc<printf_part__Percent>(Alloc<List<Token*>>(), nullptr, nullptr,
                                       nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<Token*>* flags;
  Token* width;
  Token* precision;
  Token* type;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(printf_part__Percent, flags))
         | maskbit(offsetof(printf_part__Percent, width))
         | maskbit(offsetof(printf_part__Percent, precision))
         | maskbit(offsetof(printf_part__Percent, type));
  }

  DISALLOW_COPY_AND_ASSIGN(printf_part__Percent)
};

ASDL_NAMES printf_part {
  typedef printf_part__Literal Literal;
  typedef printf_part__Percent Percent;
};

enum class expr_context_e {
  Load = 1,
  Store = 2,
  Del = 3,
  AugLoad = 4,
  AugStore = 5,
  Param = 6,
};
typedef expr_context_e expr_context_t;

const char* expr_context_str(expr_context_e tag);

ASDL_NAMES type_expr_e {
  enum no_name {
  Simple = 1,
  Compound = 2,
  };
};

const char* type_expr_str(int tag);

class type_expr_t {
 protected:
  type_expr_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(type_expr_t)
};

class type_expr__Simple : public type_expr_t {
 public:
  type_expr__Simple(Token* name)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(type_expr_e::Simple),
                      field_mask(), sizeof(type_expr__Simple)),
        name(name) {
  }

  static type_expr__Simple* Create() { 
    return Alloc<type_expr__Simple>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(type_expr__Simple, name));
  }

  DISALLOW_COPY_AND_ASSIGN(type_expr__Simple)
};

class type_expr__Compound : public type_expr_t {
 public:
  type_expr__Compound(Token* name, List<type_expr_t*>* params)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(type_expr_e::Compound),
                      field_mask(), sizeof(type_expr__Compound)),
        name(name),
        params(params) {
  }

  static type_expr__Compound* Create() { 
    return Alloc<type_expr__Compound>(nullptr, Alloc<List<type_expr_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  List<type_expr_t*>* params;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(type_expr__Compound, name))
         | maskbit(offsetof(type_expr__Compound, params));
  }

  DISALLOW_COPY_AND_ASSIGN(type_expr__Compound)
};

ASDL_NAMES type_expr {
  typedef type_expr__Simple Simple;
  typedef type_expr__Compound Compound;
};

ASDL_NAMES place_expr_e {
  enum no_name {
  Var = 1,
  Subscript = 93,
  Attribute = 94,
  };
};

const char* place_expr_str(int tag);

class place_expr_t {
 protected:
  place_expr_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(place_expr_t)
};

class place_expr__Var : public place_expr_t {
 public:
  place_expr__Var(Token* name)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(place_expr_e::Var),
                      field_mask(), sizeof(place_expr__Var)),
        name(name) {
  }

  static place_expr__Var* Create() { 
    return Alloc<place_expr__Var>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(place_expr__Var, name));
  }

  DISALLOW_COPY_AND_ASSIGN(place_expr__Var)
};

ASDL_NAMES place_expr {
  typedef place_expr__Var Var;
};

ASDL_NAMES expr_e {
  enum no_name {
  Var = 1,
  Const = 2,
  ShArrayLiteral = 72,
  RegexLiteral = 4,
  SimpleVarSub = 70,
  BracedVarSub = 67,
  CommandSub = 71,
  SingleQuoted = 69,
  DoubleQuoted = 68,
  BlockArg = 84,
  Lambda = 11,
  Unary = 12,
  Binary = 13,
  Compare = 14,
  FuncCall = 15,
  IfExp = 16,
  Tuple = 17,
  List = 18,
  Dict = 19,
  Implicit = 20,
  ListComp = 21,
  DictComp = 22,
  GeneratorExp = 23,
  Range = 24,
  Slice = 25,
  Subscript = 93,
  Attribute = 94,
  Spread = 28,
  };
};

const char* expr_str(int tag);

class expr_t {
 protected:
  expr_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(expr_t)
};

class expr__Var : public expr_t {
 public:
  expr__Var(Token* name)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Var),
                      field_mask(), sizeof(expr__Var)),
        name(name) {
  }

  static expr__Var* Create() { 
    return Alloc<expr__Var>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__Var, name));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__Var)
};

class expr__Const : public expr_t {
 public:
  expr__Const(Token* c)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Const),
                      field_mask(), sizeof(expr__Const)),
        c(c) {
  }

  static expr__Const* Create() { 
    return Alloc<expr__Const>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* c;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__Const, c));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__Const)
};

class expr__RegexLiteral : public expr_t {
 public:
  expr__RegexLiteral(Token* left, re_t* regex, List<Token*>* flags, Token*
                     trans_pref)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::RegexLiteral),
                      field_mask(), sizeof(expr__RegexLiteral)),
        left(left),
        regex(regex),
        flags(flags),
        trans_pref(trans_pref) {
  }

  static expr__RegexLiteral* Create() { 
    return Alloc<expr__RegexLiteral>(nullptr, nullptr, Alloc<List<Token*>>(),
                                     nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  re_t* regex;
  List<Token*>* flags;
  Token* trans_pref;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__RegexLiteral, left))
         | maskbit(offsetof(expr__RegexLiteral, regex))
         | maskbit(offsetof(expr__RegexLiteral, flags))
         | maskbit(offsetof(expr__RegexLiteral, trans_pref));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__RegexLiteral)
};

class expr__Lambda : public expr_t {
 public:
  expr__Lambda(List<name_type*>* params, expr_t* body)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Lambda),
                      field_mask(), sizeof(expr__Lambda)),
        params(params),
        body(body) {
  }

  static expr__Lambda* Create() { 
    return Alloc<expr__Lambda>(Alloc<List<name_type*>>(), nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<name_type*>* params;
  expr_t* body;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__Lambda, params))
         | maskbit(offsetof(expr__Lambda, body));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__Lambda)
};

class expr__Unary : public expr_t {
 public:
  expr__Unary(Token* op, expr_t* child)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Unary),
                      field_mask(), sizeof(expr__Unary)),
        op(op),
        child(child) {
  }

  static expr__Unary* Create() { 
    return Alloc<expr__Unary>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* op;
  expr_t* child;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__Unary, op))
         | maskbit(offsetof(expr__Unary, child));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__Unary)
};

class expr__Binary : public expr_t {
 public:
  expr__Binary(Token* op, expr_t* left, expr_t* right)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Binary),
                      field_mask(), sizeof(expr__Binary)),
        op(op),
        left(left),
        right(right) {
  }

  static expr__Binary* Create() { 
    return Alloc<expr__Binary>(nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* op;
  expr_t* left;
  expr_t* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__Binary, op))
         | maskbit(offsetof(expr__Binary, left))
         | maskbit(offsetof(expr__Binary, right));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__Binary)
};

class expr__Compare : public expr_t {
 public:
  expr__Compare(expr_t* left, List<Token*>* ops, List<expr_t*>* comparators)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Compare),
                      field_mask(), sizeof(expr__Compare)),
        left(left),
        ops(ops),
        comparators(comparators) {
  }

  static expr__Compare* Create() { 
    return Alloc<expr__Compare>(nullptr, Alloc<List<Token*>>(),
                                Alloc<List<expr_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* left;
  List<Token*>* ops;
  List<expr_t*>* comparators;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__Compare, left))
         | maskbit(offsetof(expr__Compare, ops))
         | maskbit(offsetof(expr__Compare, comparators));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__Compare)
};

class expr__FuncCall : public expr_t {
 public:
  expr__FuncCall(expr_t* func, ArgList* args)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::FuncCall),
                      field_mask(), sizeof(expr__FuncCall)),
        func(func),
        args(args) {
  }

  static expr__FuncCall* Create() { 
    return Alloc<expr__FuncCall>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* func;
  ArgList* args;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__FuncCall, func))
         | maskbit(offsetof(expr__FuncCall, args));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__FuncCall)
};

class expr__IfExp : public expr_t {
 public:
  expr__IfExp(expr_t* test, expr_t* body, expr_t* orelse)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::IfExp),
                      field_mask(), sizeof(expr__IfExp)),
        test(test),
        body(body),
        orelse(orelse) {
  }

  static expr__IfExp* Create() { 
    return Alloc<expr__IfExp>(nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* test;
  expr_t* body;
  expr_t* orelse;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__IfExp, test))
         | maskbit(offsetof(expr__IfExp, body))
         | maskbit(offsetof(expr__IfExp, orelse));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__IfExp)
};

class expr__Tuple : public expr_t {
 public:
  expr__Tuple(List<expr_t*>* elts, expr_context_t ctx)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Tuple),
                      field_mask(), sizeof(expr__Tuple)),
        elts(elts),
        ctx(ctx) {
  }

  static expr__Tuple* Create() { 
    return Alloc<expr__Tuple>(Alloc<List<expr_t*>>(), expr_context_e::Load);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<expr_t*>* elts;
  expr_context_t ctx;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__Tuple, elts));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__Tuple)
};

class expr__List : public expr_t {
 public:
  expr__List(List<expr_t*>* elts, expr_context_t ctx)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::List),
                      field_mask(), sizeof(expr__List)),
        elts(elts),
        ctx(ctx) {
  }

  static expr__List* Create() { 
    return Alloc<expr__List>(Alloc<List<expr_t*>>(), expr_context_e::Load);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<expr_t*>* elts;
  expr_context_t ctx;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__List, elts));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__List)
};

class expr__Dict : public expr_t {
 public:
  expr__Dict(List<expr_t*>* keys, List<expr_t*>* values)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Dict),
                      field_mask(), sizeof(expr__Dict)),
        keys(keys),
        values(values) {
  }

  static expr__Dict* Create() { 
    return Alloc<expr__Dict>(Alloc<List<expr_t*>>(), Alloc<List<expr_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<expr_t*>* keys;
  List<expr_t*>* values;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__Dict, keys))
         | maskbit(offsetof(expr__Dict, values));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__Dict)
};

class expr__Implicit : public expr_t {
 public:
  expr__Implicit()
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Implicit),
                      kZeroMask, sizeof(expr__Implicit)) {
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);

  DISALLOW_COPY_AND_ASSIGN(expr__Implicit)
};

class expr__ListComp : public expr_t {
 public:
  expr__ListComp(expr_t* elt, List<comprehension*>* generators)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::ListComp),
                      field_mask(), sizeof(expr__ListComp)),
        elt(elt),
        generators(generators) {
  }

  static expr__ListComp* Create() { 
    return Alloc<expr__ListComp>(nullptr, Alloc<List<comprehension*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* elt;
  List<comprehension*>* generators;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__ListComp, elt))
         | maskbit(offsetof(expr__ListComp, generators));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__ListComp)
};

class expr__DictComp : public expr_t {
 public:
  expr__DictComp(expr_t* key, expr_t* value, List<comprehension*>* generators)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::DictComp),
                      field_mask(), sizeof(expr__DictComp)),
        key(key),
        value(value),
        generators(generators) {
  }

  static expr__DictComp* Create() { 
    return Alloc<expr__DictComp>(nullptr, nullptr,
                                 Alloc<List<comprehension*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* key;
  expr_t* value;
  List<comprehension*>* generators;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__DictComp, key))
         | maskbit(offsetof(expr__DictComp, value))
         | maskbit(offsetof(expr__DictComp, generators));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__DictComp)
};

class expr__GeneratorExp : public expr_t {
 public:
  expr__GeneratorExp(expr_t* elt, List<comprehension*>* generators)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::GeneratorExp),
                      field_mask(), sizeof(expr__GeneratorExp)),
        elt(elt),
        generators(generators) {
  }

  static expr__GeneratorExp* Create() { 
    return Alloc<expr__GeneratorExp>(nullptr, Alloc<List<comprehension*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* elt;
  List<comprehension*>* generators;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__GeneratorExp, elt))
         | maskbit(offsetof(expr__GeneratorExp, generators));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__GeneratorExp)
};

class expr__Range : public expr_t {
 public:
  expr__Range(expr_t* lower, expr_t* upper)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Range),
                      field_mask(), sizeof(expr__Range)),
        lower(lower),
        upper(upper) {
  }

  static expr__Range* Create() { 
    return Alloc<expr__Range>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* lower;
  expr_t* upper;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__Range, lower))
         | maskbit(offsetof(expr__Range, upper));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__Range)
};

class expr__Slice : public expr_t {
 public:
  expr__Slice(expr_t* lower, expr_t* upper)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Slice),
                      field_mask(), sizeof(expr__Slice)),
        lower(lower),
        upper(upper) {
  }

  static expr__Slice* Create() { 
    return Alloc<expr__Slice>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* lower;
  expr_t* upper;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__Slice, lower))
         | maskbit(offsetof(expr__Slice, upper));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__Slice)
};

class expr__Spread : public expr_t {
 public:
  expr__Spread(expr_t* child, expr_context_t ctx)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(expr_e::Spread),
                      field_mask(), sizeof(expr__Spread)),
        child(child),
        ctx(ctx) {
  }

  static expr__Spread* Create() { 
    return Alloc<expr__Spread>(nullptr, expr_context_e::Load);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* child;
  expr_context_t ctx;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(expr__Spread, child));
  }

  DISALLOW_COPY_AND_ASSIGN(expr__Spread)
};

ASDL_NAMES expr {
  typedef expr__Var Var;
  typedef expr__Const Const;
  typedef expr__RegexLiteral RegexLiteral;
  typedef expr__Lambda Lambda;
  typedef expr__Unary Unary;
  typedef expr__Binary Binary;
  typedef expr__Compare Compare;
  typedef expr__FuncCall FuncCall;
  typedef expr__IfExp IfExp;
  typedef expr__Tuple Tuple;
  typedef expr__List List;
  typedef expr__Dict Dict;
  typedef expr__Implicit Implicit;
  typedef expr__ListComp ListComp;
  typedef expr__DictComp DictComp;
  typedef expr__GeneratorExp GeneratorExp;
  typedef expr__Range Range;
  typedef expr__Slice Slice;
  typedef expr__Spread Spread;
};

ASDL_NAMES class_literal_term_e {
  enum no_name {
  PosixClass = 95,
  PerlClass = 96,
  Range = 3,
  CharLiteral = 4,
  SimpleVarSub = 70,
  BracedVarSub = 67,
  SingleQuoted = 69,
  DoubleQuoted = 68,
  };
};

const char* class_literal_term_str(int tag);

class class_literal_term_t {
 protected:
  class_literal_term_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(class_literal_term_t)
};

class class_literal_term__Range : public class_literal_term_t {
 public:
  class_literal_term__Range(Token* start, Token* end)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(class_literal_term_e::Range),
                      field_mask(), sizeof(class_literal_term__Range)),
        start(start),
        end(end) {
  }

  static class_literal_term__Range* Create() { 
    return Alloc<class_literal_term__Range>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* start;
  Token* end;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(class_literal_term__Range, start))
         | maskbit(offsetof(class_literal_term__Range, end));
  }

  DISALLOW_COPY_AND_ASSIGN(class_literal_term__Range)
};

class class_literal_term__CharLiteral : public class_literal_term_t {
 public:
  class_literal_term__CharLiteral(Token* tok)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(class_literal_term_e::CharLiteral),
                      field_mask(), sizeof(class_literal_term__CharLiteral)),
        tok(tok) {
  }

  static class_literal_term__CharLiteral* Create() { 
    return Alloc<class_literal_term__CharLiteral>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* tok;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(class_literal_term__CharLiteral, tok));
  }

  DISALLOW_COPY_AND_ASSIGN(class_literal_term__CharLiteral)
};

ASDL_NAMES class_literal_term {
  typedef class_literal_term__Range Range;
  typedef class_literal_term__CharLiteral CharLiteral;
};

ASDL_NAMES char_class_term_e {
  enum no_name {
  PosixClass = 95,
  PerlClass = 96,
  Range = 3,
  CharCode = 97,
  };
};

const char* char_class_term_str(int tag);

class char_class_term_t {
 protected:
  char_class_term_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(char_class_term_t)
};

class char_class_term__Range : public char_class_term_t {
 public:
  char_class_term__Range(CharCode* start, CharCode* end)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(char_class_term_e::Range),
                      field_mask(), sizeof(char_class_term__Range)),
        start(start),
        end(end) {
  }

  static char_class_term__Range* Create() { 
    return Alloc<char_class_term__Range>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  CharCode* start;
  CharCode* end;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(char_class_term__Range, start))
         | maskbit(offsetof(char_class_term__Range, end));
  }

  DISALLOW_COPY_AND_ASSIGN(char_class_term__Range)
};

ASDL_NAMES char_class_term {
  typedef char_class_term__Range Range;
};

ASDL_NAMES re_repeat_e {
  enum no_name {
  Op = 1,
  Num = 2,
  Range = 3,
  };
};

const char* re_repeat_str(int tag);

class re_repeat_t {
 protected:
  re_repeat_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(re_repeat_t)
};

class re_repeat__Op : public re_repeat_t {
 public:
  re_repeat__Op(Token* op)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_repeat_e::Op),
                      field_mask(), sizeof(re_repeat__Op)),
        op(op) {
  }

  static re_repeat__Op* Create() { 
    return Alloc<re_repeat__Op>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* op;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re_repeat__Op, op));
  }

  DISALLOW_COPY_AND_ASSIGN(re_repeat__Op)
};

class re_repeat__Num : public re_repeat_t {
 public:
  re_repeat__Num(Token* times)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_repeat_e::Num),
                      field_mask(), sizeof(re_repeat__Num)),
        times(times) {
  }

  static re_repeat__Num* Create() { 
    return Alloc<re_repeat__Num>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* times;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re_repeat__Num, times));
  }

  DISALLOW_COPY_AND_ASSIGN(re_repeat__Num)
};

class re_repeat__Range : public re_repeat_t {
 public:
  re_repeat__Range(Token* lower, Token* upper)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_repeat_e::Range),
                      field_mask(), sizeof(re_repeat__Range)),
        lower(lower),
        upper(upper) {
  }

  static re_repeat__Range* Create() { 
    return Alloc<re_repeat__Range>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* lower;
  Token* upper;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re_repeat__Range, lower))
         | maskbit(offsetof(re_repeat__Range, upper));
  }

  DISALLOW_COPY_AND_ASSIGN(re_repeat__Range)
};

ASDL_NAMES re_repeat {
  typedef re_repeat__Op Op;
  typedef re_repeat__Num Num;
  typedef re_repeat__Range Range;
};

ASDL_NAMES re_e {
  enum no_name {
  Token = 66,
  PosixClass = 95,
  PerlClass = 96,
  CharClassLiteral = 4,
  CharClass = 5,
  Splice = 6,
  SimpleVarSub = 70,
  BracedVarSub = 67,
  SingleQuoted = 69,
  DoubleQuoted = 68,
  Repeat = 11,
  Seq = 12,
  Alt = 13,
  Group = 14,
  Capture = 15,
  Backtracking = 16,
  Primitive = 17,
  LiteralChars = 18,
  };
};

const char* re_str(int tag);

class re_t {
 protected:
  re_t() {
  }
 public:
  int tag_() const {
    return reinterpret_cast<const ObjHeader*>(this)->type_tag;
  }
  hnode_t* PrettyTree();
  DISALLOW_COPY_AND_ASSIGN(re_t)
};

class re__CharClassLiteral : public re_t {
 public:
  re__CharClassLiteral(bool negated, List<class_literal_term_t*>* terms)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_e::CharClassLiteral),
                      field_mask(), sizeof(re__CharClassLiteral)),
        negated(negated),
        terms(terms) {
  }

  static re__CharClassLiteral* Create() { 
    return Alloc<re__CharClassLiteral>(false,
                                       Alloc<List<class_literal_term_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  bool negated;
  List<class_literal_term_t*>* terms;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re__CharClassLiteral, terms));
  }

  DISALLOW_COPY_AND_ASSIGN(re__CharClassLiteral)
};

class re__CharClass : public re_t {
 public:
  re__CharClass(bool negated, List<char_class_term_t*>* terms)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_e::CharClass),
                      field_mask(), sizeof(re__CharClass)),
        negated(negated),
        terms(terms) {
  }

  static re__CharClass* Create() { 
    return Alloc<re__CharClass>(false, Alloc<List<char_class_term_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  bool negated;
  List<char_class_term_t*>* terms;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re__CharClass, terms));
  }

  DISALLOW_COPY_AND_ASSIGN(re__CharClass)
};

class re__Splice : public re_t {
 public:
  re__Splice(Token* name, Str* var_name)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_e::Splice),
                      field_mask(), sizeof(re__Splice)),
        name(name),
        var_name(var_name) {
  }

  static re__Splice* Create() { 
    return Alloc<re__Splice>(nullptr, kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  Str* var_name;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re__Splice, name))
         | maskbit(offsetof(re__Splice, var_name));
  }

  DISALLOW_COPY_AND_ASSIGN(re__Splice)
};

class re__Repeat : public re_t {
 public:
  re__Repeat(re_t* child, re_repeat_t* op)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_e::Repeat),
                      field_mask(), sizeof(re__Repeat)),
        child(child),
        op(op) {
  }

  static re__Repeat* Create() { 
    return Alloc<re__Repeat>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  re_t* child;
  re_repeat_t* op;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re__Repeat, child))
         | maskbit(offsetof(re__Repeat, op));
  }

  DISALLOW_COPY_AND_ASSIGN(re__Repeat)
};

class re__Seq : public re_t {
 public:
  re__Seq(List<re_t*>* children)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_e::Seq),
                      field_mask(), sizeof(re__Seq)),
        children(children) {
  }

  static re__Seq* Create() { 
    return Alloc<re__Seq>(Alloc<List<re_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<re_t*>* children;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re__Seq, children));
  }

  DISALLOW_COPY_AND_ASSIGN(re__Seq)
};

class re__Alt : public re_t {
 public:
  re__Alt(List<re_t*>* children)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_e::Alt),
                      field_mask(), sizeof(re__Alt)),
        children(children) {
  }

  static re__Alt* Create() { 
    return Alloc<re__Alt>(Alloc<List<re_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<re_t*>* children;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re__Alt, children));
  }

  DISALLOW_COPY_AND_ASSIGN(re__Alt)
};

class re__Group : public re_t {
 public:
  re__Group(re_t* child)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_e::Group),
                      field_mask(), sizeof(re__Group)),
        child(child) {
  }

  static re__Group* Create() { 
    return Alloc<re__Group>(nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  re_t* child;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re__Group, child));
  }

  DISALLOW_COPY_AND_ASSIGN(re__Group)
};

class re__Capture : public re_t {
 public:
  re__Capture(re_t* child, Token* var_name)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_e::Capture),
                      field_mask(), sizeof(re__Capture)),
        child(child),
        var_name(var_name) {
  }

  static re__Capture* Create() { 
    return Alloc<re__Capture>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  re_t* child;
  Token* var_name;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re__Capture, child))
         | maskbit(offsetof(re__Capture, var_name));
  }

  DISALLOW_COPY_AND_ASSIGN(re__Capture)
};

class re__Backtracking : public re_t {
 public:
  re__Backtracking(bool negated, Token* name, re_t* child)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_e::Backtracking),
                      field_mask(), sizeof(re__Backtracking)),
        negated(negated),
        name(name),
        child(child) {
  }

  static re__Backtracking* Create() { 
    return Alloc<re__Backtracking>(false, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  bool negated;
  Token* name;
  re_t* child;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re__Backtracking, name))
         | maskbit(offsetof(re__Backtracking, child));
  }

  DISALLOW_COPY_AND_ASSIGN(re__Backtracking)
};

class re__Primitive : public re_t {
 public:
  re__Primitive(Id_t id)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_e::Primitive),
                      kZeroMask, sizeof(re__Primitive)),
        id(id) {
  }

  static re__Primitive* Create() { 
    return Alloc<re__Primitive>(-1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t id;

  DISALLOW_COPY_AND_ASSIGN(re__Primitive)
};

class re__LiteralChars : public re_t {
 public:
  re__LiteralChars(Str* s, int spid)
      : GC_ASDL_CLASS(header_, static_cast<uint16_t>(re_e::LiteralChars),
                      field_mask(), sizeof(re__LiteralChars)),
        s(s),
        spid(spid) {
  }

  static re__LiteralChars* Create() { 
    return Alloc<re__LiteralChars>(kEmptyString, -1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* s;
  int spid;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(re__LiteralChars, s));
  }

  DISALLOW_COPY_AND_ASSIGN(re__LiteralChars)
};

ASDL_NAMES re {
  typedef re__CharClassLiteral CharClassLiteral;
  typedef re__CharClass CharClass;
  typedef re__Splice Splice;
  typedef re__Repeat Repeat;
  typedef re__Seq Seq;
  typedef re__Alt Alt;
  typedef re__Group Group;
  typedef re__Capture Capture;
  typedef re__Backtracking Backtracking;
  typedef re__Primitive Primitive;
  typedef re__LiteralChars LiteralChars;
};

class BoolOutParam {
 public:
  BoolOutParam(bool b)
      : GC_ASDL_CLASS(header_, 64,
                      kZeroMask, sizeof(BoolOutParam)),
        b(b) {
  }

  static BoolOutParam* Create() { 
    return Alloc<BoolOutParam>(false);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  bool b;

  DISALLOW_COPY_AND_ASSIGN(BoolOutParam)
};

class SourceLine {
 public:
  SourceLine(int line_num, Str* content, source_t* src)
      : GC_ASDL_CLASS(header_, 65,
                      field_mask(), sizeof(SourceLine)),
        line_num(line_num),
        content(content),
        src(src) {
  }

  static SourceLine* Create() { 
    return Alloc<SourceLine>(-1, kEmptyString, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  int line_num;
  Str* content;
  source_t* src;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(SourceLine, content))
         | maskbit(offsetof(SourceLine, src));
  }

  DISALLOW_COPY_AND_ASSIGN(SourceLine)
};

class Token : public loc_t, public suffix_op_t, public word_part_t, public
word_t, public re_t {
 public:
  Token(Id_t id, int col, int length, int span_id, SourceLine* line, Str* tval)
      : GC_ASDL_CLASS(header_, 66,
                      field_mask(), sizeof(Token)),
        id(id),
        col(col),
        length(length),
        span_id(span_id),
        line(line),
        tval(tval) {
  }

  static Token* Create() { 
    return Alloc<Token>(-1, -1, -1, -1, nullptr, kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Id_t id;
  int col;
  int length;
  int span_id;
  SourceLine* line;
  Str* tval;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(Token, line))
         | maskbit(offsetof(Token, tval));
  }

  DISALLOW_COPY_AND_ASSIGN(Token)
};

class braced_var_sub : public word_part_t, public expr_t, public
class_literal_term_t, public re_t {
 public:
  braced_var_sub(Token* left, Token* token, Str* var_name, Token* prefix_op,
                 bracket_op_t* bracket_op, suffix_op_t* suffix_op, Token* right)
      : GC_ASDL_CLASS(header_, 67,
                      field_mask(), sizeof(braced_var_sub)),
        left(left),
        token(token),
        var_name(var_name),
        prefix_op(prefix_op),
        bracket_op(bracket_op),
        suffix_op(suffix_op),
        right(right) {
  }

  static braced_var_sub* Create() { 
    return Alloc<braced_var_sub>(nullptr, nullptr, kEmptyString, nullptr,
                                 nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  Token* token;
  Str* var_name;
  Token* prefix_op;
  bracket_op_t* bracket_op;
  suffix_op_t* suffix_op;
  Token* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(braced_var_sub, left))
         | maskbit(offsetof(braced_var_sub, token))
         | maskbit(offsetof(braced_var_sub, var_name))
         | maskbit(offsetof(braced_var_sub, prefix_op))
         | maskbit(offsetof(braced_var_sub, bracket_op))
         | maskbit(offsetof(braced_var_sub, suffix_op))
         | maskbit(offsetof(braced_var_sub, right));
  }

  DISALLOW_COPY_AND_ASSIGN(braced_var_sub)
};

class double_quoted : public word_part_t, public expr_t, public
class_literal_term_t, public re_t {
 public:
  double_quoted(Token* left, List<word_part_t*>* parts, Token* right)
      : GC_ASDL_CLASS(header_, 68,
                      field_mask(), sizeof(double_quoted)),
        left(left),
        parts(parts),
        right(right) {
  }

  static double_quoted* Create() { 
    return Alloc<double_quoted>(nullptr, Alloc<List<word_part_t*>>(), nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  List<word_part_t*>* parts;
  Token* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(double_quoted, left))
         | maskbit(offsetof(double_quoted, parts))
         | maskbit(offsetof(double_quoted, right));
  }

  DISALLOW_COPY_AND_ASSIGN(double_quoted)
};

class single_quoted : public word_part_t, public expr_t, public
class_literal_term_t, public re_t {
 public:
  single_quoted(Token* left, List<Token*>* tokens, Token* right)
      : GC_ASDL_CLASS(header_, 69,
                      field_mask(), sizeof(single_quoted)),
        left(left),
        tokens(tokens),
        right(right) {
  }

  static single_quoted* Create() { 
    return Alloc<single_quoted>(nullptr, Alloc<List<Token*>>(), nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  List<Token*>* tokens;
  Token* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(single_quoted, left))
         | maskbit(offsetof(single_quoted, tokens))
         | maskbit(offsetof(single_quoted, right));
  }

  DISALLOW_COPY_AND_ASSIGN(single_quoted)
};

class simple_var_sub : public word_part_t, public arith_expr_t, public expr_t,
public class_literal_term_t, public re_t {
 public:
  simple_var_sub(Token* left, Str* var_name)
      : GC_ASDL_CLASS(header_, 70,
                      field_mask(), sizeof(simple_var_sub)),
        left(left),
        var_name(var_name) {
  }

  static simple_var_sub* Create() { 
    return Alloc<simple_var_sub>(nullptr, kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  Str* var_name;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(simple_var_sub, left))
         | maskbit(offsetof(simple_var_sub, var_name));
  }

  DISALLOW_COPY_AND_ASSIGN(simple_var_sub)
};

class command_sub : public word_part_t, public expr_t {
 public:
  command_sub(Token* left_token, command_t* child, Token* right)
      : GC_ASDL_CLASS(header_, 71,
                      field_mask(), sizeof(command_sub)),
        left_token(left_token),
        child(child),
        right(right) {
  }

  static command_sub* Create() { 
    return Alloc<command_sub>(nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left_token;
  command_t* child;
  Token* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(command_sub, left_token))
         | maskbit(offsetof(command_sub, child))
         | maskbit(offsetof(command_sub, right));
  }

  DISALLOW_COPY_AND_ASSIGN(command_sub)
};

class sh_array_literal : public word_part_t, public expr_t {
 public:
  sh_array_literal(Token* left, List<word_t*>* words)
      : GC_ASDL_CLASS(header_, 72,
                      field_mask(), sizeof(sh_array_literal)),
        left(left),
        words(words) {
  }

  static sh_array_literal* Create() { 
    return Alloc<sh_array_literal>(nullptr, Alloc<List<word_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  List<word_t*>* words;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(sh_array_literal, left))
         | maskbit(offsetof(sh_array_literal, words));
  }

  DISALLOW_COPY_AND_ASSIGN(sh_array_literal)
};

class ArgList {
 public:
  ArgList(Token* left, List<expr_t*>* positional, List<named_arg*>* named,
          Token* right)
      : GC_ASDL_CLASS(header_, 73,
                      field_mask(), sizeof(ArgList)),
        left(left),
        positional(positional),
        named(named),
        right(right) {
  }

  static ArgList* Create() { 
    return Alloc<ArgList>(nullptr, Alloc<List<expr_t*>>(),
                          Alloc<List<named_arg*>>(), nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  List<expr_t*>* positional;
  List<named_arg*>* named;
  Token* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(ArgList, left))
         | maskbit(offsetof(ArgList, positional))
         | maskbit(offsetof(ArgList, named))
         | maskbit(offsetof(ArgList, right));
  }

  DISALLOW_COPY_AND_ASSIGN(ArgList)
};

class assoc_pair {
 public:
  assoc_pair(compound_word* key, compound_word* value)
      : GC_ASDL_CLASS(header_, 74,
                      field_mask(), sizeof(assoc_pair)),
        key(key),
        value(value) {
  }

  static assoc_pair* Create() { 
    return Alloc<assoc_pair>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  compound_word* key;
  compound_word* value;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(assoc_pair, key))
         | maskbit(offsetof(assoc_pair, value));
  }

  DISALLOW_COPY_AND_ASSIGN(assoc_pair)
};

class compound_word : public rhs_word_t, public word_t, public arith_expr_t,
public redir_param_t {
 public:
  compound_word(List<word_part_t*>* parts)
      : GC_ASDL_CLASS(header_, 75,
                      field_mask(), sizeof(compound_word)),
        parts(parts) {
  }

  static compound_word* Create() { 
    return Alloc<compound_word>(Alloc<List<word_part_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<word_part_t*>* parts;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(compound_word, parts));
  }

  DISALLOW_COPY_AND_ASSIGN(compound_word)
};

class string_line {
 public:
  string_line(int dedent, List<word_part_t*>* part)
      : GC_ASDL_CLASS(header_, 76,
                      field_mask(), sizeof(string_line)),
        dedent(dedent),
        part(part) {
  }

  static string_line* Create() { 
    return Alloc<string_line>(-1, Alloc<List<word_part_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  int dedent;
  List<word_part_t*>* part;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(string_line, part));
  }

  DISALLOW_COPY_AND_ASSIGN(string_line)
};

class triple_quoted {
 public:
  triple_quoted(int min_dedent, List<string_line*>* lines)
      : GC_ASDL_CLASS(header_, 77,
                      field_mask(), sizeof(triple_quoted)),
        min_dedent(min_dedent),
        lines(lines) {
  }

  static triple_quoted* Create() { 
    return Alloc<triple_quoted>(-1, Alloc<List<string_line*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  int min_dedent;
  List<string_line*>* lines;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(triple_quoted, lines));
  }

  DISALLOW_COPY_AND_ASSIGN(triple_quoted)
};

class redir {
 public:
  redir(Token* op, redir_loc_t* loc, redir_param_t* arg)
      : GC_ASDL_CLASS(header_, 78,
                      field_mask(), sizeof(redir)),
        op(op),
        loc(loc),
        arg(arg) {
  }

  static redir* Create() { 
    return Alloc<redir>(nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* op;
  redir_loc_t* loc;
  redir_param_t* arg;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(redir, op))
         | maskbit(offsetof(redir, loc))
         | maskbit(offsetof(redir, arg));
  }

  DISALLOW_COPY_AND_ASSIGN(redir)
};

class assign_pair {
 public:
  assign_pair(sh_lhs_expr_t* lhs, assign_op_t op, rhs_word_t* rhs, List<int>*
              spids)
      : GC_ASDL_CLASS(header_, 79,
                      field_mask(), sizeof(assign_pair)),
        lhs(lhs),
        op(op),
        rhs(rhs),
        spids(spids) {
  }

  static assign_pair* Create() { 
    return Alloc<assign_pair>(nullptr, assign_op_e::Equal, nullptr,
                              Alloc<List<int>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  sh_lhs_expr_t* lhs;
  assign_op_t op;
  rhs_word_t* rhs;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(assign_pair, lhs))
         | maskbit(offsetof(assign_pair, rhs))
         | maskbit(offsetof(assign_pair, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(assign_pair)
};

class env_pair {
 public:
  env_pair(Str* name, rhs_word_t* val, List<int>* spids)
      : GC_ASDL_CLASS(header_, 80,
                      field_mask(), sizeof(env_pair)),
        name(name),
        val(val),
        spids(spids) {
  }

  static env_pair* Create() { 
    return Alloc<env_pair>(kEmptyString, nullptr, Alloc<List<int>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Str* name;
  rhs_word_t* val;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(env_pair, name))
         | maskbit(offsetof(env_pair, val))
         | maskbit(offsetof(env_pair, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(env_pair)
};

class case_arm {
 public:
  case_arm(List<word_t*>* pat_list, List<command_t*>* action, List<int>* spids)
      : GC_ASDL_CLASS(header_, 81,
                      field_mask(), sizeof(case_arm)),
        pat_list(pat_list),
        action(action),
        spids(spids) {
  }

  static case_arm* Create() { 
    return Alloc<case_arm>(Alloc<List<word_t*>>(), Alloc<List<command_t*>>(),
                           Alloc<List<int>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<word_t*>* pat_list;
  List<command_t*>* action;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(case_arm, pat_list))
         | maskbit(offsetof(case_arm, action))
         | maskbit(offsetof(case_arm, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(case_arm)
};

class if_arm {
 public:
  if_arm(condition_t* cond, List<command_t*>* action, List<int>* spids)
      : GC_ASDL_CLASS(header_, 82,
                      field_mask(), sizeof(if_arm)),
        cond(cond),
        action(action),
        spids(spids) {
  }

  static if_arm* Create() { 
    return Alloc<if_arm>(nullptr, Alloc<List<command_t*>>(),
                         Alloc<List<int>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  condition_t* cond;
  List<command_t*>* action;
  List<int>* spids;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(if_arm, cond))
         | maskbit(offsetof(if_arm, action))
         | maskbit(offsetof(if_arm, spids));
  }

  DISALLOW_COPY_AND_ASSIGN(if_arm)
};

class BraceGroup : public command_t {
 public:
  BraceGroup(Token* left, Token* doc_token, List<command_t*>* children,
             List<redir*>* redirects, Token* right)
      : GC_ASDL_CLASS(header_, 83,
                      field_mask(), sizeof(BraceGroup)),
        left(left),
        doc_token(doc_token),
        children(children),
        redirects(redirects),
        right(right) {
  }

  static BraceGroup* Create() { 
    return Alloc<BraceGroup>(nullptr, nullptr, Alloc<List<command_t*>>(),
                             Alloc<List<redir*>>(), nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* left;
  Token* doc_token;
  List<command_t*>* children;
  List<redir*>* redirects;
  Token* right;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(BraceGroup, left))
         | maskbit(offsetof(BraceGroup, doc_token))
         | maskbit(offsetof(BraceGroup, children))
         | maskbit(offsetof(BraceGroup, redirects))
         | maskbit(offsetof(BraceGroup, right));
  }

  DISALLOW_COPY_AND_ASSIGN(BraceGroup)
};

class BlockArg : public expr_t {
 public:
  BlockArg(BraceGroup* brace_group, List<SourceLine*>* lines)
      : GC_ASDL_CLASS(header_, 84,
                      field_mask(), sizeof(BlockArg)),
        brace_group(brace_group),
        lines(lines) {
  }

  static BlockArg* Create() { 
    return Alloc<BlockArg>(nullptr, Alloc<List<SourceLine*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  BraceGroup* brace_group;
  List<SourceLine*>* lines;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(BlockArg, brace_group))
         | maskbit(offsetof(BlockArg, lines));
  }

  DISALLOW_COPY_AND_ASSIGN(BlockArg)
};

class variant {
 public:
  variant(Token* tag_name, variant_type_t* typ)
      : GC_ASDL_CLASS(header_, 85,
                      field_mask(), sizeof(variant)),
        tag_name(tag_name),
        typ(typ) {
  }

  static variant* Create() { 
    return Alloc<variant>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* tag_name;
  variant_type_t* typ;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(variant, tag_name))
         | maskbit(offsetof(variant, typ));
  }

  DISALLOW_COPY_AND_ASSIGN(variant)
};

class import_name {
 public:
  import_name(Token* name, Token* alias)
      : GC_ASDL_CLASS(header_, 86,
                      field_mask(), sizeof(import_name)),
        name(name),
        alias(alias) {
  }

  static import_name* Create() { 
    return Alloc<import_name>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  Token* alias;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(import_name, name))
         | maskbit(offsetof(import_name, alias));
  }

  DISALLOW_COPY_AND_ASSIGN(import_name)
};

class UntypedParam {
 public:
  UntypedParam(Token* ref, Token* name, expr_t* default_val)
      : GC_ASDL_CLASS(header_, 87,
                      field_mask(), sizeof(UntypedParam)),
        ref(ref),
        name(name),
        default_val(default_val) {
  }

  static UntypedParam* Create() { 
    return Alloc<UntypedParam>(nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* ref;
  Token* name;
  expr_t* default_val;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(UntypedParam, ref))
         | maskbit(offsetof(UntypedParam, name))
         | maskbit(offsetof(UntypedParam, default_val));
  }

  DISALLOW_COPY_AND_ASSIGN(UntypedParam)
};

class TypedParam {
 public:
  TypedParam(Token* name, Token* type, expr_t* default_val)
      : GC_ASDL_CLASS(header_, 88,
                      field_mask(), sizeof(TypedParam)),
        name(name),
        type(type),
        default_val(default_val) {
  }

  static TypedParam* Create() { 
    return Alloc<TypedParam>(nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  Token* type;
  expr_t* default_val;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(TypedParam, name))
         | maskbit(offsetof(TypedParam, type))
         | maskbit(offsetof(TypedParam, default_val));
  }

  DISALLOW_COPY_AND_ASSIGN(TypedParam)
};

class param {
 public:
  param(Token* prefix, Token* name, type_expr_t* type, expr_t* default_val)
      : GC_ASDL_CLASS(header_, 89,
                      field_mask(), sizeof(param)),
        prefix(prefix),
        name(name),
        type(type),
        default_val(default_val) {
  }

  static param* Create() { 
    return Alloc<param>(nullptr, nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* prefix;
  Token* name;
  type_expr_t* type;
  expr_t* default_val;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(param, prefix))
         | maskbit(offsetof(param, name))
         | maskbit(offsetof(param, type))
         | maskbit(offsetof(param, default_val));
  }

  DISALLOW_COPY_AND_ASSIGN(param)
};

class name_type {
 public:
  name_type(Token* name, type_expr_t* typ)
      : GC_ASDL_CLASS(header_, 90,
                      field_mask(), sizeof(name_type)),
        name(name),
        typ(typ) {
  }

  static name_type* Create() { 
    return Alloc<name_type>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  type_expr_t* typ;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(name_type, name))
         | maskbit(offsetof(name_type, typ));
  }

  DISALLOW_COPY_AND_ASSIGN(name_type)
};

class comprehension {
 public:
  comprehension(List<name_type*>* lhs, expr_t* iter, expr_t* cond)
      : GC_ASDL_CLASS(header_, 91,
                      field_mask(), sizeof(comprehension)),
        lhs(lhs),
        iter(iter),
        cond(cond) {
  }

  static comprehension* Create() { 
    return Alloc<comprehension>(Alloc<List<name_type*>>(), nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  List<name_type*>* lhs;
  expr_t* iter;
  expr_t* cond;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(comprehension, lhs))
         | maskbit(offsetof(comprehension, iter))
         | maskbit(offsetof(comprehension, cond));
  }

  DISALLOW_COPY_AND_ASSIGN(comprehension)
};

class named_arg {
 public:
  named_arg(Token* name, expr_t* value)
      : GC_ASDL_CLASS(header_, 92,
                      field_mask(), sizeof(named_arg)),
        name(name),
        value(value) {
  }

  static named_arg* Create() { 
    return Alloc<named_arg>(nullptr, nullptr);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* name;
  expr_t* value;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(named_arg, name))
         | maskbit(offsetof(named_arg, value));
  }

  DISALLOW_COPY_AND_ASSIGN(named_arg)
};

class subscript : public place_expr_t, public expr_t {
 public:
  subscript(expr_t* obj, List<expr_t*>* indices)
      : GC_ASDL_CLASS(header_, 93,
                      field_mask(), sizeof(subscript)),
        obj(obj),
        indices(indices) {
  }

  static subscript* Create() { 
    return Alloc<subscript>(nullptr, Alloc<List<expr_t*>>());
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* obj;
  List<expr_t*>* indices;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(subscript, obj))
         | maskbit(offsetof(subscript, indices));
  }

  DISALLOW_COPY_AND_ASSIGN(subscript)
};

class attribute : public place_expr_t, public expr_t {
 public:
  attribute(expr_t* obj, Token* op, Token* attr, expr_context_t ctx)
      : GC_ASDL_CLASS(header_, 94,
                      field_mask(), sizeof(attribute)),
        obj(obj),
        op(op),
        attr(attr),
        ctx(ctx) {
  }

  static attribute* Create() { 
    return Alloc<attribute>(nullptr, nullptr, nullptr, expr_context_e::Load);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  expr_t* obj;
  Token* op;
  Token* attr;
  expr_context_t ctx;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(attribute, obj))
         | maskbit(offsetof(attribute, op))
         | maskbit(offsetof(attribute, attr));
  }

  DISALLOW_COPY_AND_ASSIGN(attribute)
};

class posix_class : public class_literal_term_t, public char_class_term_t,
public re_t {
 public:
  posix_class(Token* negated, Str* name)
      : GC_ASDL_CLASS(header_, 95,
                      field_mask(), sizeof(posix_class)),
        negated(negated),
        name(name) {
  }

  static posix_class* Create() { 
    return Alloc<posix_class>(nullptr, kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* negated;
  Str* name;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(posix_class, negated))
         | maskbit(offsetof(posix_class, name));
  }

  DISALLOW_COPY_AND_ASSIGN(posix_class)
};

class perl_class : public class_literal_term_t, public char_class_term_t,
public re_t {
 public:
  perl_class(Token* negated, Str* name)
      : GC_ASDL_CLASS(header_, 96,
                      field_mask(), sizeof(perl_class)),
        negated(negated),
        name(name) {
  }

  static perl_class* Create() { 
    return Alloc<perl_class>(nullptr, kEmptyString);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  Token* negated;
  Str* name;

  static constexpr uint16_t field_mask() {
    return maskbit(offsetof(perl_class, negated))
         | maskbit(offsetof(perl_class, name));
  }

  DISALLOW_COPY_AND_ASSIGN(perl_class)
};

class CharCode : public char_class_term_t {
 public:
  CharCode(int i, bool u_braced, int spid)
      : GC_ASDL_CLASS(header_, 97,
                      kZeroMask, sizeof(CharCode)),
        i(i),
        u_braced(u_braced),
        spid(spid) {
  }

  static CharCode* Create() { 
    return Alloc<CharCode>(-1, false, -1);
  }

  hnode_t* PrettyTree();

  GC_OBJ(header_);
  int i;
  bool u_braced;
  int spid;

  DISALLOW_COPY_AND_ASSIGN(CharCode)
};


}  // namespace syntax_asdl

#endif  // SYNTAX_ASDL
